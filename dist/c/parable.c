// Generated by Tongues transpiler - C11 backend
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

// === Global error state ===
static int g_parse_error = 0;
static char g_error_msg[1024] = {0};

// === Forward declarations ===
typedef struct Node Node;
typedef struct ParseError ParseError;
typedef struct MatchedPairError MatchedPairError;
typedef struct TokenType TokenType;
typedef struct Token Token;
typedef struct ParserStateFlags ParserStateFlags;
typedef struct DolbraceState DolbraceState;
typedef struct MatchedPairFlags MatchedPairFlags;
typedef struct SavedParserState SavedParserState;
typedef struct QuoteState QuoteState;
typedef struct ParseContext ParseContext;
typedef struct ContextStack ContextStack;
typedef struct Lexer Lexer;
typedef struct Word Word;
typedef struct Command Command;
typedef struct Pipeline Pipeline;
typedef struct List List;
typedef struct Operator Operator;
typedef struct PipeBoth PipeBoth;
typedef struct Empty Empty;
typedef struct Comment Comment;
typedef struct Redirect Redirect;
typedef struct HereDoc HereDoc;
typedef struct Subshell Subshell;
typedef struct BraceGroup BraceGroup;
typedef struct If If;
typedef struct While While;
typedef struct Until Until;
typedef struct For For;
typedef struct ForArith ForArith;
typedef struct Select Select;
typedef struct Case Case;
typedef struct CasePattern CasePattern;
typedef struct Function Function;
typedef struct ParamExpansion ParamExpansion;
typedef struct ParamLength ParamLength;
typedef struct ParamIndirect ParamIndirect;
typedef struct CommandSubstitution CommandSubstitution;
typedef struct ArithmeticExpansion ArithmeticExpansion;
typedef struct ArithmeticCommand ArithmeticCommand;
typedef struct ArithNumber ArithNumber;
typedef struct ArithEmpty ArithEmpty;
typedef struct ArithVar ArithVar;
typedef struct ArithBinaryOp ArithBinaryOp;
typedef struct ArithUnaryOp ArithUnaryOp;
typedef struct ArithPreIncr ArithPreIncr;
typedef struct ArithPostIncr ArithPostIncr;
typedef struct ArithPreDecr ArithPreDecr;
typedef struct ArithPostDecr ArithPostDecr;
typedef struct ArithAssign ArithAssign;
typedef struct ArithTernary ArithTernary;
typedef struct ArithComma ArithComma;
typedef struct ArithSubscript ArithSubscript;
typedef struct ArithEscape ArithEscape;
typedef struct ArithDeprecated ArithDeprecated;
typedef struct ArithConcat ArithConcat;
typedef struct AnsiCQuote AnsiCQuote;
typedef struct LocaleString LocaleString;
typedef struct ProcessSubstitution ProcessSubstitution;
typedef struct Negation Negation;
typedef struct Time Time;
typedef struct ConditionalExpr ConditionalExpr;
typedef struct UnaryTest UnaryTest;
typedef struct BinaryTest BinaryTest;
typedef struct CondAnd CondAnd;
typedef struct CondOr CondOr;
typedef struct CondNot CondNot;
typedef struct CondParen CondParen;
typedef struct Array Array;
typedef struct Coproc Coproc;
typedef struct Parser Parser;

// === Kind constants ===
#define KIND_PARSEERROR 1
#define KIND_MATCHEDPAIRERROR 2
#define KIND_TOKENTYPE 3
#define KIND_TOKEN 4
#define KIND_PARSERSTATEFLAGS 5
#define KIND_DOLBRACESTATE 6
#define KIND_MATCHEDPAIRFLAGS 7
#define KIND_SAVEDPARSERSTATE 8
#define KIND_QUOTESTATE 9
#define KIND_PARSECONTEXT 10
#define KIND_CONTEXTSTACK 11
#define KIND_LEXER 12
#define KIND_WORD 13
#define KIND_COMMAND 14
#define KIND_PIPELINE 15
#define KIND_LIST 16
#define KIND_OPERATOR 17
#define KIND_PIPEBOTH 18
#define KIND_EMPTY 19
#define KIND_COMMENT 20
#define KIND_REDIRECT 21
#define KIND_HEREDOC 22
#define KIND_SUBSHELL 23
#define KIND_BRACEGROUP 24
#define KIND_IF 25
#define KIND_WHILE 26
#define KIND_UNTIL 27
#define KIND_FOR 28
#define KIND_FORARITH 29
#define KIND_SELECT 30
#define KIND_CASE 31
#define KIND_CASEPATTERN 32
#define KIND_FUNCTION 33
#define KIND_PARAMEXPANSION 34
#define KIND_PARAMLENGTH 35
#define KIND_PARAMINDIRECT 36
#define KIND_COMMANDSUBSTITUTION 37
#define KIND_ARITHMETICEXPANSION 38
#define KIND_ARITHMETICCOMMAND 39
#define KIND_ARITHNUMBER 40
#define KIND_ARITHEMPTY 41
#define KIND_ARITHVAR 42
#define KIND_ARITHBINARYOP 43
#define KIND_ARITHUNARYOP 44
#define KIND_ARITHPREINCR 45
#define KIND_ARITHPOSTINCR 46
#define KIND_ARITHPREDECR 47
#define KIND_ARITHPOSTDECR 48
#define KIND_ARITHASSIGN 49
#define KIND_ARITHTERNARY 50
#define KIND_ARITHCOMMA 51
#define KIND_ARITHSUBSCRIPT 52
#define KIND_ARITHESCAPE 53
#define KIND_ARITHDEPRECATED 54
#define KIND_ARITHCONCAT 55
#define KIND_ANSICQUOTE 56
#define KIND_LOCALESTRING 57
#define KIND_PROCESSSUBSTITUTION 58
#define KIND_NEGATION 59
#define KIND_TIME 60
#define KIND_CONDITIONALEXPR 61
#define KIND_UNARYTEST 62
#define KIND_BINARYTEST 63
#define KIND_CONDAND 64
#define KIND_CONDOR 65
#define KIND_CONDNOT 66
#define KIND_CONDPAREN 67
#define KIND_ARRAY 68
#define KIND_COPROC 69
#define KIND_PARSER 70
#define KIND_STRING 71

static const char *_kind_to_str(int kind) {
    switch (kind) {
    case KIND_PARSEERROR: return "parse-error";
    case KIND_MATCHEDPAIRERROR: return "matched-pair-error";
    case KIND_TOKENTYPE: return "token-type";
    case KIND_TOKEN: return "token";
    case KIND_PARSERSTATEFLAGS: return "parser-state-flags";
    case KIND_DOLBRACESTATE: return "dolbrace-state";
    case KIND_MATCHEDPAIRFLAGS: return "matched-pair-flags";
    case KIND_SAVEDPARSERSTATE: return "saved-parser-state";
    case KIND_QUOTESTATE: return "quote-state";
    case KIND_PARSECONTEXT: return "parse-context";
    case KIND_CONTEXTSTACK: return "context-stack";
    case KIND_LEXER: return "lexer";
    case KIND_WORD: return "word";
    case KIND_COMMAND: return "command";
    case KIND_PIPELINE: return "pipeline";
    case KIND_LIST: return "list";
    case KIND_OPERATOR: return "operator";
    case KIND_PIPEBOTH: return "pipe-both";
    case KIND_EMPTY: return "empty";
    case KIND_COMMENT: return "comment";
    case KIND_REDIRECT: return "redirect";
    case KIND_HEREDOC: return "here-doc";
    case KIND_SUBSHELL: return "subshell";
    case KIND_BRACEGROUP: return "brace-group";
    case KIND_IF: return "if";
    case KIND_WHILE: return "while";
    case KIND_UNTIL: return "until";
    case KIND_FOR: return "for";
    case KIND_FORARITH: return "for-arith";
    case KIND_SELECT: return "select";
    case KIND_CASE: return "case";
    case KIND_CASEPATTERN: return "case-pattern";
    case KIND_FUNCTION: return "function";
    case KIND_PARAMEXPANSION: return "param-expansion";
    case KIND_PARAMLENGTH: return "param-length";
    case KIND_PARAMINDIRECT: return "param-indirect";
    case KIND_COMMANDSUBSTITUTION: return "command-substitution";
    case KIND_ARITHMETICEXPANSION: return "arithmetic-expansion";
    case KIND_ARITHMETICCOMMAND: return "arithmetic-command";
    case KIND_ARITHNUMBER: return "arith-number";
    case KIND_ARITHEMPTY: return "arith-empty";
    case KIND_ARITHVAR: return "arith-var";
    case KIND_ARITHBINARYOP: return "arith-binary-op";
    case KIND_ARITHUNARYOP: return "arith-unary-op";
    case KIND_ARITHPREINCR: return "arith-pre-incr";
    case KIND_ARITHPOSTINCR: return "arith-post-incr";
    case KIND_ARITHPREDECR: return "arith-pre-decr";
    case KIND_ARITHPOSTDECR: return "arith-post-decr";
    case KIND_ARITHASSIGN: return "arith-assign";
    case KIND_ARITHTERNARY: return "arith-ternary";
    case KIND_ARITHCOMMA: return "arith-comma";
    case KIND_ARITHSUBSCRIPT: return "arith-subscript";
    case KIND_ARITHESCAPE: return "arith-escape";
    case KIND_ARITHDEPRECATED: return "arith-deprecated";
    case KIND_ARITHCONCAT: return "arith-concat";
    case KIND_ANSICQUOTE: return "ansi-c-quote";
    case KIND_LOCALESTRING: return "locale-string";
    case KIND_PROCESSSUBSTITUTION: return "process-substitution";
    case KIND_NEGATION: return "negation";
    case KIND_TIME: return "time";
    case KIND_CONDITIONALEXPR: return "conditional-expr";
    case KIND_UNARYTEST: return "unary-test";
    case KIND_BINARYTEST: return "binary-test";
    case KIND_CONDAND: return "cond-and";
    case KIND_CONDOR: return "cond-or";
    case KIND_CONDNOT: return "cond-not";
    case KIND_CONDPAREN: return "cond-paren";
    case KIND_ARRAY: return "array";
    case KIND_COPROC: return "coproc";
    case KIND_PARSER: return "parser";
    default: return "";
    }
}

// === Generic 'any' interface type ===
// Used for interface{}/any types that need runtime type checking
typedef struct Any {
    int kind;
    void *data;
} Any;

// === Arena allocator ===
typedef struct Arena {
    char *base;
    char *ptr;
    size_t cap;
} Arena;

static Arena *g_arena = NULL;

static Arena *arena_new(size_t cap) {
    Arena *a = (Arena *)malloc(sizeof(Arena));
    a->base = (char *)malloc(cap);
    a->ptr = a->base;
    a->cap = cap;
    return a;
}

static void *arena_alloc(Arena *a, size_t size) {
    size = (size + 7) & ~7;  // 8-byte align
    if ((size_t)(a->ptr - a->base) + size > a->cap) {
        // Grow arena
        size_t used = a->ptr - a->base;
        size_t new_cap = a->cap * 2;
        while (used + size > new_cap) new_cap *= 2;
        char *new_base = (char *)realloc(a->base, new_cap);
        a->base = new_base;
        a->ptr = new_base + used;
        a->cap = new_cap;
    }
    void *result = a->ptr;
    a->ptr += size;
    return result;
}

static void arena_free(Arena *a) {
    if (a) {
        free(a->base);
        free(a);
    }
}

static void arena_reset(Arena *a) {
    a->ptr = a->base;
}

static char *arena_strdup(Arena *a, const char *s) {
    size_t len = strlen(s);
    char *r = (char *)arena_alloc(a, len + 1);
    memcpy(r, s, len + 1);
    return r;
}

static char *arena_strndup(Arena *a, const char *s, size_t n) {
    char *r = (char *)arena_alloc(a, n + 1);
    memcpy(r, s, n);
    r[n] = '\0';
    return r;
}

// === String helpers ===
static int32_t _rune_at(const char *s, int idx) {
    if (idx < 0 || !s) return -1;
    int i = 0;
    const unsigned char *u = (const unsigned char *)s;
    while (*u) {
        if (i == idx) {
            if (*u < 0x80) return *u;
            if ((*u & 0xE0) == 0xC0) return ((*u & 0x1F) << 6) | (u[1] & 0x3F);
            if ((*u & 0xF0) == 0xE0) return ((*u & 0x0F) << 12) | ((u[1] & 0x3F) << 6) | (u[2] & 0x3F);
            if ((*u & 0xF8) == 0xF0) return ((*u & 0x07) << 18) | ((u[1] & 0x3F) << 12) | ((u[2] & 0x3F) << 6) | (u[3] & 0x3F);
            return -1;
        }
        if (*u < 0x80) u++;
        else if ((*u & 0xE0) == 0xC0) u += 2;
        else if ((*u & 0xF0) == 0xE0) u += 3;
        else if ((*u & 0xF8) == 0xF0) u += 4;
        else u++;
        i++;
    }
    return -1;
}

static int _rune_len(const char *s) {
    if (!s) return 0;
    int len = 0;
    const unsigned char *u = (const unsigned char *)s;
    while (*u) {
        if (*u < 0x80) u++;
        else if ((*u & 0xE0) == 0xC0) u += 2;
        else if ((*u & 0xF0) == 0xE0) u += 3;
        else if ((*u & 0xF8) == 0xF0) u += 4;
        else u++;
        len++;
    }
    return len;
}

static char *_char_at_str(Arena *a, const char *s, int idx) {
    int32_t r = _rune_at(s, idx);
    if (r < 0) return arena_strdup(a, "");
    char buf[5] = {0};
    if (r < 0x80) { buf[0] = r; }
    else if (r < 0x800) { buf[0] = 0xC0 | (r >> 6); buf[1] = 0x80 | (r & 0x3F); }
    else if (r < 0x10000) { buf[0] = 0xE0 | (r >> 12); buf[1] = 0x80 | ((r >> 6) & 0x3F); buf[2] = 0x80 | (r & 0x3F); }
    else { buf[0] = 0xF0 | (r >> 18); buf[1] = 0x80 | ((r >> 12) & 0x3F); buf[2] = 0x80 | ((r >> 6) & 0x3F); buf[3] = 0x80 | (r & 0x3F); }
    return arena_strdup(a, buf);
}

static char *_substring(Arena *a, const char *s, int start, int end) {
    if (!s || start < 0) start = 0;
    if (end < start) return arena_strdup(a, "");
    const unsigned char *u = (const unsigned char *)s;
    const char *byte_start = NULL;
    const char *byte_end = NULL;
    int i = 0;
    while (*u) {
        if (i == start) byte_start = (const char *)u;
        if (i == end) { byte_end = (const char *)u; break; }
        if (*u < 0x80) u++;
        else if ((*u & 0xE0) == 0xC0) u += 2;
        else if ((*u & 0xF0) == 0xE0) u += 3;
        else if ((*u & 0xF8) == 0xF0) u += 4;
        else u++;
        i++;
    }
    if (!byte_start) return arena_strdup(a, "");
    if (!byte_end) byte_end = (const char *)u;
    return arena_strndup(a, byte_start, byte_end - byte_start);
}

static bool _str_startswith(const char *s, const char *prefix) {
    if (!s || !prefix) return false;
    size_t plen = strlen(prefix);
    return strncmp(s, prefix, plen) == 0;
}

static bool _str_endswith(const char *s, const char *suffix) {
    if (!s || !suffix) return false;
    size_t slen = strlen(s);
    size_t suflen = strlen(suffix);
    if (suflen > slen) return false;
    return strcmp(s + slen - suflen, suffix) == 0;
}

static int _str_find(const char *s, const char *sub) {
    if (!s || !sub) return -1;
    const char *p = strstr(s, sub);
    if (!p) return -1;
    // Return character index, not byte index
    int idx = 0;
    const unsigned char *u = (const unsigned char *)s;
    while ((const char *)u < p) {
        if (*u < 0x80) u++;
        else if ((*u & 0xE0) == 0xC0) u += 2;
        else if ((*u & 0xF0) == 0xE0) u += 3;
        else if ((*u & 0xF8) == 0xF0) u += 4;
        else u++;
        idx++;
    }
    return idx;
}

static int _str_rfind(const char *s, const char *sub) {
    if (!s || !sub) return -1;
    size_t slen = strlen(s);
    size_t sublen = strlen(sub);
    if (sublen > slen) return -1;
    for (size_t i = slen - sublen + 1; i > 0; i--) {
        if (strncmp(s + i - 1, sub, sublen) == 0) {
            // Return character index
            int idx = 0;
            const unsigned char *u = (const unsigned char *)s;
            while ((const char *)u < s + i - 1) {
                if (*u < 0x80) u++;
                else if ((*u & 0xE0) == 0xC0) u += 2;
                else if ((*u & 0xF0) == 0xE0) u += 3;
                else if ((*u & 0xF8) == 0xF0) u += 4;
                else u++;
                idx++;
            }
            return idx;
        }
    }
    return -1;
}

static char *_str_replace(Arena *a, const char *s, const char *old, const char *new_) {
    if (!s || !old || !new_) return arena_strdup(a, s ? s : "");
    size_t slen = strlen(s);
    size_t oldlen = strlen(old);
    size_t newlen = strlen(new_);
    if (oldlen == 0) return arena_strdup(a, s);
    // Count occurrences
    int count = 0;
    const char *p = s;
    while ((p = strstr(p, old)) != NULL) { count++; p += oldlen; }
    if (count == 0) return arena_strdup(a, s);
    size_t rlen = slen + count * (newlen - oldlen);
    char *r = (char *)arena_alloc(a, rlen + 1);
    char *dst = r;
    p = s;
    const char *prev = s;
    while ((p = strstr(p, old)) != NULL) {
        size_t n = p - prev;
        memcpy(dst, prev, n);
        dst += n;
        memcpy(dst, new_, newlen);
        dst += newlen;
        p += oldlen;
        prev = p;
    }
    strcpy(dst, prev);
    return r;
}

static char *_str_lower(Arena *a, const char *s) {
    if (!s) return arena_strdup(a, "");
    size_t len = strlen(s);
    char *r = (char *)arena_alloc(a, len + 1);
    for (size_t i = 0; i <= len; i++) {
        char c = s[i];
        if (c >= 'A' && c <= 'Z') c = c + 32;
        r[i] = c;
    }
    return r;
}

static char *_str_upper(Arena *a, const char *s) {
    if (!s) return arena_strdup(a, "");
    size_t len = strlen(s);
    char *r = (char *)arena_alloc(a, len + 1);
    for (size_t i = 0; i <= len; i++) {
        char c = s[i];
        if (c >= 'a' && c <= 'z') c = c - 32;
        r[i] = c;
    }
    return r;
}

static bool _str_is_digit(const char *s) {
    if (!s || !*s) return false;
    while (*s) {
        if (*s < '0' || *s > '9') return false;
        s++;
    }
    return true;
}

static bool _str_is_alpha(const char *s) {
    if (!s || !*s) return false;
    while (*s) {
        if (!((*s >= 'A' && *s <= 'Z') || (*s >= 'a' && *s <= 'z'))) return false;
        s++;
    }
    return true;
}

static bool _str_is_alnum(const char *s) {
    if (!s || !*s) return false;
    while (*s) {
        if (!((*s >= 'A' && *s <= 'Z') || (*s >= 'a' && *s <= 'z') || (*s >= '0' && *s <= '9'))) return false;
        s++;
    }
    return true;
}

static bool _str_is_space(const char *s) {
    if (!s || !*s) return false;
    while (*s) {
        if (*s != ' ' && *s != '\t' && *s != '\n' && *s != '\r' && *s != '\f' && *s != '\v') return false;
        s++;
    }
    return true;
}

static bool _rune_is_digit(int32_t r) { return r >= '0' && r <= '9'; }
static bool _rune_is_alpha(int32_t r) { return (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z'); }
static bool _rune_is_alnum(int32_t r) { return _rune_is_alpha(r) || _rune_is_digit(r); }
static bool _rune_is_space(int32_t r) { return r == ' ' || r == '\t' || r == '\n' || r == '\r' || r == '\f' || r == '\v'; }
static bool _rune_is_upper(int32_t r) { return r >= 'A' && r <= 'Z'; }
static bool _rune_is_lower(int32_t r) { return r >= 'a' && r <= 'z'; }

static char *_str_concat(Arena *a, const char *s1, const char *s2) {
    if (!s1) s1 = "";
    if (!s2) s2 = "";
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *r = (char *)arena_alloc(a, len1 + len2 + 1);
    memcpy(r, s1, len1);
    memcpy(r + len1, s2, len2 + 1);
    return r;
}

static char *_str_repeat(Arena *a, const char *s, int n) {
    if (!s || n <= 0) return arena_strdup(a, "");
    size_t len = strlen(s);
    char *r = (char *)arena_alloc(a, len * n + 1);
    char *p = r;
    for (int i = 0; i < n; i++) { memcpy(p, s, len); p += len; }
    *p = '\0';
    return r;
}

static char *_str_trim(Arena *a, const char *s, const char *chars) {
    if (!s) return arena_strdup(a, "");
    const char *start = s;
    while (*start && strchr(chars, *start)) start++;
    if (!*start) return arena_strdup(a, "");
    const char *end = s + strlen(s) - 1;
    while (end > start && strchr(chars, *end)) end--;
    return arena_strndup(a, start, end - start + 1);
}

static char *_str_ltrim(Arena *a, const char *s, const char *chars) {
    if (!s) return arena_strdup(a, "");
    while (*s && strchr(chars, *s)) s++;
    return arena_strdup(a, s);
}

static char *_str_rtrim(Arena *a, const char *s, const char *chars) {
    if (!s || !*s) return arena_strdup(a, "");
    size_t len = strlen(s);
    while (len > 0 && strchr(chars, s[len - 1])) len--;
    return arena_strndup(a, s, len);
}

static int64_t _parse_int(const char *s, int base) {
    if (!s) return 0;
    return strtoll(s, NULL, base);
}

static char *_int_to_str(Arena *a, int64_t n) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", (long long)n);
    return arena_strdup(a, buf);
}

static char *_rune_to_str(Arena *a, int32_t r) {
    char buf[5] = {0};
    if (r < 0x80) { buf[0] = r; }
    else if (r < 0x800) { buf[0] = 0xC0 | (r >> 6); buf[1] = 0x80 | (r & 0x3F); }
    else if (r < 0x10000) { buf[0] = 0xE0 | (r >> 12); buf[1] = 0x80 | ((r >> 6) & 0x3F); buf[2] = 0x80 | (r & 0x3F); }
    else { buf[0] = 0xF0 | (r >> 18); buf[1] = 0x80 | ((r >> 12) & 0x3F); buf[2] = 0x80 | ((r >> 6) & 0x3F); buf[3] = 0x80 | (r & 0x3F); }
    return arena_strdup(a, buf);
}

static bool _str_contains(const char *s, const char *sub) {
    if (!s || !sub) return false;
    return strstr(s, sub) != NULL;
}

static int _str_count(const char *s, const char *sub) {
    if (!s || !sub || !*sub) return 0;
    int count = 0;
    size_t sublen = strlen(sub);
    const char *p = s;
    while ((p = strstr(p, sub)) != NULL) { count++; p += sublen; }
    return count;
}

// === Dynamic array (Vec) helpers ===
#define VEC_INIT_CAP 8

#define VEC_PUSH(a, vec, item) do { \
    if ((vec)->len >= (vec)->cap) { \
        size_t new_cap = (vec)->cap ? (vec)->cap * 2 : VEC_INIT_CAP; \
        void *new_data = arena_alloc(a, new_cap * sizeof(*(vec)->data)); \
        if ((vec)->data) memcpy(new_data, (vec)->data, (vec)->len * sizeof(*(vec)->data)); \
        (vec)->data = new_data; \
        (vec)->cap = new_cap; \
    } \
    (vec)->data[(vec)->len++] = (item); \
} while(0)

// Extend a vector with all elements from another vector
#define VEC_EXTEND(a, dest, src) do { \
    for (size_t _i = 0; _i < (src)->len; _i++) { \
        VEC_PUSH((a), (dest), (src)->data[_i]); \
    } \
} while(0)

static void _vec_extend(Arena *a, void *dest_ptr, void *src_ptr) {
    // Generic extend - caller ensures types match
    // This is a placeholder; actual use should be VEC_EXTEND macro
    (void)a; (void)dest_ptr; (void)src_ptr;
}

// === Map helpers ===
// Simple linear-probe hash map for small maps
static uint64_t _hash_str(const char *s) {
    uint64_t h = 5381;
    while (*s) h = ((h << 5) + h) ^ (unsigned char)*s++;
    return h;
}

static uint64_t _hash_int(int64_t n) {
    return (uint64_t)n * 0x9e3779b97f4a7c15ULL;
}

// Variable-argument string formatting helper
static char *_str_format(Arena *a, const char *fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    if (len < 0) { va_end(args2); return arena_strdup(a, ""); }
    char *buf = (char *)arena_alloc(a, len + 1);
    vsnprintf(buf, len + 1, fmt, args2);
    va_end(args2);
    return buf;
}

// Vec_Byte forward declaration for _str_to_bytes
typedef struct Vec_Byte { uint8_t *data; size_t len; size_t cap; } Vec_Byte;

// String to bytes conversion (UTF-8 encoded)
static Vec_Byte _str_to_bytes(Arena *a, const char *s) {
    if (!s) return (Vec_Byte){NULL, 0, 0};
    size_t len = strlen(s);
    uint8_t *data = (uint8_t *)arena_alloc(a, len);
    memcpy(data, s, len);
    return (Vec_Byte){data, len, len};
}

// Generic set membership (placeholder - sets aren't fully implemented)
static bool _set_contains(void *set, const char *key) {
    (void)set; (void)key;
    return false;
}

// Generic map membership (placeholder - maps aren't fully implemented)
static bool _map_contains(void *map, const char *key) {
    (void)map; (void)key;
    return false;
}

// === Tuple forward declarations for Vec element types ===
typedef struct Tuple_NodePtr_bool Tuple_NodePtr_bool;
typedef struct Tuple_bool_bool Tuple_bool_bool;
typedef struct Tuple_constcharPtr_bool Tuple_constcharPtr_bool;

// === Slice (Vec) typedefs ===
typedef struct Vec_Any { void * *data; size_t len; size_t cap; } Vec_Any;
typedef struct Vec_CasePattern { CasePattern * *data; size_t len; size_t cap; } Vec_CasePattern;
typedef struct Vec_HereDoc { HereDoc * *data; size_t len; size_t cap; } Vec_HereDoc;
typedef struct Vec_Int { int64_t *data; size_t len; size_t cap; } Vec_Int;
typedef struct Vec_Node { Node * *data; size_t len; size_t cap; } Vec_Node;
typedef struct Vec_ParseContext { ParseContext * *data; size_t len; size_t cap; } Vec_ParseContext;
typedef struct Vec_Str { const char * *data; size_t len; size_t cap; } Vec_Str;
typedef struct Vec_Token { Token * *data; size_t len; size_t cap; } Vec_Token;
typedef struct Vec_Tuple_NodePtr_bool { Tuple_NodePtr_bool *data; size_t len; size_t cap; } Vec_Tuple_NodePtr_bool;
typedef struct Vec_Tuple_bool_bool { Tuple_bool_bool *data; size_t len; size_t cap; } Vec_Tuple_bool_bool;
typedef struct Vec_Tuple_constcharPtr_bool { Tuple_constcharPtr_bool *data; size_t len; size_t cap; } Vec_Tuple_constcharPtr_bool;
typedef struct Vec_VecNode { Vec_Node *data; size_t len; size_t cap; } Vec_VecNode;
typedef struct Vec_Word { Word * *data; size_t len; size_t cap; } Vec_Word;

static char *_str_join(Arena *a, const char *sep, Vec_Str vec) {
    if (vec.len == 0) return arena_strdup(a, "");
    size_t sep_len = strlen(sep);
    size_t total = 0;
    for (size_t i = 0; i < vec.len; i++) {
        total += strlen(vec.data[i]);
        if (i > 0) total += sep_len;
    }
    char *result = (char *)arena_alloc(a, total + 1);
    char *p = result;
    for (size_t i = 0; i < vec.len; i++) {
        if (i > 0) { memcpy(p, sep, sep_len); p += sep_len; }
        size_t len = strlen(vec.data[i]);
        memcpy(p, vec.data[i], len);
        p += len;
    }
    *p = '\0';
    return result;
}

// === Tuple types ===
typedef struct Tuple_NodePtr_bool Tuple_NodePtr_bool;
typedef struct Tuple_NodePtr_constcharPtr Tuple_NodePtr_constcharPtr;
typedef struct Tuple_NodePtr_constcharPtr_Vec_Node Tuple_NodePtr_constcharPtr_Vec_Node;
typedef struct Tuple_bool_bool Tuple_bool_bool;
typedef struct Tuple_bool_constcharPtr Tuple_bool_constcharPtr;
typedef struct Tuple_constcharPtr_bool Tuple_constcharPtr_bool;
typedef struct Tuple_constcharPtr_constcharPtr Tuple_constcharPtr_constcharPtr;
typedef struct Tuple_constcharPtr_int64_t Tuple_constcharPtr_int64_t;
typedef struct Tuple_int64_t_Vec_Str Tuple_int64_t_Vec_Str;
typedef struct Tuple_int64_t_Vec_Str_bool Tuple_int64_t_Vec_Str_bool;
typedef struct Tuple_int64_t_constcharPtr Tuple_int64_t_constcharPtr;
typedef struct Tuple_int64_t_int64_t Tuple_int64_t_int64_t;

struct Tuple_NodePtr_bool {
    Node * F0;
    bool F1;
};
struct Tuple_NodePtr_constcharPtr {
    Node * F0;
    const char * F1;
};
struct Tuple_NodePtr_constcharPtr_Vec_Node {
    Node * F0;
    const char * F1;
    Vec_Node F2;
};
struct Tuple_bool_bool {
    bool F0;
    bool F1;
};
struct Tuple_bool_constcharPtr {
    bool F0;
    const char * F1;
};
struct Tuple_constcharPtr_bool {
    const char * F0;
    bool F1;
};
struct Tuple_constcharPtr_constcharPtr {
    const char * F0;
    const char * F1;
};
struct Tuple_constcharPtr_int64_t {
    const char * F0;
    int64_t F1;
};
struct Tuple_int64_t_Vec_Str {
    int64_t F0;
    Vec_Str F1;
};
struct Tuple_int64_t_Vec_Str_bool {
    int64_t F0;
    Vec_Str F1;
    bool F2;
};
struct Tuple_int64_t_constcharPtr {
    int64_t F0;
    const char * F1;
};
struct Tuple_int64_t_int64_t {
    int64_t F0;
    int64_t F1;
};

// Interface: Node
struct Node {
    int kind;
    void *data;
};

struct ParseError {
    const char * message;
    int64_t pos;
    int64_t line;
};

static ParseError *ParseError_new(const char * message, int64_t pos, int64_t line) {
    ParseError *self = (ParseError *)arena_alloc(g_arena, sizeof(ParseError));
    self->message = message;
    self->pos = pos;
    self->line = line;
    return self;
}

struct MatchedPairError {
    ParseError base;
};

static MatchedPairError *MatchedPairError_new(void) {
    MatchedPairError *self = (MatchedPairError *)arena_alloc(g_arena, sizeof(MatchedPairError));
    return self;
}

struct TokenType {
};

static TokenType *TokenType_new(void) {
    TokenType *self = (TokenType *)arena_alloc(g_arena, sizeof(TokenType));
    return self;
}

struct Token {
    int64_t type;
    const char * value;
    int64_t pos;
    Vec_Node parts;
    Word * word;
};

static Token *Token_new(int64_t type, const char * value, int64_t pos, Vec_Node parts, Word * word) {
    Token *self = (Token *)arena_alloc(g_arena, sizeof(Token));
    self->type = type;
    self->value = value;
    self->pos = pos;
    self->parts = parts;
    self->word = word;
    return self;
}

struct ParserStateFlags {
};

static ParserStateFlags *ParserStateFlags_new(void) {
    ParserStateFlags *self = (ParserStateFlags *)arena_alloc(g_arena, sizeof(ParserStateFlags));
    return self;
}

struct DolbraceState {
};

static DolbraceState *DolbraceState_new(void) {
    DolbraceState *self = (DolbraceState *)arena_alloc(g_arena, sizeof(DolbraceState));
    return self;
}

struct MatchedPairFlags {
};

static MatchedPairFlags *MatchedPairFlags_new(void) {
    MatchedPairFlags *self = (MatchedPairFlags *)arena_alloc(g_arena, sizeof(MatchedPairFlags));
    return self;
}

struct SavedParserState {
    int64_t parser_state;
    int64_t dolbrace_state;
    Vec_Node pending_heredocs;
    Vec_ParseContext ctx_stack;
    const char * eof_token;
};

static SavedParserState *SavedParserState_new(int64_t parser_state, int64_t dolbrace_state, Vec_Node pending_heredocs, Vec_ParseContext ctx_stack, const char * eof_token) {
    SavedParserState *self = (SavedParserState *)arena_alloc(g_arena, sizeof(SavedParserState));
    self->parser_state = parser_state;
    self->dolbrace_state = dolbrace_state;
    self->pending_heredocs = pending_heredocs;
    self->ctx_stack = ctx_stack;
    self->eof_token = eof_token;
    return self;
}

struct QuoteState {
    bool single;
    bool double_;
    Vec_Tuple_bool_bool stack;
};

static QuoteState *QuoteState_new(bool single, bool double_, Vec_Tuple_bool_bool stack) {
    QuoteState *self = (QuoteState *)arena_alloc(g_arena, sizeof(QuoteState));
    self->single = single;
    self->double_ = double_;
    self->stack = stack;
    return self;
}

struct ParseContext {
    int64_t kind;
    int64_t paren_depth;
    int64_t brace_depth;
    int64_t bracket_depth;
    int64_t case_depth;
    int64_t arith_depth;
    int64_t arith_paren_depth;
    QuoteState * quote;
};

static ParseContext *ParseContext_new(int64_t kind, int64_t paren_depth, int64_t brace_depth, int64_t bracket_depth, int64_t case_depth, int64_t arith_depth, int64_t arith_paren_depth, QuoteState * quote) {
    ParseContext *self = (ParseContext *)arena_alloc(g_arena, sizeof(ParseContext));
    self->kind = kind;
    self->paren_depth = paren_depth;
    self->brace_depth = brace_depth;
    self->bracket_depth = bracket_depth;
    self->case_depth = case_depth;
    self->arith_depth = arith_depth;
    self->arith_paren_depth = arith_paren_depth;
    self->quote = quote;
    return self;
}

struct ContextStack {
    Vec_ParseContext stack;
};

static ContextStack *ContextStack_new(Vec_ParseContext stack) {
    ContextStack *self = (ContextStack *)arena_alloc(g_arena, sizeof(ContextStack));
    self->stack = stack;
    return self;
}

struct Lexer {
    void * reserved_words;
    const char * source;
    int64_t pos;
    int64_t length;
    QuoteState * quote;
    Token * token_cache;
    int64_t parser_state;
    int64_t dolbrace_state;
    Vec_Node pending_heredocs;
    bool extglob;
    Parser * parser;
    const char * eof_token;
    Token * last_read_token;
    int64_t word_context;
    bool at_command_start;
    bool in_array_literal;
    bool in_assign_builtin;
    int64_t post_read_pos;
    int64_t cached_word_context;
    bool cached_at_command_start;
    bool cached_in_array_literal;
    bool cached_in_assign_builtin;
};

static Lexer *Lexer_new(void * reserved_words, const char * source, int64_t pos, int64_t length, QuoteState * quote, Token * token_cache, int64_t parser_state, int64_t dolbrace_state, Vec_Node pending_heredocs, bool extglob, Parser * parser, const char * eof_token, Token * last_read_token, int64_t word_context, bool at_command_start, bool in_array_literal, bool in_assign_builtin, int64_t post_read_pos, int64_t cached_word_context, bool cached_at_command_start, bool cached_in_array_literal, bool cached_in_assign_builtin) {
    Lexer *self = (Lexer *)arena_alloc(g_arena, sizeof(Lexer));
    self->reserved_words = reserved_words;
    self->source = source;
    self->pos = pos;
    self->length = length;
    self->quote = quote;
    self->token_cache = token_cache;
    self->parser_state = parser_state;
    self->dolbrace_state = dolbrace_state;
    self->pending_heredocs = pending_heredocs;
    self->extglob = extglob;
    self->parser = parser;
    self->eof_token = eof_token;
    self->last_read_token = last_read_token;
    self->word_context = word_context;
    self->at_command_start = at_command_start;
    self->in_array_literal = in_array_literal;
    self->in_assign_builtin = in_assign_builtin;
    self->post_read_pos = post_read_pos;
    self->cached_word_context = cached_word_context;
    self->cached_at_command_start = cached_at_command_start;
    self->cached_in_array_literal = cached_in_array_literal;
    self->cached_in_assign_builtin = cached_in_assign_builtin;
    return self;
}

struct Word {
    const char * value;
    Vec_Node parts;
    const char * kind;
};

static Word *Word_new(const char * value, Vec_Node parts, const char * kind) {
    Word *self = (Word *)arena_alloc(g_arena, sizeof(Word));
    self->value = value;
    self->parts = parts;
    self->kind = kind;
    return self;
}

struct Command {
    Vec_Word words;
    Vec_Node redirects;
    const char * kind;
};

static Command *Command_new(Vec_Word words, Vec_Node redirects, const char * kind) {
    Command *self = (Command *)arena_alloc(g_arena, sizeof(Command));
    self->words = words;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct Pipeline {
    Vec_Node commands;
    const char * kind;
};

static Pipeline *Pipeline_new(Vec_Node commands, const char * kind) {
    Pipeline *self = (Pipeline *)arena_alloc(g_arena, sizeof(Pipeline));
    self->commands = commands;
    self->kind = kind;
    return self;
}

struct List {
    Vec_Node parts;
    const char * kind;
};

static List *List_new(Vec_Node parts, const char * kind) {
    List *self = (List *)arena_alloc(g_arena, sizeof(List));
    self->parts = parts;
    self->kind = kind;
    return self;
}

struct Operator {
    const char * op;
    const char * kind;
};

static Operator *Operator_new(const char * op, const char * kind) {
    Operator *self = (Operator *)arena_alloc(g_arena, sizeof(Operator));
    self->op = op;
    self->kind = kind;
    return self;
}

struct PipeBoth {
    const char * kind;
};

static PipeBoth *PipeBoth_new(const char * kind) {
    PipeBoth *self = (PipeBoth *)arena_alloc(g_arena, sizeof(PipeBoth));
    self->kind = kind;
    return self;
}

struct Empty {
    const char * kind;
};

static Empty *Empty_new(const char * kind) {
    Empty *self = (Empty *)arena_alloc(g_arena, sizeof(Empty));
    self->kind = kind;
    return self;
}

struct Comment {
    const char * text;
    const char * kind;
};

static Comment *Comment_new(const char * text, const char * kind) {
    Comment *self = (Comment *)arena_alloc(g_arena, sizeof(Comment));
    self->text = text;
    self->kind = kind;
    return self;
}

struct Redirect {
    const char * op;
    Word * target;
    int64_t fd;
    const char * kind;
};

static Redirect *Redirect_new(const char * op, Word * target, int64_t fd, const char * kind) {
    Redirect *self = (Redirect *)arena_alloc(g_arena, sizeof(Redirect));
    self->op = op;
    self->target = target;
    self->fd = fd;
    self->kind = kind;
    return self;
}

struct HereDoc {
    const char * delimiter;
    const char * content;
    bool strip_tabs;
    bool quoted;
    int64_t fd;
    bool complete;
    int64_t start_pos;
    const char * kind;
};

static HereDoc *HereDoc_new(const char * delimiter, const char * content, bool strip_tabs, bool quoted, int64_t fd, bool complete, int64_t start_pos, const char * kind) {
    HereDoc *self = (HereDoc *)arena_alloc(g_arena, sizeof(HereDoc));
    self->delimiter = delimiter;
    self->content = content;
    self->strip_tabs = strip_tabs;
    self->quoted = quoted;
    self->fd = fd;
    self->complete = complete;
    self->start_pos = start_pos;
    self->kind = kind;
    return self;
}

struct Subshell {
    Node * body;
    Vec_Node * redirects;
    const char * kind;
};

static Subshell *Subshell_new(Node * body, Vec_Node * redirects, const char * kind) {
    Subshell *self = (Subshell *)arena_alloc(g_arena, sizeof(Subshell));
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct BraceGroup {
    Node * body;
    Vec_Node * redirects;
    const char * kind;
};

static BraceGroup *BraceGroup_new(Node * body, Vec_Node * redirects, const char * kind) {
    BraceGroup *self = (BraceGroup *)arena_alloc(g_arena, sizeof(BraceGroup));
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct If {
    Node * condition;
    Node * then_body;
    Node * else_body;
    Vec_Node redirects;
    const char * kind;
};

static If *If_new(Node * condition, Node * then_body, Node * else_body, Vec_Node redirects, const char * kind) {
    If *self = (If *)arena_alloc(g_arena, sizeof(If));
    self->condition = condition;
    self->then_body = then_body;
    self->else_body = else_body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct While {
    Node * condition;
    Node * body;
    Vec_Node redirects;
    const char * kind;
};

static While *While_new(Node * condition, Node * body, Vec_Node redirects, const char * kind) {
    While *self = (While *)arena_alloc(g_arena, sizeof(While));
    self->condition = condition;
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct Until {
    Node * condition;
    Node * body;
    Vec_Node redirects;
    const char * kind;
};

static Until *Until_new(Node * condition, Node * body, Vec_Node redirects, const char * kind) {
    Until *self = (Until *)arena_alloc(g_arena, sizeof(Until));
    self->condition = condition;
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct For {
    const char * var;
    Vec_Word * words;
    Node * body;
    Vec_Node redirects;
    const char * kind;
};

static For *For_new(const char * var, Vec_Word * words, Node * body, Vec_Node redirects, const char * kind) {
    For *self = (For *)arena_alloc(g_arena, sizeof(For));
    self->var = var;
    self->words = words;
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct ForArith {
    const char * init;
    const char * cond;
    const char * incr;
    Node * body;
    Vec_Node redirects;
    const char * kind;
};

static ForArith *ForArith_new(const char * init, const char * cond, const char * incr, Node * body, Vec_Node redirects, const char * kind) {
    ForArith *self = (ForArith *)arena_alloc(g_arena, sizeof(ForArith));
    self->init = init;
    self->cond = cond;
    self->incr = incr;
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct Select {
    const char * var;
    Vec_Word * words;
    Node * body;
    Vec_Node redirects;
    const char * kind;
};

static Select *Select_new(const char * var, Vec_Word * words, Node * body, Vec_Node redirects, const char * kind) {
    Select *self = (Select *)arena_alloc(g_arena, sizeof(Select));
    self->var = var;
    self->words = words;
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct Case {
    Word * word;
    Vec_CasePattern patterns;
    Vec_Node redirects;
    const char * kind;
};

static Case *Case_new(Word * word, Vec_CasePattern patterns, Vec_Node redirects, const char * kind) {
    Case *self = (Case *)arena_alloc(g_arena, sizeof(Case));
    self->word = word;
    self->patterns = patterns;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct CasePattern {
    const char * pattern;
    Node * body;
    const char * terminator;
    const char * kind;
};

static CasePattern *CasePattern_new(const char * pattern, Node * body, const char * terminator, const char * kind) {
    CasePattern *self = (CasePattern *)arena_alloc(g_arena, sizeof(CasePattern));
    self->pattern = pattern;
    self->body = body;
    self->terminator = terminator;
    self->kind = kind;
    return self;
}

struct Function {
    const char * name;
    Node * body;
    const char * kind;
};

static Function *Function_new(const char * name, Node * body, const char * kind) {
    Function *self = (Function *)arena_alloc(g_arena, sizeof(Function));
    self->name = name;
    self->body = body;
    self->kind = kind;
    return self;
}

struct ParamExpansion {
    const char * param;
    const char * op;
    const char * arg;
    const char * kind;
};

static ParamExpansion *ParamExpansion_new(const char * param, const char * op, const char * arg, const char * kind) {
    ParamExpansion *self = (ParamExpansion *)arena_alloc(g_arena, sizeof(ParamExpansion));
    self->param = param;
    self->op = op;
    self->arg = arg;
    self->kind = kind;
    return self;
}

struct ParamLength {
    const char * param;
    const char * kind;
};

static ParamLength *ParamLength_new(const char * param, const char * kind) {
    ParamLength *self = (ParamLength *)arena_alloc(g_arena, sizeof(ParamLength));
    self->param = param;
    self->kind = kind;
    return self;
}

struct ParamIndirect {
    const char * param;
    const char * op;
    const char * arg;
    const char * kind;
};

static ParamIndirect *ParamIndirect_new(const char * param, const char * op, const char * arg, const char * kind) {
    ParamIndirect *self = (ParamIndirect *)arena_alloc(g_arena, sizeof(ParamIndirect));
    self->param = param;
    self->op = op;
    self->arg = arg;
    self->kind = kind;
    return self;
}

struct CommandSubstitution {
    Node * command;
    bool brace;
    const char * kind;
};

static CommandSubstitution *CommandSubstitution_new(Node * command, bool brace, const char * kind) {
    CommandSubstitution *self = (CommandSubstitution *)arena_alloc(g_arena, sizeof(CommandSubstitution));
    self->command = command;
    self->brace = brace;
    self->kind = kind;
    return self;
}

struct ArithmeticExpansion {
    Node * expression;
    const char * kind;
};

static ArithmeticExpansion *ArithmeticExpansion_new(Node * expression, const char * kind) {
    ArithmeticExpansion *self = (ArithmeticExpansion *)arena_alloc(g_arena, sizeof(ArithmeticExpansion));
    self->expression = expression;
    self->kind = kind;
    return self;
}

struct ArithmeticCommand {
    Node * expression;
    Vec_Node redirects;
    const char * raw_content;
    const char * kind;
};

static ArithmeticCommand *ArithmeticCommand_new(Node * expression, Vec_Node redirects, const char * raw_content, const char * kind) {
    ArithmeticCommand *self = (ArithmeticCommand *)arena_alloc(g_arena, sizeof(ArithmeticCommand));
    self->expression = expression;
    self->redirects = redirects;
    self->raw_content = raw_content;
    self->kind = kind;
    return self;
}

struct ArithNumber {
    const char * value;
    const char * kind;
};

static ArithNumber *ArithNumber_new(const char * value, const char * kind) {
    ArithNumber *self = (ArithNumber *)arena_alloc(g_arena, sizeof(ArithNumber));
    self->value = value;
    self->kind = kind;
    return self;
}

struct ArithEmpty {
    const char * kind;
};

static ArithEmpty *ArithEmpty_new(const char * kind) {
    ArithEmpty *self = (ArithEmpty *)arena_alloc(g_arena, sizeof(ArithEmpty));
    self->kind = kind;
    return self;
}

struct ArithVar {
    const char * name;
    const char * kind;
};

static ArithVar *ArithVar_new(const char * name, const char * kind) {
    ArithVar *self = (ArithVar *)arena_alloc(g_arena, sizeof(ArithVar));
    self->name = name;
    self->kind = kind;
    return self;
}

struct ArithBinaryOp {
    const char * op;
    Node * left;
    Node * right;
    const char * kind;
};

static ArithBinaryOp *ArithBinaryOp_new(const char * op, Node * left, Node * right, const char * kind) {
    ArithBinaryOp *self = (ArithBinaryOp *)arena_alloc(g_arena, sizeof(ArithBinaryOp));
    self->op = op;
    self->left = left;
    self->right = right;
    self->kind = kind;
    return self;
}

struct ArithUnaryOp {
    const char * op;
    Node * operand;
    const char * kind;
};

static ArithUnaryOp *ArithUnaryOp_new(const char * op, Node * operand, const char * kind) {
    ArithUnaryOp *self = (ArithUnaryOp *)arena_alloc(g_arena, sizeof(ArithUnaryOp));
    self->op = op;
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct ArithPreIncr {
    Node * operand;
    const char * kind;
};

static ArithPreIncr *ArithPreIncr_new(Node * operand, const char * kind) {
    ArithPreIncr *self = (ArithPreIncr *)arena_alloc(g_arena, sizeof(ArithPreIncr));
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct ArithPostIncr {
    Node * operand;
    const char * kind;
};

static ArithPostIncr *ArithPostIncr_new(Node * operand, const char * kind) {
    ArithPostIncr *self = (ArithPostIncr *)arena_alloc(g_arena, sizeof(ArithPostIncr));
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct ArithPreDecr {
    Node * operand;
    const char * kind;
};

static ArithPreDecr *ArithPreDecr_new(Node * operand, const char * kind) {
    ArithPreDecr *self = (ArithPreDecr *)arena_alloc(g_arena, sizeof(ArithPreDecr));
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct ArithPostDecr {
    Node * operand;
    const char * kind;
};

static ArithPostDecr *ArithPostDecr_new(Node * operand, const char * kind) {
    ArithPostDecr *self = (ArithPostDecr *)arena_alloc(g_arena, sizeof(ArithPostDecr));
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct ArithAssign {
    const char * op;
    Node * target;
    Node * value;
    const char * kind;
};

static ArithAssign *ArithAssign_new(const char * op, Node * target, Node * value, const char * kind) {
    ArithAssign *self = (ArithAssign *)arena_alloc(g_arena, sizeof(ArithAssign));
    self->op = op;
    self->target = target;
    self->value = value;
    self->kind = kind;
    return self;
}

struct ArithTernary {
    Node * condition;
    Node * if_true;
    Node * if_false;
    const char * kind;
};

static ArithTernary *ArithTernary_new(Node * condition, Node * if_true, Node * if_false, const char * kind) {
    ArithTernary *self = (ArithTernary *)arena_alloc(g_arena, sizeof(ArithTernary));
    self->condition = condition;
    self->if_true = if_true;
    self->if_false = if_false;
    self->kind = kind;
    return self;
}

struct ArithComma {
    Node * left;
    Node * right;
    const char * kind;
};

static ArithComma *ArithComma_new(Node * left, Node * right, const char * kind) {
    ArithComma *self = (ArithComma *)arena_alloc(g_arena, sizeof(ArithComma));
    self->left = left;
    self->right = right;
    self->kind = kind;
    return self;
}

struct ArithSubscript {
    const char * array;
    Node * index;
    const char * kind;
};

static ArithSubscript *ArithSubscript_new(const char * array, Node * index, const char * kind) {
    ArithSubscript *self = (ArithSubscript *)arena_alloc(g_arena, sizeof(ArithSubscript));
    self->array = array;
    self->index = index;
    self->kind = kind;
    return self;
}

struct ArithEscape {
    const char * char_;
    const char * kind;
};

static ArithEscape *ArithEscape_new(const char * char_, const char * kind) {
    ArithEscape *self = (ArithEscape *)arena_alloc(g_arena, sizeof(ArithEscape));
    self->char_ = char_;
    self->kind = kind;
    return self;
}

struct ArithDeprecated {
    const char * expression;
    const char * kind;
};

static ArithDeprecated *ArithDeprecated_new(const char * expression, const char * kind) {
    ArithDeprecated *self = (ArithDeprecated *)arena_alloc(g_arena, sizeof(ArithDeprecated));
    self->expression = expression;
    self->kind = kind;
    return self;
}

struct ArithConcat {
    Vec_Node parts;
    const char * kind;
};

static ArithConcat *ArithConcat_new(Vec_Node parts, const char * kind) {
    ArithConcat *self = (ArithConcat *)arena_alloc(g_arena, sizeof(ArithConcat));
    self->parts = parts;
    self->kind = kind;
    return self;
}

struct AnsiCQuote {
    const char * content;
    const char * kind;
};

static AnsiCQuote *AnsiCQuote_new(const char * content, const char * kind) {
    AnsiCQuote *self = (AnsiCQuote *)arena_alloc(g_arena, sizeof(AnsiCQuote));
    self->content = content;
    self->kind = kind;
    return self;
}

struct LocaleString {
    const char * content;
    const char * kind;
};

static LocaleString *LocaleString_new(const char * content, const char * kind) {
    LocaleString *self = (LocaleString *)arena_alloc(g_arena, sizeof(LocaleString));
    self->content = content;
    self->kind = kind;
    return self;
}

struct ProcessSubstitution {
    const char * direction;
    Node * command;
    const char * kind;
};

static ProcessSubstitution *ProcessSubstitution_new(const char * direction, Node * command, const char * kind) {
    ProcessSubstitution *self = (ProcessSubstitution *)arena_alloc(g_arena, sizeof(ProcessSubstitution));
    self->direction = direction;
    self->command = command;
    self->kind = kind;
    return self;
}

struct Negation {
    Node * pipeline;
    const char * kind;
};

static Negation *Negation_new(Node * pipeline, const char * kind) {
    Negation *self = (Negation *)arena_alloc(g_arena, sizeof(Negation));
    self->pipeline = pipeline;
    self->kind = kind;
    return self;
}

struct Time {
    Node * pipeline;
    bool posix;
    const char * kind;
};

static Time *Time_new(Node * pipeline, bool posix, const char * kind) {
    Time *self = (Time *)arena_alloc(g_arena, sizeof(Time));
    self->pipeline = pipeline;
    self->posix = posix;
    self->kind = kind;
    return self;
}

struct ConditionalExpr {
    Any * body;
    Vec_Node redirects;
    const char * kind;
};

static ConditionalExpr *ConditionalExpr_new(Any * body, Vec_Node redirects, const char * kind) {
    ConditionalExpr *self = (ConditionalExpr *)arena_alloc(g_arena, sizeof(ConditionalExpr));
    self->body = body;
    self->redirects = redirects;
    self->kind = kind;
    return self;
}

struct UnaryTest {
    const char * op;
    Word * operand;
    const char * kind;
};

static UnaryTest *UnaryTest_new(const char * op, Word * operand, const char * kind) {
    UnaryTest *self = (UnaryTest *)arena_alloc(g_arena, sizeof(UnaryTest));
    self->op = op;
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct BinaryTest {
    const char * op;
    Word * left;
    Word * right;
    const char * kind;
};

static BinaryTest *BinaryTest_new(const char * op, Word * left, Word * right, const char * kind) {
    BinaryTest *self = (BinaryTest *)arena_alloc(g_arena, sizeof(BinaryTest));
    self->op = op;
    self->left = left;
    self->right = right;
    self->kind = kind;
    return self;
}

struct CondAnd {
    Node * left;
    Node * right;
    const char * kind;
};

static CondAnd *CondAnd_new(Node * left, Node * right, const char * kind) {
    CondAnd *self = (CondAnd *)arena_alloc(g_arena, sizeof(CondAnd));
    self->left = left;
    self->right = right;
    self->kind = kind;
    return self;
}

struct CondOr {
    Node * left;
    Node * right;
    const char * kind;
};

static CondOr *CondOr_new(Node * left, Node * right, const char * kind) {
    CondOr *self = (CondOr *)arena_alloc(g_arena, sizeof(CondOr));
    self->left = left;
    self->right = right;
    self->kind = kind;
    return self;
}

struct CondNot {
    Node * operand;
    const char * kind;
};

static CondNot *CondNot_new(Node * operand, const char * kind) {
    CondNot *self = (CondNot *)arena_alloc(g_arena, sizeof(CondNot));
    self->operand = operand;
    self->kind = kind;
    return self;
}

struct CondParen {
    Node * inner;
    const char * kind;
};

static CondParen *CondParen_new(Node * inner, const char * kind) {
    CondParen *self = (CondParen *)arena_alloc(g_arena, sizeof(CondParen));
    self->inner = inner;
    self->kind = kind;
    return self;
}

struct Array {
    Vec_Word elements;
    const char * kind;
};

static Array *Array_new(Vec_Word elements, const char * kind) {
    Array *self = (Array *)arena_alloc(g_arena, sizeof(Array));
    self->elements = elements;
    self->kind = kind;
    return self;
}

struct Coproc {
    Node * command;
    const char * name;
    const char * kind;
};

static Coproc *Coproc_new(Node * command, const char * name, const char * kind) {
    Coproc *self = (Coproc *)arena_alloc(g_arena, sizeof(Coproc));
    self->command = command;
    self->name = name;
    self->kind = kind;
    return self;
}

struct Parser {
    const char * source;
    int64_t pos;
    int64_t length;
    Vec_HereDoc pending_heredocs;
    int64_t cmdsub_heredoc_end;
    bool saw_newline_in_single_quote;
    bool in_process_sub;
    bool extglob;
    ContextStack * ctx;
    Lexer * lexer;
    Vec_Token token_history;
    int64_t parser_state;
    int64_t dolbrace_state;
    const char * eof_token;
    int64_t word_context;
    bool at_command_start;
    bool in_array_literal;
    bool in_assign_builtin;
    const char * arith_src;
    int64_t arith_pos;
    int64_t arith_len;
};

static Parser *Parser_new(const char * source, int64_t pos, int64_t length, Vec_HereDoc pending_heredocs, int64_t cmdsub_heredoc_end, bool saw_newline_in_single_quote, bool in_process_sub, bool extglob, ContextStack * ctx, Lexer * lexer, Vec_Token token_history, int64_t parser_state, int64_t dolbrace_state, const char * eof_token, int64_t word_context, bool at_command_start, bool in_array_literal, bool in_assign_builtin, const char * arith_src, int64_t arith_pos, int64_t arith_len) {
    Parser *self = (Parser *)arena_alloc(g_arena, sizeof(Parser));
    self->source = source;
    self->pos = pos;
    self->length = length;
    self->pending_heredocs = pending_heredocs;
    self->cmdsub_heredoc_end = cmdsub_heredoc_end;
    self->saw_newline_in_single_quote = saw_newline_in_single_quote;
    self->in_process_sub = in_process_sub;
    self->extglob = extglob;
    self->ctx = ctx;
    self->lexer = lexer;
    self->token_history = token_history;
    self->parser_state = parser_state;
    self->dolbrace_state = dolbrace_state;
    self->eof_token = eof_token;
    self->word_context = word_context;
    self->at_command_start = at_command_start;
    self->in_array_literal = in_array_literal;
    self->in_assign_builtin = in_assign_builtin;
    self->arith_src = arith_src;
    self->arith_pos = arith_pos;
    self->arith_len = arith_len;
    return self;
}

// === Constants ===
static void * ANSI_C_ESCAPES;  // initialized in init()
static const int64_t TOKENTYPE_EOF = 0;
static const int64_t TOKENTYPE_WORD = 1;
static const int64_t TOKENTYPE_NEWLINE = 2;
static const int64_t TOKENTYPE_SEMI = 10;
static const int64_t TOKENTYPE_PIPE = 11;
static const int64_t TOKENTYPE_AMP = 12;
static const int64_t TOKENTYPE_LPAREN = 13;
static const int64_t TOKENTYPE_RPAREN = 14;
static const int64_t TOKENTYPE_LBRACE = 15;
static const int64_t TOKENTYPE_RBRACE = 16;
static const int64_t TOKENTYPE_LESS = 17;
static const int64_t TOKENTYPE_GREATER = 18;
static const int64_t TOKENTYPE_AND_AND = 30;
static const int64_t TOKENTYPE_OR_OR = 31;
static const int64_t TOKENTYPE_SEMI_SEMI = 32;
static const int64_t TOKENTYPE_SEMI_AMP = 33;
static const int64_t TOKENTYPE_SEMI_SEMI_AMP = 34;
static const int64_t TOKENTYPE_LESS_LESS = 35;
static const int64_t TOKENTYPE_GREATER_GREATER = 36;
static const int64_t TOKENTYPE_LESS_AMP = 37;
static const int64_t TOKENTYPE_GREATER_AMP = 38;
static const int64_t TOKENTYPE_LESS_GREATER = 39;
static const int64_t TOKENTYPE_GREATER_PIPE = 40;
static const int64_t TOKENTYPE_LESS_LESS_MINUS = 41;
static const int64_t TOKENTYPE_LESS_LESS_LESS = 42;
static const int64_t TOKENTYPE_AMP_GREATER = 43;
static const int64_t TOKENTYPE_AMP_GREATER_GREATER = 44;
static const int64_t TOKENTYPE_PIPE_AMP = 45;
static const int64_t TOKENTYPE_IF = 50;
static const int64_t TOKENTYPE_THEN = 51;
static const int64_t TOKENTYPE_ELSE = 52;
static const int64_t TOKENTYPE_ELIF = 53;
static const int64_t TOKENTYPE_FI = 54;
static const int64_t TOKENTYPE_CASE = 55;
static const int64_t TOKENTYPE_ESAC = 56;
static const int64_t TOKENTYPE_FOR = 57;
static const int64_t TOKENTYPE_WHILE = 58;
static const int64_t TOKENTYPE_UNTIL = 59;
static const int64_t TOKENTYPE_DO = 60;
static const int64_t TOKENTYPE_DONE = 61;
static const int64_t TOKENTYPE_IN = 62;
static const int64_t TOKENTYPE_FUNCTION = 63;
static const int64_t TOKENTYPE_SELECT = 64;
static const int64_t TOKENTYPE_COPROC = 65;
static const int64_t TOKENTYPE_TIME = 66;
static const int64_t TOKENTYPE_BANG = 67;
static const int64_t TOKENTYPE_LBRACKET_LBRACKET = 68;
static const int64_t TOKENTYPE_RBRACKET_RBRACKET = 69;
static const int64_t TOKENTYPE_ASSIGNMENT_WORD = 80;
static const int64_t TOKENTYPE_NUMBER = 81;
static const int64_t PARSERSTATEFLAGS_NONE = 0;
static const int64_t PARSERSTATEFLAGS_PST_CASEPAT = 1;
static const int64_t PARSERSTATEFLAGS_PST_CMDSUBST = 2;
static const int64_t PARSERSTATEFLAGS_PST_CASESTMT = 4;
static const int64_t PARSERSTATEFLAGS_PST_CONDEXPR = 8;
static const int64_t PARSERSTATEFLAGS_PST_COMPASSIGN = 16;
static const int64_t PARSERSTATEFLAGS_PST_ARITH = 32;
static const int64_t PARSERSTATEFLAGS_PST_HEREDOC = 64;
static const int64_t PARSERSTATEFLAGS_PST_REGEXP = 128;
static const int64_t PARSERSTATEFLAGS_PST_EXTPAT = 256;
static const int64_t PARSERSTATEFLAGS_PST_SUBSHELL = 512;
static const int64_t PARSERSTATEFLAGS_PST_REDIRLIST = 1024;
static const int64_t PARSERSTATEFLAGS_PST_COMMENT = 2048;
static const int64_t PARSERSTATEFLAGS_PST_EOFTOKEN = 4096;
static const int64_t DOLBRACESTATE_NONE = 0;
static const int64_t DOLBRACESTATE_PARAM = 1;
static const int64_t DOLBRACESTATE_OP = 2;
static const int64_t DOLBRACESTATE_WORD = 4;
static const int64_t DOLBRACESTATE_QUOTE = 64;
static const int64_t DOLBRACESTATE_QUOTE2 = 128;
static const int64_t MATCHEDPAIRFLAGS_NONE = 0;
static const int64_t MATCHEDPAIRFLAGS_DQUOTE = 1;
static const int64_t MATCHEDPAIRFLAGS_DOLBRACE = 2;
static const int64_t MATCHEDPAIRFLAGS_COMMAND = 4;
static const int64_t MATCHEDPAIRFLAGS_ARITH = 8;
static const int64_t MATCHEDPAIRFLAGS_ALLOWESC = 16;
static const int64_t MATCHEDPAIRFLAGS_EXTGLOB = 32;
static const int64_t MATCHEDPAIRFLAGS_FIRSTCLOSE = 64;
static const int64_t MATCHEDPAIRFLAGS_ARRAYSUB = 128;
static const int64_t MATCHEDPAIRFLAGS_BACKQUOTE = 256;
static const int64_t PARSECONTEXT_NORMAL = 0;
static const int64_t PARSECONTEXT_COMMAND_SUB = 1;
static const int64_t PARSECONTEXT_ARITHMETIC = 2;
static const int64_t PARSECONTEXT_CASE_PATTERN = 3;
static const int64_t PARSECONTEXT_BRACE_EXPANSION = 4;
static void * RESERVED_WORDS;  // initialized in init()
static void * COND_UNARY_OPS;  // initialized in init()
static void * COND_BINARY_OPS;  // initialized in init()
static void * COMPOUND_KEYWORDS;  // initialized in init()
static void * ASSIGNMENT_BUILTINS;  // initialized in init()
static const int64_t SMP_LITERAL = 1;
static const int64_t SMP_PAST_OPEN = 2;
static const int64_t WORD_CTX_NORMAL = 0;
static const int64_t WORD_CTX_COND = 1;
static const int64_t WORD_CTX_REGEX = 2;

// === Function declarations ===
static bool is_hex_digit(const char * c);
static bool is_octal_digit(const char * c);
static int64_t get_ansi_escape(const char * c);
static bool is_whitespace(const char * c);
static Vec_Byte string_to_bytes(const char * s);
static bool is_whitespace_no_newline(const char * c);
static const char * substring(const char * s, int64_t start, int64_t end);
static bool starts_with_at(const char * s, int64_t pos, const char * prefix);
static int64_t count_consecutive_dollars_before(const char * s, int64_t pos);
static bool is_expansion_start(const char * s, int64_t pos, const char * delimiter);
static Vec_Node sublist(Vec_Node lst, int64_t start, int64_t end);
static const char * repeat_str(const char * s, int64_t n);
static const char * strip_line_continuations_comment_aware(const char * text);
static const char * append_redirects(const char * base, Vec_Node * redirects);
static const char * format_arith_val(const char * s);
static Tuple_int64_t_Vec_Str consume_single_quote(const char * s, int64_t start);
static Tuple_int64_t_Vec_Str consume_double_quote(const char * s, int64_t start);
static bool has_bracket_close(const char * s, int64_t start, int64_t depth);
static Tuple_int64_t_Vec_Str_bool consume_bracket_class(const char * s, int64_t start, int64_t depth);
static const char * format_cond_body(Node * node);
static bool starts_with_subshell(Node * node);
static const char * format_cmdsub_node(Node * node, int64_t indent, bool in_procsub, bool compact_redirects, bool procsub_first);
static const char * format_redirect(Node * r, bool compact, bool heredoc_op_only);
static const char * format_heredoc_body(Node * r);
static bool lookahead_for_esac(const char * value, int64_t start, int64_t case_depth);
static int64_t skip_backtick(const char * value, int64_t start);
static int64_t skip_single_quoted(const char * s, int64_t start);
static int64_t skip_double_quoted(const char * s, int64_t start);
static bool is_valid_arithmetic_start(const char * value, int64_t start);
static int64_t find_funsub_end(const char * value, int64_t start);
static int64_t find_cmdsub_end(const char * value, int64_t start);
static int64_t find_braced_param_end(const char * value, int64_t start);
static int64_t skip_heredoc(const char * value, int64_t start);
static Tuple_int64_t_int64_t find_heredoc_content_end(const char * source, int64_t start, Vec_Tuple_constcharPtr_bool delimiters);
static bool is_word_boundary(const char * s, int64_t pos, int64_t word_len);
static bool is_quote(const char * c);
static const char * collapse_whitespace(const char * s);
static int64_t count_trailing_backslashes(const char * s);
static const char * normalize_heredoc_delimiter(const char * delimiter);
static bool is_metachar(const char * c);
static bool is_funsub_char(const char * c);
static bool is_extglob_prefix(const char * c);
static bool is_redirect_char(const char * c);
static bool is_special_param(const char * c);
static bool is_special_param_unbraced(const char * c);
static bool is_digit(const char * c);
static bool is_semicolon_or_newline(const char * c);
static bool is_word_end_context(const char * c);
static int64_t skip_matched_pair(const char * s, int64_t start, const char * open, const char * close, int64_t flags);
static int64_t skip_subscript(const char * s, int64_t start, int64_t flags);
static int64_t assignment(const char * s, int64_t flags);
static bool is_array_assignment_prefix(Vec_Str chars);
static bool is_special_param_or_digit(const char * c);
static bool is_param_expansion_op(const char * c);
static bool is_simple_param_op(const char * c);
static bool is_escape_char_in_backtick(const char * c);
static bool is_negation_boundary(const char * c);
static bool is_backslash_escaped(const char * value, int64_t idx);
static bool is_dollar_dollar_paren(const char * value, int64_t idx);
static bool is_paren(const char * c);
static bool is_caret_or_bang(const char * c);
static bool is_at_or_star(const char * c);
static bool is_digit_or_dash(const char * c);
static bool is_newline_or_right_paren(const char * c);
static bool is_semicolon_newline_brace(const char * c);
static bool looks_like_assignment(const char * s);
static bool is_valid_identifier(const char * name);
static Vec_Node parse(const char * source, bool extglob);
static ParseError * new_parse_error(const char * message, int64_t pos, int64_t line);
static MatchedPairError * new_matched_pair_error(const char * message, int64_t pos, int64_t line);
static QuoteState * new_quote_state(void);
static ParseContext * new_parse_context(int64_t kind);
static ContextStack * new_context_stack(void);
static Lexer * new_lexer(const char * source, bool extglob);
static Parser * new_parser(const char * source, bool in_process_sub, bool extglob);
static const char * Node_get_kind(Node *self);
static const char * Node_to_sexp(Node *self);
static const char * ParseError_format_message(ParseError *self);
static const char * Token__repr__(Token *self);
static void QuoteState_push(QuoteState *self);
static void QuoteState_pop(QuoteState *self);
static bool QuoteState_in_quotes(QuoteState *self);
static QuoteState * QuoteState_copy(QuoteState *self);
static bool QuoteState_outer_double(QuoteState *self);
static ParseContext * ParseContext_copy(ParseContext *self);
static ParseContext * ContextStack_get_current(ContextStack *self);
static void ContextStack_push(ContextStack *self, int64_t kind);
static ParseContext * ContextStack_pop(ContextStack *self);
static Vec_ParseContext ContextStack_copy_stack(ContextStack *self);
static void ContextStack_restore_from(ContextStack *self, Vec_ParseContext saved_stack);
static const char * Lexer_peek(Lexer *self);
static const char * Lexer_advance(Lexer *self);
static bool Lexer_at_end(Lexer *self);
static const char * Lexer_lookahead(Lexer *self, int64_t n);
static bool Lexer_is_metachar(Lexer *self, const char * c);
static Token * Lexer_read_operator(Lexer *self);
static void Lexer_skip_blanks(Lexer *self);
static bool Lexer_skip_comment(Lexer *self);
static Tuple_constcharPtr_bool Lexer_read_single_quote(Lexer *self, int64_t start);
static bool Lexer_is_word_terminator(Lexer *self, int64_t ctx, const char * ch, int64_t bracket_depth, int64_t paren_depth);
static bool Lexer_read_bracket_expression(Lexer *self, Vec_Str * chars, Vec_Node parts, bool for_regex, int64_t paren_depth);
static const char * Lexer_parse_matched_pair(Lexer *self, const char * open_char, const char * close_char, int64_t flags, bool initial_was_dollar);
static const char * Lexer_collect_param_argument(Lexer *self, int64_t flags, bool was_dollar);
static Word * Lexer_read_word_internal(Lexer *self, int64_t ctx, bool at_command_start, bool in_array_literal, bool in_assign_builtin);
static Token * Lexer_read_word(Lexer *self);
static Token * Lexer_next_token(Lexer *self);
static Token * Lexer_peek_token(Lexer *self);
static Tuple_NodePtr_constcharPtr Lexer_read_ansi_c_quote(Lexer *self);
static void Lexer_sync_to_parser(Lexer *self);
static void Lexer_sync_from_parser(Lexer *self);
static Tuple_NodePtr_constcharPtr_Vec_Node Lexer_read_locale_string(Lexer *self);
static void Lexer_update_dolbrace_for_op(Lexer *self, const char * op, bool has_param);
static const char * Lexer_consume_param_operator(Lexer *self);
static bool Lexer_param_subscript_has_close(Lexer *self, int64_t start_pos);
static const char * Lexer_consume_param_name(Lexer *self);
static Tuple_NodePtr_constcharPtr Lexer_read_param_expansion(Lexer *self, bool in_dquote);
static Tuple_NodePtr_constcharPtr Lexer_read_braced_param(Lexer *self, int64_t start, bool in_dquote);
static Tuple_NodePtr_constcharPtr Lexer_read_funsub(Lexer *self, int64_t start);
static const char * Word_to_sexp(Word *self);
static void Word_append_with_ctlesc(Word *self, Vec_Byte * result, int64_t byte_val);
static const char * Word_double_ctlesc_smart(Word *self, const char * value);
static const char * Word_normalize_param_expansion_newlines(Word *self, const char * value);
static const char * Word_sh_single_quote(Word *self, const char * s);
static Vec_Byte Word_ansi_c_to_bytes(Word *self, const char * inner);
static const char * Word_expand_ansi_c_escapes(Word *self, const char * value);
static const char * Word_expand_all_ansi_c_quotes(Word *self, const char * value);
static const char * Word_strip_locale_string_dollars(Word *self, const char * value);
static const char * Word_normalize_array_whitespace(Word *self, const char * value);
static int64_t Word_find_matching_paren(Word *self, const char * value, int64_t open_pos);
static const char * Word_normalize_array_inner(Word *self, const char * inner);
static const char * Word_strip_arith_line_continuations(Word *self, const char * value);
static Vec_Node Word_collect_cmdsubs(Word *self, Node * node);
static Vec_Node Word_collect_procsubs(Word *self, Node * node);
static const char * Word_format_command_substitutions(Word *self, const char * value, bool in_arith);
static const char * Word_normalize_extglob_whitespace(Word *self, const char * value);
static const char * Word_get_cond_formatted_value(Word *self);
static const char * Word_get_kind(Word *self);
static const char * Command_to_sexp(Command *self);
static const char * Command_get_kind(Command *self);
static const char * Pipeline_to_sexp(Pipeline *self);
static const char * Pipeline_cmd_sexp(Pipeline *self, Node * cmd, bool needs_redirect);
static const char * Pipeline_get_kind(Pipeline *self);
static const char * List_to_sexp(List *self);
static const char * List_to_sexp_with_precedence(List *self, Vec_Node parts, void * op_names);
static const char * List_to_sexp_amp_and_higher(List *self, Vec_Node parts, void * op_names);
static const char * List_to_sexp_and_or(List *self, Vec_Node parts, void * op_names);
static const char * List_get_kind(List *self);
static const char * Operator_to_sexp(Operator *self);
static const char * Operator_get_kind(Operator *self);
static const char * PipeBoth_to_sexp(PipeBoth *self);
static const char * PipeBoth_get_kind(PipeBoth *self);
static const char * Empty_to_sexp(Empty *self);
static const char * Empty_get_kind(Empty *self);
static const char * Comment_to_sexp(Comment *self);
static const char * Comment_get_kind(Comment *self);
static const char * Redirect_to_sexp(Redirect *self);
static const char * Redirect_get_kind(Redirect *self);
static const char * HereDoc_to_sexp(HereDoc *self);
static const char * HereDoc_get_kind(HereDoc *self);
static const char * Subshell_to_sexp(Subshell *self);
static const char * Subshell_get_kind(Subshell *self);
static const char * BraceGroup_to_sexp(BraceGroup *self);
static const char * BraceGroup_get_kind(BraceGroup *self);
static const char * If_to_sexp(If *self);
static const char * If_get_kind(If *self);
static const char * While_to_sexp(While *self);
static const char * While_get_kind(While *self);
static const char * Until_to_sexp(Until *self);
static const char * Until_get_kind(Until *self);
static const char * For_to_sexp(For *self);
static const char * For_get_kind(For *self);
static const char * ForArith_to_sexp(ForArith *self);
static const char * ForArith_get_kind(ForArith *self);
static const char * Select_to_sexp(Select *self);
static const char * Select_get_kind(Select *self);
static const char * Case_to_sexp(Case *self);
static const char * Case_get_kind(Case *self);
static const char * CasePattern_to_sexp(CasePattern *self);
static const char * CasePattern_get_kind(CasePattern *self);
static const char * Function_to_sexp(Function *self);
static const char * Function_get_kind(Function *self);
static const char * ParamExpansion_to_sexp(ParamExpansion *self);
static const char * ParamExpansion_get_kind(ParamExpansion *self);
static const char * ParamLength_to_sexp(ParamLength *self);
static const char * ParamLength_get_kind(ParamLength *self);
static const char * ParamIndirect_to_sexp(ParamIndirect *self);
static const char * ParamIndirect_get_kind(ParamIndirect *self);
static const char * CommandSubstitution_to_sexp(CommandSubstitution *self);
static const char * CommandSubstitution_get_kind(CommandSubstitution *self);
static const char * ArithmeticExpansion_to_sexp(ArithmeticExpansion *self);
static const char * ArithmeticExpansion_get_kind(ArithmeticExpansion *self);
static const char * ArithmeticCommand_to_sexp(ArithmeticCommand *self);
static const char * ArithmeticCommand_get_kind(ArithmeticCommand *self);
static const char * ArithNumber_to_sexp(ArithNumber *self);
static const char * ArithNumber_get_kind(ArithNumber *self);
static const char * ArithEmpty_to_sexp(ArithEmpty *self);
static const char * ArithEmpty_get_kind(ArithEmpty *self);
static const char * ArithVar_to_sexp(ArithVar *self);
static const char * ArithVar_get_kind(ArithVar *self);
static const char * ArithBinaryOp_to_sexp(ArithBinaryOp *self);
static const char * ArithBinaryOp_get_kind(ArithBinaryOp *self);
static const char * ArithUnaryOp_to_sexp(ArithUnaryOp *self);
static const char * ArithUnaryOp_get_kind(ArithUnaryOp *self);
static const char * ArithPreIncr_to_sexp(ArithPreIncr *self);
static const char * ArithPreIncr_get_kind(ArithPreIncr *self);
static const char * ArithPostIncr_to_sexp(ArithPostIncr *self);
static const char * ArithPostIncr_get_kind(ArithPostIncr *self);
static const char * ArithPreDecr_to_sexp(ArithPreDecr *self);
static const char * ArithPreDecr_get_kind(ArithPreDecr *self);
static const char * ArithPostDecr_to_sexp(ArithPostDecr *self);
static const char * ArithPostDecr_get_kind(ArithPostDecr *self);
static const char * ArithAssign_to_sexp(ArithAssign *self);
static const char * ArithAssign_get_kind(ArithAssign *self);
static const char * ArithTernary_to_sexp(ArithTernary *self);
static const char * ArithTernary_get_kind(ArithTernary *self);
static const char * ArithComma_to_sexp(ArithComma *self);
static const char * ArithComma_get_kind(ArithComma *self);
static const char * ArithSubscript_to_sexp(ArithSubscript *self);
static const char * ArithSubscript_get_kind(ArithSubscript *self);
static const char * ArithEscape_to_sexp(ArithEscape *self);
static const char * ArithEscape_get_kind(ArithEscape *self);
static const char * ArithDeprecated_to_sexp(ArithDeprecated *self);
static const char * ArithDeprecated_get_kind(ArithDeprecated *self);
static const char * ArithConcat_to_sexp(ArithConcat *self);
static const char * ArithConcat_get_kind(ArithConcat *self);
static const char * AnsiCQuote_to_sexp(AnsiCQuote *self);
static const char * AnsiCQuote_get_kind(AnsiCQuote *self);
static const char * LocaleString_to_sexp(LocaleString *self);
static const char * LocaleString_get_kind(LocaleString *self);
static const char * ProcessSubstitution_to_sexp(ProcessSubstitution *self);
static const char * ProcessSubstitution_get_kind(ProcessSubstitution *self);
static const char * Negation_to_sexp(Negation *self);
static const char * Negation_get_kind(Negation *self);
static const char * Time_to_sexp(Time *self);
static const char * Time_get_kind(Time *self);
static const char * ConditionalExpr_to_sexp(ConditionalExpr *self);
static const char * ConditionalExpr_get_kind(ConditionalExpr *self);
static const char * UnaryTest_to_sexp(UnaryTest *self);
static const char * UnaryTest_get_kind(UnaryTest *self);
static const char * BinaryTest_to_sexp(BinaryTest *self);
static const char * BinaryTest_get_kind(BinaryTest *self);
static const char * CondAnd_to_sexp(CondAnd *self);
static const char * CondAnd_get_kind(CondAnd *self);
static const char * CondOr_to_sexp(CondOr *self);
static const char * CondOr_get_kind(CondOr *self);
static const char * CondNot_to_sexp(CondNot *self);
static const char * CondNot_get_kind(CondNot *self);
static const char * CondParen_to_sexp(CondParen *self);
static const char * CondParen_get_kind(CondParen *self);
static const char * Array_to_sexp(Array *self);
static const char * Array_get_kind(Array *self);
static const char * Coproc_to_sexp(Coproc *self);
static const char * Coproc_get_kind(Coproc *self);
static void Parser_set_state(Parser *self, int64_t flag);
static void Parser_clear_state(Parser *self, int64_t flag);
static bool Parser_in_state(Parser *self, int64_t flag);
static SavedParserState * Parser_save_parser_state(Parser *self);
static void Parser_restore_parser_state(Parser *self, SavedParserState * saved);
static void Parser_record_token(Parser *self, Token * tok);
static void Parser_update_dolbrace_for_op(Parser *self, const char * op, bool has_param);
static void Parser_sync_lexer(Parser *self);
static void Parser_sync_parser(Parser *self);
static Token * Parser_lex_peek_token(Parser *self);
static Token * Parser_lex_next_token(Parser *self);
static void Parser_lex_skip_blanks(Parser *self);
static bool Parser_lex_skip_comment(Parser *self);
static bool Parser_lex_is_command_terminator(Parser *self);
static Tuple_int64_t_constcharPtr Parser_lex_peek_operator(Parser *self);
static const char * Parser_lex_peek_reserved_word(Parser *self);
static bool Parser_lex_is_at_reserved_word(Parser *self, const char * word);
static bool Parser_lex_consume_word(Parser *self, const char * expected);
static const char * Parser_lex_peek_case_terminator(Parser *self);
static bool Parser_at_end(Parser *self);
static const char * Parser_peek(Parser *self);
static const char * Parser_advance(Parser *self);
static const char * Parser_peek_at(Parser *self, int64_t offset);
static const char * Parser_lookahead(Parser *self, int64_t n);
static bool Parser_is_bang_followed_by_procsub(Parser *self);
static void Parser_skip_whitespace(Parser *self);
static void Parser_skip_whitespace_and_newlines(Parser *self);
static bool Parser_at_list_terminating_bracket(Parser *self);
static bool Parser_at_eof_token(Parser *self);
static Vec_Node Parser_collect_redirects(Parser *self);
static Node * Parser_parse_loop_body(Parser *self, const char * context);
static const char * Parser_peek_word(Parser *self);
static bool Parser_consume_word(Parser *self, const char * expected);
static bool Parser_is_word_terminator(Parser *self, int64_t ctx, const char * ch, int64_t bracket_depth, int64_t paren_depth);
static void Parser_scan_double_quote(Parser *self, Vec_Str * chars, Vec_Node parts, int64_t start, bool handle_line_continuation);
static bool Parser_parse_dollar_expansion(Parser *self, Vec_Str * chars, Vec_Node * parts, bool in_dquote);
static Word * Parser_parse_word_internal(Parser *self, int64_t ctx, bool at_command_start, bool in_array_literal);
static Word * Parser_parse_word(Parser *self, bool at_command_start, bool in_array_literal, bool in_assign_builtin);
static Tuple_NodePtr_constcharPtr Parser_parse_command_substitution(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_funsub(Parser *self, int64_t start);
static bool Parser_is_assignment_word(Parser *self, Node * word);
static Tuple_NodePtr_constcharPtr Parser_parse_backtick_substitution(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_process_substitution(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_array_literal(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_arithmetic_expansion(Parser *self);
static Node * Parser_parse_arith_expr(Parser *self, const char * content);
static bool Parser_arith_at_end(Parser *self);
static const char * Parser_arith_peek(Parser *self, int64_t offset);
static const char * Parser_arith_advance(Parser *self);
static void Parser_arith_skip_ws(Parser *self);
static bool Parser_arith_match(Parser *self, const char * s);
static bool Parser_arith_consume(Parser *self, const char * s);
static Node * Parser_arith_parse_comma(Parser *self);
static Node * Parser_arith_parse_assign(Parser *self);
static Node * Parser_arith_parse_ternary(Parser *self);
static Node * Parser_arith_parse_left_assoc(Parser *self, Vec_Str ops, Node * (*parsefn)(Parser *));
static Node * Parser_arith_parse_logical_or(Parser *self);
static Node * Parser_arith_parse_logical_and(Parser *self);
static Node * Parser_arith_parse_bitwise_or(Parser *self);
static Node * Parser_arith_parse_bitwise_xor(Parser *self);
static Node * Parser_arith_parse_bitwise_and(Parser *self);
static Node * Parser_arith_parse_equality(Parser *self);
static Node * Parser_arith_parse_comparison(Parser *self);
static Node * Parser_arith_parse_shift(Parser *self);
static Node * Parser_arith_parse_additive(Parser *self);
static Node * Parser_arith_parse_multiplicative(Parser *self);
static Node * Parser_arith_parse_exponentiation(Parser *self);
static Node * Parser_arith_parse_unary(Parser *self);
static Node * Parser_arith_parse_postfix(Parser *self);
static Node * Parser_arith_parse_primary(Parser *self);
static Node * Parser_arith_parse_expansion(Parser *self);
static Node * Parser_arith_parse_cmdsub(Parser *self);
static Node * Parser_arith_parse_braced_param(Parser *self);
static Node * Parser_arith_parse_single_quote(Parser *self);
static Node * Parser_arith_parse_double_quote(Parser *self);
static Node * Parser_arith_parse_backtick(Parser *self);
static Node * Parser_arith_parse_number_or_var(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_deprecated_arithmetic(Parser *self);
static Tuple_NodePtr_constcharPtr Parser_parse_param_expansion(Parser *self, bool in_dquote);
static Node * Parser_parse_redirect(Parser *self);
static Tuple_constcharPtr_bool Parser_parse_heredoc_delimiter(Parser *self);
static Tuple_constcharPtr_int64_t Parser_read_heredoc_line(Parser *self, bool quoted);
static Tuple_bool_constcharPtr Parser_line_matches_delimiter(Parser *self, const char * line, const char * delimiter, bool strip_tabs);
static void Parser_gather_heredoc_bodies(Parser *self);
static HereDoc * Parser_parse_heredoc(Parser *self, int64_t fd, bool strip_tabs);
static Command * Parser_parse_command(Parser *self);
static Subshell * Parser_parse_subshell(Parser *self);
static ArithmeticCommand * Parser_parse_arithmetic_command(Parser *self);
static ConditionalExpr * Parser_parse_conditional_expr(Parser *self);
static void Parser_cond_skip_whitespace(Parser *self);
static bool Parser_cond_at_end(Parser *self);
static Node * Parser_parse_cond_or(Parser *self);
static Node * Parser_parse_cond_and(Parser *self);
static Node * Parser_parse_cond_term(Parser *self);
static Word * Parser_parse_cond_word(Parser *self);
static Word * Parser_parse_cond_regex_word(Parser *self);
static BraceGroup * Parser_parse_brace_group(Parser *self);
static If * Parser_parse_if(Parser *self);
static If * Parser_parse_elif_chain(Parser *self);
static While * Parser_parse_while(Parser *self);
static Until * Parser_parse_until(Parser *self);
static Node * Parser_parse_for(Parser *self);
static ForArith * Parser_parse_for_arith(Parser *self);
static Select * Parser_parse_select(Parser *self);
static const char * Parser_consume_case_terminator(Parser *self);
static Case * Parser_parse_case(Parser *self);
static Coproc * Parser_parse_coproc(Parser *self);
static Function * Parser_parse_function(Parser *self);
static Node * Parser_parse_compound_command(Parser *self);
static bool Parser_at_list_until_terminator(Parser *self, void * stop_words);
static Node * Parser_parse_list_until(Parser *self, void * stop_words);
static Node * Parser_parse_pipeline(Parser *self);
static Node * Parser_parse_simple_pipeline(Parser *self);
static const char * Parser_parse_list_operator(Parser *self);
static const char * Parser_peek_list_operator(Parser *self);
static Node * Parser_parse_list(Parser *self, bool newline_as_separator);
static Node * Parser_parse_comment(Parser *self);
static Vec_Node Parser_parse(Parser *self);
static bool Parser_last_word_on_own_line(Parser *self, Vec_Node nodes);
static void Parser_strip_trailing_backslash_from_last_word(Parser *self, Vec_Node nodes);
static Word * Parser_find_last_word(Parser *self, Node * node);

static bool is_hex_digit(const char * c) {
    return ((((c[0] >= '0') && (c[0] <= '9')) || ((c[0] >= 'a') && (c[0] <= 'f'))) || ((c[0] >= 'A') && (c[0] <= 'F')));
}

static bool is_octal_digit(const char * c) {
    return ((c[0] >= '0') && (c[0] <= '7'));
}

static int64_t get_ansi_escape(const char * c) {
    return 0 /* map_get(ANSI_C_ESCAPES, c) */;
}

static bool is_whitespace(const char * c) {
    return (((strcmp(c, " ") == 0) || (strcmp(c, "\t") == 0)) || (strcmp(c, "\n") == 0));
}

static Vec_Byte string_to_bytes(const char * s) {
    return _str_to_bytes(g_arena, s) /* copy */;
}

static bool is_whitespace_no_newline(const char * c) {
    return ((strcmp(c, " ") == 0) || (strcmp(c, "\t") == 0));
}

static const char * substring(const char * s, int64_t start, int64_t end) {
    return _substring(g_arena, s, start, end);
}

static bool starts_with_at(const char * s, int64_t pos, const char * prefix) {
    return _str_startswith(s, prefix);
}

static int64_t count_consecutive_dollars_before(const char * s, int64_t pos) {
    int64_t count = 0;
    int64_t k = (pos - 1);
    while (((k >= 0) && (strcmp((const char *)(_char_at_str(g_arena, s, k)), "$") == 0))) {
        int64_t bs_count = 0;
        int64_t j = (k - 1);
        while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, s, j)), "\\") == 0))) {
            bs_count += 1;
            j -= 1;
        }
        if (((bs_count % 2) == 1)) {
            break;
        }
        count += 1;
        k -= 1;
    }
    return count;
}

static bool is_expansion_start(const char * s, int64_t pos, const char * delimiter) {
    if (!(starts_with_at(s, pos, delimiter))) {
        return false;
    }
    return ((count_consecutive_dollars_before(s, pos) % 2) == 0);
}

static Vec_Node sublist(Vec_Node lst, int64_t start, int64_t end) {
    return /* slice[start:end] */ lst;
}

static const char * repeat_str(const char * s, int64_t n) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    while ((i < n)) {
        VEC_PUSH(g_arena, &result, (s));
        i += 1;
    }
    return _str_join(g_arena, "", result);
}

static const char * strip_line_continuations_comment_aware(const char * text) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    bool in_comment = false;
    QuoteState * quote = new_quote_state();
    while ((i < _rune_len(text))) {
        const char * c = (const char *)(_char_at_str(g_arena, text, i));
        if ((((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(text))) && (strcmp((const char *)(_char_at_str(g_arena, text, (i + 1))), "\n") == 0))) {
            int64_t num_preceding_backslashes = 0;
            int64_t j = (i - 1);
            while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, text, j)), "\\") == 0))) {
                num_preceding_backslashes += 1;
                j -= 1;
            }
            if (((num_preceding_backslashes % 2) == 0)) {
                if (in_comment) {
                    VEC_PUSH(g_arena, &result, ("\n"));
                }
                i += 2;
                in_comment = false;
                continue;
            }
        }
        if ((strcmp(c, "\n") == 0)) {
            in_comment = false;
            VEC_PUSH(g_arena, &result, (c));
            i += 1;
            continue;
        }
        if ((((strcmp(c, "'") == 0) && !(quote->double_)) && !(in_comment))) {
            quote->single = !(quote->single);
        } else if ((((strcmp(c, "\"") == 0) && !(quote->single)) && !(in_comment))) {
            quote->double_ = !(quote->double_);
        } else if ((((strcmp(c, "#") == 0) && !(quote->single)) && !(in_comment))) {
            in_comment = true;
        }
        VEC_PUSH(g_arena, &result, (c));
        i += 1;
    }
    return _str_join(g_arena, "", result);
}

static const char * append_redirects(const char * base, Vec_Node * redirects) {
    if ((redirects != NULL)) {
        Vec_Str parts = (Vec_Str){NULL, 0, 0};
        if (redirects != NULL) {
            for (size_t _idx = 0; _idx < redirects->len; _idx++) {
                Node * r = redirects->data[_idx];
                VEC_PUSH(g_arena, &parts, (Node_to_sexp(r)));
            }
        }
        return _str_concat(g_arena, _str_concat(g_arena, base, " "), _str_join(g_arena, " ", parts));
    }
    return base;
}

static const char * format_arith_val(const char * s) {
    Word * w = Word_new(s, (Vec_Node){NULL, 0, 0}, "word");
    const char * val = Word_expand_all_ansi_c_quotes(w, s);
    val = Word_strip_locale_string_dollars(w, val);
    val = Word_format_command_substitutions(w, val, false);
    val = _str_replace(g_arena, _str_replace(g_arena, val, "\\", "\\\\"), "\"", "\\\"");
    val = _str_replace(g_arena, _str_replace(g_arena, val, "\n", "\\n"), "\t", "\\t");
    return val;
}

static Tuple_int64_t_Vec_Str consume_single_quote(const char * s, int64_t start) {
    Vec_Str chars = (Vec_Str){(const char *[]){ "'" }, 1, 1};
    int64_t i = (start + 1);
    while (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "'") != 0))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    if ((i < _rune_len(s))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    return (Tuple_int64_t_Vec_Str){i, chars};
}

static Tuple_int64_t_Vec_Str consume_double_quote(const char * s, int64_t start) {
    Vec_Str chars = (Vec_Str){(const char *[]){ "\"" }, 1, 1};
    int64_t i = (start + 1);
    while (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "\"") != 0))) {
        if (((strcmp((const char *)(_char_at_str(g_arena, s, i)), "\\") == 0) && ((i + 1) < _rune_len(s)))) {
            VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
            i += 1;
        }
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    if ((i < _rune_len(s))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    return (Tuple_int64_t_Vec_Str){i, chars};
}

static bool has_bracket_close(const char * s, int64_t start, int64_t depth) {
    int64_t i = start;
    while ((i < _rune_len(s))) {
        if ((strcmp((const char *)(_char_at_str(g_arena, s, i)), "]") == 0)) {
            return true;
        }
        if ((((strcmp((const char *)(_char_at_str(g_arena, s, i)), "|") == 0) || (strcmp((const char *)(_char_at_str(g_arena, s, i)), ")") == 0)) && (depth == 0))) {
            return false;
        }
        i += 1;
    }
    return false;
}

static Tuple_int64_t_Vec_Str_bool consume_bracket_class(const char * s, int64_t start, int64_t depth) {
    int64_t scan_pos = (start + 1);
    if (((scan_pos < _rune_len(s)) && ((strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), "!") == 0) || (strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), "^") == 0)))) {
        scan_pos += 1;
    }
    if (((scan_pos < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), "]") == 0))) {
        if (has_bracket_close(s, (scan_pos + 1), depth)) {
            scan_pos += 1;
        }
    }
    bool is_bracket = false;
    while ((scan_pos < _rune_len(s))) {
        if ((strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), "]") == 0)) {
            is_bracket = true;
            break;
        }
        if (((strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), ")") == 0) && (depth == 0))) {
            break;
        }
        if (((strcmp((const char *)(_char_at_str(g_arena, s, scan_pos)), "|") == 0) && (depth == 0))) {
            break;
        }
        scan_pos += 1;
    }
    if (!(is_bracket)) {
        return (Tuple_int64_t_Vec_Str_bool){(start + 1), (Vec_Str){(const char *[]){ "[" }, 1, 1}, false};
    }
    Vec_Str chars = (Vec_Str){(const char *[]){ "[" }, 1, 1};
    int64_t i = (start + 1);
    if (((i < _rune_len(s)) && ((strcmp((const char *)(_char_at_str(g_arena, s, i)), "!") == 0) || (strcmp((const char *)(_char_at_str(g_arena, s, i)), "^") == 0)))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    if (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "]") == 0))) {
        if (has_bracket_close(s, (i + 1), depth)) {
            VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
            i += 1;
        }
    }
    while (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "]") != 0))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    if ((i < _rune_len(s))) {
        VEC_PUSH(g_arena, &chars, ((const char *)(_char_at_str(g_arena, s, i))));
        i += 1;
    }
    return (Tuple_int64_t_Vec_Str_bool){i, chars, true};
}

static const char * format_cond_body(Node * node) {
    const char * kind = _kind_to_str(node->kind);
    if ((strcmp(kind, "unary-test") == 0)) {
        const char * operand_val = Word_get_cond_formatted_value(((UnaryTest *)(node))->operand);
        return _str_concat(g_arena, _str_concat(g_arena, ((UnaryTest *)(node))->op, " "), operand_val);
    }
    if ((strcmp(kind, "binary-test") == 0)) {
        const char * left_val = Word_get_cond_formatted_value(((BinaryTest *)(node))->left);
        const char * right_val = Word_get_cond_formatted_value(((BinaryTest *)(node))->right);
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, left_val, " "), ((BinaryTest *)(node))->op), " "), right_val);
    }
    if ((strcmp(kind, "cond-and") == 0)) {
        return _str_concat(g_arena, _str_concat(g_arena, format_cond_body((Node *)((CondAnd *)(node))->left), " && "), format_cond_body((Node *)((CondAnd *)(node))->right));
    }
    if ((strcmp(kind, "cond-or") == 0)) {
        return _str_concat(g_arena, _str_concat(g_arena, format_cond_body((Node *)((CondOr *)(node))->left), " || "), format_cond_body((Node *)((CondOr *)(node))->right));
    }
    if ((strcmp(kind, "cond-not") == 0)) {
        return _str_concat(g_arena, "! ", format_cond_body((Node *)((CondNot *)(node))->operand));
    }
    if ((strcmp(kind, "cond-paren") == 0)) {
        return _str_concat(g_arena, _str_concat(g_arena, "( ", format_cond_body((Node *)((CondParen *)(node))->inner)), " )");
    }
    return "";
}

static bool starts_with_subshell(Node * node) {
    void *_data1 = node->data;
    switch (node->kind) {
    case KIND_SUBSHELL: {
        Subshell *node = (Subshell *)_data1;
        return true;
        break;
    }
    }
    void *_data2 = node->data;
    switch (node->kind) {
    case KIND_LIST: {
        List *node = (List *)_data2;
        for (size_t _idx = 0; _idx < node->parts.len; _idx++) {
            Node * p = node->parts.data[_idx];
            if ((strcmp(_kind_to_str(p->kind), "operator") != 0)) {
                return starts_with_subshell((Node *)p);
            }
        }
        return false;
        break;
    }
    }
    void *_data3 = node->data;
    switch (node->kind) {
    case KIND_PIPELINE: {
        Pipeline *node = (Pipeline *)_data3;
        if ((node->commands.len > 0)) {
            return starts_with_subshell((Node *)node->commands.data[0]);
        }
        return false;
        break;
    }
    }
    return false;
}

static const char * format_cmdsub_node(Node * node, int64_t indent, bool in_procsub, bool compact_redirects, bool procsub_first) {
    if ((node == NULL)) {
        return "";
    }
    const char * sp = _str_repeat(g_arena, " ", indent);
    const char * inner_sp = _str_repeat(g_arena, " ", (indent + 4));
    void *_data4 = node->data;
    switch (node->kind) {
    case KIND_ARITHEMPTY: {
        ArithEmpty *node = (ArithEmpty *)_data4;
        return "";
        break;
    }
    }
    const char * result;
    Vec_Str parts;
    const char * val;
    Vec_HereDoc heredocs;
    Vec_Str word_parts;
    Vec_Str redirect_parts;
    void *_data5 = node->data;
    switch (node->kind) {
    case KIND_COMMAND: {
        Command *node = (Command *)_data5;
        parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < node->words.len; _idx++) {
            Word * w = node->words.data[_idx];
            val = Word_expand_all_ansi_c_quotes(w, w->value);
            val = Word_strip_locale_string_dollars(w, val);
            val = Word_normalize_array_whitespace(w, val);
            val = Word_format_command_substitutions(w, val, false);
            VEC_PUSH(g_arena, &parts, (val));
        }
        heredocs = (Vec_HereDoc){NULL, 0, 0};
        for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
            Node * r = node->redirects.data[_idx];
            void *_data6 = r->data;
            switch (r->kind) {
            case KIND_HEREDOC: {
                HereDoc *r = (HereDoc *)_data6;
                VEC_PUSH(g_arena, &heredocs, (r));
                break;
            }
            }
        }
        for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
            Node * r = node->redirects.data[_idx];
            VEC_PUSH(g_arena, &parts, (format_redirect((Node *)r, compact_redirects, true)));
        }
        if (((compact_redirects && (node->words.len > 0)) && (node->redirects.len > 0))) {
            word_parts = /* slice[0:node->words.len] */ parts;
            redirect_parts = /* slice[node->words.len:parts.len] */ parts;
            result = _str_concat(g_arena, _str_join(g_arena, " ", word_parts), _str_join(g_arena, "", redirect_parts));
        } else {
            result = _str_join(g_arena, " ", parts);
        }
        for (size_t _idx = 0; _idx < heredocs.len; _idx++) {
            HereDoc * h = heredocs.data[_idx];
            result = _str_concat(g_arena, result, format_heredoc_body((Node *)h));
        }
        return result;
        break;
    }
    }
    Node * cmd;
    bool needs_redirect;
    int64_t first_nl;
    Vec_Tuple_NodePtr_bool cmds;
    int64_t i;
    Vec_Str result_parts;
    int64_t idx;
    const char * formatted;
    bool is_last;
    bool has_heredoc;
    bool compact_pipe;
    const char * part;
    void *_data7 = node->data;
    switch (node->kind) {
    case KIND_PIPELINE: {
        Pipeline *node = (Pipeline *)_data7;
        cmds = (Vec_Tuple_NodePtr_bool){NULL, 0, 0};
        i = 0;
        while ((i < node->commands.len)) {
            cmd = (Node *)node->commands.data[i];
            void *_data8 = cmd->data;
            switch (cmd->kind) {
            case KIND_PIPEBOTH: {
                PipeBoth *cmd = (PipeBoth *)_data8;
                i += 1;
                continue;
                break;
            }
            }
            needs_redirect = (((i + 1) < node->commands.len) && (strcmp(_kind_to_str(node->commands.data[(i + 1)]->kind), "pipe-both") == 0));
            VEC_PUSH(g_arena, &cmds, ((Tuple_NodePtr_bool){(Node *)cmd, needs_redirect}));
            i += 1;
        }
        result_parts = (Vec_Str){NULL, 0, 0};
        idx = 0;
        while ((idx < cmds.len)) {
            {
                Tuple_NodePtr_bool entry = cmds.data[idx];
                cmd = (Node *)entry.F0;
                needs_redirect = entry.F1;
            }
            formatted = format_cmdsub_node((Node *)cmd, indent, in_procsub, false, (procsub_first && (idx == 0)));
            is_last = (idx == (cmds.len - 1));
            has_heredoc = false;
            if (((strcmp(_kind_to_str(cmd->kind), "command") == 0) && (((Command *)(cmd->data))->redirects.len > 0))) {
                for (size_t _idx = 0; _idx < ((Command *)(cmd->data))->redirects.len; _idx++) {
                    Node * r = ((Command *)(cmd->data))->redirects.data[_idx];
                    void *_data9 = r->data;
                    switch (r->kind) {
                    case KIND_HEREDOC: {
                        HereDoc *r = (HereDoc *)_data9;
                        has_heredoc = true;
                        break;
                        break;
                    }
                    }
                }
            }
            if (needs_redirect) {
                if (has_heredoc) {
                    first_nl = _str_find(formatted, "\n");
                    if ((first_nl != -(1))) {
                        formatted = _str_concat(g_arena, _str_concat(g_arena, _substring(g_arena, formatted, 0, first_nl), " 2>&1"), _substring(g_arena, formatted, first_nl, _rune_len(formatted)));
                    } else {
                        formatted = _str_concat(g_arena, formatted, " 2>&1");
                    }
                } else {
                    formatted = _str_concat(g_arena, formatted, " 2>&1");
                }
            }
            if ((!(is_last) && has_heredoc)) {
                first_nl = _str_find(formatted, "\n");
                if ((first_nl != -(1))) {
                    formatted = _str_concat(g_arena, _str_concat(g_arena, _substring(g_arena, formatted, 0, first_nl), " |"), _substring(g_arena, formatted, first_nl, _rune_len(formatted)));
                }
                VEC_PUSH(g_arena, &result_parts, (formatted));
            } else {
                VEC_PUSH(g_arena, &result_parts, (formatted));
            }
            idx += 1;
        }
        compact_pipe = ((in_procsub && (cmds.len > 0)) && (strcmp(_kind_to_str(cmds.data[0].F0->kind), "subshell") == 0));
        result = "";
        idx = 0;
        while ((idx < result_parts.len)) {
            part = result_parts.data[idx];
            if ((idx > 0)) {
                if (_str_endswith(result, "\n")) {
                    result = _str_concat(g_arena, _str_concat(g_arena, result, "  "), part);
                } else if (compact_pipe) {
                    result = _str_concat(g_arena, _str_concat(g_arena, result, "|"), part);
                } else {
                    result = _str_concat(g_arena, _str_concat(g_arena, result, " | "), part);
                }
            } else {
                result = part;
            }
            idx += 1;
        }
        return result;
        break;
    }
    }
    const char * last;
    bool skipped_semi;
    int64_t cmd_count;
    const char * formatted_cmd;
    const char * s;
    void *_data10 = node->data;
    switch (node->kind) {
    case KIND_LIST: {
        List *node = (List *)_data10;
        has_heredoc = false;
        for (size_t _idx = 0; _idx < node->parts.len; _idx++) {
            Node * p = node->parts.data[_idx];
            if (((strcmp(_kind_to_str(p->kind), "command") == 0) && (((Command *)(p->data))->redirects.len > 0))) {
                for (size_t _idx = 0; _idx < ((Command *)(p->data))->redirects.len; _idx++) {
                    Node * r = ((Command *)(p->data))->redirects.data[_idx];
                    void *_data11 = r->data;
                    switch (r->kind) {
                    case KIND_HEREDOC: {
                        HereDoc *r = (HereDoc *)_data11;
                        has_heredoc = true;
                        break;
                        break;
                    }
                    }
                }
            } else {
                void *_data12 = p->data;
                switch (p->kind) {
                case KIND_PIPELINE: {
                    Pipeline *p = (Pipeline *)_data12;
                    for (size_t _idx = 0; _idx < p->commands.len; _idx++) {
                        Node * cmd = p->commands.data[_idx];
                        if (((strcmp(_kind_to_str(cmd->kind), "command") == 0) && (((Command *)(cmd->data))->redirects.len > 0))) {
                            for (size_t _idx = 0; _idx < ((Command *)(cmd->data))->redirects.len; _idx++) {
                                Node * r = ((Command *)(cmd->data))->redirects.data[_idx];
                                void *_data13 = r->data;
                                switch (r->kind) {
                                case KIND_HEREDOC: {
                                    HereDoc *r = (HereDoc *)_data13;
                                    has_heredoc = true;
                                    break;
                                    break;
                                }
                                }
                            }
                        }
                        if (has_heredoc) {
                            break;
                        }
                    }
                    break;
                }
                }
            }
        }
        Vec_Str result = (Vec_Str){NULL, 0, 0};
        skipped_semi = false;
        cmd_count = 0;
        for (size_t _idx = 0; _idx < node->parts.len; _idx++) {
            Node * p = node->parts.data[_idx];
            void *_data14 = p->data;
            switch (p->kind) {
            case KIND_OPERATOR: {
                Operator *p = (Operator *)_data14;
                if ((strcmp(p->op, ";") == 0)) {
                    if (((result.len > 0) && _str_endswith(result.data[(result.len - 1)], "\n"))) {
                        skipped_semi = true;
                        continue;
                    }
                    if ((((result.len >= 3) && (strcmp(result.data[(result.len - 2)], "\n") == 0)) && _str_endswith(result.data[(result.len - 3)], "\n"))) {
                        skipped_semi = true;
                        continue;
                    }
                    VEC_PUSH(g_arena, &result, (";"));
                    skipped_semi = false;
                } else if ((strcmp(p->op, "\n") == 0)) {
                    if (((result.len > 0) && (strcmp(result.data[(result.len - 1)], ";") == 0))) {
                        skipped_semi = false;
                        continue;
                    }
                    if (((result.len > 0) && _str_endswith(result.data[(result.len - 1)], "\n"))) {
                        VEC_PUSH(g_arena, &result, ((skipped_semi ? " " : "\n")));
                        skipped_semi = false;
                        continue;
                    }
                    VEC_PUSH(g_arena, &result, ("\n"));
                    skipped_semi = false;
                } else if ((strcmp(p->op, "&") == 0)) {
                    if ((((result.len > 0) && _str_contains(result.data[(result.len - 1)], "<<")) && _str_contains(result.data[(result.len - 1)], "\n"))) {
                        last = result.data[(result.len - 1)];
                        if ((_str_contains(last, " |") || _str_startswith(last, "|"))) {
                            result.data[(result.len - 1)] = _str_concat(g_arena, last, " &");
                        } else {
                            first_nl = _str_find(last, "\n");
                            result.data[(result.len - 1)] = _str_concat(g_arena, _str_concat(g_arena, _substring(g_arena, last, 0, first_nl), " &"), _substring(g_arena, last, first_nl, _rune_len(last)));
                        }
                    } else {
                        VEC_PUSH(g_arena, &result, (" &"));
                    }
                } else if ((((result.len > 0) && _str_contains(result.data[(result.len - 1)], "<<")) && _str_contains(result.data[(result.len - 1)], "\n"))) {
                    last = result.data[(result.len - 1)];
                    first_nl = _str_find(last, "\n");
                    result.data[(result.len - 1)] = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _substring(g_arena, last, 0, first_nl), " "), p->op), " "), _substring(g_arena, last, first_nl, _rune_len(last)));
                } else {
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, " ", p->op)));
                }
                break;
            }
            default: {
                if (((result.len > 0) && !((_str_endswith(result.data[(result.len - 1)], " ") || _str_endswith(result.data[(result.len - 1)], "\n"))))) {
                    VEC_PUSH(g_arena, &result, (" "));
                }
                formatted_cmd = format_cmdsub_node((Node *)p, indent, in_procsub, compact_redirects, (procsub_first && (cmd_count == 0)));
                if ((result.len > 0)) {
                    last = result.data[(result.len - 1)];
                    if ((_str_contains(last, " || \n") || _str_contains(last, " && \n"))) {
                        formatted_cmd = _str_concat(g_arena, " ", formatted_cmd);
                    }
                }
                if (skipped_semi) {
                    formatted_cmd = _str_concat(g_arena, " ", formatted_cmd);
                    skipped_semi = false;
                }
                VEC_PUSH(g_arena, &result, (formatted_cmd));
                cmd_count += 1;
            }
            }
        }
        s = _str_join(g_arena, "", result);
        if ((_str_contains(s, " &\n") && _str_endswith(s, "\n"))) {
            return _str_concat(g_arena, s, " ");
        }
        while (_str_endswith(s, ";")) {
            s = substring(s, 0, (_rune_len(s) - 1));
        }
        if (!(has_heredoc)) {
            while (_str_endswith(s, "\n")) {
                s = substring(s, 0, (_rune_len(s) - 1));
            }
        }
        return s;
        break;
    }
    }
    const char * cond;
    const char * then_body;
    const char * else_body;
    void *_data15 = node->data;
    switch (node->kind) {
    case KIND_IF: {
        If *node = (If *)_data15;
        cond = format_cmdsub_node((Node *)node->condition, indent, false, false, false);
        then_body = format_cmdsub_node((Node *)node->then_body, (indent + 4), false, false, false);
        const char * result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "if ", cond), "; then\n"), inner_sp), then_body), ";");
        if ((node->else_body != NULL)) {
            else_body = format_cmdsub_node(node->else_body, (indent + 4), false, false, false);
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, result, "\n"), sp), "else\n"), inner_sp), else_body), ";");
        }
        result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, result, "\n"), sp), "fi");
        return result;
        break;
    }
    }
    const char * body;
    void *_data16 = node->data;
    switch (node->kind) {
    case KIND_WHILE: {
        While *node = (While *)_data16;
        cond = format_cmdsub_node((Node *)node->condition, indent, false, false, false);
        body = format_cmdsub_node((Node *)node->body, (indent + 4), false, false, false);
        result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "while ", cond), "; do\n"), inner_sp), body), ";\n"), sp), "done");
        if ((node->redirects.len > 0)) {
            for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
                Node * r = node->redirects.data[_idx];
                result = _str_concat(g_arena, _str_concat(g_arena, result, " "), format_redirect((Node *)r, false, false));
            }
        }
        return result;
        break;
    }
    }
    void *_data17 = node->data;
    switch (node->kind) {
    case KIND_UNTIL: {
        Until *node = (Until *)_data17;
        cond = format_cmdsub_node((Node *)node->condition, indent, false, false, false);
        body = format_cmdsub_node((Node *)node->body, (indent + 4), false, false, false);
        result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "until ", cond), "; do\n"), inner_sp), body), ";\n"), sp), "done");
        if ((node->redirects.len > 0)) {
            for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
                Node * r = node->redirects.data[_idx];
                result = _str_concat(g_arena, _str_concat(g_arena, result, " "), format_redirect((Node *)r, false, false));
            }
        }
        return result;
        break;
    }
    }
    const char * var;
    Vec_Str word_vals;
    const char * words;
    void *_data18 = node->data;
    switch (node->kind) {
    case KIND_FOR: {
        For *node = (For *)_data18;
        var = node->var;
        body = format_cmdsub_node((Node *)node->body, (indent + 4), false, false, false);
        if ((node->words != NULL)) {
            word_vals = (Vec_Str){NULL, 0, 0};
            if (node->words != NULL) {
                for (size_t _idx = 0; _idx < node->words->len; _idx++) {
                    Word * w = node->words->data[_idx];
                    VEC_PUSH(g_arena, &word_vals, (w->value));
                }
            }
            words = _str_join(g_arena, " ", word_vals);
            if ((words != NULL && words[0] != '\0')) {
                result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "for ", var), " in "), words), ";\n"), sp), "do\n"), inner_sp), body), ";\n"), sp), "done");
            } else {
                result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "for ", var), " in ;\n"), sp), "do\n"), inner_sp), body), ";\n"), sp), "done");
            }
        } else {
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "for ", var), " in \"$@\";\n"), sp), "do\n"), inner_sp), body), ";\n"), sp), "done");
        }
        if ((node->redirects.len > 0)) {
            for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
                Node * r = node->redirects.data[_idx];
                result = _str_concat(g_arena, _str_concat(g_arena, result, " "), format_redirect((Node *)r, false, false));
            }
        }
        return result;
        break;
    }
    }
    void *_data19 = node->data;
    switch (node->kind) {
    case KIND_FORARITH: {
        ForArith *node = (ForArith *)_data19;
        body = format_cmdsub_node((Node *)node->body, (indent + 4), false, false, false);
        result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "for ((", node->init), "; "), node->cond), "; "), node->incr), "))\ndo\n"), inner_sp), body), ";\n"), sp), "done");
        if ((node->redirects.len > 0)) {
            for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
                Node * r = node->redirects.data[_idx];
                result = _str_concat(g_arena, _str_concat(g_arena, result, " "), format_redirect((Node *)r, false, false));
            }
        }
        return result;
        break;
    }
    }
    const char * word;
    Vec_Str patterns;
    CasePattern * p;
    const char * pat;
    const char * term;
    const char * pat_indent;
    const char * term_indent;
    const char * body_part;
    Any * pattern_str;
    const char * redirects;
    void *_data20 = node->data;
    switch (node->kind) {
    case KIND_CASE: {
        Case *node = (Case *)_data20;
        word = node->word->value;
        patterns = (Vec_Str){NULL, 0, 0};
        i = 0;
        while ((i < node->patterns.len)) {
            p = node->patterns.data[i];
            pat = _str_replace(g_arena, p->pattern, "|", " | ");
            if ((p->body != NULL)) {
                body = format_cmdsub_node(p->body, (indent + 8), false, false, false);
            } else {
                body = "";
            }
            term = p->terminator;
            pat_indent = _str_repeat(g_arena, " ", (indent + 8));
            term_indent = _str_repeat(g_arena, " ", (indent + 4));
            body_part = ((body != NULL && body[0] != '\0') ? _str_concat(g_arena, _str_concat(g_arena, pat_indent, body), "\n") : "\n");
            if ((i == 0)) {
                VEC_PUSH(g_arena, &patterns, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, " ", pat), ")\n"), body_part), term_indent), term)));
            } else {
                VEC_PUSH(g_arena, &patterns, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, pat, ")\n"), body_part), term_indent), term)));
            }
            i += 1;
        }
        pattern_str = _str_join(g_arena, _str_concat(g_arena, "\n", _str_repeat(g_arena, " ", (indent + 4))), patterns);
        redirects = "";
        if ((node->redirects.len > 0)) {
            redirect_parts = (Vec_Str){NULL, 0, 0};
            for (size_t _idx = 0; _idx < node->redirects.len; _idx++) {
                Node * r = node->redirects.data[_idx];
                VEC_PUSH(g_arena, &redirect_parts, (format_redirect((Node *)r, false, false)));
            }
            redirects = _str_concat(g_arena, " ", _str_join(g_arena, " ", redirect_parts));
        }
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "case ", word), " in"), pattern_str), "\n"), sp), "esac"), redirects);
        break;
    }
    }
    const char * name;
    Node * inner_body;
    void *_data21 = node->data;
    switch (node->kind) {
    case KIND_FUNCTION: {
        Function *node = (Function *)_data21;
        name = node->name;
        inner_body = (Node *)((strcmp(_kind_to_str(node->body->kind), "brace-group") == 0) ? ((BraceGroup *)(node->body->data))->body : node->body);
        body = _str_rtrim(g_arena, format_cmdsub_node((Node *)inner_body, (indent + 4), false, false, false), ";");
        return _str_format(g_arena, "function %v () \n{ \n%v%v\n}", name, inner_sp, body);
        break;
    }
    }
    void *_data22 = node->data;
    switch (node->kind) {
    case KIND_SUBSHELL: {
        Subshell *node = (Subshell *)_data22;
        body = format_cmdsub_node((Node *)node->body, indent, in_procsub, compact_redirects, false);
        redirects = "";
        if ((node->redirects != NULL)) {
            redirect_parts = (Vec_Str){NULL, 0, 0};
            if (node->redirects != NULL) {
                for (size_t _idx = 0; _idx < node->redirects->len; _idx++) {
                    Node * r = node->redirects->data[_idx];
                    VEC_PUSH(g_arena, &redirect_parts, (format_redirect((Node *)r, false, false)));
                }
            }
            redirects = _str_join(g_arena, " ", redirect_parts);
        }
        if (procsub_first) {
            if ((redirects != NULL && redirects[0] != '\0')) {
                return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(", body), ") "), redirects);
            }
            return _str_concat(g_arena, _str_concat(g_arena, "(", body), ")");
        }
        if ((redirects != NULL && redirects[0] != '\0')) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "( ", body), " ) "), redirects);
        }
        return _str_concat(g_arena, _str_concat(g_arena, "( ", body), " )");
        break;
    }
    }
    const char * terminator;
    void *_data23 = node->data;
    switch (node->kind) {
    case KIND_BRACEGROUP: {
        BraceGroup *node = (BraceGroup *)_data23;
        body = format_cmdsub_node((Node *)node->body, indent, false, false, false);
        body = _str_rtrim(g_arena, body, ";");
        terminator = (_str_endswith(body, " &") ? " }" : "; }");
        redirects = "";
        if ((node->redirects != NULL)) {
            redirect_parts = (Vec_Str){NULL, 0, 0};
            if (node->redirects != NULL) {
                for (size_t _idx = 0; _idx < node->redirects->len; _idx++) {
                    Node * r = node->redirects->data[_idx];
                    VEC_PUSH(g_arena, &redirect_parts, (format_redirect((Node *)r, false, false)));
                }
            }
            redirects = _str_join(g_arena, " ", redirect_parts);
        }
        if ((redirects != NULL && redirects[0] != '\0')) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "{ ", body), terminator), " "), redirects);
        }
        return _str_concat(g_arena, _str_concat(g_arena, "{ ", body), terminator);
        break;
    }
    }
    void *_data24 = node->data;
    switch (node->kind) {
    case KIND_ARITHMETICCOMMAND: {
        ArithmeticCommand *node = (ArithmeticCommand *)_data24;
        return _str_concat(g_arena, _str_concat(g_arena, "((", node->raw_content), "))");
        break;
    }
    }
    void *_data25 = node->data;
    switch (node->kind) {
    case KIND_CONDITIONALEXPR: {
        ConditionalExpr *node = (ConditionalExpr *)_data25;
        body = format_cond_body((Node *)((Node *)(node->body)));
        return _str_concat(g_arena, _str_concat(g_arena, "[[ ", body), " ]]");
        break;
    }
    }
    void *_data26 = node->data;
    switch (node->kind) {
    case KIND_NEGATION: {
        Negation *node = (Negation *)_data26;
        if ((node->pipeline != NULL)) {
            return _str_concat(g_arena, "! ", format_cmdsub_node((Node *)node->pipeline, indent, false, false, false));
        }
        return "! ";
        break;
    }
    }
    const char * prefix;
    void *_data27 = node->data;
    switch (node->kind) {
    case KIND_TIME: {
        Time *node = (Time *)_data27;
        prefix = (node->posix ? "time -p " : "time ");
        if ((node->pipeline != NULL)) {
            return _str_concat(g_arena, prefix, format_cmdsub_node((Node *)node->pipeline, indent, false, false, false));
        }
        return prefix;
        break;
    }
    }
    return "";
}

static const char * format_redirect(Node * r, bool compact, bool heredoc_op_only) {
    const char * op;
    const char * delim;
    void *_data28 = r->data;
    switch (r->kind) {
    case KIND_HEREDOC: {
        HereDoc *r = (HereDoc *)_data28;
        if (r->strip_tabs) {
            op = "<<-";
        } else {
            op = "<<";
        }
        if ((r->fd > 0)) {
            op = _str_concat(g_arena, _int_to_str(g_arena, r->fd), op);
        }
        if (r->quoted) {
            delim = _str_concat(g_arena, _str_concat(g_arena, "'", r->delimiter), "'");
        } else {
            delim = r->delimiter;
        }
        if (heredoc_op_only) {
            return _str_concat(g_arena, op, delim);
        }
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, op, delim), "\n"), r->content), r->delimiter), "\n");
        break;
    }
    }
    op = ((Redirect *)(r->data))->op;
    if ((strcmp(op, "1>") == 0)) {
        op = ">";
    } else if ((strcmp(op, "0<") == 0)) {
        op = "<";
    }
    const char * target = ((Redirect *)(r->data))->target->value;
    target = Word_expand_all_ansi_c_quotes(((Redirect *)(r->data))->target, target);
    target = Word_strip_locale_string_dollars(((Redirect *)(r->data))->target, target);
    target = Word_format_command_substitutions(((Redirect *)(r->data))->target, target, false);
    if (_str_startswith(target, "&")) {
        bool was_input_close = false;
        if (((strcmp(target, "&-") == 0) && _str_endswith(op, "<"))) {
            was_input_close = true;
            op = _str_concat(g_arena, substring(op, 0, (_rune_len(op) - 1)), ">");
        }
        const char * after_amp = substring(target, 1, _rune_len(target));
        bool is_literal_fd = ((strcmp(after_amp, "-") == 0) || ((_rune_len(after_amp) > 0) && _str_is_digit((const char *)(_char_at_str(g_arena, after_amp, 0)))));
        if (is_literal_fd) {
            if (((strcmp(op, ">") == 0) || (strcmp(op, ">&") == 0))) {
                op = (was_input_close ? "0>" : "1>");
            } else if (((strcmp(op, "<") == 0) || (strcmp(op, "<&") == 0))) {
                op = "0<";
            }
        } else if ((strcmp(op, "1>") == 0)) {
            op = ">";
        } else if ((strcmp(op, "0<") == 0)) {
            op = "<";
        }
        return _str_concat(g_arena, op, target);
    }
    if (_str_endswith(op, "&")) {
        return _str_concat(g_arena, op, target);
    }
    if (compact) {
        return _str_concat(g_arena, op, target);
    }
    return _str_concat(g_arena, _str_concat(g_arena, op, " "), target);
}

static const char * format_heredoc_body(Node * r) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "\n", ((HereDoc *)(r->data))->content), ((HereDoc *)(r->data))->delimiter), "\n");
}

static bool lookahead_for_esac(const char * value, int64_t start, int64_t case_depth) {
    int64_t i = start;
    int64_t depth = case_depth;
    QuoteState * quote = new_quote_state();
    while ((i < _rune_len(value))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if ((((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(value))) && quote->double_)) {
            i += 2;
            continue;
        }
        if (((strcmp(c, "'") == 0) && !(quote->double_))) {
            quote->single = !(quote->single);
            i += 1;
            continue;
        }
        if (((strcmp(c, "\"") == 0) && !(quote->single))) {
            quote->double_ = !(quote->double_);
            i += 1;
            continue;
        }
        if ((quote->single || quote->double_)) {
            i += 1;
            continue;
        }
        if ((starts_with_at(value, i, "case") && is_word_boundary(value, i, 4))) {
            depth += 1;
            i += 4;
        } else if ((starts_with_at(value, i, "esac") && is_word_boundary(value, i, 4))) {
            depth -= 1;
            if ((depth == 0)) {
                return true;
            }
            i += 4;
        } else if ((strcmp(c, "(") == 0)) {
            i += 1;
        } else if ((strcmp(c, ")") == 0)) {
            if ((depth > 0)) {
                i += 1;
            } else {
                break;
            }
        } else {
            i += 1;
        }
    }
    return false;
}

static int64_t skip_backtick(const char * value, int64_t start) {
    int64_t i = (start + 1);
    while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "`") != 0))) {
        if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\\") == 0) && ((i + 1) < _rune_len(value)))) {
            i += 2;
        } else {
            i += 1;
        }
    }
    if ((i < _rune_len(value))) {
        i += 1;
    }
    return i;
}

static int64_t skip_single_quoted(const char * s, int64_t start) {
    int64_t i = start;
    while (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "'") != 0))) {
        i += 1;
    }
    return ((i < _rune_len(s)) ? (i + 1) : i);
}

static int64_t skip_double_quoted(const char * s, int64_t start) {
    int64_t i = start;
    int64_t n = _rune_len(s);
    bool pass_next = false;
    bool backq = false;
    while ((i < n)) {
        const char * c = (const char *)(_char_at_str(g_arena, s, i));
        if (pass_next) {
            pass_next = false;
            i += 1;
            continue;
        }
        if ((strcmp(c, "\\") == 0)) {
            pass_next = true;
            i += 1;
            continue;
        }
        if (backq) {
            if ((strcmp(c, "`") == 0)) {
                backq = false;
            }
            i += 1;
            continue;
        }
        if ((strcmp(c, "`") == 0)) {
            backq = true;
            i += 1;
            continue;
        }
        if (((strcmp(c, "$") == 0) && ((i + 1) < n))) {
            if ((strcmp((const char *)(_char_at_str(g_arena, s, (i + 1))), "(") == 0)) {
                i = find_cmdsub_end(s, (i + 2));
                continue;
            }
            if ((strcmp((const char *)(_char_at_str(g_arena, s, (i + 1))), "{") == 0)) {
                i = find_braced_param_end(s, (i + 2));
                continue;
            }
        }
        if ((strcmp(c, "\"") == 0)) {
            return (i + 1);
        }
        i += 1;
    }
    return i;
}

static bool is_valid_arithmetic_start(const char * value, int64_t start) {
    int64_t scan_paren = 0;
    int64_t scan_i = (start + 3);
    while ((scan_i < _rune_len(value))) {
        const char * scan_c = (const char *)(_char_at_str(g_arena, value, scan_i));
        if (is_expansion_start(value, scan_i, "$(")) {
            scan_i = find_cmdsub_end(value, (scan_i + 2));
            continue;
        }
        if ((strcmp(scan_c, "(") == 0)) {
            scan_paren += 1;
        } else if ((strcmp(scan_c, ")") == 0)) {
            if ((scan_paren > 0)) {
                scan_paren -= 1;
            } else if ((((scan_i + 1) < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, (scan_i + 1))), ")") == 0))) {
                return true;
            } else {
                return false;
            }
        }
        scan_i += 1;
    }
    return false;
}

static int64_t find_funsub_end(const char * value, int64_t start) {
    int64_t depth = 1;
    int64_t i = start;
    QuoteState * quote = new_quote_state();
    while (((i < _rune_len(value)) && (depth > 0))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if ((((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(value))) && !(quote->single))) {
            i += 2;
            continue;
        }
        if (((strcmp(c, "'") == 0) && !(quote->double_))) {
            quote->single = !(quote->single);
            i += 1;
            continue;
        }
        if (((strcmp(c, "\"") == 0) && !(quote->single))) {
            quote->double_ = !(quote->double_);
            i += 1;
            continue;
        }
        if ((quote->single || quote->double_)) {
            i += 1;
            continue;
        }
        if ((strcmp(c, "{") == 0)) {
            depth += 1;
        } else if ((strcmp(c, "}") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                return (i + 1);
            }
        }
        i += 1;
    }
    return _rune_len(value);
}

static int64_t find_cmdsub_end(const char * value, int64_t start) {
    int64_t depth = 1;
    int64_t i = start;
    int64_t case_depth = 0;
    bool in_case_patterns = false;
    int64_t arith_depth = 0;
    int64_t arith_paren_depth = 0;
    while (((i < _rune_len(value)) && (depth > 0))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if (((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(value)))) {
            i += 2;
            continue;
        }
        if ((strcmp(c, "'") == 0)) {
            i = skip_single_quoted(value, (i + 1));
            continue;
        }
        if ((strcmp(c, "\"") == 0)) {
            i = skip_double_quoted(value, (i + 1));
            continue;
        }
        if ((((strcmp(c, "#") == 0) && (arith_depth == 0)) && (((((((((i == start) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), " ") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "\t") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "\n") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), ";") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "|") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "&") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "(") == 0)) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), ")") == 0)))) {
            while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\n") != 0))) {
                i += 1;
            }
            continue;
        }
        if (starts_with_at(value, i, "<<<")) {
            i += 3;
            while (((i < _rune_len(value)) && ((strcmp((const char *)(_char_at_str(g_arena, value, i)), " ") == 0) || (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\t") == 0)))) {
                i += 1;
            }
            if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\"") == 0))) {
                i += 1;
                while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\"") != 0))) {
                    if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\\") == 0) && ((i + 1) < _rune_len(value)))) {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }
                if ((i < _rune_len(value))) {
                    i += 1;
                }
            } else if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "'") == 0))) {
                i += 1;
                while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "'") != 0))) {
                    i += 1;
                }
                if ((i < _rune_len(value))) {
                    i += 1;
                }
            } else {
                while (((i < _rune_len(value)) && !_str_contains(" \t\n;|&<>()", (const char *)(_char_at_str(g_arena, value, i))))) {
                    i += 1;
                }
            }
            continue;
        }
        if (is_expansion_start(value, i, "$((")) {
            if (is_valid_arithmetic_start(value, i)) {
                arith_depth += 1;
                i += 3;
                continue;
            }
            int64_t j = find_cmdsub_end(value, (i + 2));
            i = j;
            continue;
        }
        if ((((arith_depth > 0) && (arith_paren_depth == 0)) && starts_with_at(value, i, "))"))) {
            arith_depth -= 1;
            i += 2;
            continue;
        }
        if ((strcmp(c, "`") == 0)) {
            i = skip_backtick(value, i);
            continue;
        }
        if (((arith_depth == 0) && starts_with_at(value, i, "<<"))) {
            i = skip_heredoc(value, i);
            continue;
        }
        if ((starts_with_at(value, i, "case") && is_word_boundary(value, i, 4))) {
            case_depth += 1;
            in_case_patterns = false;
            i += 4;
            continue;
        }
        if ((((case_depth > 0) && starts_with_at(value, i, "in")) && is_word_boundary(value, i, 2))) {
            in_case_patterns = true;
            i += 2;
            continue;
        }
        if ((starts_with_at(value, i, "esac") && is_word_boundary(value, i, 4))) {
            if ((case_depth > 0)) {
                case_depth -= 1;
                in_case_patterns = false;
            }
            i += 4;
            continue;
        }
        if (starts_with_at(value, i, ";;")) {
            i += 2;
            continue;
        }
        if ((strcmp(c, "(") == 0)) {
            if (!((in_case_patterns && (case_depth > 0)))) {
                if ((arith_depth > 0)) {
                    arith_paren_depth += 1;
                } else {
                    depth += 1;
                }
            }
        } else if ((strcmp(c, ")") == 0)) {
            if ((in_case_patterns && (case_depth > 0))) {
                if (!(lookahead_for_esac(value, (i + 1), case_depth))) {
                    depth -= 1;
                }
            } else if ((arith_depth > 0)) {
                if ((arith_paren_depth > 0)) {
                    arith_paren_depth -= 1;
                }
            } else {
                depth -= 1;
            }
        }
        i += 1;
    }
    return i;
}

static int64_t find_braced_param_end(const char * value, int64_t start) {
    int64_t depth = 1;
    int64_t i = start;
    bool in_double = false;
    int64_t dolbrace_state = DOLBRACESTATE_PARAM;
    while (((i < _rune_len(value)) && (depth > 0))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if (((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(value)))) {
            i += 2;
            continue;
        }
        if ((((strcmp(c, "'") == 0) && (dolbrace_state == DOLBRACESTATE_QUOTE)) && !(in_double))) {
            i = skip_single_quoted(value, (i + 1));
            continue;
        }
        if ((strcmp(c, "\"") == 0)) {
            in_double = !(in_double);
            i += 1;
            continue;
        }
        if (in_double) {
            i += 1;
            continue;
        }
        if (((dolbrace_state == DOLBRACESTATE_PARAM) && _str_contains("%#^,", c))) {
            dolbrace_state = DOLBRACESTATE_QUOTE;
        } else if (((dolbrace_state == DOLBRACESTATE_PARAM) && _str_contains(":-=?+/", c))) {
            dolbrace_state = DOLBRACESTATE_WORD;
        }
        if ((((strcmp(c, "[") == 0) && (dolbrace_state == DOLBRACESTATE_PARAM)) && !(in_double))) {
            int64_t end = skip_subscript(value, i, 0);
            if ((end != -(1))) {
                i = end;
                continue;
            }
        }
        if (((((strcmp(c, "<") == 0) || (strcmp(c, ">") == 0)) && ((i + 1) < _rune_len(value))) && (strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "(") == 0))) {
            i = find_cmdsub_end(value, (i + 2));
            continue;
        }
        if ((strcmp(c, "{") == 0)) {
            depth += 1;
        } else if ((strcmp(c, "}") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                return (i + 1);
            }
        }
        if (is_expansion_start(value, i, "$(")) {
            i = find_cmdsub_end(value, (i + 2));
            continue;
        }
        if (is_expansion_start(value, i, "${")) {
            i = find_braced_param_end(value, (i + 2));
            continue;
        }
        i += 1;
    }
    return i;
}

static int64_t skip_heredoc(const char * value, int64_t start) {
    int64_t i = (start + 2);
    if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "-") == 0))) {
        i += 1;
    }
    while (((i < _rune_len(value)) && is_whitespace_no_newline((const char *)(_char_at_str(g_arena, value, i))))) {
        i += 1;
    }
    int64_t delim_start = i;
    Any * quote_char = NULL;
    const char * delimiter;
    if (((i < _rune_len(value)) && ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\"") == 0) || (strcmp((const char *)(_char_at_str(g_arena, value, i)), "'") == 0)))) {
        quote_char = (const char *)(_char_at_str(g_arena, value, i));
        i += 1;
        delim_start = i;
        while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), quote_char) != 0))) {
            i += 1;
        }
        delimiter = substring(value, delim_start, i);
        if ((i < _rune_len(value))) {
            i += 1;
        }
    } else if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\\") == 0))) {
        i += 1;
        delim_start = i;
        if ((i < _rune_len(value))) {
            i += 1;
        }
        while (((i < _rune_len(value)) && !(is_metachar((const char *)(_char_at_str(g_arena, value, i)))))) {
            i += 1;
        }
        delimiter = substring(value, delim_start, i);
    } else {
        while (((i < _rune_len(value)) && !(is_metachar((const char *)(_char_at_str(g_arena, value, i)))))) {
            i += 1;
        }
        delimiter = substring(value, delim_start, i);
    }
    int64_t paren_depth = 0;
    QuoteState * quote = new_quote_state();
    bool in_backtick = false;
    while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\n") != 0))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if ((((strcmp(c, "\\") == 0) && ((i + 1) < _rune_len(value))) && (quote->double_ || in_backtick))) {
            i += 2;
            continue;
        }
        if ((((strcmp(c, "'") == 0) && !(quote->double_)) && !(in_backtick))) {
            quote->single = !(quote->single);
            i += 1;
            continue;
        }
        if ((((strcmp(c, "\"") == 0) && !(quote->single)) && !(in_backtick))) {
            quote->double_ = !(quote->double_);
            i += 1;
            continue;
        }
        if (((strcmp(c, "`") == 0) && !(quote->single))) {
            in_backtick = !(in_backtick);
            i += 1;
            continue;
        }
        if (((quote->single || quote->double_) || in_backtick)) {
            i += 1;
            continue;
        }
        if ((strcmp(c, "(") == 0)) {
            paren_depth += 1;
        } else if ((strcmp(c, ")") == 0)) {
            if ((paren_depth == 0)) {
                break;
            }
            paren_depth -= 1;
        }
        i += 1;
    }
    if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), ")") == 0))) {
        return i;
    }
    if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\n") == 0))) {
        i += 1;
    }
    while ((i < _rune_len(value))) {
        int64_t line_start = i;
        int64_t line_end = i;
        while (((line_end < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, line_end)), "\n") != 0))) {
            line_end += 1;
        }
        const char * line = substring(value, line_start, line_end);
        while ((line_end < _rune_len(value))) {
            int64_t trailing_bs = 0;
            for (int64_t j = (_rune_len(line) - 1); (j > -(1)); j += -(1)) {
                if ((strcmp((const char *)(_char_at_str(g_arena, line, j)), "\\") == 0)) {
                    trailing_bs += 1;
                } else {
                    break;
                }
            }
            if (((trailing_bs % 2) == 0)) {
                break;
            }
            line = _substring(g_arena, line, 0, (_rune_len(line) - 1));
            line_end += 1;
            int64_t next_line_start = line_end;
            while (((line_end < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, line_end)), "\n") != 0))) {
                line_end += 1;
            }
            line = _str_concat(g_arena, line, substring(value, next_line_start, line_end));
        }
        const char * stripped;
        if ((((start + 2) < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, (start + 2))), "-") == 0))) {
            stripped = _str_ltrim(g_arena, line, "\t");
        } else {
            stripped = line;
        }
        if ((strcmp(stripped, delimiter) == 0)) {
            if ((line_end < _rune_len(value))) {
                return (line_end + 1);
            } else {
                return line_end;
            }
        }
        if ((_str_startswith(stripped, delimiter) && (_rune_len(stripped) > _rune_len(delimiter)))) {
            int64_t tabs_stripped = (_rune_len(line) - _rune_len(stripped));
            return ((line_start + tabs_stripped) + _rune_len(delimiter));
        }
        if ((line_end < _rune_len(value))) {
            i = (line_end + 1);
        } else {
            i = line_end;
        }
    }
    return i;
}

static Tuple_int64_t_int64_t find_heredoc_content_end(const char * source, int64_t start, Vec_Tuple_constcharPtr_bool delimiters) {
    if (!((delimiters.len > 0))) {
        return (Tuple_int64_t_int64_t){start, start};
    }
    int64_t pos = start;
    while (((pos < _rune_len(source)) && (strcmp((const char *)(_char_at_str(g_arena, source, pos)), "\n") != 0))) {
        pos += 1;
    }
    if ((pos >= _rune_len(source))) {
        return (Tuple_int64_t_int64_t){start, start};
    }
    int64_t content_start = pos;
    pos += 1;
    for (size_t _idx = 0; _idx < delimiters.len; _idx++) {
        Tuple_constcharPtr_bool item = delimiters.data[_idx];
        const char * delimiter = item.F0;
        bool strip_tabs = item.F1;
        while ((pos < _rune_len(source))) {
            int64_t line_start = pos;
            int64_t line_end = pos;
            while (((line_end < _rune_len(source)) && (strcmp((const char *)(_char_at_str(g_arena, source, line_end)), "\n") != 0))) {
                line_end += 1;
            }
            const char * line = substring(source, line_start, line_end);
            while ((line_end < _rune_len(source))) {
                int64_t trailing_bs = 0;
                for (int64_t j = (_rune_len(line) - 1); (j > -(1)); j += -(1)) {
                    if ((strcmp((const char *)(_char_at_str(g_arena, line, j)), "\\") == 0)) {
                        trailing_bs += 1;
                    } else {
                        break;
                    }
                }
                if (((trailing_bs % 2) == 0)) {
                    break;
                }
                line = _substring(g_arena, line, 0, (_rune_len(line) - 1));
                line_end += 1;
                int64_t next_line_start = line_end;
                while (((line_end < _rune_len(source)) && (strcmp((const char *)(_char_at_str(g_arena, source, line_end)), "\n") != 0))) {
                    line_end += 1;
                }
                line = _str_concat(g_arena, line, substring(source, next_line_start, line_end));
            }
            const char * line_stripped;
            if (strip_tabs) {
                line_stripped = _str_ltrim(g_arena, line, "\t");
            } else {
                line_stripped = line;
            }
            if ((strcmp(line_stripped, delimiter) == 0)) {
                pos = ((line_end < _rune_len(source)) ? (line_end + 1) : line_end);
                break;
            }
            if ((_str_startswith(line_stripped, delimiter) && (_rune_len(line_stripped) > _rune_len(delimiter)))) {
                int64_t tabs_stripped = (_rune_len(line) - _rune_len(line_stripped));
                pos = ((line_start + tabs_stripped) + _rune_len(delimiter));
                break;
            }
            pos = ((line_end < _rune_len(source)) ? (line_end + 1) : line_end);
        }
    }
    return (Tuple_int64_t_int64_t){content_start, pos};
}

static bool is_word_boundary(const char * s, int64_t pos, int64_t word_len) {
    if ((pos > 0)) {
        const char * prev = (const char *)(_char_at_str(g_arena, s, (pos - 1)));
        if ((_str_is_alnum(prev) || (strcmp(prev, "_") == 0))) {
            return false;
        }
        if (_str_contains("{}!", prev)) {
            return false;
        }
    }
    int64_t end = (pos + word_len);
    if (((end < _rune_len(s)) && (_str_is_alnum((const char *)(_char_at_str(g_arena, s, end))) || (strcmp((const char *)(_char_at_str(g_arena, s, end)), "_") == 0)))) {
        return false;
    }
    return true;
}

static bool is_quote(const char * c) {
    return ((strcmp(c, "'") == 0) || (strcmp(c, "\"") == 0));
}

static const char * collapse_whitespace(const char * s) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    bool prev_was_ws = false;
    for (int _idx = 0; _idx < _rune_len(s); _idx++) {
        int32_t c = _rune_at(s, _idx);
        if (((c == ' ') || (c == '\t'))) {
            if (!(prev_was_ws)) {
                VEC_PUSH(g_arena, &result, (" "));
            }
            prev_was_ws = true;
        } else {
            VEC_PUSH(g_arena, &result, (_rune_to_str(g_arena, c)));
            prev_was_ws = false;
        }
    }
    const char * joined = _str_join(g_arena, "", result);
    return _str_trim(g_arena, joined, " \t");
}

static int64_t count_trailing_backslashes(const char * s) {
    int64_t count = 0;
    for (int64_t i = (_rune_len(s) - 1); (i > -(1)); i += -(1)) {
        if ((strcmp((const char *)(_char_at_str(g_arena, s, i)), "\\") == 0)) {
            count += 1;
        } else {
            break;
        }
    }
    return count;
}

static const char * normalize_heredoc_delimiter(const char * delimiter) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    while ((i < _rune_len(delimiter))) {
        int64_t depth;
        Vec_Str inner;
        const char * inner_str;
        if ((((i + 1) < _rune_len(delimiter)) && (strcmp(_substring(g_arena, delimiter, i, (i + 2)), "$(") == 0))) {
            VEC_PUSH(g_arena, &result, ("$("));
            i += 2;
            depth = 1;
            inner = (Vec_Str){NULL, 0, 0};
            while (((i < _rune_len(delimiter)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), "(") == 0)) {
                    depth += 1;
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                } else if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), ")") == 0)) {
                    depth -= 1;
                    if ((depth == 0)) {
                        inner_str = _str_join(g_arena, "", inner);
                        inner_str = collapse_whitespace(inner_str);
                        VEC_PUSH(g_arena, &result, (inner_str));
                        VEC_PUSH(g_arena, &result, (")"));
                    } else {
                        VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                    }
                } else {
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                }
                i += 1;
            }
        } else if ((((i + 1) < _rune_len(delimiter)) && (strcmp(_substring(g_arena, delimiter, i, (i + 2)), "${") == 0))) {
            VEC_PUSH(g_arena, &result, ("${"));
            i += 2;
            depth = 1;
            inner = (Vec_Str){NULL, 0, 0};
            while (((i < _rune_len(delimiter)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), "{") == 0)) {
                    depth += 1;
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                } else if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), "}") == 0)) {
                    depth -= 1;
                    if ((depth == 0)) {
                        inner_str = _str_join(g_arena, "", inner);
                        inner_str = collapse_whitespace(inner_str);
                        VEC_PUSH(g_arena, &result, (inner_str));
                        VEC_PUSH(g_arena, &result, ("}"));
                    } else {
                        VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                    }
                } else {
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                }
                i += 1;
            }
        } else if (((((i + 1) < _rune_len(delimiter)) && _str_contains("<>", (const char *)(_char_at_str(g_arena, delimiter, i)))) && (strcmp((const char *)(_char_at_str(g_arena, delimiter, (i + 1))), "(") == 0))) {
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, delimiter, i))));
            VEC_PUSH(g_arena, &result, ("("));
            i += 2;
            depth = 1;
            inner = (Vec_Str){NULL, 0, 0};
            while (((i < _rune_len(delimiter)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), "(") == 0)) {
                    depth += 1;
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                } else if ((strcmp((const char *)(_char_at_str(g_arena, delimiter, i)), ")") == 0)) {
                    depth -= 1;
                    if ((depth == 0)) {
                        inner_str = _str_join(g_arena, "", inner);
                        inner_str = collapse_whitespace(inner_str);
                        VEC_PUSH(g_arena, &result, (inner_str));
                        VEC_PUSH(g_arena, &result, (")"));
                    } else {
                        VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                    }
                } else {
                    VEC_PUSH(g_arena, &inner, ((const char *)(_char_at_str(g_arena, delimiter, i))));
                }
                i += 1;
            }
        } else {
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, delimiter, i))));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static bool is_metachar(const char * c) {
    return ((((((((((strcmp(c, " ") == 0) || (strcmp(c, "\t") == 0)) || (strcmp(c, "\n") == 0)) || (strcmp(c, "|") == 0)) || (strcmp(c, "&") == 0)) || (strcmp(c, ";") == 0)) || (strcmp(c, "(") == 0)) || (strcmp(c, ")") == 0)) || (strcmp(c, "<") == 0)) || (strcmp(c, ">") == 0));
}

static bool is_funsub_char(const char * c) {
    return ((((strcmp(c, " ") == 0) || (strcmp(c, "\t") == 0)) || (strcmp(c, "\n") == 0)) || (strcmp(c, "|") == 0));
}

static bool is_extglob_prefix(const char * c) {
    return (((((strcmp(c, "@") == 0) || (strcmp(c, "?") == 0)) || (strcmp(c, "*") == 0)) || (strcmp(c, "+") == 0)) || (strcmp(c, "!") == 0));
}

static bool is_redirect_char(const char * c) {
    return ((strcmp(c, "<") == 0) || (strcmp(c, ">") == 0));
}

static bool is_special_param(const char * c) {
    return ((((((((strcmp(c, "?") == 0) || (strcmp(c, "$") == 0)) || (strcmp(c, "!") == 0)) || (strcmp(c, "#") == 0)) || (strcmp(c, "@") == 0)) || (strcmp(c, "*") == 0)) || (strcmp(c, "-") == 0)) || (strcmp(c, "&") == 0));
}

static bool is_special_param_unbraced(const char * c) {
    return (((((((strcmp(c, "?") == 0) || (strcmp(c, "$") == 0)) || (strcmp(c, "!") == 0)) || (strcmp(c, "#") == 0)) || (strcmp(c, "@") == 0)) || (strcmp(c, "*") == 0)) || (strcmp(c, "-") == 0));
}

static bool is_digit(const char * c) {
    return ((c[0] >= '0') && (c[0] <= '9'));
}

static bool is_semicolon_or_newline(const char * c) {
    return ((strcmp(c, ";") == 0) || (strcmp(c, "\n") == 0));
}

static bool is_word_end_context(const char * c) {
    return ((((((((((strcmp(c, " ") == 0) || (strcmp(c, "\t") == 0)) || (strcmp(c, "\n") == 0)) || (strcmp(c, ";") == 0)) || (strcmp(c, "|") == 0)) || (strcmp(c, "&") == 0)) || (strcmp(c, "<") == 0)) || (strcmp(c, ">") == 0)) || (strcmp(c, "(") == 0)) || (strcmp(c, ")") == 0));
}

static int64_t skip_matched_pair(const char * s, int64_t start, const char * open, const char * close, int64_t flags) {
    int64_t n = _rune_len(s);
    int64_t i;
    if (((flags & SMP_PAST_OPEN) != 0)) {
        i = start;
    } else {
        if (((start >= n) || (strcmp((const char *)(_char_at_str(g_arena, s, start)), open) != 0))) {
            return -(1);
        }
        i = (start + 1);
    }
    int64_t depth = 1;
    bool pass_next = false;
    bool backq = false;
    while (((i < n) && (depth > 0))) {
        const char * c = (const char *)(_char_at_str(g_arena, s, i));
        if (pass_next) {
            pass_next = false;
            i += 1;
            continue;
        }
        int64_t literal = (flags & SMP_LITERAL);
        if ((!((literal != 0)) && (strcmp(c, "\\") == 0))) {
            pass_next = true;
            i += 1;
            continue;
        }
        if (backq) {
            if ((strcmp(c, "`") == 0)) {
                backq = false;
            }
            i += 1;
            continue;
        }
        if ((!((literal != 0)) && (strcmp(c, "`") == 0))) {
            backq = true;
            i += 1;
            continue;
        }
        if ((!((literal != 0)) && (strcmp(c, "'") == 0))) {
            i = skip_single_quoted(s, (i + 1));
            continue;
        }
        if ((!((literal != 0)) && (strcmp(c, "\"") == 0))) {
            i = skip_double_quoted(s, (i + 1));
            continue;
        }
        if ((!((literal != 0)) && is_expansion_start(s, i, "$("))) {
            i = find_cmdsub_end(s, (i + 2));
            continue;
        }
        if ((!((literal != 0)) && is_expansion_start(s, i, "${"))) {
            i = find_braced_param_end(s, (i + 2));
            continue;
        }
        if ((!((literal != 0)) && (strcmp(c, open) == 0))) {
            depth += 1;
        } else if ((strcmp(c, close) == 0)) {
            depth -= 1;
        }
        i += 1;
    }
    return ((depth == 0) ? i : -(1));
}

static int64_t skip_subscript(const char * s, int64_t start, int64_t flags) {
    return skip_matched_pair(s, start, "[", "]", flags);
}

static int64_t assignment(const char * s, int64_t flags) {
    if (!((s != NULL && s[0] != '\0'))) {
        return -(1);
    }
    if (!((_str_is_alpha((const char *)(_char_at_str(g_arena, s, 0))) || (strcmp((const char *)(_char_at_str(g_arena, s, 0)), "_") == 0)))) {
        return -(1);
    }
    int64_t i = 1;
    while ((i < _rune_len(s))) {
        const char * c = (const char *)(_char_at_str(g_arena, s, i));
        if ((strcmp(c, "=") == 0)) {
            return i;
        }
        if ((strcmp(c, "[") == 0)) {
            int64_t sub_flags = (((flags & 2) != 0) ? SMP_LITERAL : 0);
            int64_t end = skip_subscript(s, i, sub_flags);
            if ((end == -(1))) {
                return -(1);
            }
            i = end;
            if (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "+") == 0))) {
                i += 1;
            }
            if (((i < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, i)), "=") == 0))) {
                return i;
            }
            return -(1);
        }
        if ((strcmp(c, "+") == 0)) {
            if ((((i + 1) < _rune_len(s)) && (strcmp((const char *)(_char_at_str(g_arena, s, (i + 1))), "=") == 0))) {
                return (i + 1);
            }
            return -(1);
        }
        if (!((_str_is_alnum(c) || (strcmp(c, "_") == 0)))) {
            return -(1);
        }
        i += 1;
    }
    return -(1);
}

static bool is_array_assignment_prefix(Vec_Str chars) {
    if (!((chars.len > 0))) {
        return false;
    }
    if (!((_str_is_alpha(chars.data[0]) || (strcmp(chars.data[0], "_") == 0)))) {
        return false;
    }
    const char * s = _str_join(g_arena, "", chars);
    int64_t i = 1;
    while (((i < _rune_len(s)) && (_str_is_alnum((const char *)(_char_at_str(g_arena, s, i))) || (strcmp((const char *)(_char_at_str(g_arena, s, i)), "_") == 0)))) {
        i += 1;
    }
    while ((i < _rune_len(s))) {
        if ((strcmp((const char *)(_char_at_str(g_arena, s, i)), "[") != 0)) {
            return false;
        }
        int64_t end = skip_subscript(s, i, SMP_LITERAL);
        if ((end == -(1))) {
            return false;
        }
        i = end;
    }
    return true;
}

static bool is_special_param_or_digit(const char * c) {
    return (is_special_param(c) || is_digit(c));
}

static bool is_param_expansion_op(const char * c) {
    return (((((((((((((strcmp(c, ":") == 0) || (strcmp(c, "-") == 0)) || (strcmp(c, "=") == 0)) || (strcmp(c, "+") == 0)) || (strcmp(c, "?") == 0)) || (strcmp(c, "#") == 0)) || (strcmp(c, "%") == 0)) || (strcmp(c, "/") == 0)) || (strcmp(c, "^") == 0)) || (strcmp(c, ",") == 0)) || (strcmp(c, "@") == 0)) || (strcmp(c, "*") == 0)) || (strcmp(c, "[") == 0));
}

static bool is_simple_param_op(const char * c) {
    return ((((strcmp(c, "-") == 0) || (strcmp(c, "=") == 0)) || (strcmp(c, "?") == 0)) || (strcmp(c, "+") == 0));
}

static bool is_escape_char_in_backtick(const char * c) {
    return (((strcmp(c, "$") == 0) || (strcmp(c, "`") == 0)) || (strcmp(c, "\\") == 0));
}

static bool is_negation_boundary(const char * c) {
    return ((((((is_whitespace(c) || (strcmp(c, ";") == 0)) || (strcmp(c, "|") == 0)) || (strcmp(c, ")") == 0)) || (strcmp(c, "&") == 0)) || (strcmp(c, ">") == 0)) || (strcmp(c, "<") == 0));
}

static bool is_backslash_escaped(const char * value, int64_t idx) {
    int64_t bs_count = 0;
    int64_t j = (idx - 1);
    while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, value, j)), "\\") == 0))) {
        bs_count += 1;
        j -= 1;
    }
    return ((bs_count % 2) == 1);
}

static bool is_dollar_dollar_paren(const char * value, int64_t idx) {
    int64_t dollar_count = 0;
    int64_t j = (idx - 1);
    while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, value, j)), "$") == 0))) {
        dollar_count += 1;
        j -= 1;
    }
    return ((dollar_count % 2) == 1);
}

static bool is_paren(const char * c) {
    return ((strcmp(c, "(") == 0) || (strcmp(c, ")") == 0));
}

static bool is_caret_or_bang(const char * c) {
    return ((strcmp(c, "!") == 0) || (strcmp(c, "^") == 0));
}

static bool is_at_or_star(const char * c) {
    return ((strcmp(c, "@") == 0) || (strcmp(c, "*") == 0));
}

static bool is_digit_or_dash(const char * c) {
    return (is_digit(c) || (strcmp(c, "-") == 0));
}

static bool is_newline_or_right_paren(const char * c) {
    return ((strcmp(c, "\n") == 0) || (strcmp(c, ")") == 0));
}

static bool is_semicolon_newline_brace(const char * c) {
    return (((strcmp(c, ";") == 0) || (strcmp(c, "\n") == 0)) || (strcmp(c, "{") == 0));
}

static bool looks_like_assignment(const char * s) {
    return (assignment(s, 0) != -(1));
}

static bool is_valid_identifier(const char * name) {
    if (!((name != NULL && name[0] != '\0'))) {
        return false;
    }
    if (!((_str_is_alpha((const char *)(_char_at_str(g_arena, name, 0))) || (strcmp((const char *)(_char_at_str(g_arena, name, 0)), "_") == 0)))) {
        return false;
    }
    for (int _idx = 0; _idx < _rune_len(_substring(g_arena, name, 1, _rune_len(name))); _idx++) {
        int32_t c = _rune_at(_substring(g_arena, name, 1, _rune_len(name)), _idx);
        if (!((_rune_is_alnum(c) || (c == '_')))) {
            return false;
        }
    }
    return true;
}

static Vec_Node parse(const char * source, bool extglob) {
    Parser * parser = new_parser(source, false, extglob);
    return Parser_parse(parser);
}

static ParseError * new_parse_error(const char * message, int64_t pos, int64_t line) {
    ParseError * self = ParseError_new(NULL, 0, 0);
    self->message = message;
    self->pos = pos;
    self->line = line;
    return self;
}

static MatchedPairError * new_matched_pair_error(const char * message, int64_t pos, int64_t line) {
    return MatchedPairError_new();
}

static QuoteState * new_quote_state(void) {
    QuoteState * self = QuoteState_new(false, false, (Vec_Tuple_bool_bool){NULL, 0, 0});
    self->single = false;
    self->double_ = false;
    self->stack = (Vec_Tuple_bool_bool){NULL, 0, 0};
    return self;
}

static ParseContext * new_parse_context(int64_t kind) {
    ParseContext * self = ParseContext_new(0, 0, 0, 0, 0, 0, 0, NULL);
    self->kind = kind;
    self->paren_depth = 0;
    self->brace_depth = 0;
    self->bracket_depth = 0;
    self->case_depth = 0;
    self->arith_depth = 0;
    self->arith_paren_depth = 0;
    self->quote = new_quote_state();
    return self;
}

static ContextStack * new_context_stack(void) {
    ContextStack * self = ContextStack_new((Vec_ParseContext){NULL, 0, 0});
    self->stack = (Vec_ParseContext){(ParseContext *[]){ new_parse_context(0) }, 1, 1};
    return self;
}

static Lexer * new_lexer(const char * source, bool extglob) {
    Lexer * self = Lexer_new(NULL, NULL, 0, 0, NULL, NULL, 0, 0, (Vec_Node){NULL, 0, 0}, false, NULL, NULL, NULL, 0, false, false, false, 0, 0, false, false, false);
    self->source = source;
    self->pos = 0;
    self->length = _rune_len(source);
    self->quote = new_quote_state();
    self->token_cache = NULL;
    self->parser_state = PARSERSTATEFLAGS_NONE;
    self->dolbrace_state = DOLBRACESTATE_NONE;
    self->pending_heredocs = (Vec_Node){NULL, 0, 0};
    self->extglob = extglob;
    self->parser = NULL;
    self->eof_token = "";
    self->last_read_token = NULL;
    self->word_context = WORD_CTX_NORMAL;
    self->at_command_start = false;
    self->in_array_literal = false;
    self->in_assign_builtin = false;
    self->post_read_pos = 0;
    self->cached_word_context = WORD_CTX_NORMAL;
    self->cached_at_command_start = false;
    self->cached_in_array_literal = false;
    self->cached_in_assign_builtin = false;
    return self;
}

static Parser * new_parser(const char * source, bool in_process_sub, bool extglob) {
    Parser * self = Parser_new(NULL, 0, 0, (Vec_HereDoc){NULL, 0, 0}, 0, false, false, false, NULL, NULL, (Vec_Token){NULL, 0, 0}, 0, 0, NULL, 0, false, false, false, NULL, 0, 0);
    self->source = source;
    self->pos = 0;
    self->length = _rune_len(source);
    self->pending_heredocs = (Vec_HereDoc){NULL, 0, 0};
    self->cmdsub_heredoc_end = -(1);
    self->saw_newline_in_single_quote = false;
    self->in_process_sub = in_process_sub;
    self->extglob = extglob;
    self->ctx = new_context_stack();
    self->lexer = new_lexer(source, extglob);
    self->lexer->parser = self;
    self->token_history = (Vec_Token){(Token *[]){ NULL, NULL, NULL, NULL }, 4, 4};
    self->parser_state = PARSERSTATEFLAGS_NONE;
    self->dolbrace_state = DOLBRACESTATE_NONE;
    self->eof_token = "";
    self->word_context = WORD_CTX_NORMAL;
    self->at_command_start = false;
    self->in_array_literal = false;
    self->in_assign_builtin = false;
    self->arith_src = "";
    self->arith_pos = 0;
    self->arith_len = 0;
    return self;
}

static const char * ParseError_format_message(ParseError *self) {
    if (((self->line != 0) && (self->pos != 0))) {
        return _str_format(g_arena, "Parse error at line %v, position %v: %v", self->line, self->pos, self->message);
    } else if ((self->pos != 0)) {
        return _str_format(g_arena, "Parse error at position %v: %v", self->pos, self->message);
    }
    return _str_format(g_arena, "Parse error: %v", self->message);
}

static const char * Token__repr__(Token *self) {
    if ((self->word != NULL)) {
        return _str_format(g_arena, "Token(%v, %v, %v, word=%v)", self->type, self->value, self->pos, self->word);
    }
    if ((self->parts.len > 0)) {
        return _str_format(g_arena, "Token(%v, %v, %v, parts=%v)", self->type, self->value, self->pos, self->parts.len);
    }
    return _str_format(g_arena, "Token(%v, %v, %v)", self->type, self->value, self->pos);
}

static void QuoteState_push(QuoteState *self) {
    VEC_PUSH(g_arena, &self->stack, ((Tuple_bool_bool){self->single, self->double_}));
    self->single = false;
    self->double_ = false;
}

static void QuoteState_pop(QuoteState *self) {
    if ((self->stack.len > 0)) {
        Tuple_bool_bool _tup29 = self->stack.data[--self->stack.len];
    }
}

static bool QuoteState_in_quotes(QuoteState *self) {
    return (self->single || self->double_);
}

static QuoteState * QuoteState_copy(QuoteState *self) {
    QuoteState * qs = new_quote_state();
    qs->single = self->single;
    qs->double_ = self->double_;
    qs->stack = self->stack /* copy */;
    return qs;
}

static bool QuoteState_outer_double(QuoteState *self) {
    if ((self->stack.len == 0)) {
        return false;
    }
    return self->stack.data[(self->stack.len - 1)].F1;
}

static ParseContext * ParseContext_copy(ParseContext *self) {
    ParseContext * ctx = new_parse_context(self->kind);
    ctx->paren_depth = self->paren_depth;
    ctx->brace_depth = self->brace_depth;
    ctx->bracket_depth = self->bracket_depth;
    ctx->case_depth = self->case_depth;
    ctx->arith_depth = self->arith_depth;
    ctx->arith_paren_depth = self->arith_paren_depth;
    ctx->quote = QuoteState_copy(self->quote);
    return ctx;
}

static ParseContext * ContextStack_get_current(ContextStack *self) {
    return self->stack.data[(self->stack.len - 1)];
}

static void ContextStack_push(ContextStack *self, int64_t kind) {
    VEC_PUSH(g_arena, &self->stack, (new_parse_context(kind)));
}

static ParseContext * ContextStack_pop(ContextStack *self) {
    if ((self->stack.len > 1)) {
        return self->stack.data[--self->stack.len];
    }
    return self->stack.data[0];
}

static Vec_ParseContext ContextStack_copy_stack(ContextStack *self) {
    Vec_ParseContext result = (Vec_ParseContext){NULL, 0, 0};
    for (size_t _idx = 0; _idx < self->stack.len; _idx++) {
        ParseContext * ctx = self->stack.data[_idx];
        VEC_PUSH(g_arena, &result, (ParseContext_copy(ctx)));
    }
    return result;
}

static void ContextStack_restore_from(ContextStack *self, Vec_ParseContext saved_stack) {
    Vec_ParseContext result = (Vec_ParseContext){NULL, 0, 0};
    for (size_t _idx = 0; _idx < saved_stack.len; _idx++) {
        ParseContext * ctx = saved_stack.data[_idx];
        VEC_PUSH(g_arena, &result, (ParseContext_copy(ctx)));
    }
    self->stack = result;
}

static const char * Lexer_peek(Lexer *self) {
    if ((self->pos >= self->length)) {
        return "";
    }
    return (const char *)(_char_at_str(g_arena, self->source, self->pos));
}

static const char * Lexer_advance(Lexer *self) {
    if ((self->pos >= self->length)) {
        return "";
    }
    const char * c = (const char *)(_char_at_str(g_arena, self->source, self->pos));
    self->pos += 1;
    return c;
}

static bool Lexer_at_end(Lexer *self) {
    return (self->pos >= self->length);
}

static const char * Lexer_lookahead(Lexer *self, int64_t n) {
    return substring(self->source, self->pos, (self->pos + n));
}

static bool Lexer_is_metachar(Lexer *self, const char * c) {
    return _str_contains("|&;()<> \t\n", c);
}

static Token * Lexer_read_operator(Lexer *self) {
    int64_t start = self->pos;
    const char * c = Lexer_peek(self);
    if ((strcmp(c, "") == 0)) {
        return NULL;
    }
    const char * two = Lexer_lookahead(self, 2);
    const char * three = Lexer_lookahead(self, 3);
    if ((strcmp(three, ";;&") == 0)) {
        self->pos += 3;
        return Token_new(TOKENTYPE_SEMI_SEMI_AMP, three, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(three, "<<-") == 0)) {
        self->pos += 3;
        return Token_new(TOKENTYPE_LESS_LESS_MINUS, three, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(three, "<<<") == 0)) {
        self->pos += 3;
        return Token_new(TOKENTYPE_LESS_LESS_LESS, three, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(three, "&>>") == 0)) {
        self->pos += 3;
        return Token_new(TOKENTYPE_AMP_GREATER_GREATER, three, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "&&") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_AND_AND, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "||") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_OR_OR, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, ";;") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_SEMI_SEMI, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, ";&") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_SEMI_AMP, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "<<") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_LESS_LESS, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, ">>") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_GREATER_GREATER, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "<&") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_LESS_AMP, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, ">&") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_GREATER_AMP, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "<>") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_LESS_GREATER, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, ">|") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_GREATER_PIPE, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "&>") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_AMP_GREATER, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(two, "|&") == 0)) {
        self->pos += 2;
        return Token_new(TOKENTYPE_PIPE_AMP, two, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, ";") == 0)) {
        self->pos += 1;
        return Token_new(TOKENTYPE_SEMI, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, "|") == 0)) {
        self->pos += 1;
        return Token_new(TOKENTYPE_PIPE, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, "&") == 0)) {
        self->pos += 1;
        return Token_new(TOKENTYPE_AMP, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, "(") == 0)) {
        if ((self->word_context == WORD_CTX_REGEX)) {
            return NULL;
        }
        self->pos += 1;
        return Token_new(TOKENTYPE_LPAREN, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, ")") == 0)) {
        if ((self->word_context == WORD_CTX_REGEX)) {
            return NULL;
        }
        self->pos += 1;
        return Token_new(TOKENTYPE_RPAREN, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, "<") == 0)) {
        if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            return NULL;
        }
        self->pos += 1;
        return Token_new(TOKENTYPE_LESS, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, ">") == 0)) {
        if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            return NULL;
        }
        self->pos += 1;
        return Token_new(TOKENTYPE_GREATER, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    if ((strcmp(c, "\n") == 0)) {
        self->pos += 1;
        return Token_new(TOKENTYPE_NEWLINE, c, start, (Vec_Node){NULL, 0, 0}, NULL);
    }
    return NULL;
}

static void Lexer_skip_blanks(Lexer *self) {
    while ((self->pos < self->length)) {
        const char * c = (const char *)(_char_at_str(g_arena, self->source, self->pos));
        if (((strcmp(c, " ") != 0) && (strcmp(c, "\t") != 0))) {
            break;
        }
        self->pos += 1;
    }
}

static bool Lexer_skip_comment(Lexer *self) {
    if ((self->pos >= self->length)) {
        return false;
    }
    if ((strcmp((const char *)(_char_at_str(g_arena, self->source, self->pos)), "#") != 0)) {
        return false;
    }
    if (QuoteState_in_quotes(self->quote)) {
        return false;
    }
    if ((self->pos > 0)) {
        const char * prev = (const char *)(_char_at_str(g_arena, self->source, (self->pos - 1)));
        if (!_str_contains(" \t\n;|&(){}", prev)) {
            return false;
        }
    }
    while (((self->pos < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, self->pos)), "\n") != 0))) {
        self->pos += 1;
    }
    return true;
}

static Tuple_constcharPtr_bool Lexer_read_single_quote(Lexer *self, int64_t start) {
    Vec_Str chars = (Vec_Str){(const char *[]){ "'" }, 1, 1};
    bool saw_newline = false;
    while ((self->pos < self->length)) {
        const char * c = (const char *)(_char_at_str(g_arena, self->source, self->pos));
        if ((strcmp(c, "\n") == 0)) {
            saw_newline = true;
        }
        VEC_PUSH(g_arena, &chars, (c));
        self->pos += 1;
        if ((strcmp(c, "'") == 0)) {
            return (Tuple_constcharPtr_bool){_str_join(g_arena, "", chars), saw_newline};
        }
    }
    g_parse_error = 1;
    snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated single quote");
    return (Tuple_constcharPtr_bool){NULL, 0};
}

static bool Lexer_is_word_terminator(Lexer *self, int64_t ctx, const char * ch, int64_t bracket_depth, int64_t paren_depth) {
    if ((ctx == WORD_CTX_REGEX)) {
        if ((((strcmp(ch, "]") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0))) {
            return true;
        }
        if ((((strcmp(ch, "&") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "&") == 0))) {
            return true;
        }
        if (((strcmp(ch, ")") == 0) && (paren_depth == 0))) {
            return true;
        }
        return (is_whitespace(ch) && (paren_depth == 0));
    }
    if ((ctx == WORD_CTX_COND)) {
        if ((((strcmp(ch, "]") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0))) {
            return true;
        }
        if ((strcmp(ch, ")") == 0)) {
            return true;
        }
        if ((strcmp(ch, "&") == 0)) {
            return true;
        }
        if ((strcmp(ch, "|") == 0)) {
            return true;
        }
        if ((strcmp(ch, ";") == 0)) {
            return true;
        }
        if ((is_redirect_char(ch) && !((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))))) {
            return true;
        }
        return is_whitespace(ch);
    }
    if ((((((self->parser_state & PARSERSTATEFLAGS_PST_EOFTOKEN) != 0) && (strcmp(self->eof_token, "") != 0)) && (strcmp(ch, self->eof_token) == 0)) && (bracket_depth == 0))) {
        return true;
    }
    if (((is_redirect_char(ch) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
        return false;
    }
    return (is_metachar(ch) && (bracket_depth == 0));
}

static bool Lexer_read_bracket_expression(Lexer *self, Vec_Str * chars, Vec_Node parts, bool for_regex, int64_t paren_depth) {
    if (for_regex) {
        int64_t scan = (self->pos + 1);
        if (((scan < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, scan)), "^") == 0))) {
            scan += 1;
        }
        if (((scan < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, scan)), "]") == 0))) {
            scan += 1;
        }
        bool bracket_will_close = false;
        while ((scan < self->length)) {
            const char * sc = (const char *)(_char_at_str(g_arena, self->source, scan));
            if ((((strcmp(sc, "]") == 0) && ((scan + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (scan + 1))), "]") == 0))) {
                break;
            }
            if (((strcmp(sc, ")") == 0) && (paren_depth > 0))) {
                break;
            }
            if ((((strcmp(sc, "&") == 0) && ((scan + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (scan + 1))), "&") == 0))) {
                break;
            }
            if ((strcmp(sc, "]") == 0)) {
                bracket_will_close = true;
                break;
            }
            if ((((strcmp(sc, "[") == 0) && ((scan + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (scan + 1))), ":") == 0))) {
                scan += 2;
                while (((scan < self->length) && !((((strcmp((const char *)(_char_at_str(g_arena, self->source, scan)), ":") == 0) && ((scan + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (scan + 1))), "]") == 0))))) {
                    scan += 1;
                }
                if ((scan < self->length)) {
                    scan += 2;
                }
                continue;
            }
            scan += 1;
        }
        if (!(bracket_will_close)) {
            return false;
        }
    } else {
        if (((self->pos + 1) >= self->length)) {
            return false;
        }
        const char * next_ch = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
        if (((is_whitespace_no_newline(next_ch) || (strcmp(next_ch, "&") == 0)) || (strcmp(next_ch, "|") == 0))) {
            return false;
        }
    }
    VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
    if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "^") == 0))) {
        VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
    }
    if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "]") == 0))) {
        VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
    }
    while (!(Lexer_at_end(self))) {
        const char * c = Lexer_peek(self);
        if ((strcmp(c, "]") == 0)) {
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            break;
        }
        if ((((strcmp(c, "[") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ":") == 0))) {
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            while ((!(Lexer_at_end(self)) && !((((strcmp(Lexer_peek(self), ":") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0))))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
            if (!(Lexer_at_end(self))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
        } else if ((((!(for_regex) && (strcmp(c, "[") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "=") == 0))) {
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            while ((!(Lexer_at_end(self)) && !((((strcmp(Lexer_peek(self), "=") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0))))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
            if (!(Lexer_at_end(self))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
        } else if ((((!(for_regex) && (strcmp(c, "[") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ".") == 0))) {
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            while ((!(Lexer_at_end(self)) && !((((strcmp(Lexer_peek(self), ".") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0))))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
            if (!(Lexer_at_end(self))) {
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            }
        } else if ((for_regex && (strcmp(c, "$") == 0))) {
            Lexer_sync_to_parser(self);
            if (!(Parser_parse_dollar_expansion(self->parser, chars, &(parts), false))) {
                Lexer_sync_from_parser(self);
                VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
            } else {
                Lexer_sync_from_parser(self);
            }
        } else {
            VEC_PUSH(g_arena, chars, (Lexer_advance(self)));
        }
    }
    return true;
}

static const char * Lexer_parse_matched_pair(Lexer *self, const char * open_char, const char * close_char, int64_t flags, bool initial_was_dollar) {
    int64_t start = self->pos;
    int64_t count = 1;
    Vec_Str chars = (Vec_Str){NULL, 0, 0};
    bool pass_next = false;
    bool was_dollar = initial_was_dollar;
    bool was_gtlt = false;
    while ((count > 0)) {
        if (Lexer_at_end(self)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_format(g_arena, "unexpected EOF while looking for matching `%v'", close_char));
            return NULL;
        }
        const char * ch = Lexer_advance(self);
        if ((((flags & MATCHEDPAIRFLAGS_DOLBRACE) != 0) && (self->dolbrace_state == DOLBRACESTATE_OP))) {
            if (!_str_contains("#%^,~:-=?+/", ch)) {
                self->dolbrace_state = DOLBRACESTATE_WORD;
            }
        }
        if (pass_next) {
            pass_next = false;
            VEC_PUSH(g_arena, &chars, (ch));
            was_dollar = (strcmp(ch, "$") == 0);
            was_gtlt = _str_contains("<>", ch);
            continue;
        }
        if ((strcmp(open_char, "'") == 0)) {
            if ((strcmp(ch, close_char) == 0)) {
                count -= 1;
                if ((count == 0)) {
                    break;
                }
            }
            if (((strcmp(ch, "\\") == 0) && ((flags & MATCHEDPAIRFLAGS_ALLOWESC) != 0))) {
                pass_next = true;
            }
            VEC_PUSH(g_arena, &chars, (ch));
            was_dollar = false;
            was_gtlt = false;
            continue;
        }
        if ((strcmp(ch, "\\") == 0)) {
            if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "\n") == 0))) {
                Lexer_advance(self);
                was_dollar = false;
                was_gtlt = false;
                continue;
            }
            pass_next = true;
            VEC_PUSH(g_arena, &chars, (ch));
            was_dollar = false;
            was_gtlt = false;
            continue;
        }
        if ((strcmp(ch, close_char) == 0)) {
            count -= 1;
            if ((count == 0)) {
                break;
            }
            VEC_PUSH(g_arena, &chars, (ch));
            was_dollar = false;
            was_gtlt = _str_contains("<>", ch);
            continue;
        }
        if (((strcmp(ch, open_char) == 0) && (strcmp(open_char, close_char) != 0))) {
            if (!((((flags & MATCHEDPAIRFLAGS_DOLBRACE) != 0) && (strcmp(open_char, "{") == 0)))) {
                count += 1;
            }
            VEC_PUSH(g_arena, &chars, (ch));
            was_dollar = false;
            was_gtlt = _str_contains("<>", ch);
            continue;
        }
        const char * nested;
        if ((_str_contains("'\"`", ch) && (strcmp(open_char, close_char) != 0))) {
            if ((strcmp(ch, "'") == 0)) {
                VEC_PUSH(g_arena, &chars, (ch));
                int64_t quote_flags = (was_dollar ? (flags | MATCHEDPAIRFLAGS_ALLOWESC) : flags);
                nested = Lexer_parse_matched_pair(self, "'", "'", quote_flags, false);
                VEC_PUSH(g_arena, &chars, (nested));
                VEC_PUSH(g_arena, &chars, ("'"));
                was_dollar = false;
                was_gtlt = false;
                continue;
            } else if ((strcmp(ch, "\"") == 0)) {
                VEC_PUSH(g_arena, &chars, (ch));
                nested = Lexer_parse_matched_pair(self, "\"", "\"", (flags | MATCHEDPAIRFLAGS_DQUOTE), false);
                VEC_PUSH(g_arena, &chars, (nested));
                VEC_PUSH(g_arena, &chars, ("\""));
                was_dollar = false;
                was_gtlt = false;
                continue;
            } else if ((strcmp(ch, "`") == 0)) {
                VEC_PUSH(g_arena, &chars, (ch));
                nested = Lexer_parse_matched_pair(self, "`", "`", flags, false);
                VEC_PUSH(g_arena, &chars, (nested));
                VEC_PUSH(g_arena, &chars, ("`"));
                was_dollar = false;
                was_gtlt = false;
                continue;
            }
        }
        Node * arith_node;
        const char * arith_text;
        Node * cmd_node;
        const char * cmd_text;
        if ((((strcmp(ch, "$") == 0) && !(Lexer_at_end(self))) && !(((flags & MATCHEDPAIRFLAGS_EXTGLOB) != 0)))) {
            const char * next_ch = Lexer_peek(self);
            if (was_dollar) {
                VEC_PUSH(g_arena, &chars, (ch));
                was_dollar = false;
                was_gtlt = false;
                continue;
            }
            if ((strcmp(next_ch, "{") == 0)) {
                if (((flags & MATCHEDPAIRFLAGS_ARITH) != 0)) {
                    int64_t after_brace_pos = (self->pos + 1);
                    if (((after_brace_pos >= self->length) || !(is_funsub_char((const char *)(_char_at_str(g_arena, self->source, after_brace_pos)))))) {
                        VEC_PUSH(g_arena, &chars, (ch));
                        was_dollar = true;
                        was_gtlt = false;
                        continue;
                    }
                }
                self->pos -= 1;
                Lexer_sync_to_parser(self);
                bool in_dquote = ((flags & MATCHEDPAIRFLAGS_DQUOTE) != 0);
                Tuple_NodePtr_constcharPtr _tup30 = Parser_parse_param_expansion(self->parser, in_dquote);
                Node * param_node = _tup30.F0;
                const char * param_text = _tup30.F1;
                Lexer_sync_from_parser(self);
                if ((param_node != NULL)) {
                    VEC_PUSH(g_arena, &chars, (param_text));
                    was_dollar = false;
                    was_gtlt = false;
                } else {
                    VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                    was_dollar = true;
                    was_gtlt = false;
                }
                continue;
            } else if ((strcmp(next_ch, "(") == 0)) {
                self->pos -= 1;
                Lexer_sync_to_parser(self);
                if ((((self->pos + 2) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "(") == 0))) {
                    Tuple_NodePtr_constcharPtr _tup31 = Parser_parse_arithmetic_expansion(self->parser);
                    arith_node = _tup31.F0;
                    arith_text = _tup31.F1;
                    Lexer_sync_from_parser(self);
                    if ((arith_node != NULL)) {
                        VEC_PUSH(g_arena, &chars, (arith_text));
                        was_dollar = false;
                        was_gtlt = false;
                    } else {
                        Lexer_sync_to_parser(self);
                        Tuple_NodePtr_constcharPtr _tup32 = Parser_parse_command_substitution(self->parser);
                        cmd_node = _tup32.F0;
                        cmd_text = _tup32.F1;
                        Lexer_sync_from_parser(self);
                        if ((cmd_node != NULL)) {
                            VEC_PUSH(g_arena, &chars, (cmd_text));
                            was_dollar = false;
                            was_gtlt = false;
                        } else {
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                            was_dollar = false;
                            was_gtlt = false;
                        }
                    }
                } else {
                    Tuple_NodePtr_constcharPtr _tup33 = Parser_parse_command_substitution(self->parser);
                    cmd_node = _tup33.F0;
                    cmd_text = _tup33.F1;
                    Lexer_sync_from_parser(self);
                    if ((cmd_node != NULL)) {
                        VEC_PUSH(g_arena, &chars, (cmd_text));
                        was_dollar = false;
                        was_gtlt = false;
                    } else {
                        VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        was_dollar = false;
                        was_gtlt = false;
                    }
                }
                continue;
            } else if ((strcmp(next_ch, "[") == 0)) {
                self->pos -= 1;
                Lexer_sync_to_parser(self);
                Tuple_NodePtr_constcharPtr _tup34 = Parser_parse_deprecated_arithmetic(self->parser);
                arith_node = _tup34.F0;
                arith_text = _tup34.F1;
                Lexer_sync_from_parser(self);
                if ((arith_node != NULL)) {
                    VEC_PUSH(g_arena, &chars, (arith_text));
                    was_dollar = false;
                    was_gtlt = false;
                } else {
                    VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                    was_dollar = true;
                    was_gtlt = false;
                }
                continue;
            }
        }
        if ((((strcmp(ch, "(") == 0) && was_gtlt) && ((flags & (MATCHEDPAIRFLAGS_DOLBRACE | MATCHEDPAIRFLAGS_ARRAYSUB)) != 0))) {
            const char * direction = chars.data[(chars.len - 1)];
            Vec_Str chars = /* slice[0:(chars.len - 1)] */ chars;
            self->pos -= 1;
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup35 = Parser_parse_process_substitution(self->parser);
            Node * procsub_node = _tup35.F0;
            const char * procsub_text = _tup35.F1;
            Lexer_sync_from_parser(self);
            if ((procsub_node != NULL)) {
                VEC_PUSH(g_arena, &chars, (procsub_text));
                was_dollar = false;
                was_gtlt = false;
            } else {
                VEC_PUSH(g_arena, &chars, (direction));
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                was_dollar = false;
                was_gtlt = false;
            }
            continue;
        }
        VEC_PUSH(g_arena, &chars, (ch));
        was_dollar = (strcmp(ch, "$") == 0);
        was_gtlt = _str_contains("<>", ch);
    }
    return _str_join(g_arena, "", chars);
}

static const char * Lexer_collect_param_argument(Lexer *self, int64_t flags, bool was_dollar) {
    return Lexer_parse_matched_pair(self, "{", "}", (flags | MATCHEDPAIRFLAGS_DOLBRACE), was_dollar);
}

static Word * Lexer_read_word_internal(Lexer *self, int64_t ctx, bool at_command_start, bool in_array_literal, bool in_assign_builtin) {
    int64_t start = self->pos;
    Vec_Str chars = (Vec_Str){NULL, 0, 0};
    Vec_Node parts = (Vec_Node){NULL, 0, 0};
    int64_t bracket_depth = 0;
    int64_t bracket_start_pos = -(1);
    bool seen_equals = false;
    int64_t paren_depth = 0;
    while (!(Lexer_at_end(self))) {
        const char * ch = Lexer_peek(self);
        if ((ctx == WORD_CTX_REGEX)) {
            if ((((strcmp(ch, "\\") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\n") == 0))) {
                Lexer_advance(self);
                Lexer_advance(self);
                continue;
            }
        }
        if (((ctx != WORD_CTX_NORMAL) && Lexer_is_word_terminator(self, ctx, ch, bracket_depth, paren_depth))) {
            break;
        }
        if (((ctx == WORD_CTX_NORMAL) && (strcmp(ch, "[") == 0))) {
            if ((bracket_depth > 0)) {
                bracket_depth += 1;
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                continue;
            }
            if (((((chars.len > 0) && at_command_start) && !(seen_equals)) && is_array_assignment_prefix(chars))) {
                const char * prev_char = chars.data[(chars.len - 1)];
                if ((_str_is_alnum(prev_char) || (strcmp(prev_char, "_") == 0))) {
                    int64_t bracket_start_pos = self->pos;
                    bracket_depth += 1;
                    VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                    continue;
                }
            }
            if (((!((chars.len > 0)) && !(seen_equals)) && in_array_literal)) {
                bracket_start_pos = self->pos;
                bracket_depth += 1;
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                continue;
            }
        }
        if ((((ctx == WORD_CTX_NORMAL) && (strcmp(ch, "]") == 0)) && (bracket_depth > 0))) {
            bracket_depth -= 1;
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            continue;
        }
        if ((((ctx == WORD_CTX_NORMAL) && (strcmp(ch, "=") == 0)) && (bracket_depth == 0))) {
            seen_equals = true;
        }
        if (((ctx == WORD_CTX_REGEX) && (strcmp(ch, "(") == 0))) {
            paren_depth += 1;
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            continue;
        }
        if (((ctx == WORD_CTX_REGEX) && (strcmp(ch, ")") == 0))) {
            if ((paren_depth > 0)) {
                paren_depth -= 1;
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                continue;
            }
            break;
        }
        if ((((ctx == WORD_CTX_COND) || (ctx == WORD_CTX_REGEX)) && (strcmp(ch, "[") == 0))) {
            bool for_regex = (ctx == WORD_CTX_REGEX);
            if (Lexer_read_bracket_expression(self, &(chars), parts, for_regex, paren_depth)) {
                continue;
            }
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            continue;
        }
        const char * content;
        if (((ctx == WORD_CTX_COND) && (strcmp(ch, "(") == 0))) {
            if (((self->extglob && (chars.len > 0)) && is_extglob_prefix(chars.data[(chars.len - 1)]))) {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                content = Lexer_parse_matched_pair(self, "(", ")", MATCHEDPAIRFLAGS_EXTGLOB, false);
                VEC_PUSH(g_arena, &chars, (content));
                VEC_PUSH(g_arena, &chars, (")"));
                continue;
            } else {
                break;
            }
        }
        if ((((ctx == WORD_CTX_REGEX) && is_whitespace(ch)) && (paren_depth > 0))) {
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            continue;
        }
        if ((strcmp(ch, "'") == 0)) {
            Lexer_advance(self);
            bool track_newline = (ctx == WORD_CTX_NORMAL);
            Tuple_constcharPtr_bool _tup36 = Lexer_read_single_quote(self, start);
            content = _tup36.F0;
            bool saw_newline = _tup36.F1;
            VEC_PUSH(g_arena, &chars, (content));
            if (((track_newline && saw_newline) && (self->parser != NULL))) {
                self->parser->saw_newline_in_single_quote = true;
            }
            continue;
        }
        Node * cmdsub_result0;
        const char * cmdsub_result1;
        if ((strcmp(ch, "\"") == 0)) {
            Lexer_advance(self);
            if ((ctx == WORD_CTX_NORMAL)) {
                VEC_PUSH(g_arena, &chars, ("\""));
                bool in_single_in_dquote = false;
                while ((!(Lexer_at_end(self)) && (in_single_in_dquote || (strcmp(Lexer_peek(self), "\"") != 0)))) {
                    const char * c = Lexer_peek(self);
                    if (in_single_in_dquote) {
                        VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        if ((strcmp(c, "'") == 0)) {
                            in_single_in_dquote = false;
                        }
                        continue;
                    }
                    if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
                        const char * next_c = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
                        if ((strcmp(next_c, "\n") == 0)) {
                            Lexer_advance(self);
                            Lexer_advance(self);
                        } else {
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        }
                    } else if ((strcmp(c, "$") == 0)) {
                        Lexer_sync_to_parser(self);
                        if (!(Parser_parse_dollar_expansion(self->parser, &(chars), &(parts), true))) {
                            Lexer_sync_from_parser(self);
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        } else {
                            Lexer_sync_from_parser(self);
                        }
                    } else if ((strcmp(c, "`") == 0)) {
                        Lexer_sync_to_parser(self);
                        Tuple_NodePtr_constcharPtr _tup37 = Parser_parse_backtick_substitution(self->parser);
                        cmdsub_result0 = _tup37.F0;
                        cmdsub_result1 = _tup37.F1;
                        Lexer_sync_from_parser(self);
                        if ((cmdsub_result0 != NULL)) {
                            VEC_PUSH(g_arena, &parts, (cmdsub_result0));
                            VEC_PUSH(g_arena, &chars, (cmdsub_result1));
                        } else {
                            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                        }
                    } else {
                        VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                    }
                }
                if (Lexer_at_end(self)) {
                    g_parse_error = 1;
                    snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated double quote");
                    return NULL;
                }
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            } else {
                bool handle_line_continuation = (ctx == WORD_CTX_COND);
                Lexer_sync_to_parser(self);
                Parser_scan_double_quote(self->parser, &(chars), parts, start, handle_line_continuation);
                Lexer_sync_from_parser(self);
            }
            continue;
        }
        if (((strcmp(ch, "\\") == 0) && ((self->pos + 1) < self->length))) {
            const char * next_ch = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
            if (((ctx != WORD_CTX_REGEX) && (strcmp(next_ch, "\n") == 0))) {
                Lexer_advance(self);
                Lexer_advance(self);
            } else {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            }
            continue;
        }
        if (((((ctx != WORD_CTX_REGEX) && (strcmp(ch, "$") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "'") == 0))) {
            Tuple_NodePtr_constcharPtr _tup38 = Lexer_read_ansi_c_quote(self);
            Node * ansi_result0 = _tup38.F0;
            const char * ansi_result1 = _tup38.F1;
            if ((ansi_result0 != NULL)) {
                VEC_PUSH(g_arena, &parts, (ansi_result0));
                VEC_PUSH(g_arena, &chars, (ansi_result1));
            } else {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            }
            continue;
        }
        if (((((ctx != WORD_CTX_REGEX) && (strcmp(ch, "$") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\"") == 0))) {
            Tuple_NodePtr_constcharPtr_Vec_Node _tup39 = Lexer_read_locale_string(self);
            Node * locale_result0 = _tup39.F0;
            const char * locale_result1 = _tup39.F1;
            Vec_Node locale_result2 = _tup39.F2;
            if ((locale_result0 != NULL)) {
                VEC_PUSH(g_arena, &parts, (locale_result0));
                do { Vec_Node _src = locale_result2; for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &parts, _src.data[_i]); } } while(0);
                VEC_PUSH(g_arena, &chars, (locale_result1));
            } else {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            }
            continue;
        }
        if ((strcmp(ch, "$") == 0)) {
            Lexer_sync_to_parser(self);
            if (!(Parser_parse_dollar_expansion(self->parser, &(chars), &(parts), false))) {
                Lexer_sync_from_parser(self);
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            } else {
                Lexer_sync_from_parser(self);
                if ((((((((self->extglob && (ctx == WORD_CTX_NORMAL)) && (chars.len > 0)) && (_rune_len(chars.data[(chars.len - 1)]) == 2)) && (strcmp((const char *)(_char_at_str(g_arena, chars.data[(chars.len - 1)], 0)), "$") == 0)) && _str_contains("?*@", (const char *)(_char_at_str(g_arena, chars.data[(chars.len - 1)], 1)))) && !(Lexer_at_end(self))) && (strcmp(Lexer_peek(self), "(") == 0))) {
                    VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                    content = Lexer_parse_matched_pair(self, "(", ")", MATCHEDPAIRFLAGS_EXTGLOB, false);
                    VEC_PUSH(g_arena, &chars, (content));
                    VEC_PUSH(g_arena, &chars, (")"));
                }
            }
            continue;
        }
        if (((ctx != WORD_CTX_REGEX) && (strcmp(ch, "`") == 0))) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup40 = Parser_parse_backtick_substitution(self->parser);
            cmdsub_result0 = _tup40.F0;
            cmdsub_result1 = _tup40.F1;
            Lexer_sync_from_parser(self);
            if ((cmdsub_result0 != NULL)) {
                VEC_PUSH(g_arena, &parts, (cmdsub_result0));
                VEC_PUSH(g_arena, &chars, (cmdsub_result1));
            } else {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            }
            continue;
        }
        if (((((ctx != WORD_CTX_REGEX) && is_redirect_char(ch)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup41 = Parser_parse_process_substitution(self->parser);
            Node * procsub_result0 = _tup41.F0;
            const char * procsub_result1 = _tup41.F1;
            Lexer_sync_from_parser(self);
            if ((procsub_result0 != NULL)) {
                VEC_PUSH(g_arena, &parts, (procsub_result0));
                VEC_PUSH(g_arena, &chars, (procsub_result1));
            } else if ((procsub_result1 != NULL && procsub_result1[0] != '\0')) {
                VEC_PUSH(g_arena, &chars, (procsub_result1));
            } else {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                if ((ctx == WORD_CTX_NORMAL)) {
                    VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
                }
            }
            continue;
        }
        if (((((ctx == WORD_CTX_NORMAL) && (strcmp(ch, "(") == 0)) && (chars.len > 0)) && (bracket_depth == 0))) {
            bool is_array_assign = false;
            if ((((chars.len >= 3) && (strcmp(chars.data[(chars.len - 2)], "+") == 0)) && (strcmp(chars.data[(chars.len - 1)], "=") == 0))) {
                is_array_assign = is_array_assignment_prefix(/* slice[0:(chars.len - 2)] */ chars);
            } else if (((strcmp(chars.data[(chars.len - 1)], "=") == 0) && (chars.len >= 2))) {
                is_array_assign = is_array_assignment_prefix(/* slice[0:(chars.len - 1)] */ chars);
            }
            if ((is_array_assign && (at_command_start || in_assign_builtin))) {
                Lexer_sync_to_parser(self);
                Tuple_NodePtr_constcharPtr _tup42 = Parser_parse_array_literal(self->parser);
                Node * array_result0 = _tup42.F0;
                const char * array_result1 = _tup42.F1;
                Lexer_sync_from_parser(self);
                if ((array_result0 != NULL)) {
                    VEC_PUSH(g_arena, &parts, (array_result0));
                    VEC_PUSH(g_arena, &chars, (array_result1));
                } else {
                    break;
                }
                continue;
            }
        }
        if (((((self->extglob && (ctx == WORD_CTX_NORMAL)) && is_extglob_prefix(ch)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            content = Lexer_parse_matched_pair(self, "(", ")", MATCHEDPAIRFLAGS_EXTGLOB, false);
            VEC_PUSH(g_arena, &chars, (content));
            VEC_PUSH(g_arena, &chars, (")"));
            continue;
        }
        if ((((((ctx == WORD_CTX_NORMAL) && ((self->parser_state & PARSERSTATEFLAGS_PST_EOFTOKEN) != 0)) && (strcmp(self->eof_token, "") != 0)) && (strcmp(ch, self->eof_token) == 0)) && (bracket_depth == 0))) {
            if (!((chars.len > 0))) {
                VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
            }
            break;
        }
        if ((((ctx == WORD_CTX_NORMAL) && is_metachar(ch)) && (bracket_depth == 0))) {
            break;
        }
        VEC_PUSH(g_arena, &chars, (Lexer_advance(self)));
    }
    if ((((bracket_depth > 0) && (bracket_start_pos != -(1))) && Lexer_at_end(self))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `]'");
        return NULL;
    }
    if (!((chars.len > 0))) {
        return NULL;
    }
    if ((parts.len > 0)) {
        return Word_new(_str_join(g_arena, "", chars), parts, "word");
    }
    return Word_new(_str_join(g_arena, "", chars), (Vec_Node){NULL, 0, 0}, "word");
}

static Token * Lexer_read_word(Lexer *self) {
    int64_t start = self->pos;
    if ((self->pos >= self->length)) {
        return NULL;
    }
    const char * c = Lexer_peek(self);
    if ((strcmp(c, "") == 0)) {
        return NULL;
    }
    bool is_procsub = ((((strcmp(c, "<") == 0) || (strcmp(c, ">") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0));
    bool is_regex_paren = ((self->word_context == WORD_CTX_REGEX) && ((strcmp(c, "(") == 0) || (strcmp(c, ")") == 0)));
    if (((Lexer_is_metachar(self, c) && !(is_procsub)) && !(is_regex_paren))) {
        return NULL;
    }
    Word * word = Lexer_read_word_internal(self, self->word_context, self->at_command_start, self->in_array_literal, self->in_assign_builtin);
    if ((word == NULL)) {
        return NULL;
    }
    return Token_new(TOKENTYPE_WORD, word->value, start, (Vec_Node){NULL, 0, 0}, word);
}

static Token * Lexer_next_token(Lexer *self) {
    Token * tok;
    if ((self->token_cache != NULL)) {
        tok = self->token_cache;
        self->token_cache = NULL;
        self->last_read_token = tok;
        return tok;
    }
    Lexer_skip_blanks(self);
    if (Lexer_at_end(self)) {
        tok = Token_new(TOKENTYPE_EOF, "", self->pos, (Vec_Node){NULL, 0, 0}, NULL);
        self->last_read_token = tok;
        return tok;
    }
    if (((((strcmp(self->eof_token, "") != 0) && (strcmp(Lexer_peek(self), self->eof_token) == 0)) && !(((self->parser_state & PARSERSTATEFLAGS_PST_CASEPAT) != 0))) && !(((self->parser_state & PARSERSTATEFLAGS_PST_EOFTOKEN) != 0)))) {
        tok = Token_new(TOKENTYPE_EOF, "", self->pos, (Vec_Node){NULL, 0, 0}, NULL);
        self->last_read_token = tok;
        return tok;
    }
    while (Lexer_skip_comment(self)) {
        Lexer_skip_blanks(self);
        if (Lexer_at_end(self)) {
            tok = Token_new(TOKENTYPE_EOF, "", self->pos, (Vec_Node){NULL, 0, 0}, NULL);
            self->last_read_token = tok;
            return tok;
        }
        if (((((strcmp(self->eof_token, "") != 0) && (strcmp(Lexer_peek(self), self->eof_token) == 0)) && !(((self->parser_state & PARSERSTATEFLAGS_PST_CASEPAT) != 0))) && !(((self->parser_state & PARSERSTATEFLAGS_PST_EOFTOKEN) != 0)))) {
            tok = Token_new(TOKENTYPE_EOF, "", self->pos, (Vec_Node){NULL, 0, 0}, NULL);
            self->last_read_token = tok;
            return tok;
        }
    }
    tok = Lexer_read_operator(self);
    if ((tok != NULL)) {
        self->last_read_token = tok;
        return tok;
    }
    tok = Lexer_read_word(self);
    if ((tok != NULL)) {
        self->last_read_token = tok;
        return tok;
    }
    tok = Token_new(TOKENTYPE_EOF, "", self->pos, (Vec_Node){NULL, 0, 0}, NULL);
    self->last_read_token = tok;
    return tok;
}

static Token * Lexer_peek_token(Lexer *self) {
    if ((self->token_cache == NULL)) {
        Token * saved_last = self->last_read_token;
        self->token_cache = Lexer_next_token(self);
        self->last_read_token = saved_last;
    }
    return self->token_cache;
}

static Tuple_NodePtr_constcharPtr Lexer_read_ansi_c_quote(Lexer *self) {
    if ((Lexer_at_end(self) || (strcmp(Lexer_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    if ((((self->pos + 1) >= self->length) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "'") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    Lexer_advance(self);
    Lexer_advance(self);
    Vec_Str content_chars = (Vec_Str){NULL, 0, 0};
    bool found_close = false;
    while (!(Lexer_at_end(self))) {
        const char * ch = Lexer_peek(self);
        if ((strcmp(ch, "'") == 0)) {
            Lexer_advance(self);
            found_close = true;
            break;
        } else if ((strcmp(ch, "\\") == 0)) {
            VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            if (!(Lexer_at_end(self))) {
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            }
        } else {
            VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
        }
    }
    if (!(found_close)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF while looking for matching `''");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    const char * text = substring(self->source, start, self->pos);
    const char * content = _str_join(g_arena, "", content_chars);
    AnsiCQuote * node = AnsiCQuote_new(content, "ansi-c");
    return (Tuple_NodePtr_constcharPtr){(Node *)node, text};
}

static void Lexer_sync_to_parser(Lexer *self) {
    if ((self->parser != NULL)) {
        self->parser->pos = self->pos;
    }
}

static void Lexer_sync_from_parser(Lexer *self) {
    if ((self->parser != NULL)) {
        self->pos = self->parser->pos;
    }
}

static Tuple_NodePtr_constcharPtr_Vec_Node Lexer_read_locale_string(Lexer *self) {
    if ((Lexer_at_end(self) || (strcmp(Lexer_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr_Vec_Node){(Node *)NULL, "", (Vec_Node){NULL, 0, 0}};
    }
    if ((((self->pos + 1) >= self->length) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\"") != 0))) {
        return (Tuple_NodePtr_constcharPtr_Vec_Node){(Node *)NULL, "", (Vec_Node){NULL, 0, 0}};
    }
    int64_t start = self->pos;
    Lexer_advance(self);
    Lexer_advance(self);
    Vec_Str content_chars = (Vec_Str){NULL, 0, 0};
    Vec_Node inner_parts = (Vec_Node){NULL, 0, 0};
    bool found_close = false;
    while (!(Lexer_at_end(self))) {
        const char * ch = Lexer_peek(self);
        Node * cmdsub_node;
        const char * cmdsub_text;
        if ((strcmp(ch, "\"") == 0)) {
            Lexer_advance(self);
            found_close = true;
            break;
        } else if (((strcmp(ch, "\\") == 0) && ((self->pos + 1) < self->length))) {
            const char * next_ch = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
            if ((strcmp(next_ch, "\n") == 0)) {
                Lexer_advance(self);
                Lexer_advance(self);
            } else {
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            }
        } else if (((((strcmp(ch, "$") == 0) && ((self->pos + 2) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "(") == 0))) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup43 = Parser_parse_arithmetic_expansion(self->parser);
            Node * arith_node = _tup43.F0;
            const char * arith_text = _tup43.F1;
            Lexer_sync_from_parser(self);
            if ((arith_node != NULL)) {
                VEC_PUSH(g_arena, &inner_parts, (arith_node));
                VEC_PUSH(g_arena, &content_chars, (arith_text));
            } else {
                Lexer_sync_to_parser(self);
                Tuple_NodePtr_constcharPtr _tup44 = Parser_parse_command_substitution(self->parser);
                cmdsub_node = _tup44.F0;
                cmdsub_text = _tup44.F1;
                Lexer_sync_from_parser(self);
                if ((cmdsub_node != NULL)) {
                    VEC_PUSH(g_arena, &inner_parts, (cmdsub_node));
                    VEC_PUSH(g_arena, &content_chars, (cmdsub_text));
                } else {
                    VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
                }
            }
        } else if (is_expansion_start(self->source, self->pos, "$(")) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup45 = Parser_parse_command_substitution(self->parser);
            cmdsub_node = _tup45.F0;
            cmdsub_text = _tup45.F1;
            Lexer_sync_from_parser(self);
            if ((cmdsub_node != NULL)) {
                VEC_PUSH(g_arena, &inner_parts, (cmdsub_node));
                VEC_PUSH(g_arena, &content_chars, (cmdsub_text));
            } else {
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            }
        } else if ((strcmp(ch, "$") == 0)) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup46 = Parser_parse_param_expansion(self->parser, false);
            Node * param_node = _tup46.F0;
            const char * param_text = _tup46.F1;
            Lexer_sync_from_parser(self);
            if ((param_node != NULL)) {
                VEC_PUSH(g_arena, &inner_parts, (param_node));
                VEC_PUSH(g_arena, &content_chars, (param_text));
            } else {
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            }
        } else if ((strcmp(ch, "`") == 0)) {
            Lexer_sync_to_parser(self);
            Tuple_NodePtr_constcharPtr _tup47 = Parser_parse_backtick_substitution(self->parser);
            cmdsub_node = _tup47.F0;
            cmdsub_text = _tup47.F1;
            Lexer_sync_from_parser(self);
            if ((cmdsub_node != NULL)) {
                VEC_PUSH(g_arena, &inner_parts, (cmdsub_node));
                VEC_PUSH(g_arena, &content_chars, (cmdsub_text));
            } else {
                VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
            }
        } else {
            VEC_PUSH(g_arena, &content_chars, (Lexer_advance(self)));
        }
    }
    if (!(found_close)) {
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr_Vec_Node){(Node *)NULL, "", (Vec_Node){NULL, 0, 0}};
    }
    const char * content = _str_join(g_arena, "", content_chars);
    const char * text = _str_concat(g_arena, _str_concat(g_arena, "$\"", content), "\"");
    return (Tuple_NodePtr_constcharPtr_Vec_Node){(Node *)LocaleString_new(content, "locale"), text, inner_parts};
}

static void Lexer_update_dolbrace_for_op(Lexer *self, const char * op, bool has_param) {
    if ((self->dolbrace_state == DOLBRACESTATE_NONE)) {
        return;
    }
    if (((strcmp(op, "") == 0) || (_rune_len(op) == 0))) {
        return;
    }
    const char * first_char = (const char *)(_char_at_str(g_arena, op, 0));
    if (((self->dolbrace_state == DOLBRACESTATE_PARAM) && has_param)) {
        if (_str_contains("%#^,", first_char)) {
            self->dolbrace_state = DOLBRACESTATE_QUOTE;
            return;
        }
        if ((strcmp(first_char, "/") == 0)) {
            self->dolbrace_state = DOLBRACESTATE_QUOTE2;
            return;
        }
    }
    if ((self->dolbrace_state == DOLBRACESTATE_PARAM)) {
        if (_str_contains("#%^,~:-=?+/", first_char)) {
            self->dolbrace_state = DOLBRACESTATE_OP;
        }
    }
}

static const char * Lexer_consume_param_operator(Lexer *self) {
    if (Lexer_at_end(self)) {
        return "";
    }
    const char * ch = Lexer_peek(self);
    const char * next_ch;
    if ((strcmp(ch, ":") == 0)) {
        Lexer_advance(self);
        if (Lexer_at_end(self)) {
            return ":";
        }
        next_ch = Lexer_peek(self);
        if (is_simple_param_op(next_ch)) {
            Lexer_advance(self);
            return _str_concat(g_arena, ":", next_ch);
        }
        return ":";
    }
    if (is_simple_param_op(ch)) {
        Lexer_advance(self);
        return ch;
    }
    if ((strcmp(ch, "#") == 0)) {
        Lexer_advance(self);
        if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "#") == 0))) {
            Lexer_advance(self);
            return "##";
        }
        return "#";
    }
    if ((strcmp(ch, "%") == 0)) {
        Lexer_advance(self);
        if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "%") == 0))) {
            Lexer_advance(self);
            return "%%";
        }
        return "%";
    }
    if ((strcmp(ch, "/") == 0)) {
        Lexer_advance(self);
        if (!(Lexer_at_end(self))) {
            next_ch = Lexer_peek(self);
            if ((strcmp(next_ch, "/") == 0)) {
                Lexer_advance(self);
                return "//";
            } else if ((strcmp(next_ch, "#") == 0)) {
                Lexer_advance(self);
                return "/#";
            } else if ((strcmp(next_ch, "%") == 0)) {
                Lexer_advance(self);
                return "/%";
            }
        }
        return "/";
    }
    if ((strcmp(ch, "^") == 0)) {
        Lexer_advance(self);
        if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "^") == 0))) {
            Lexer_advance(self);
            return "^^";
        }
        return "^";
    }
    if ((strcmp(ch, ",") == 0)) {
        Lexer_advance(self);
        if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), ",") == 0))) {
            Lexer_advance(self);
            return ",,";
        }
        return ",";
    }
    if ((strcmp(ch, "@") == 0)) {
        Lexer_advance(self);
        return "@";
    }
    return "";
}

static bool Lexer_param_subscript_has_close(Lexer *self, int64_t start_pos) {
    int64_t depth = 1;
    int64_t i = (start_pos + 1);
    QuoteState * quote = new_quote_state();
    while ((i < self->length)) {
        const char * c = (const char *)(_char_at_str(g_arena, self->source, i));
        if (quote->single) {
            if ((strcmp(c, "'") == 0)) {
                quote->single = false;
            }
            i += 1;
            continue;
        }
        if (quote->double_) {
            if (((strcmp(c, "\\") == 0) && ((i + 1) < self->length))) {
                i += 2;
                continue;
            }
            if ((strcmp(c, "\"") == 0)) {
                quote->double_ = false;
            }
            i += 1;
            continue;
        }
        if ((strcmp(c, "'") == 0)) {
            quote->single = true;
            i += 1;
            continue;
        }
        if ((strcmp(c, "\"") == 0)) {
            quote->double_ = true;
            i += 1;
            continue;
        }
        if ((strcmp(c, "\\") == 0)) {
            i += 2;
            continue;
        }
        if ((strcmp(c, "}") == 0)) {
            return false;
        }
        if ((strcmp(c, "[") == 0)) {
            depth += 1;
        } else if ((strcmp(c, "]") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                return true;
            }
        }
        i += 1;
    }
    return false;
}

static const char * Lexer_consume_param_name(Lexer *self) {
    if (Lexer_at_end(self)) {
        return "";
    }
    const char * ch = Lexer_peek(self);
    if (is_special_param(ch)) {
        if ((((strcmp(ch, "$") == 0) && ((self->pos + 1) < self->length)) && _str_contains("{'\"", (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)))))) {
            return "";
        }
        Lexer_advance(self);
        return ch;
    }
    if (_str_is_digit(ch)) {
        Vec_Str name_chars = (Vec_Str){NULL, 0, 0};
        while ((!(Lexer_at_end(self)) && _str_is_digit(Lexer_peek(self)))) {
            VEC_PUSH(g_arena, &name_chars, (Lexer_advance(self)));
        }
        return _str_join(g_arena, "", name_chars);
    }
    if ((_str_is_alpha(ch) || (strcmp(ch, "_") == 0))) {
        Vec_Str name_chars = (Vec_Str){NULL, 0, 0};
        while (!(Lexer_at_end(self))) {
            const char * c = Lexer_peek(self);
            if ((_str_is_alnum(c) || (strcmp(c, "_") == 0))) {
                VEC_PUSH(g_arena, &name_chars, (Lexer_advance(self)));
            } else if ((strcmp(c, "[") == 0)) {
                if (!(Lexer_param_subscript_has_close(self, self->pos))) {
                    break;
                }
                VEC_PUSH(g_arena, &name_chars, (Lexer_advance(self)));
                const char * content = Lexer_parse_matched_pair(self, "[", "]", MATCHEDPAIRFLAGS_ARRAYSUB, false);
                VEC_PUSH(g_arena, &name_chars, (content));
                VEC_PUSH(g_arena, &name_chars, ("]"));
                break;
            } else {
                break;
            }
        }
        if ((name_chars.len > 0)) {
            return _str_join(g_arena, "", name_chars);
        } else {
            return "";
        }
    }
    return "";
}

static Tuple_NodePtr_constcharPtr Lexer_read_param_expansion(Lexer *self, bool in_dquote) {
    if ((Lexer_at_end(self) || (strcmp(Lexer_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    Lexer_advance(self);
    if (Lexer_at_end(self)) {
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    const char * ch = Lexer_peek(self);
    if ((strcmp(ch, "{") == 0)) {
        Lexer_advance(self);
        return Lexer_read_braced_param(self, start, in_dquote);
    }
    const char * text;
    if (((is_special_param_unbraced(ch) || is_digit(ch)) || (strcmp(ch, "#") == 0))) {
        Lexer_advance(self);
        text = substring(self->source, start, self->pos);
        return (Tuple_NodePtr_constcharPtr){(Node *)ParamExpansion_new(ch, NULL, NULL, "param"), text};
    }
    if ((_str_is_alpha(ch) || (strcmp(ch, "_") == 0))) {
        int64_t name_start = self->pos;
        while (!(Lexer_at_end(self))) {
            const char * c = Lexer_peek(self);
            if ((_str_is_alnum(c) || (strcmp(c, "_") == 0))) {
                Lexer_advance(self);
            } else {
                break;
            }
        }
        const char * name = substring(self->source, name_start, self->pos);
        text = substring(self->source, start, self->pos);
        return (Tuple_NodePtr_constcharPtr){(Node *)ParamExpansion_new(name, NULL, NULL, "param"), text};
    }
    self->pos = start;
    return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
}

static Tuple_NodePtr_constcharPtr Lexer_read_braced_param(Lexer *self, int64_t start, bool in_dquote) {
    if (Lexer_at_end(self)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `}'");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    int64_t saved_dolbrace = self->dolbrace_state;
    self->dolbrace_state = DOLBRACESTATE_PARAM;
    const char * ch = Lexer_peek(self);
    if (is_funsub_char(ch)) {
        self->dolbrace_state = saved_dolbrace;
        return Lexer_read_funsub(self, start);
    }
    const char * param;
    const char * text;
    if ((strcmp(ch, "#") == 0)) {
        Lexer_advance(self);
        param = Lexer_consume_param_name(self);
        if ((((param != NULL && param[0] != '\0') && !(Lexer_at_end(self))) && (strcmp(Lexer_peek(self), "}") == 0))) {
            Lexer_advance(self);
            text = substring(self->source, start, self->pos);
            self->dolbrace_state = saved_dolbrace;
            return (Tuple_NodePtr_constcharPtr){(Node *)ParamLength_new(param, "param-len"), text};
        }
        self->pos = (start + 2);
    }
    const char * op;
    const char * arg;
    if ((strcmp(ch, "!") == 0)) {
        Lexer_advance(self);
        while ((!(Lexer_at_end(self)) && is_whitespace_no_newline(Lexer_peek(self)))) {
            Lexer_advance(self);
        }
        param = Lexer_consume_param_name(self);
        if ((param != NULL && param[0] != '\0')) {
            while ((!(Lexer_at_end(self)) && is_whitespace_no_newline(Lexer_peek(self)))) {
                Lexer_advance(self);
            }
            if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "}") == 0))) {
                Lexer_advance(self);
                text = substring(self->source, start, self->pos);
                self->dolbrace_state = saved_dolbrace;
                return (Tuple_NodePtr_constcharPtr){(Node *)ParamIndirect_new(param, NULL, NULL, "param-indirect"), text};
            }
            if ((!(Lexer_at_end(self)) && is_at_or_star(Lexer_peek(self)))) {
                const char * suffix = Lexer_advance(self);
                const char * trailing = Lexer_parse_matched_pair(self, "{", "}", MATCHEDPAIRFLAGS_DOLBRACE, false);
                text = substring(self->source, start, self->pos);
                self->dolbrace_state = saved_dolbrace;
                return (Tuple_NodePtr_constcharPtr){(Node *)ParamIndirect_new(_str_concat(g_arena, _str_concat(g_arena, param, suffix), trailing), NULL, NULL, "param-indirect"), text};
            }
            op = Lexer_consume_param_operator(self);
            if ((((strcmp(op, "") == 0) && !(Lexer_at_end(self))) && !_str_contains("}\"'`", Lexer_peek(self)))) {
                op = Lexer_advance(self);
            }
            if (((strcmp(op, "") != 0) && !_str_contains("\"'`", op))) {
                arg = Lexer_parse_matched_pair(self, "{", "}", MATCHEDPAIRFLAGS_DOLBRACE, false);
                text = substring(self->source, start, self->pos);
                self->dolbrace_state = saved_dolbrace;
                return (Tuple_NodePtr_constcharPtr){(Node *)ParamIndirect_new(param, op, arg, "param-indirect"), text};
            }
            if (Lexer_at_end(self)) {
                self->dolbrace_state = saved_dolbrace;
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `}'");
                return (Tuple_NodePtr_constcharPtr){NULL, NULL};
            }
            self->pos = (start + 2);
        } else {
            self->pos = (start + 2);
        }
    }
    param = Lexer_consume_param_name(self);
    if (!((param != NULL && param[0] != '\0'))) {
        if ((!(Lexer_at_end(self)) && (_str_contains("-=+?", Lexer_peek(self)) || (((strcmp(Lexer_peek(self), ":") == 0) && ((self->pos + 1) < self->length)) && is_simple_param_op((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)))))))) {
            param = "";
        } else {
            const char * content = Lexer_parse_matched_pair(self, "{", "}", MATCHEDPAIRFLAGS_DOLBRACE, false);
            text = _str_concat(g_arena, _str_concat(g_arena, "${", content), "}");
            self->dolbrace_state = saved_dolbrace;
            return (Tuple_NodePtr_constcharPtr){(Node *)ParamExpansion_new(content, NULL, NULL, "param"), text};
        }
    }
    if (Lexer_at_end(self)) {
        self->dolbrace_state = saved_dolbrace;
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `}'");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    if ((strcmp(Lexer_peek(self), "}") == 0)) {
        Lexer_advance(self);
        text = substring(self->source, start, self->pos);
        self->dolbrace_state = saved_dolbrace;
        return (Tuple_NodePtr_constcharPtr){(Node *)ParamExpansion_new(param, NULL, NULL, "param"), text};
    }
    op = Lexer_consume_param_operator(self);
    if ((strcmp(op, "") == 0)) {
        if ((((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "$") == 0)) && ((self->pos + 1) < self->length)) && ((strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\"") == 0) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "'") == 0)))) {
            int64_t dollar_count = (1 + count_consecutive_dollars_before(self->source, self->pos));
            if (((dollar_count % 2) == 1)) {
                op = "";
            } else {
                op = Lexer_advance(self);
            }
        } else if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "`") == 0))) {
            int64_t backtick_pos = self->pos;
            Lexer_advance(self);
            while ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "`") != 0))) {
                const char * bc = Lexer_peek(self);
                if (((strcmp(bc, "\\") == 0) && ((self->pos + 1) < self->length))) {
                    const char * next_c = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
                    if (is_escape_char_in_backtick(next_c)) {
                        Lexer_advance(self);
                    }
                }
                Lexer_advance(self);
            }
            if (Lexer_at_end(self)) {
                self->dolbrace_state = saved_dolbrace;
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated backtick");
                return (Tuple_NodePtr_constcharPtr){NULL, NULL};
            }
            Lexer_advance(self);
            op = "`";
        } else if ((((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "$") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "{") == 0))) {
            op = "";
        } else if ((!(Lexer_at_end(self)) && ((strcmp(Lexer_peek(self), "'") == 0) || (strcmp(Lexer_peek(self), "\"") == 0)))) {
            op = "";
        } else if ((!(Lexer_at_end(self)) && (strcmp(Lexer_peek(self), "\\") == 0))) {
            op = Lexer_advance(self);
            if (!(Lexer_at_end(self))) {
                op = _str_concat(g_arena, op, Lexer_advance(self));
            }
        } else {
            op = Lexer_advance(self);
        }
    }
    Lexer_update_dolbrace_for_op(self, op, (_rune_len(param) > 0));
    // try {
    int64_t flags = (in_dquote ? MATCHEDPAIRFLAGS_DQUOTE : MATCHEDPAIRFLAGS_NONE);
    bool param_ends_with_dollar = ((strcmp(param, "") != 0) && _str_endswith(param, "$"));
    arg = Lexer_collect_param_argument(self, flags, param_ends_with_dollar);
    // } catch handled via error returns
    if (((((strcmp(op, "<") == 0) || (strcmp(op, ">") == 0)) && _str_startswith(arg, "(")) && _str_endswith(arg, ")"))) {
        const char * inner = _substring(g_arena, arg, 1, (_rune_len(arg) - 1));
        // try {
        Parser * sub_parser = new_parser(inner, true, self->parser->extglob);
        Node * parsed = (Node *)Parser_parse_list(sub_parser, true);
        if (((parsed != NULL) && Parser_at_end(sub_parser))) {
            const char * formatted = format_cmdsub_node((Node *)parsed, 0, true, false, true);
            arg = _str_concat(g_arena, _str_concat(g_arena, "(", formatted), ")");
        }
        // } catch handled via error returns
    }
    text = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "${", param), op), arg), "}");
    self->dolbrace_state = saved_dolbrace;
    return (Tuple_NodePtr_constcharPtr){(Node *)ParamExpansion_new(param, op, arg, "param"), text};
}

static Tuple_NodePtr_constcharPtr Lexer_read_funsub(Lexer *self, int64_t start) {
    return Parser_parse_funsub(self->parser, start);
}

static const char * Word_to_sexp(Word *self) {
    const char * value = self->value;
    value = Word_expand_all_ansi_c_quotes(self, value);
    value = Word_strip_locale_string_dollars(self, value);
    value = Word_normalize_array_whitespace(self, value);
    value = Word_format_command_substitutions(self, value, false);
    value = Word_normalize_param_expansion_newlines(self, value);
    value = Word_strip_arith_line_continuations(self, value);
    value = Word_double_ctlesc_smart(self, value);
    value = _str_replace(g_arena, value, "\x7f", "\x01\x7f");
    value = _str_replace(g_arena, value, "\\", "\\\\");
    if ((_str_endswith(value, "\\\\") && !(_str_endswith(value, "\\\\\\\\")))) {
        value = _str_concat(g_arena, value, "\\\\");
    }
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, value, "\"", "\\\""), "\n", "\\n"), "\t", "\\t");
    return _str_concat(g_arena, _str_concat(g_arena, "(word \"", escaped), "\")");
}

static void Word_append_with_ctlesc(Word *self, Vec_Byte * result, int64_t byte_val) {
    VEC_PUSH(g_arena, result, ((uint8_t)(byte_val)));
}

static const char * Word_double_ctlesc_smart(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    QuoteState * quote = new_quote_state();
    for (int _idx = 0; _idx < _rune_len(value); _idx++) {
        int32_t c = _rune_at(value, _idx);
        if (((c == '\'') && !(quote->double_))) {
            quote->single = !(quote->single);
        } else if (((c == '"') && !(quote->single))) {
            quote->double_ = !(quote->double_);
        }
        VEC_PUSH(g_arena, &result, (_rune_to_str(g_arena, c)));
        if ((c == '\x01')) {
            if (quote->double_) {
                int64_t bs_count = 0;
                for (int64_t j = (result.len - 2); (j > -(1)); j += -(1)) {
                    if ((strcmp(result.data[j], "\\") == 0)) {
                        bs_count += 1;
                    } else {
                        break;
                    }
                }
                if (((bs_count % 2) == 0)) {
                    VEC_PUSH(g_arena, &result, ("\x01"));
                }
            } else {
                VEC_PUSH(g_arena, &result, ("\x01"));
            }
        }
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_normalize_param_expansion_newlines(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    QuoteState * quote = new_quote_state();
    while ((i < _rune_len(value))) {
        const char * c = (const char *)(_char_at_str(g_arena, value, i));
        if (((strcmp(c, "'") == 0) && !(quote->double_))) {
            quote->single = !(quote->single);
            VEC_PUSH(g_arena, &result, (c));
            i += 1;
        } else if (((strcmp(c, "\"") == 0) && !(quote->single))) {
            quote->double_ = !(quote->double_);
            VEC_PUSH(g_arena, &result, (c));
            i += 1;
        } else if ((is_expansion_start(value, i, "${") && !(quote->single))) {
            VEC_PUSH(g_arena, &result, ("$"));
            VEC_PUSH(g_arena, &result, ("{"));
            i += 2;
            bool had_leading_newline = ((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\n") == 0));
            if (had_leading_newline) {
                VEC_PUSH(g_arena, &result, (" "));
                i += 1;
            }
            int64_t depth = 1;
            while (((i < _rune_len(value)) && (depth > 0))) {
                const char * ch = (const char *)(_char_at_str(g_arena, value, i));
                if ((((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(value))) && !(quote->single))) {
                    if ((strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "\n") == 0)) {
                        i += 2;
                        continue;
                    }
                    VEC_PUSH(g_arena, &result, (ch));
                    VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, (i + 1)))));
                    i += 2;
                    continue;
                }
                if (((strcmp(ch, "'") == 0) && !(quote->double_))) {
                    quote->single = !(quote->single);
                } else if (((strcmp(ch, "\"") == 0) && !(quote->single))) {
                    quote->double_ = !(quote->double_);
                } else if (!(QuoteState_in_quotes(quote))) {
                    if ((strcmp(ch, "{") == 0)) {
                        depth += 1;
                    } else if ((strcmp(ch, "}") == 0)) {
                        depth -= 1;
                        if ((depth == 0)) {
                            if (had_leading_newline) {
                                VEC_PUSH(g_arena, &result, (" "));
                            }
                            VEC_PUSH(g_arena, &result, (ch));
                            i += 1;
                            break;
                        }
                    }
                }
                VEC_PUSH(g_arena, &result, (ch));
                i += 1;
            }
        } else {
            VEC_PUSH(g_arena, &result, (c));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_sh_single_quote(Word *self, const char * s) {
    if (!((s != NULL && s[0] != '\0'))) {
        return "''";
    }
    if ((strcmp(s, "'") == 0)) {
        return "\\'";
    }
    Vec_Str result = (Vec_Str){(const char *[]){ "'" }, 1, 1};
    for (int _idx = 0; _idx < _rune_len(s); _idx++) {
        int32_t c = _rune_at(s, _idx);
        if ((c == '\'')) {
            VEC_PUSH(g_arena, &result, ("'\\''"));
        } else {
            VEC_PUSH(g_arena, &result, (_rune_to_str(g_arena, c)));
        }
    }
    VEC_PUSH(g_arena, &result, ("'"));
    return _str_join(g_arena, "", result);
}

static Vec_Byte Word_ansi_c_to_bytes(Word *self, const char * inner) {
    Vec_Byte result = ((Vec_Byte){NULL, 0, 0});
    int64_t i = 0;
    while ((i < _rune_len(inner))) {
        int64_t j;
        int64_t byte_val;
        int64_t codepoint;
        if (((strcmp((const char *)(_char_at_str(g_arena, inner, i)), "\\") == 0) && ((i + 1) < _rune_len(inner)))) {
            const char * c = (const char *)(_char_at_str(g_arena, inner, (i + 1)));
            int64_t simple = get_ansi_escape(c);
            if ((simple >= 0)) {
                VEC_PUSH(g_arena, &result, ((uint8_t)(simple)));
                i += 2;
            } else if ((strcmp(c, "'") == 0)) {
                VEC_PUSH(g_arena, &result, ((uint8_t)(39)));
                i += 2;
            } else if ((strcmp(c, "x") == 0)) {
                if ((((i + 2) < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, (i + 2))), "{") == 0))) {
                    j = (i + 3);
                    while (((j < _rune_len(inner)) && is_hex_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                        j += 1;
                    }
                    const char * hex_str = substring(inner, (i + 3), j);
                    if (((j < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), "}") == 0))) {
                        j += 1;
                    }
                    if (!((hex_str != NULL && hex_str[0] != '\0'))) {
                        return result;
                    }
                    byte_val = (_parse_int(hex_str, 16) & 255);
                    if ((byte_val == 0)) {
                        return result;
                    }
                    Word_append_with_ctlesc(self, &(result), byte_val);
                    i = j;
                } else {
                    j = (i + 2);
                    while ((((j < _rune_len(inner)) && (j < (i + 4))) && is_hex_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                        j += 1;
                    }
                    if ((j > (i + 2))) {
                        byte_val = _parse_int(substring(inner, (i + 2), j), 16);
                        if ((byte_val == 0)) {
                            return result;
                        }
                        Word_append_with_ctlesc(self, &(result), byte_val);
                        i = j;
                    } else {
                        VEC_PUSH(g_arena, &result, ((uint8_t)((int64_t)((uint8_t)(const char *)(_char_at_str(g_arena, inner, i))[0]))));
                        i += 1;
                    }
                }
            } else if ((strcmp(c, "u") == 0)) {
                j = (i + 2);
                while ((((j < _rune_len(inner)) && (j < (i + 6))) && is_hex_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                    j += 1;
                }
                if ((j > (i + 2))) {
                    codepoint = _parse_int(substring(inner, (i + 2), j), 16);
                    if ((codepoint == 0)) {
                        return result;
                    }
                    do { Vec_Byte _src = _str_to_bytes(g_arena, (const char *)((int32_t)(codepoint))); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
                    i = j;
                } else {
                    VEC_PUSH(g_arena, &result, ((uint8_t)((int64_t)((uint8_t)(const char *)(_char_at_str(g_arena, inner, i))[0]))));
                    i += 1;
                }
            } else if ((strcmp(c, "U") == 0)) {
                j = (i + 2);
                while ((((j < _rune_len(inner)) && (j < (i + 10))) && is_hex_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                    j += 1;
                }
                if ((j > (i + 2))) {
                    codepoint = _parse_int(substring(inner, (i + 2), j), 16);
                    if ((codepoint == 0)) {
                        return result;
                    }
                    do { Vec_Byte _src = _str_to_bytes(g_arena, (const char *)((int32_t)(codepoint))); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
                    i = j;
                } else {
                    VEC_PUSH(g_arena, &result, ((uint8_t)((int64_t)((uint8_t)(const char *)(_char_at_str(g_arena, inner, i))[0]))));
                    i += 1;
                }
            } else if ((strcmp(c, "c") == 0)) {
                if (((i + 3) <= _rune_len(inner))) {
                    const char * ctrl_char = (const char *)(_char_at_str(g_arena, inner, (i + 2)));
                    int64_t skip_extra = 0;
                    if ((((strcmp(ctrl_char, "\\") == 0) && ((i + 4) <= _rune_len(inner))) && (strcmp((const char *)(_char_at_str(g_arena, inner, (i + 3))), "\\") == 0))) {
                        skip_extra = 1;
                    }
                    int64_t ctrl_val = ((int64_t)((uint8_t)ctrl_char[0]) & 31);
                    if ((ctrl_val == 0)) {
                        return result;
                    }
                    Word_append_with_ctlesc(self, &(result), ctrl_val);
                    i += (3 + skip_extra);
                } else {
                    VEC_PUSH(g_arena, &result, ((uint8_t)((int64_t)((uint8_t)(const char *)(_char_at_str(g_arena, inner, i))[0]))));
                    i += 1;
                }
            } else if ((strcmp(c, "0") == 0)) {
                j = (i + 2);
                while ((((j < _rune_len(inner)) && (j < (i + 4))) && is_octal_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                    j += 1;
                }
                if ((j > (i + 2))) {
                    byte_val = (_parse_int(substring(inner, (i + 1), j), 8) & 255);
                    if ((byte_val == 0)) {
                        return result;
                    }
                    Word_append_with_ctlesc(self, &(result), byte_val);
                    i = j;
                } else {
                    return result;
                }
            } else if (((c[0] >= '1') && (c[0] <= '7'))) {
                j = (i + 1);
                while ((((j < _rune_len(inner)) && (j < (i + 4))) && is_octal_digit((const char *)(_char_at_str(g_arena, inner, j))))) {
                    j += 1;
                }
                byte_val = (_parse_int(substring(inner, (i + 1), j), 8) & 255);
                if ((byte_val == 0)) {
                    return result;
                }
                Word_append_with_ctlesc(self, &(result), byte_val);
                i = j;
            } else {
                VEC_PUSH(g_arena, &result, ((uint8_t)(92)));
                VEC_PUSH(g_arena, &result, ((uint8_t)((int64_t)((uint8_t)c[0]))));
                i += 2;
            }
        } else {
            do { Vec_Byte _src = _str_to_bytes(g_arena, (const char *)(_char_at_str(g_arena, inner, i))); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
            i += 1;
        }
    }
    return result;
}

static const char * Word_expand_ansi_c_escapes(Word *self, const char * value) {
    if (!((_str_startswith(value, "'") && _str_endswith(value, "'")))) {
        return value;
    }
    const char * inner = substring(value, 1, (_rune_len(value) - 1));
    Vec_Byte literal_bytes = Word_ansi_c_to_bytes(self, inner);
    const char * literal_str = ((const char *)(literal_bytes.data));
    return Word_sh_single_quote(self, literal_str);
}

static const char * Word_expand_all_ansi_c_quotes(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    QuoteState * quote = new_quote_state();
    bool in_backtick = false;
    int64_t brace_depth = 0;
    while ((i < _rune_len(value))) {
        const char * ch = (const char *)(_char_at_str(g_arena, value, i));
        if (((strcmp(ch, "`") == 0) && !(quote->single))) {
            in_backtick = !(in_backtick);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
            continue;
        }
        if (in_backtick) {
            if (((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(value)))) {
                VEC_PUSH(g_arena, &result, (ch));
                VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, (i + 1)))));
                i += 2;
            } else {
                VEC_PUSH(g_arena, &result, (ch));
                i += 1;
            }
            continue;
        }
        if (!(quote->single)) {
            if (is_expansion_start(value, i, "${")) {
                brace_depth += 1;
                QuoteState_push(quote);
                VEC_PUSH(g_arena, &result, ("${"));
                i += 2;
                continue;
            } else if ((((strcmp(ch, "}") == 0) && (brace_depth > 0)) && !(quote->double_))) {
                brace_depth -= 1;
                VEC_PUSH(g_arena, &result, (ch));
                QuoteState_pop(quote);
                i += 1;
                continue;
            }
        }
        bool effective_in_dquote = quote->double_;
        if (((strcmp(ch, "'") == 0) && !(effective_in_dquote))) {
            bool is_ansi_c = (((!(quote->single) && (i > 0)) && (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "$") == 0)) && ((count_consecutive_dollars_before(value, (i - 1)) % 2) == 0));
            if (!(is_ansi_c)) {
                quote->single = !(quote->single);
            }
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if (((strcmp(ch, "\"") == 0) && !(quote->single))) {
            quote->double_ = !(quote->double_);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if ((((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(value))) && !(quote->single))) {
            VEC_PUSH(g_arena, &result, (ch));
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, (i + 1)))));
            i += 2;
        } else if ((((starts_with_at(value, i, "$'") && !(quote->single)) && !(effective_in_dquote)) && ((count_consecutive_dollars_before(value, i) % 2) == 0))) {
            int64_t j = (i + 2);
            while ((j < _rune_len(value))) {
                if (((strcmp((const char *)(_char_at_str(g_arena, value, j)), "\\") == 0) && ((j + 1) < _rune_len(value)))) {
                    j += 2;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, value, j)), "'") == 0)) {
                    j += 1;
                    break;
                } else {
                    j += 1;
                }
            }
            const char * ansi_str = substring(value, i, j);
            const char * expanded = Word_expand_ansi_c_escapes(self, substring(ansi_str, 1, _rune_len(ansi_str)));
            bool outer_in_dquote = QuoteState_outer_double(quote);
            if (((((brace_depth > 0) && outer_in_dquote) && _str_startswith(expanded, "'")) && _str_endswith(expanded, "'"))) {
                const char * inner = substring(expanded, 1, (_rune_len(expanded) - 1));
                if ((_str_find(inner, "\x01") == -(1))) {
                    const char * result_str = _str_join(g_arena, "", result);
                    bool in_pattern = false;
                    int64_t last_brace_idx = _str_rfind(result_str, "${");
                    if ((last_brace_idx >= 0)) {
                        const char * after_brace = _substring(g_arena, result_str, (last_brace_idx + 2), _rune_len(result_str));
                        int64_t var_name_len = 0;
                        if ((after_brace != NULL && after_brace[0] != '\0')) {
                            if (_str_contains("@*#?-$!0123456789_", (const char *)(_char_at_str(g_arena, after_brace, 0)))) {
                                var_name_len = 1;
                            } else if ((_str_is_alpha((const char *)(_char_at_str(g_arena, after_brace, 0))) || (strcmp((const char *)(_char_at_str(g_arena, after_brace, 0)), "_") == 0))) {
                                while ((var_name_len < _rune_len(after_brace))) {
                                    const char * c = (const char *)(_char_at_str(g_arena, after_brace, var_name_len));
                                    if (!((_str_is_alnum(c) || (strcmp(c, "_") == 0)))) {
                                        break;
                                    }
                                    var_name_len += 1;
                                }
                            }
                        }
                        if ((((var_name_len > 0) && (var_name_len < _rune_len(after_brace))) && !_str_contains("#?-", (const char *)(_char_at_str(g_arena, after_brace, 0))))) {
                            const char * op_start = _substring(g_arena, after_brace, var_name_len, _rune_len(after_brace));
                            if ((_str_startswith(op_start, "@") && (_rune_len(op_start) > 1))) {
                                op_start = _substring(g_arena, op_start, 1, _rune_len(op_start));
                            }
                            for (size_t _idx = 0; _idx < (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.len; _idx++) {
                                const char * op = (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.data[_idx];
                                if (_str_startswith(op_start, op)) {
                                    in_pattern = true;
                                    break;
                                }
                            }
                            if (((!(in_pattern) && (op_start != NULL && op_start[0] != '\0')) && !_str_contains("%#/^,~:+-=?", (const char *)(_char_at_str(g_arena, op_start, 0))))) {
                                for (size_t _idx = 0; _idx < (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.len; _idx++) {
                                    const char * op = (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.data[_idx];
                                    if (_str_contains(op_start, op)) {
                                        in_pattern = true;
                                        break;
                                    }
                                }
                            }
                        } else if (((var_name_len == 0) && (_rune_len(after_brace) > 1))) {
                            const char * first_char = (const char *)(_char_at_str(g_arena, after_brace, 0));
                            if (!_str_contains("%#/^,", first_char)) {
                                const char * rest = _substring(g_arena, after_brace, 1, _rune_len(after_brace));
                                for (size_t _idx = 0; _idx < (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.len; _idx++) {
                                    const char * op = (Vec_Str){(const char *[]){ "//", "%%", "##", "/", "%", "#", "^", "^^", ",", ",," }, 10, 10}.data[_idx];
                                    if (_str_contains(rest, op)) {
                                        in_pattern = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (!(in_pattern)) {
                        expanded = inner;
                    }
                }
            }
            VEC_PUSH(g_arena, &result, (expanded));
            i = j;
        } else {
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_strip_locale_string_dollars(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    int64_t brace_depth = 0;
    int64_t bracket_depth = 0;
    QuoteState * quote = new_quote_state();
    QuoteState * brace_quote = new_quote_state();
    bool bracket_in_double_quote = false;
    while ((i < _rune_len(value))) {
        const char * ch = (const char *)(_char_at_str(g_arena, value, i));
        if (((((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(value))) && !(quote->single)) && !(brace_quote->single))) {
            VEC_PUSH(g_arena, &result, (ch));
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, (i + 1)))));
            i += 2;
        } else if ((((starts_with_at(value, i, "${") && !(quote->single)) && !(brace_quote->single)) && ((i == 0) || (strcmp((const char *)(_char_at_str(g_arena, value, (i - 1))), "$") != 0)))) {
            brace_depth += 1;
            brace_quote->double_ = false;
            brace_quote->single = false;
            VEC_PUSH(g_arena, &result, ("$"));
            VEC_PUSH(g_arena, &result, ("{"));
            i += 2;
        } else if ((((((strcmp(ch, "}") == 0) && (brace_depth > 0)) && !(quote->single)) && !(brace_quote->double_)) && !(brace_quote->single))) {
            brace_depth -= 1;
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if (((((strcmp(ch, "[") == 0) && (brace_depth > 0)) && !(quote->single)) && !(brace_quote->double_))) {
            bracket_depth += 1;
            bracket_in_double_quote = false;
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if (((((strcmp(ch, "]") == 0) && (bracket_depth > 0)) && !(quote->single)) && !(bracket_in_double_quote))) {
            bracket_depth -= 1;
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if ((((strcmp(ch, "'") == 0) && !(quote->double_)) && (brace_depth == 0))) {
            quote->single = !(quote->single);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if ((((strcmp(ch, "\"") == 0) && !(quote->single)) && (brace_depth == 0))) {
            quote->double_ = !(quote->double_);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if ((((strcmp(ch, "\"") == 0) && !(quote->single)) && (bracket_depth > 0))) {
            bracket_in_double_quote = !(bracket_in_double_quote);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if (((((strcmp(ch, "\"") == 0) && !(quote->single)) && !(brace_quote->single)) && (brace_depth > 0))) {
            brace_quote->double_ = !(brace_quote->double_);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if (((((strcmp(ch, "'") == 0) && !(quote->double_)) && !(brace_quote->double_)) && (brace_depth > 0))) {
            brace_quote->single = !(brace_quote->single);
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        } else if ((((((starts_with_at(value, i, "$\"") && !(quote->single)) && !(brace_quote->single)) && (((brace_depth > 0) || (bracket_depth > 0)) || !(quote->double_))) && !(brace_quote->double_)) && !(bracket_in_double_quote))) {
            int64_t dollar_count = (1 + count_consecutive_dollars_before(value, i));
            if (((dollar_count % 2) == 1)) {
                VEC_PUSH(g_arena, &result, ("\""));
                if ((bracket_depth > 0)) {
                    bracket_in_double_quote = true;
                } else if ((brace_depth > 0)) {
                    brace_quote->double_ = true;
                } else {
                    quote->double_ = true;
                }
                i += 2;
            } else {
                VEC_PUSH(g_arena, &result, (ch));
                i += 1;
            }
        } else {
            VEC_PUSH(g_arena, &result, (ch));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_normalize_array_whitespace(Word *self, const char * value) {
    int64_t i = 0;
    if (!(((i < _rune_len(value)) && (_str_is_alpha((const char *)(_char_at_str(g_arena, value, i))) || (strcmp((const char *)(_char_at_str(g_arena, value, i)), "_") == 0))))) {
        return value;
    }
    i += 1;
    while (((i < _rune_len(value)) && (_str_is_alnum((const char *)(_char_at_str(g_arena, value, i))) || (strcmp((const char *)(_char_at_str(g_arena, value, i)), "_") == 0)))) {
        i += 1;
    }
    while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "[") == 0))) {
        int64_t depth = 1;
        i += 1;
        while (((i < _rune_len(value)) && (depth > 0))) {
            if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "[") == 0)) {
                depth += 1;
            } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "]") == 0)) {
                depth -= 1;
            }
            i += 1;
        }
        if ((depth != 0)) {
            return value;
        }
    }
    if (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "+") == 0))) {
        i += 1;
    }
    if (!(((((i + 1) < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "=") == 0)) && (strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "(") == 0)))) {
        return value;
    }
    const char * prefix = substring(value, 0, (i + 1));
    int64_t open_paren_pos = (i + 1);
    int64_t close_paren_pos;
    if (_str_endswith(value, ")")) {
        close_paren_pos = (_rune_len(value) - 1);
    } else {
        close_paren_pos = Word_find_matching_paren(self, value, open_paren_pos);
        if ((close_paren_pos < 0)) {
            return value;
        }
    }
    const char * inner = substring(value, (open_paren_pos + 1), close_paren_pos);
    const char * suffix = substring(value, (close_paren_pos + 1), _rune_len(value));
    const char * result = Word_normalize_array_inner(self, inner);
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, prefix, "("), result), ")"), suffix);
}

static int64_t Word_find_matching_paren(Word *self, const char * value, int64_t open_pos) {
    if (((open_pos >= _rune_len(value)) || (strcmp((const char *)(_char_at_str(g_arena, value, open_pos)), "(") != 0))) {
        return -(1);
    }
    int64_t i = (open_pos + 1);
    int64_t depth = 1;
    QuoteState * quote = new_quote_state();
    while (((i < _rune_len(value)) && (depth > 0))) {
        const char * ch = (const char *)(_char_at_str(g_arena, value, i));
        if ((((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(value))) && !(quote->single))) {
            i += 2;
            continue;
        }
        if (((strcmp(ch, "'") == 0) && !(quote->double_))) {
            quote->single = !(quote->single);
            i += 1;
            continue;
        }
        if (((strcmp(ch, "\"") == 0) && !(quote->single))) {
            quote->double_ = !(quote->double_);
            i += 1;
            continue;
        }
        if ((quote->single || quote->double_)) {
            i += 1;
            continue;
        }
        if ((strcmp(ch, "#") == 0)) {
            while (((i < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "\n") != 0))) {
                i += 1;
            }
            continue;
        }
        if ((strcmp(ch, "(") == 0)) {
            depth += 1;
        } else if ((strcmp(ch, ")") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                return i;
            }
        }
        i += 1;
    }
    return -(1);
}

static const char * Word_normalize_array_inner(Word *self, const char * inner) {
    Vec_Str normalized = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    bool in_whitespace = true;
    int64_t brace_depth = 0;
    int64_t bracket_depth = 0;
    while ((i < _rune_len(inner))) {
        const char * ch = (const char *)(_char_at_str(g_arena, inner, i));
        int64_t j;
        int64_t depth;
        if (is_whitespace(ch)) {
            if ((((!(in_whitespace) && (normalized.len > 0)) && (brace_depth == 0)) && (bracket_depth == 0))) {
                VEC_PUSH(g_arena, &normalized, (" "));
                in_whitespace = true;
            }
            if (((brace_depth > 0) || (bracket_depth > 0))) {
                VEC_PUSH(g_arena, &normalized, (ch));
            }
            i += 1;
        } else if ((strcmp(ch, "'") == 0)) {
            in_whitespace = false;
            j = (i + 1);
            while (((j < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), "'") != 0))) {
                j += 1;
            }
            VEC_PUSH(g_arena, &normalized, (substring(inner, i, (j + 1))));
            i = (j + 1);
        } else if ((strcmp(ch, "\"") == 0)) {
            in_whitespace = false;
            j = (i + 1);
            Vec_Str dq_content = (Vec_Str){(const char *[]){ "\"" }, 1, 1};
            int64_t dq_brace_depth = 0;
            while ((j < _rune_len(inner))) {
                if (((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\\") == 0) && ((j + 1) < _rune_len(inner)))) {
                    if ((strcmp((const char *)(_char_at_str(g_arena, inner, (j + 1))), "\n") == 0)) {
                        j += 2;
                    } else {
                        VEC_PUSH(g_arena, &dq_content, ((const char *)(_char_at_str(g_arena, inner, j))));
                        VEC_PUSH(g_arena, &dq_content, ((const char *)(_char_at_str(g_arena, inner, (j + 1)))));
                        j += 2;
                    }
                } else if (is_expansion_start(inner, j, "${")) {
                    VEC_PUSH(g_arena, &dq_content, ("${"));
                    dq_brace_depth += 1;
                    j += 2;
                } else if (((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "}") == 0) && (dq_brace_depth > 0))) {
                    VEC_PUSH(g_arena, &dq_content, ("}"));
                    dq_brace_depth -= 1;
                    j += 1;
                } else if (((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\"") == 0) && (dq_brace_depth == 0))) {
                    VEC_PUSH(g_arena, &dq_content, ("\""));
                    j += 1;
                    break;
                } else {
                    VEC_PUSH(g_arena, &dq_content, ((const char *)(_char_at_str(g_arena, inner, j))));
                    j += 1;
                }
            }
            VEC_PUSH(g_arena, &normalized, (_str_join(g_arena, "", dq_content)));
            i = j;
        } else if (((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(inner)))) {
            if ((strcmp((const char *)(_char_at_str(g_arena, inner, (i + 1))), "\n") == 0)) {
                i += 2;
            } else {
                in_whitespace = false;
                VEC_PUSH(g_arena, &normalized, (substring(inner, i, (i + 2))));
                i += 2;
            }
        } else if (is_expansion_start(inner, i, "$((")) {
            in_whitespace = false;
            j = (i + 3);
            depth = 1;
            while (((j < _rune_len(inner)) && (depth > 0))) {
                if (((((j + 1) < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), "(") == 0)) && (strcmp((const char *)(_char_at_str(g_arena, inner, (j + 1))), "(") == 0))) {
                    depth += 1;
                    j += 2;
                } else if (((((j + 1) < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), ")") == 0)) && (strcmp((const char *)(_char_at_str(g_arena, inner, (j + 1))), ")") == 0))) {
                    depth -= 1;
                    j += 2;
                } else {
                    j += 1;
                }
            }
            VEC_PUSH(g_arena, &normalized, (substring(inner, i, j)));
            i = j;
        } else if (is_expansion_start(inner, i, "$(")) {
            in_whitespace = false;
            j = (i + 2);
            depth = 1;
            while (((j < _rune_len(inner)) && (depth > 0))) {
                if ((((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "(") == 0) && (j > 0)) && (strcmp((const char *)(_char_at_str(g_arena, inner, (j - 1))), "$") == 0))) {
                    depth += 1;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), ")") == 0)) {
                    depth -= 1;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "'") == 0)) {
                    j += 1;
                    while (((j < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), "'") != 0))) {
                        j += 1;
                    }
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\"") == 0)) {
                    j += 1;
                    while ((j < _rune_len(inner))) {
                        if (((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\\") == 0) && ((j + 1) < _rune_len(inner)))) {
                            j += 2;
                            continue;
                        }
                        if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\"") == 0)) {
                            break;
                        }
                        j += 1;
                    }
                }
                j += 1;
            }
            VEC_PUSH(g_arena, &normalized, (substring(inner, i, j)));
            i = j;
        } else if (((((strcmp(ch, "<") == 0) || (strcmp(ch, ">") == 0)) && ((i + 1) < _rune_len(inner))) && (strcmp((const char *)(_char_at_str(g_arena, inner, (i + 1))), "(") == 0))) {
            in_whitespace = false;
            j = (i + 2);
            depth = 1;
            while (((j < _rune_len(inner)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "(") == 0)) {
                    depth += 1;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), ")") == 0)) {
                    depth -= 1;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "'") == 0)) {
                    j += 1;
                    while (((j < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, j)), "'") != 0))) {
                        j += 1;
                    }
                } else if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\"") == 0)) {
                    j += 1;
                    while ((j < _rune_len(inner))) {
                        if (((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\\") == 0) && ((j + 1) < _rune_len(inner)))) {
                            j += 2;
                            continue;
                        }
                        if ((strcmp((const char *)(_char_at_str(g_arena, inner, j)), "\"") == 0)) {
                            break;
                        }
                        j += 1;
                    }
                }
                j += 1;
            }
            VEC_PUSH(g_arena, &normalized, (substring(inner, i, j)));
            i = j;
        } else if (is_expansion_start(inner, i, "${")) {
            in_whitespace = false;
            VEC_PUSH(g_arena, &normalized, ("${"));
            brace_depth += 1;
            i += 2;
        } else if (((strcmp(ch, "{") == 0) && (brace_depth > 0))) {
            VEC_PUSH(g_arena, &normalized, (ch));
            brace_depth += 1;
            i += 1;
        } else if (((strcmp(ch, "}") == 0) && (brace_depth > 0))) {
            VEC_PUSH(g_arena, &normalized, (ch));
            brace_depth -= 1;
            i += 1;
        } else if ((((strcmp(ch, "#") == 0) && (brace_depth == 0)) && in_whitespace)) {
            while (((i < _rune_len(inner)) && (strcmp((const char *)(_char_at_str(g_arena, inner, i)), "\n") != 0))) {
                i += 1;
            }
        } else if ((strcmp(ch, "[") == 0)) {
            if ((in_whitespace || (bracket_depth > 0))) {
                bracket_depth += 1;
            }
            in_whitespace = false;
            VEC_PUSH(g_arena, &normalized, (ch));
            i += 1;
        } else if (((strcmp(ch, "]") == 0) && (bracket_depth > 0))) {
            VEC_PUSH(g_arena, &normalized, (ch));
            bracket_depth -= 1;
            i += 1;
        } else {
            in_whitespace = false;
            VEC_PUSH(g_arena, &normalized, (ch));
            i += 1;
        }
    }
    return _str_rtrim(g_arena, _str_join(g_arena, "", normalized), " \t\n\r");
}

static const char * Word_strip_arith_line_continuations(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    while ((i < _rune_len(value))) {
        if (is_expansion_start(value, i, "$((")) {
            int64_t start = i;
            i += 3;
            int64_t depth = 2;
            Vec_Str arith_content = (Vec_Str){NULL, 0, 0};
            int64_t first_close_idx = -(1);
            while (((i < _rune_len(value)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "(") == 0)) {
                    VEC_PUSH(g_arena, &arith_content, ("("));
                    depth += 1;
                    i += 1;
                    if ((depth > 1)) {
                        Any * first_close_idx = -(1);
                    }
                } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), ")") == 0)) {
                    if ((depth == 2)) {
                        first_close_idx = arith_content.len;
                    }
                    depth -= 1;
                    if ((depth > 0)) {
                        VEC_PUSH(g_arena, &arith_content, (")"));
                    }
                    i += 1;
                } else if ((((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\\") == 0) && ((i + 1) < _rune_len(value))) && (strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "\n") == 0))) {
                    int64_t num_backslashes = 0;
                    int64_t j = (arith_content.len - 1);
                    while (((j >= 0) && (strcmp(arith_content.data[j], "\n") == 0))) {
                        j -= 1;
                    }
                    while (((j >= 0) && (strcmp(arith_content.data[j], "\\") == 0))) {
                        num_backslashes += 1;
                        j -= 1;
                    }
                    if (((num_backslashes % 2) == 1)) {
                        VEC_PUSH(g_arena, &arith_content, ("\\"));
                        VEC_PUSH(g_arena, &arith_content, ("\n"));
                        i += 2;
                    } else {
                        i += 2;
                    }
                    if ((depth == 1)) {
                        first_close_idx = -(1);
                    }
                } else {
                    VEC_PUSH(g_arena, &arith_content, ((const char *)(_char_at_str(g_arena, value, i))));
                    i += 1;
                    if ((depth == 1)) {
                        first_close_idx = -(1);
                    }
                }
            }
            if (((depth == 0) || ((depth == 1) && (first_close_idx != -(1))))) {
                const char * content = _str_join(g_arena, "", arith_content);
                if ((first_close_idx != -(1))) {
                    content = _substring(g_arena, content, 0, first_close_idx);
                    const char * closing = ((depth == 0) ? "))" : ")");
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, "$((", content), closing)));
                } else {
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, "$((", content), ")")));
                }
            } else {
                VEC_PUSH(g_arena, &result, (substring(value, start, i)));
            }
        } else {
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static Vec_Node Word_collect_cmdsubs(Word *self, Node * node) {
    Vec_Node result = (Vec_Node){NULL, 0, 0};
    void *_data48 = node->data;
    switch (node->kind) {
    case KIND_COMMANDSUBSTITUTION: {
        CommandSubstitution *node = (CommandSubstitution *)_data48;
        VEC_PUSH(g_arena, &result, (node));
        break;
    }
    case KIND_ARRAY: {
        Array *node = (Array *)_data48;
        for (size_t _idx = 0; _idx < node->elements.len; _idx++) {
            Word * elem = node->elements.data[_idx];
            for (size_t _idx = 0; _idx < elem->parts.len; _idx++) {
                Node * p = elem->parts.data[_idx];
                void *_data49 = p->data;
                switch (p->kind) {
                case KIND_COMMANDSUBSTITUTION: {
                    CommandSubstitution *p = (CommandSubstitution *)_data49;
                    VEC_PUSH(g_arena, &result, (p));
                    break;
                }
                default: {
                    do { Vec_Node _src = Word_collect_cmdsubs(self, p); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
                }
                }
            }
        }
        break;
    }
    case KIND_ARITHMETICEXPANSION: {
        ArithmeticExpansion *node = (ArithmeticExpansion *)_data48;
        if ((node->expression != NULL)) {
            do { Vec_Node _src = Word_collect_cmdsubs(self, node->expression); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        }
        break;
    }
    case KIND_ARITHBINARYOP: {
        ArithBinaryOp *node = (ArithBinaryOp *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->left); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->right); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHCOMMA: {
        ArithComma *node = (ArithComma *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->left); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->right); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHUNARYOP: {
        ArithUnaryOp *node = (ArithUnaryOp *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->operand); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHPREINCR: {
        ArithPreIncr *node = (ArithPreIncr *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->operand); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHPOSTINCR: {
        ArithPostIncr *node = (ArithPostIncr *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->operand); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHPREDECR: {
        ArithPreDecr *node = (ArithPreDecr *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->operand); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHPOSTDECR: {
        ArithPostDecr *node = (ArithPostDecr *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->operand); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHTERNARY: {
        ArithTernary *node = (ArithTernary *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->condition); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->if_true); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->if_false); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    case KIND_ARITHASSIGN: {
        ArithAssign *node = (ArithAssign *)_data48;
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->target); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        do { Vec_Node _src = Word_collect_cmdsubs(self, node->value); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
        break;
    }
    }
    return result;
}

static Vec_Node Word_collect_procsubs(Word *self, Node * node) {
    Vec_Node result = (Vec_Node){NULL, 0, 0};
    void *_data50 = node->data;
    switch (node->kind) {
    case KIND_PROCESSSUBSTITUTION: {
        ProcessSubstitution *node = (ProcessSubstitution *)_data50;
        VEC_PUSH(g_arena, &result, (node));
        break;
    }
    case KIND_ARRAY: {
        Array *node = (Array *)_data50;
        for (size_t _idx = 0; _idx < node->elements.len; _idx++) {
            Word * elem = node->elements.data[_idx];
            for (size_t _idx = 0; _idx < elem->parts.len; _idx++) {
                Node * p = elem->parts.data[_idx];
                void *_data51 = p->data;
                switch (p->kind) {
                case KIND_PROCESSSUBSTITUTION: {
                    ProcessSubstitution *p = (ProcessSubstitution *)_data51;
                    VEC_PUSH(g_arena, &result, (p));
                    break;
                }
                default: {
                    do { Vec_Node _src = Word_collect_procsubs(self, p); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &result, _src.data[_i]); } } while(0);
                }
                }
            }
        }
        break;
    }
    }
    return result;
}

static const char * Word_format_command_substitutions(Word *self, const char * value, bool in_arith) {
    Vec_Node cmdsub_parts = (Vec_Node){NULL, 0, 0};
    Vec_Node procsub_parts = (Vec_Node){NULL, 0, 0};
    bool has_arith = false;
    for (size_t _idx = 0; _idx < self->parts.len; _idx++) {
        Node * p = self->parts.data[_idx];
        void *_data52 = p->data;
        switch (p->kind) {
        case KIND_COMMANDSUBSTITUTION: {
            CommandSubstitution *p = (CommandSubstitution *)_data52;
            VEC_PUSH(g_arena, &cmdsub_parts, (p));
            break;
        }
        case KIND_PROCESSSUBSTITUTION: {
            ProcessSubstitution *p = (ProcessSubstitution *)_data52;
            VEC_PUSH(g_arena, &procsub_parts, (p));
            break;
        }
        case KIND_ARITHMETICEXPANSION: {
            ArithmeticExpansion *p = (ArithmeticExpansion *)_data52;
            has_arith = true;
            break;
        }
        default: {
            do { Vec_Node _src = Word_collect_cmdsubs(self, p); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &cmdsub_parts, _src.data[_i]); } } while(0);
            do { Vec_Node _src = Word_collect_procsubs(self, p); for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &procsub_parts, _src.data[_i]); } } while(0);
        }
        }
    }
    bool has_brace_cmdsub = ((((_str_find(value, "${ ") != -(1)) || (_str_find(value, "${\t") != -(1))) || (_str_find(value, "${\n") != -(1))) || (_str_find(value, "${|") != -(1)));
    bool has_untracked_cmdsub = false;
    bool has_untracked_procsub = false;
    int64_t idx = 0;
    QuoteState * scan_quote = new_quote_state();
    while ((idx < _rune_len(value))) {
        if ((strcmp((const char *)(_char_at_str(g_arena, value, idx)), "\"") == 0)) {
            scan_quote->double_ = !(scan_quote->double_);
            idx += 1;
        } else if (((strcmp((const char *)(_char_at_str(g_arena, value, idx)), "'") == 0) && !(scan_quote->double_))) {
            idx += 1;
            while (((idx < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, idx)), "'") != 0))) {
                idx += 1;
            }
            if ((idx < _rune_len(value))) {
                idx += 1;
            }
        } else if ((((starts_with_at(value, idx, "$(") && !(starts_with_at(value, idx, "$(("))) && !(is_backslash_escaped(value, idx))) && !(is_dollar_dollar_paren(value, idx)))) {
            has_untracked_cmdsub = true;
            break;
        } else if (((starts_with_at(value, idx, "<(") || starts_with_at(value, idx, ">(")) && !(scan_quote->double_))) {
            if (((idx == 0) || (!(_str_is_alnum((const char *)(_char_at_str(g_arena, value, (idx - 1))))) && !_str_contains("\"'", (const char *)(_char_at_str(g_arena, value, (idx - 1))))))) {
                has_untracked_procsub = true;
                break;
            }
            idx += 1;
        } else {
            idx += 1;
        }
    }
    bool has_param_with_procsub_pattern = (_str_contains(value, "${") && (_str_contains(value, "<(") || _str_contains(value, ">(")));
    if ((((((!((cmdsub_parts.len > 0)) && !((procsub_parts.len > 0))) && !(has_brace_cmdsub)) && !(has_untracked_cmdsub)) && !(has_untracked_procsub)) && !(has_param_with_procsub_pattern))) {
        return value;
    }
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    int64_t cmdsub_idx = 0;
    int64_t procsub_idx = 0;
    QuoteState * main_quote = new_quote_state();
    int64_t extglob_depth = 0;
    int64_t deprecated_arith_depth = 0;
    int64_t arith_depth = 0;
    int64_t arith_paren_depth = 0;
    while ((i < _rune_len(value))) {
        if (((((i > 0) && is_extglob_prefix((const char *)(_char_at_str(g_arena, value, (i - 1))))) && (strcmp((const char *)(_char_at_str(g_arena, value, i)), "(") == 0)) && !(is_backslash_escaped(value, (i - 1))))) {
            extglob_depth += 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), ")") == 0) && (extglob_depth > 0))) {
            extglob_depth -= 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if ((starts_with_at(value, i, "$[") && !(is_backslash_escaped(value, i)))) {
            deprecated_arith_depth += 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "]") == 0) && (deprecated_arith_depth > 0))) {
            deprecated_arith_depth -= 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if (((is_expansion_start(value, i, "$((") && !(is_backslash_escaped(value, i))) && has_arith)) {
            arith_depth += 1;
            arith_paren_depth += 2;
            VEC_PUSH(g_arena, &result, ("$(("));
            i += 3;
            continue;
        }
        if ((((arith_depth > 0) && (arith_paren_depth == 2)) && starts_with_at(value, i, "))"))) {
            arith_depth -= 1;
            arith_paren_depth -= 2;
            VEC_PUSH(g_arena, &result, ("))"));
            i += 2;
            continue;
        }
        if ((arith_depth > 0)) {
            if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "(") == 0)) {
                arith_paren_depth += 1;
                VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
                i += 1;
                continue;
            } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), ")") == 0)) {
                arith_paren_depth -= 1;
                VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
                i += 1;
                continue;
            }
        }
        int64_t j;
        if ((is_expansion_start(value, i, "$((") && !(has_arith))) {
            j = find_cmdsub_end(value, (i + 2));
            VEC_PUSH(g_arena, &result, (substring(value, i, j)));
            if ((cmdsub_idx < cmdsub_parts.len)) {
                cmdsub_idx += 1;
            }
            i = j;
            continue;
        }
        const char * inner;
        Node * node;
        const char * formatted;
        Parser * parser;
        Node * parsed;
        const char * prefix;
        const char * suffix;
        const char * direction;
        bool compact;
        const char * stripped;
        int64_t depth;
        if ((((starts_with_at(value, i, "$(") && !(starts_with_at(value, i, "$(("))) && !(is_backslash_escaped(value, i))) && !(is_dollar_dollar_paren(value, i)))) {
            j = find_cmdsub_end(value, (i + 2));
            if ((extglob_depth > 0)) {
                VEC_PUSH(g_arena, &result, (substring(value, i, j)));
                if ((cmdsub_idx < cmdsub_parts.len)) {
                    cmdsub_idx += 1;
                }
                i = j;
                continue;
            }
            inner = substring(value, (i + 2), (j - 1));
            if ((cmdsub_idx < cmdsub_parts.len)) {
                node = (Node *)cmdsub_parts.data[cmdsub_idx];
                formatted = format_cmdsub_node((Node *)((CommandSubstitution *)(node->data))->command, 0, false, false, false);
                cmdsub_idx += 1;
            } else {
                // try {
                parser = new_parser(inner, false, false);
                parsed = (Node *)Parser_parse_list(parser, true);
                formatted = ((parsed != NULL) ? format_cmdsub_node((Node *)parsed, 0, false, false, false) : "");
                // } catch handled via error returns
            }
            if (_str_startswith(formatted, "(")) {
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, "$( ", formatted), ")")));
            } else {
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, "$(", formatted), ")")));
            }
            i = j;
        } else if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "`") == 0) && (cmdsub_idx < cmdsub_parts.len))) {
            j = (i + 1);
            while ((j < _rune_len(value))) {
                if (((strcmp((const char *)(_char_at_str(g_arena, value, j)), "\\") == 0) && ((j + 1) < _rune_len(value)))) {
                    j += 2;
                    continue;
                }
                if ((strcmp((const char *)(_char_at_str(g_arena, value, j)), "`") == 0)) {
                    j += 1;
                    break;
                }
                j += 1;
            }
            VEC_PUSH(g_arena, &result, (substring(value, i, j)));
            cmdsub_idx += 1;
            i = j;
        } else if ((((is_expansion_start(value, i, "${") && ((i + 2) < _rune_len(value))) && is_funsub_char((const char *)(_char_at_str(g_arena, value, (i + 2))))) && !(is_backslash_escaped(value, i)))) {
            j = find_funsub_end(value, (i + 2));
            Node * cmdsub_node = (Node *)((cmdsub_idx < cmdsub_parts.len) ? cmdsub_parts.data[cmdsub_idx] : NULL);
            if (((cmdsub_node->kind == KIND_COMMANDSUBSTITUTION) && ((CommandSubstitution *)(cmdsub_node))->brace)) {
                CommandSubstitution * node = (CommandSubstitution *)(cmdsub_node->data);
                formatted = format_cmdsub_node((Node *)((CommandSubstitution *)(node))->command, 0, false, false, false);
                bool has_pipe = (strcmp((const char *)(_char_at_str(g_arena, value, (i + 2))), "|") == 0);
                prefix = (has_pipe ? "${|" : "${ ");
                const char * orig_inner = substring(value, (i + 2), (j - 1));
                bool ends_with_newline = _str_endswith(orig_inner, "\n");
                if ((!((formatted != NULL && formatted[0] != '\0')) || _str_is_space(formatted))) {
                    suffix = "}";
                } else if ((_str_endswith(formatted, "&") || _str_endswith(formatted, "& "))) {
                    suffix = (_str_endswith(formatted, "&") ? " }" : "}");
                } else if (ends_with_newline) {
                    suffix = "\n }";
                } else {
                    suffix = "; }";
                }
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, prefix, formatted), suffix)));
                cmdsub_idx += 1;
            } else {
                VEC_PUSH(g_arena, &result, (substring(value, i, j)));
            }
            i = j;
        } else if (((((starts_with_at(value, i, ">(") || starts_with_at(value, i, "<(")) && !(main_quote->double_)) && (deprecated_arith_depth == 0)) && (arith_depth == 0))) {
            bool is_procsub = ((i == 0) || (!(_str_is_alnum((const char *)(_char_at_str(g_arena, value, (i - 1))))) && !_str_contains("\"'", (const char *)(_char_at_str(g_arena, value, (i - 1))))));
            if ((extglob_depth > 0)) {
                j = find_cmdsub_end(value, (i + 2));
                VEC_PUSH(g_arena, &result, (substring(value, i, j)));
                if ((procsub_idx < procsub_parts.len)) {
                    procsub_idx += 1;
                }
                i = j;
                continue;
            }
            if ((procsub_idx < procsub_parts.len)) {
                direction = (const char *)(_char_at_str(g_arena, value, i));
                j = find_cmdsub_end(value, (i + 2));
                Node * node = (Node *)procsub_parts.data[procsub_idx];
                compact = starts_with_subshell((Node *)((ProcessSubstitution *)(node->data))->command);
                formatted = format_cmdsub_node((Node *)((ProcessSubstitution *)(node->data))->command, 0, true, compact, true);
                const char * raw_content = substring(value, (i + 2), (j - 1));
                if ((strcmp(_kind_to_str(((ProcessSubstitution *)(node->data))->command->kind), "subshell") == 0)) {
                    int64_t leading_ws_end = 0;
                    while (((leading_ws_end < _rune_len(raw_content)) && _str_contains(" \t\n", (const char *)(_char_at_str(g_arena, raw_content, leading_ws_end))))) {
                        leading_ws_end += 1;
                    }
                    const char * leading_ws = _substring(g_arena, raw_content, 0, leading_ws_end);
                    stripped = _substring(g_arena, raw_content, leading_ws_end, _rune_len(raw_content));
                    if (_str_startswith(stripped, "(")) {
                        if ((leading_ws != NULL && leading_ws[0] != '\0')) {
                            const char * normalized_ws = _str_replace(g_arena, _str_replace(g_arena, leading_ws, "\n", " "), "\t", " ");
                            const char * spaced = format_cmdsub_node((Node *)((ProcessSubstitution *)(node->data))->command, 0, false, false, false);
                            VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), normalized_ws), spaced), ")")));
                        } else {
                            raw_content = _str_replace(g_arena, raw_content, "\\\n", "");
                            VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), raw_content), ")")));
                        }
                        procsub_idx += 1;
                        i = j;
                        continue;
                    }
                }
                raw_content = substring(value, (i + 2), (j - 1));
                const char * raw_stripped = _str_replace(g_arena, raw_content, "\\\n", "");
                if ((starts_with_subshell((Node *)((ProcessSubstitution *)(node->data))->command) && (strcmp(formatted, raw_stripped) != 0))) {
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), raw_stripped), ")")));
                } else {
                    const char * final_output = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), formatted), ")");
                    VEC_PUSH(g_arena, &result, (final_output));
                }
                procsub_idx += 1;
                i = j;
            } else if ((is_procsub && (self->parts.len != 0))) {
                direction = (const char *)(_char_at_str(g_arena, value, i));
                j = find_cmdsub_end(value, (i + 2));
                if (((j > _rune_len(value)) || (((j > 0) && (j <= _rune_len(value))) && (strcmp((const char *)(_char_at_str(g_arena, value, (j - 1))), ")") != 0)))) {
                    VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
                    i += 1;
                    continue;
                }
                inner = substring(value, (i + 2), (j - 1));
                // try {
                parser = new_parser(inner, false, false);
                parsed = (Node *)Parser_parse_list(parser, true);
                if ((((parsed != NULL) && (parser->pos == _rune_len(inner))) && !_str_contains(inner, "\n"))) {
                    compact = starts_with_subshell((Node *)parsed);
                    formatted = format_cmdsub_node((Node *)parsed, 0, true, compact, true);
                } else {
                    formatted = inner;
                }
                // } catch handled via error returns
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), formatted), ")")));
                i = j;
            } else if (is_procsub) {
                direction = (const char *)(_char_at_str(g_arena, value, i));
                j = find_cmdsub_end(value, (i + 2));
                if (((j > _rune_len(value)) || (((j > 0) && (j <= _rune_len(value))) && (strcmp((const char *)(_char_at_str(g_arena, value, (j - 1))), ")") != 0)))) {
                    VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
                    i += 1;
                    continue;
                }
                inner = substring(value, (i + 2), (j - 1));
                if (in_arith) {
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), inner), ")")));
                } else if ((_str_trim(g_arena, inner, " \t\n\r") != NULL && _str_trim(g_arena, inner, " \t\n\r")[0] != '\0')) {
                    stripped = _str_ltrim(g_arena, inner, " \t");
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), stripped), ")")));
                } else {
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, direction, "("), inner), ")")));
                }
                i = j;
            } else {
                VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
                i += 1;
            }
        } else if (((((is_expansion_start(value, i, "${ ") || is_expansion_start(value, i, "${\t")) || is_expansion_start(value, i, "${\n")) || is_expansion_start(value, i, "${|")) && !(is_backslash_escaped(value, i)))) {
            prefix = _str_replace(g_arena, _str_replace(g_arena, substring(value, i, (i + 3)), "\t", " "), "\n", " ");
            j = (i + 3);
            depth = 1;
            while (((j < _rune_len(value)) && (depth > 0))) {
                if ((strcmp((const char *)(_char_at_str(g_arena, value, j)), "{") == 0)) {
                    depth += 1;
                } else if ((strcmp((const char *)(_char_at_str(g_arena, value, j)), "}") == 0)) {
                    depth -= 1;
                }
                j += 1;
            }
            inner = substring(value, (i + 2), (j - 1));
            if ((strcmp(_str_trim(g_arena, inner, " \t\n\r"), "") == 0)) {
                VEC_PUSH(g_arena, &result, ("${ }"));
            } else {
                // try {
                parser = new_parser(_str_ltrim(g_arena, inner, " \t\n|"), false, false);
                parsed = (Node *)Parser_parse_list(parser, true);
                const char * terminator;
                if ((parsed != NULL)) {
                    formatted = format_cmdsub_node((Node *)parsed, 0, false, false, false);
                    formatted = _str_rtrim(g_arena, formatted, ";");
                    if (_str_endswith(_str_rtrim(g_arena, inner, " \t"), "\n")) {
                        terminator = "\n }";
                    } else if (_str_endswith(formatted, " &")) {
                        terminator = " }";
                    } else {
                        terminator = "; }";
                    }
                    VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, prefix, formatted), terminator)));
                } else {
                    VEC_PUSH(g_arena, &result, ("${ }"));
                }
                // } catch handled via error returns
            }
            i = j;
        } else if ((is_expansion_start(value, i, "${") && !(is_backslash_escaped(value, i)))) {
            j = (i + 2);
            depth = 1;
            QuoteState * brace_quote = new_quote_state();
            while (((j < _rune_len(value)) && (depth > 0))) {
                const char * c = (const char *)(_char_at_str(g_arena, value, j));
                if ((((strcmp(c, "\\") == 0) && ((j + 1) < _rune_len(value))) && !(brace_quote->single))) {
                    j += 2;
                    continue;
                }
                if (((strcmp(c, "'") == 0) && !(brace_quote->double_))) {
                    brace_quote->single = !(brace_quote->single);
                } else if (((strcmp(c, "\"") == 0) && !(brace_quote->single))) {
                    brace_quote->double_ = !(brace_quote->double_);
                } else if (!(QuoteState_in_quotes(brace_quote))) {
                    if ((is_expansion_start(value, j, "$(") && !(starts_with_at(value, j, "$((")))) {
                        j = find_cmdsub_end(value, (j + 2));
                        continue;
                    }
                    if ((strcmp(c, "{") == 0)) {
                        depth += 1;
                    } else if ((strcmp(c, "}") == 0)) {
                        depth -= 1;
                    }
                }
                j += 1;
            }
            if ((depth > 0)) {
                inner = substring(value, (i + 2), j);
            } else {
                inner = substring(value, (i + 2), (j - 1));
            }
            const char * formatted_inner = Word_format_command_substitutions(self, inner, false);
            formatted_inner = Word_normalize_extglob_whitespace(self, formatted_inner);
            if ((depth == 0)) {
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, _str_concat(g_arena, "${", formatted_inner), "}")));
            } else {
                VEC_PUSH(g_arena, &result, (_str_concat(g_arena, "${", formatted_inner)));
            }
            i = j;
        } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\"") == 0)) {
            main_quote->double_ = !(main_quote->double_);
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
        } else if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "'") == 0) && !(main_quote->double_))) {
            j = (i + 1);
            while (((j < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, j)), "'") != 0))) {
                j += 1;
            }
            if ((j < _rune_len(value))) {
                j += 1;
            }
            VEC_PUSH(g_arena, &result, (substring(value, i, j)));
            i = j;
        } else {
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
        }
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_normalize_extglob_whitespace(Word *self, const char * value) {
    Vec_Str result = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    QuoteState * extglob_quote = new_quote_state();
    int64_t deprecated_arith_depth = 0;
    while ((i < _rune_len(value))) {
        if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\"") == 0)) {
            extglob_quote->double_ = !(extglob_quote->double_);
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if ((starts_with_at(value, i, "$[") && !(is_backslash_escaped(value, i)))) {
            deprecated_arith_depth += 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "]") == 0) && (deprecated_arith_depth > 0))) {
            deprecated_arith_depth -= 1;
            VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
            i += 1;
            continue;
        }
        if ((((i + 1) < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "(") == 0))) {
            const char * prefix_char = (const char *)(_char_at_str(g_arena, value, i));
            if (((_str_contains("><", prefix_char) && !(extglob_quote->double_)) && (deprecated_arith_depth == 0))) {
                VEC_PUSH(g_arena, &result, (prefix_char));
                VEC_PUSH(g_arena, &result, ("("));
                i += 2;
                int64_t depth = 1;
                Vec_Str pattern_parts = (Vec_Str){NULL, 0, 0};
                Vec_Str current_part = (Vec_Str){NULL, 0, 0};
                bool has_pipe = false;
                while (((i < _rune_len(value)) && (depth > 0))) {
                    const char * part_content;
                    if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "\\") == 0) && ((i + 1) < _rune_len(value)))) {
                        VEC_PUSH(g_arena, &current_part, (_substring(g_arena, value, i, (i + 2))));
                        i += 2;
                        continue;
                    } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), "(") == 0)) {
                        depth += 1;
                        VEC_PUSH(g_arena, &current_part, ((const char *)(_char_at_str(g_arena, value, i))));
                        i += 1;
                    } else if ((strcmp((const char *)(_char_at_str(g_arena, value, i)), ")") == 0)) {
                        depth -= 1;
                        if ((depth == 0)) {
                            part_content = _str_join(g_arena, "", current_part);
                            if (_str_contains(part_content, "<<")) {
                                VEC_PUSH(g_arena, &pattern_parts, (part_content));
                            } else if (has_pipe) {
                                VEC_PUSH(g_arena, &pattern_parts, (_str_trim(g_arena, part_content, " \t\n\r")));
                            } else {
                                VEC_PUSH(g_arena, &pattern_parts, (part_content));
                            }
                            break;
                        }
                        VEC_PUSH(g_arena, &current_part, ((const char *)(_char_at_str(g_arena, value, i))));
                        i += 1;
                    } else if (((strcmp((const char *)(_char_at_str(g_arena, value, i)), "|") == 0) && (depth == 1))) {
                        if ((((i + 1) < _rune_len(value)) && (strcmp((const char *)(_char_at_str(g_arena, value, (i + 1))), "|") == 0))) {
                            VEC_PUSH(g_arena, &current_part, ("||"));
                            i += 2;
                        } else {
                            has_pipe = true;
                            part_content = _str_join(g_arena, "", current_part);
                            if (_str_contains(part_content, "<<")) {
                                VEC_PUSH(g_arena, &pattern_parts, (part_content));
                            } else {
                                VEC_PUSH(g_arena, &pattern_parts, (_str_trim(g_arena, part_content, " \t\n\r")));
                            }
                            current_part = (Vec_Str){NULL, 0, 0};
                            i += 1;
                        }
                    } else {
                        VEC_PUSH(g_arena, &current_part, ((const char *)(_char_at_str(g_arena, value, i))));
                        i += 1;
                    }
                }
                VEC_PUSH(g_arena, &result, (_str_join(g_arena, " | ", pattern_parts)));
                if ((depth == 0)) {
                    VEC_PUSH(g_arena, &result, (")"));
                    i += 1;
                }
                continue;
            }
        }
        VEC_PUSH(g_arena, &result, ((const char *)(_char_at_str(g_arena, value, i))));
        i += 1;
    }
    return _str_join(g_arena, "", result);
}

static const char * Word_get_cond_formatted_value(Word *self) {
    const char * value = Word_expand_all_ansi_c_quotes(self, self->value);
    value = Word_strip_locale_string_dollars(self, value);
    value = Word_format_command_substitutions(self, value, false);
    value = Word_normalize_extglob_whitespace(self, value);
    value = _str_replace(g_arena, value, "\x01", "\x01\x01");
    return _str_rtrim(g_arena, value, "\n");
}

static const char * Word_get_kind(Word *self) {
    return self->kind;
}

static const char * Command_to_sexp(Command *self) {
    Vec_Str parts = (Vec_Str){NULL, 0, 0};
    for (size_t _idx = 0; _idx < self->words.len; _idx++) {
        Word * w = self->words.data[_idx];
        VEC_PUSH(g_arena, &parts, (Word_to_sexp(w)));
    }
    for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
        Node * r = self->redirects.data[_idx];
        VEC_PUSH(g_arena, &parts, (Node_to_sexp(r)));
    }
    const char * inner = _str_join(g_arena, " ", parts);
    if (!((inner != NULL && inner[0] != '\0'))) {
        return "(command)";
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(command ", inner), ")");
}

static const char * Command_get_kind(Command *self) {
    return self->kind;
}

static const char * Pipeline_to_sexp(Pipeline *self) {
    if ((self->commands.len == 1)) {
        return Node_to_sexp(self->commands.data[0]);
    }
    Vec_Tuple_NodePtr_bool cmds = (Vec_Tuple_NodePtr_bool){NULL, 0, 0};
    int64_t i = 0;
    Node * cmd;
    while ((i < self->commands.len)) {
        cmd = (Node *)self->commands.data[i];
        void *_data53 = cmd->data;
        switch (cmd->kind) {
        case KIND_PIPEBOTH: {
            PipeBoth *cmd = (PipeBoth *)_data53;
            i += 1;
            continue;
            break;
        }
        }
        bool needs_redirect = (((i + 1) < self->commands.len) && (strcmp(_kind_to_str(self->commands.data[(i + 1)]->kind), "pipe-both") == 0));
        VEC_PUSH(g_arena, &cmds, ((Tuple_NodePtr_bool){(Node *)cmd, needs_redirect}));
        i += 1;
    }
    Tuple_NodePtr_bool pair;
    bool needs;
    if ((cmds.len == 1)) {
        pair = cmds.data[0];
        cmd = (Node *)pair.F0;
        needs = pair.F1;
        return Pipeline_cmd_sexp(self, cmd, needs);
    }
    Tuple_NodePtr_bool last_pair = cmds.data[(cmds.len - 1)];
    Node * last_cmd = (Node *)last_pair.F0;
    bool last_needs = last_pair.F1;
    const char * result = Pipeline_cmd_sexp(self, last_cmd, last_needs);
    int64_t j = (cmds.len - 2);
    while ((j >= 0)) {
        pair = cmds.data[j];
        cmd = (Node *)pair.F0;
        needs = pair.F1;
        if ((needs && (strcmp(_kind_to_str(cmd->kind), "command") != 0))) {
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(pipe ", Node_to_sexp(cmd)), " (redirect \">&\" 1) "), result), ")");
        } else {
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(pipe ", Pipeline_cmd_sexp(self, cmd, needs)), " "), result), ")");
        }
        j -= 1;
    }
    return result;
}

static const char * Pipeline_cmd_sexp(Pipeline *self, Node * cmd, bool needs_redirect) {
    if (!(needs_redirect)) {
        return Node_to_sexp(cmd);
    }
    Vec_Str parts;
    void *_data54 = cmd->data;
    switch (cmd->kind) {
    case KIND_COMMAND: {
        Command *cmd = (Command *)_data54;
        parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < cmd->words.len; _idx++) {
            Word * w = cmd->words.data[_idx];
            VEC_PUSH(g_arena, &parts, (Word_to_sexp(w)));
        }
        for (size_t _idx = 0; _idx < cmd->redirects.len; _idx++) {
            Node * r = cmd->redirects.data[_idx];
            VEC_PUSH(g_arena, &parts, (Node_to_sexp(r)));
        }
        VEC_PUSH(g_arena, &parts, ("(redirect \">&\" 1)"));
        return _str_concat(g_arena, _str_concat(g_arena, "(command ", _str_join(g_arena, " ", parts)), ")");
        break;
    }
    }
    return Node_to_sexp(cmd);
}

static const char * Pipeline_get_kind(Pipeline *self) {
    return self->kind;
}

static const char * List_to_sexp(List *self) {
    Vec_Node parts = self->parts /* copy */;
    void * op_names = NULL;
    while ((((parts.len > 1) && (strcmp(_kind_to_str(parts.data[(parts.len - 1)]->kind), "operator") == 0)) && ((strcmp(((Operator *)(parts.data[(parts.len - 1)]->data))->op, ";") == 0) || (strcmp(((Operator *)(parts.data[(parts.len - 1)]->data))->op, "\n") == 0)))) {
        parts = /* sublist */ parts;
    }
    if ((parts.len == 1)) {
        return Node_to_sexp(parts.data[0]);
    }
    if (((strcmp(_kind_to_str(parts.data[(parts.len - 1)]->kind), "operator") == 0) && (strcmp(((Operator *)(parts.data[(parts.len - 1)]->data))->op, "&") == 0))) {
        for (int64_t i = (parts.len - 3); (i > 0); i += -(2)) {
            const char * left_sexp;
            const char * right_sexp;
            if (((strcmp(_kind_to_str(parts.data[i]->kind), "operator") == 0) && ((strcmp(((Operator *)(parts.data[i]->data))->op, ";") == 0) || (strcmp(((Operator *)(parts.data[i]->data))->op, "\n") == 0)))) {
                Vec_Node left = /* sublist */ parts;
                Vec_Node right = /* sublist */ parts;
                if ((left.len > 1)) {
                    left_sexp = List_to_sexp(List_new(left, "list"));
                } else {
                    left_sexp = Node_to_sexp(left.data[0]);
                }
                if ((right.len > 1)) {
                    right_sexp = List_to_sexp(List_new(right, "list"));
                } else {
                    right_sexp = Node_to_sexp(right.data[0]);
                }
                return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(semi ", left_sexp), " (background "), right_sexp), "))");
            }
        }
        Vec_Node inner_parts = /* sublist */ parts;
        if ((inner_parts.len == 1)) {
            return _str_concat(g_arena, _str_concat(g_arena, "(background ", Node_to_sexp(inner_parts.data[0])), ")");
        }
        List * inner_list = List_new(inner_parts, "list");
        return _str_concat(g_arena, _str_concat(g_arena, "(background ", List_to_sexp(inner_list)), ")");
    }
    return List_to_sexp_with_precedence(self, parts, op_names);
}

static const char * List_to_sexp_with_precedence(List *self, Vec_Node parts, void * op_names) {
    Vec_Int semi_positions = (Vec_Int){NULL, 0, 0};
    for (int64_t i = 0; (i < parts.len); i++) {
        if (((strcmp(_kind_to_str(parts.data[i]->kind), "operator") == 0) && ((strcmp(((Operator *)(parts.data[i]->data))->op, ";") == 0) || (strcmp(((Operator *)(parts.data[i]->data))->op, "\n") == 0)))) {
            VEC_PUSH(g_arena, &semi_positions, (i));
        }
    }
    if ((semi_positions.len > 0)) {
        Vec_VecNode segments = (Vec_VecNode){NULL, 0, 0};
        int64_t start = 0;
        Vec_Node seg;
        for (size_t _idx = 0; _idx < semi_positions.len; _idx++) {
            int64_t pos = semi_positions.data[_idx];
            seg = /* sublist */ parts;
            if (((seg.len > 0) && (strcmp(_kind_to_str(seg.data[0]->kind), "operator") != 0))) {
                VEC_PUSH(g_arena, &segments, (seg));
            }
            start = (pos + 1);
        }
        seg = /* sublist */ parts;
        if (((seg.len > 0) && (strcmp(_kind_to_str(seg.data[0]->kind), "operator") != 0))) {
            VEC_PUSH(g_arena, &segments, (seg));
        }
        if (!((segments.len > 0))) {
            return "()";
        }
        const char * result = List_to_sexp_amp_and_higher(self, segments.data[0], op_names);
        for (int64_t i = 1; (i < segments.len); i++) {
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(semi ", result), " "), List_to_sexp_amp_and_higher(self, segments.data[i], op_names)), ")");
        }
        return result;
    }
    return List_to_sexp_amp_and_higher(self, parts, op_names);
}

static const char * List_to_sexp_amp_and_higher(List *self, Vec_Node parts, void * op_names) {
    if ((parts.len == 1)) {
        return Node_to_sexp(parts.data[0]);
    }
    Vec_Int amp_positions = (Vec_Int){NULL, 0, 0};
    for (int64_t i = 1; (i < (parts.len - 1)); i += 2) {
        if (((strcmp(_kind_to_str(parts.data[i]->kind), "operator") == 0) && (strcmp(((Operator *)(parts.data[i]->data))->op, "&") == 0))) {
            VEC_PUSH(g_arena, &amp_positions, (i));
        }
    }
    if ((amp_positions.len > 0)) {
        Vec_VecNode segments = (Vec_VecNode){NULL, 0, 0};
        int64_t start = 0;
        for (size_t _idx = 0; _idx < amp_positions.len; _idx++) {
            int64_t pos = amp_positions.data[_idx];
            VEC_PUSH(g_arena, &segments, (/* sublist */ parts));
            start = (pos + 1);
        }
        VEC_PUSH(g_arena, &segments, (/* sublist */ parts));
        const char * result = List_to_sexp_and_or(self, segments.data[0], op_names);
        for (int64_t i = 1; (i < segments.len); i++) {
            result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(background ", result), " "), List_to_sexp_and_or(self, segments.data[i], op_names)), ")");
        }
        return result;
    }
    return List_to_sexp_and_or(self, parts, op_names);
}

static const char * List_to_sexp_and_or(List *self, Vec_Node parts, void * op_names) {
    if ((parts.len == 1)) {
        return Node_to_sexp(parts.data[0]);
    }
    const char * result = Node_to_sexp(parts.data[0]);
    for (int64_t i = 1; (i < (parts.len - 1)); i += 2) {
        Node * op = (Node *)parts.data[i];
        Node * cmd = (Node *)parts.data[(i + 1)];
        const char * op_name = "" /* map_get(op_names, ((Operator *)(op->data))->op) */;
        result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(", op_name), " "), result), " "), Node_to_sexp(cmd)), ")");
    }
    return result;
}

static const char * List_get_kind(List *self) {
    return self->kind;
}

static const char * Operator_to_sexp(Operator *self) {
    void * names = NULL;
    return _str_concat(g_arena, _str_concat(g_arena, "(", NULL /* map_get(names, self->op) */), ")");
}

static const char * Operator_get_kind(Operator *self) {
    return self->kind;
}

static const char * PipeBoth_to_sexp(PipeBoth *self) {
    return "(pipe-both)";
}

static const char * PipeBoth_get_kind(PipeBoth *self) {
    return self->kind;
}

static const char * Empty_to_sexp(Empty *self) {
    return "";
}

static const char * Empty_get_kind(Empty *self) {
    return self->kind;
}

static const char * Comment_to_sexp(Comment *self) {
    return "";
}

static const char * Comment_get_kind(Comment *self) {
    return self->kind;
}

static const char * Redirect_to_sexp(Redirect *self) {
    const char * op = _str_ltrim(g_arena, self->op, "0123456789");
    if (_str_startswith(op, "{")) {
        int64_t j = 1;
        if (((j < _rune_len(op)) && (_str_is_alpha((const char *)(_char_at_str(g_arena, op, j))) || (strcmp((const char *)(_char_at_str(g_arena, op, j)), "_") == 0)))) {
            j += 1;
            while (((j < _rune_len(op)) && (_str_is_alnum((const char *)(_char_at_str(g_arena, op, j))) || (strcmp((const char *)(_char_at_str(g_arena, op, j)), "_") == 0)))) {
                j += 1;
            }
            if (((j < _rune_len(op)) && (strcmp((const char *)(_char_at_str(g_arena, op, j)), "[") == 0))) {
                j += 1;
                while (((j < _rune_len(op)) && (strcmp((const char *)(_char_at_str(g_arena, op, j)), "]") != 0))) {
                    j += 1;
                }
                if (((j < _rune_len(op)) && (strcmp((const char *)(_char_at_str(g_arena, op, j)), "]") == 0))) {
                    j += 1;
                }
            }
            if (((j < _rune_len(op)) && (strcmp((const char *)(_char_at_str(g_arena, op, j)), "}") == 0))) {
                op = substring(op, (j + 1), _rune_len(op));
            }
        }
    }
    const char * target_val = self->target->value;
    target_val = Word_expand_all_ansi_c_quotes(self->target, target_val);
    target_val = Word_strip_locale_string_dollars(self->target, target_val);
    target_val = Word_format_command_substitutions(self->target, target_val, false);
    target_val = Word_strip_arith_line_continuations(self->target, target_val);
    if ((_str_endswith(target_val, "\\") && !(_str_endswith(target_val, "\\\\")))) {
        target_val = _str_concat(g_arena, target_val, "\\");
    }
    if (_str_startswith(target_val, "&")) {
        if ((strcmp(op, ">") == 0)) {
            op = ">&";
        } else if ((strcmp(op, "<") == 0)) {
            op = "<&";
        }
        const char * raw = substring(target_val, 1, _rune_len(target_val));
        if ((_str_is_digit(raw) && (_parse_int(raw, 10) <= 2147483647))) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" "), _int_to_str(g_arena, _parse_int(raw, 10))), ")");
        }
        if (((_str_endswith(raw, "-") && _str_is_digit(_substring(g_arena, raw, 0, (_rune_len(raw) - 1)))) && (_parse_int(_substring(g_arena, raw, 0, (_rune_len(raw) - 1)), 10) <= 2147483647))) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" "), _int_to_str(g_arena, _parse_int(_substring(g_arena, raw, 0, (_rune_len(raw) - 1)), 10))), ")");
        }
        if ((strcmp(target_val, "&-") == 0)) {
            return "(redirect \">&-\" 0)";
        }
        const char * fd_target = (_str_endswith(raw, "-") ? _substring(g_arena, raw, 0, (_rune_len(raw) - 1)) : raw);
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" \""), fd_target), "\")");
    }
    if (((strcmp(op, ">&") == 0) || (strcmp(op, "<&") == 0))) {
        if ((_str_is_digit(target_val) && (_parse_int(target_val, 10) <= 2147483647))) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" "), _int_to_str(g_arena, _parse_int(target_val, 10))), ")");
        }
        if ((strcmp(target_val, "-") == 0)) {
            return "(redirect \">&-\" 0)";
        }
        if (((_str_endswith(target_val, "-") && _str_is_digit(_substring(g_arena, target_val, 0, (_rune_len(target_val) - 1)))) && (_parse_int(_substring(g_arena, target_val, 0, (_rune_len(target_val) - 1)), 10) <= 2147483647))) {
            return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" "), _int_to_str(g_arena, _parse_int(_substring(g_arena, target_val, 0, (_rune_len(target_val) - 1)), 10))), ")");
        }
        const char * out_val = (_str_endswith(target_val, "-") ? _substring(g_arena, target_val, 0, (_rune_len(target_val) - 1)) : target_val);
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" \""), out_val), "\")");
    }
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(redirect \"", op), "\" \""), target_val), "\")");
}

static const char * Redirect_get_kind(Redirect *self) {
    return self->kind;
}

static const char * HereDoc_to_sexp(HereDoc *self) {
    const char * op = (self->strip_tabs ? "<<-" : "<<");
    const char * content = self->content;
    if ((_str_endswith(content, "\\") && !(_str_endswith(content, "\\\\")))) {
        content = _str_concat(g_arena, content, "\\");
    }
    return _str_format(g_arena, "(redirect \"%v\" \"%v\")", op, content);
}

static const char * HereDoc_get_kind(HereDoc *self) {
    return self->kind;
}

static const char * Subshell_to_sexp(Subshell *self) {
    const char * base = _str_concat(g_arena, _str_concat(g_arena, "(subshell ", Node_to_sexp(self->body)), ")");
    return append_redirects(base, self->redirects);
}

static const char * Subshell_get_kind(Subshell *self) {
    return self->kind;
}

static const char * BraceGroup_to_sexp(BraceGroup *self) {
    const char * base = _str_concat(g_arena, _str_concat(g_arena, "(brace-group ", Node_to_sexp(self->body)), ")");
    return append_redirects(base, self->redirects);
}

static const char * BraceGroup_get_kind(BraceGroup *self) {
    return self->kind;
}

static const char * If_to_sexp(If *self) {
    const char * result = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(if ", Node_to_sexp(self->condition)), " "), Node_to_sexp(self->then_body));
    if ((self->else_body != NULL)) {
        result = _str_concat(g_arena, _str_concat(g_arena, result, " "), Node_to_sexp(self->else_body));
    }
    result = _str_concat(g_arena, result, ")");
    for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
        Node * r = self->redirects.data[_idx];
        result = _str_concat(g_arena, _str_concat(g_arena, result, " "), Node_to_sexp(r));
    }
    return result;
}

static const char * If_get_kind(If *self) {
    return self->kind;
}

static const char * While_to_sexp(While *self) {
    const char * base = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(while ", Node_to_sexp(self->condition)), " "), Node_to_sexp(self->body)), ")");
    return append_redirects(base, self->redirects);
}

static const char * While_get_kind(While *self) {
    return self->kind;
}

static const char * Until_to_sexp(Until *self) {
    const char * base = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(until ", Node_to_sexp(self->condition)), " "), Node_to_sexp(self->body)), ")");
    return append_redirects(base, self->redirects);
}

static const char * Until_get_kind(Until *self) {
    return self->kind;
}

static const char * For_to_sexp(For *self) {
    const char * suffix = "";
    if ((self->redirects.len > 0)) {
        Vec_Str redirect_parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
            Node * r = self->redirects.data[_idx];
            VEC_PUSH(g_arena, &redirect_parts, (Node_to_sexp(r)));
        }
        suffix = _str_concat(g_arena, " ", _str_join(g_arena, " ", redirect_parts));
    }
    Word * temp_word = Word_new(self->var, (Vec_Node){NULL, 0, 0}, "word");
    const char * var_formatted = Word_format_command_substitutions(temp_word, self->var, false);
    const char * var_escaped = _str_replace(g_arena, _str_replace(g_arena, var_formatted, "\\", "\\\\"), "\"", "\\\"");
    if ((self->words == NULL)) {
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(for (word \"", var_escaped), "\") (in (word \"\\\"$@\\\"\")) "), Node_to_sexp(self->body)), ")"), suffix);
    } else if ((strlen(self->words) == 0)) {
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(for (word \"", var_escaped), "\") (in) "), Node_to_sexp(self->body)), ")"), suffix);
    } else {
        Vec_Str word_parts = (Vec_Str){NULL, 0, 0};
        if (self->words != NULL) {
            for (size_t _idx = 0; _idx < self->words->len; _idx++) {
                Word * w = self->words->data[_idx];
                VEC_PUSH(g_arena, &word_parts, (Node_to_sexp(w)));
            }
        }
        const char * word_strs = _str_join(g_arena, " ", word_parts);
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(for (word \"", var_escaped), "\") (in "), word_strs), ") "), Node_to_sexp(self->body)), ")"), suffix);
    }
}

static const char * For_get_kind(For *self) {
    return self->kind;
}

static const char * ForArith_to_sexp(ForArith *self) {
    const char * suffix = "";
    if ((self->redirects.len > 0)) {
        Vec_Str redirect_parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
            Node * r = self->redirects.data[_idx];
            VEC_PUSH(g_arena, &redirect_parts, (Node_to_sexp(r)));
        }
        suffix = _str_concat(g_arena, " ", _str_join(g_arena, " ", redirect_parts));
    }
    const char * init_val = ((self->init != NULL && self->init[0] != '\0') ? self->init : "1");
    const char * cond_val = ((self->cond != NULL && self->cond[0] != '\0') ? self->cond : "1");
    const char * incr_val = ((self->incr != NULL && self->incr[0] != '\0') ? self->incr : "1");
    const char * init_str = format_arith_val(init_val);
    const char * cond_str = format_arith_val(cond_val);
    const char * incr_str = format_arith_val(incr_val);
    const char * body_str = Node_to_sexp(self->body);
    return _str_format(g_arena, "(arith-for (init (word \"%v\")) (test (word \"%v\")) (step (word \"%v\")) %v)%v", init_str, cond_str, incr_str, body_str, suffix);
}

static const char * ForArith_get_kind(ForArith *self) {
    return self->kind;
}

static const char * Select_to_sexp(Select *self) {
    const char * suffix = "";
    if ((self->redirects.len > 0)) {
        Vec_Str redirect_parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
            Node * r = self->redirects.data[_idx];
            VEC_PUSH(g_arena, &redirect_parts, (Node_to_sexp(r)));
        }
        suffix = _str_concat(g_arena, " ", _str_join(g_arena, " ", redirect_parts));
    }
    const char * var_escaped = _str_replace(g_arena, _str_replace(g_arena, self->var, "\\", "\\\\"), "\"", "\\\"");
    const char * in_clause;
    if ((self->words != NULL)) {
        Vec_Str word_parts = (Vec_Str){NULL, 0, 0};
        if (self->words != NULL) {
            for (size_t _idx = 0; _idx < self->words->len; _idx++) {
                Word * w = self->words->data[_idx];
                VEC_PUSH(g_arena, &word_parts, (Node_to_sexp(w)));
            }
        }
        const char * word_strs = _str_join(g_arena, " ", word_parts);
        if ((self->words != NULL)) {
            in_clause = _str_concat(g_arena, _str_concat(g_arena, "(in ", word_strs), ")");
        } else {
            in_clause = "(in)";
        }
    } else {
        in_clause = "(in (word \"\\\"$@\\\"\"))";
    }
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(select (word \"", var_escaped), "\") "), in_clause), " "), Node_to_sexp(self->body)), ")"), suffix);
}

static const char * Select_get_kind(Select *self) {
    return self->kind;
}

static const char * Case_to_sexp(Case *self) {
    Vec_Str parts = (Vec_Str){NULL, 0, 0};
    VEC_PUSH(g_arena, &parts, (_str_concat(g_arena, "(case ", Word_to_sexp(self->word))));
    for (size_t _idx = 0; _idx < self->patterns.len; _idx++) {
        CasePattern * p = self->patterns.data[_idx];
        VEC_PUSH(g_arena, &parts, (CasePattern_to_sexp(p)));
    }
    const char * base = _str_concat(g_arena, _str_join(g_arena, " ", parts), ")");
    return append_redirects(base, self->redirects);
}

static const char * Case_get_kind(Case *self) {
    return self->kind;
}

static const char * CasePattern_to_sexp(CasePattern *self) {
    Vec_Str alternatives = (Vec_Str){NULL, 0, 0};
    Vec_Str current = (Vec_Str){NULL, 0, 0};
    int64_t i = 0;
    int64_t depth = 0;
    while ((i < _rune_len(self->pattern))) {
        const char * ch = (const char *)(_char_at_str(g_arena, self->pattern, i));
        int64_t result0;
        Vec_Str result1;
        if (((strcmp(ch, "\\") == 0) && ((i + 1) < _rune_len(self->pattern)))) {
            VEC_PUSH(g_arena, &current, (substring(self->pattern, i, (i + 2))));
            i += 2;
        } else if ((((((((strcmp(ch, "@") == 0) || (strcmp(ch, "?") == 0)) || (strcmp(ch, "*") == 0)) || (strcmp(ch, "+") == 0)) || (strcmp(ch, "!") == 0)) && ((i + 1) < _rune_len(self->pattern))) && (strcmp((const char *)(_char_at_str(g_arena, self->pattern, (i + 1))), "(") == 0))) {
            VEC_PUSH(g_arena, &current, (ch));
            VEC_PUSH(g_arena, &current, ("("));
            depth += 1;
            i += 2;
        } else if (is_expansion_start(self->pattern, i, "$(")) {
            VEC_PUSH(g_arena, &current, (ch));
            VEC_PUSH(g_arena, &current, ("("));
            depth += 1;
            i += 2;
        } else if (((strcmp(ch, "(") == 0) && (depth > 0))) {
            VEC_PUSH(g_arena, &current, (ch));
            depth += 1;
            i += 1;
        } else if (((strcmp(ch, ")") == 0) && (depth > 0))) {
            VEC_PUSH(g_arena, &current, (ch));
            depth -= 1;
            i += 1;
        } else if ((strcmp(ch, "[") == 0)) {
            Tuple_int64_t_Vec_Str_bool _tup55 = consume_bracket_class(self->pattern, i, depth);
            result0 = _tup55.F0;
            result1 = _tup55.F1;
            bool result2 = _tup55.F2;
            i = result0;
            do { Vec_Str _src = result1; for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &current, _src.data[_i]); } } while(0);
        } else if (((strcmp(ch, "'") == 0) && (depth == 0))) {
            Tuple_int64_t_Vec_Str _tup56 = consume_single_quote(self->pattern, i);
            result0 = _tup56.F0;
            result1 = _tup56.F1;
            i = result0;
            do { Vec_Str _src = result1; for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &current, _src.data[_i]); } } while(0);
        } else if (((strcmp(ch, "\"") == 0) && (depth == 0))) {
            Tuple_int64_t_Vec_Str _tup57 = consume_double_quote(self->pattern, i);
            result0 = _tup57.F0;
            result1 = _tup57.F1;
            i = result0;
            do { Vec_Str _src = result1; for (size_t _i = 0; _i < _src.len; _i++) { VEC_PUSH(g_arena, &current, _src.data[_i]); } } while(0);
        } else if (((strcmp(ch, "|") == 0) && (depth == 0))) {
            VEC_PUSH(g_arena, &alternatives, (_str_join(g_arena, "", current)));
            current = (Vec_Str){NULL, 0, 0};
            i += 1;
        } else {
            VEC_PUSH(g_arena, &current, (ch));
            i += 1;
        }
    }
    VEC_PUSH(g_arena, &alternatives, (_str_join(g_arena, "", current)));
    Vec_Str word_list = (Vec_Str){NULL, 0, 0};
    for (size_t _idx = 0; _idx < alternatives.len; _idx++) {
        const char * alt = alternatives.data[_idx];
        VEC_PUSH(g_arena, &word_list, (Word_to_sexp(Word_new(alt, (Vec_Node){NULL, 0, 0}, "word"))));
    }
    const char * pattern_str = _str_join(g_arena, " ", word_list);
    Vec_Str parts = (Vec_Str){(const char *[]){ _str_concat(g_arena, _str_concat(g_arena, "(pattern (", pattern_str), ")") }, 1, 1};
    if ((self->body != NULL)) {
        VEC_PUSH(g_arena, &parts, (_str_concat(g_arena, " ", Node_to_sexp(self->body))));
    } else {
        VEC_PUSH(g_arena, &parts, (" ()"));
    }
    VEC_PUSH(g_arena, &parts, (")"));
    return _str_join(g_arena, "", parts);
}

static const char * CasePattern_get_kind(CasePattern *self) {
    return self->kind;
}

static const char * Function_to_sexp(Function *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(function \"", self->name), "\" "), Node_to_sexp(self->body)), ")");
}

static const char * Function_get_kind(Function *self) {
    return self->kind;
}

static const char * ParamExpansion_to_sexp(ParamExpansion *self) {
    const char * escaped_param = _str_replace(g_arena, _str_replace(g_arena, self->param, "\\", "\\\\"), "\"", "\\\"");
    const char * arg_val;
    if ((strcmp(self->op, "") != 0)) {
        const char * escaped_op = _str_replace(g_arena, _str_replace(g_arena, self->op, "\\", "\\\\"), "\"", "\\\"");
        if ((strcmp(self->arg, "") != 0)) {
            arg_val = self->arg;
        } else {
            arg_val = "";
        }
        const char * escaped_arg = _str_replace(g_arena, _str_replace(g_arena, arg_val, "\\", "\\\\"), "\"", "\\\"");
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(param \"", escaped_param), "\" \""), escaped_op), "\" \""), escaped_arg), "\")");
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(param \"", escaped_param), "\")");
}

static const char * ParamExpansion_get_kind(ParamExpansion *self) {
    return self->kind;
}

static const char * ParamLength_to_sexp(ParamLength *self) {
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, self->param, "\\", "\\\\"), "\"", "\\\"");
    return _str_concat(g_arena, _str_concat(g_arena, "(param-len \"", escaped), "\")");
}

static const char * ParamLength_get_kind(ParamLength *self) {
    return self->kind;
}

static const char * ParamIndirect_to_sexp(ParamIndirect *self) {
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, self->param, "\\", "\\\\"), "\"", "\\\"");
    const char * arg_val;
    if ((strcmp(self->op, "") != 0)) {
        const char * escaped_op = _str_replace(g_arena, _str_replace(g_arena, self->op, "\\", "\\\\"), "\"", "\\\"");
        if ((strcmp(self->arg, "") != 0)) {
            arg_val = self->arg;
        } else {
            arg_val = "";
        }
        const char * escaped_arg = _str_replace(g_arena, _str_replace(g_arena, arg_val, "\\", "\\\\"), "\"", "\\\"");
        return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(param-indirect \"", escaped), "\" \""), escaped_op), "\" \""), escaped_arg), "\")");
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(param-indirect \"", escaped), "\")");
}

static const char * ParamIndirect_get_kind(ParamIndirect *self) {
    return self->kind;
}

static const char * CommandSubstitution_to_sexp(CommandSubstitution *self) {
    if (self->brace) {
        return _str_concat(g_arena, _str_concat(g_arena, "(funsub ", Node_to_sexp(self->command)), ")");
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(cmdsub ", Node_to_sexp(self->command)), ")");
}

static const char * CommandSubstitution_get_kind(CommandSubstitution *self) {
    return self->kind;
}

static const char * ArithmeticExpansion_to_sexp(ArithmeticExpansion *self) {
    if ((self->expression == NULL)) {
        return "(arith)";
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(arith ", Node_to_sexp(self->expression)), ")");
}

static const char * ArithmeticExpansion_get_kind(ArithmeticExpansion *self) {
    return self->kind;
}

static const char * ArithmeticCommand_to_sexp(ArithmeticCommand *self) {
    const char * formatted = Word_format_command_substitutions(Word_new(self->raw_content, (Vec_Node){NULL, 0, 0}, "word"), self->raw_content, true);
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, formatted, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n"), "\t", "\\t");
    const char * result = _str_concat(g_arena, _str_concat(g_arena, "(arith (word \"", escaped), "\"))");
    if ((self->redirects.len > 0)) {
        Vec_Str redirect_parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
            Node * r = self->redirects.data[_idx];
            VEC_PUSH(g_arena, &redirect_parts, (Node_to_sexp(r)));
        }
        const char * redirect_sexps = _str_join(g_arena, " ", redirect_parts);
        return _str_concat(g_arena, _str_concat(g_arena, result, " "), redirect_sexps);
    }
    return result;
}

static const char * ArithmeticCommand_get_kind(ArithmeticCommand *self) {
    return self->kind;
}

static const char * ArithNumber_to_sexp(ArithNumber *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(number \"", self->value), "\")");
}

static const char * ArithNumber_get_kind(ArithNumber *self) {
    return self->kind;
}

static const char * ArithEmpty_to_sexp(ArithEmpty *self) {
    return "(empty)";
}

static const char * ArithEmpty_get_kind(ArithEmpty *self) {
    return self->kind;
}

static const char * ArithVar_to_sexp(ArithVar *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(var \"", self->name), "\")");
}

static const char * ArithVar_get_kind(ArithVar *self) {
    return self->kind;
}

static const char * ArithBinaryOp_to_sexp(ArithBinaryOp *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(binary-op \"", self->op), "\" "), Node_to_sexp(self->left)), " "), Node_to_sexp(self->right)), ")");
}

static const char * ArithBinaryOp_get_kind(ArithBinaryOp *self) {
    return self->kind;
}

static const char * ArithUnaryOp_to_sexp(ArithUnaryOp *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(unary-op \"", self->op), "\" "), Node_to_sexp(self->operand)), ")");
}

static const char * ArithUnaryOp_get_kind(ArithUnaryOp *self) {
    return self->kind;
}

static const char * ArithPreIncr_to_sexp(ArithPreIncr *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(pre-incr ", Node_to_sexp(self->operand)), ")");
}

static const char * ArithPreIncr_get_kind(ArithPreIncr *self) {
    return self->kind;
}

static const char * ArithPostIncr_to_sexp(ArithPostIncr *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(post-incr ", Node_to_sexp(self->operand)), ")");
}

static const char * ArithPostIncr_get_kind(ArithPostIncr *self) {
    return self->kind;
}

static const char * ArithPreDecr_to_sexp(ArithPreDecr *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(pre-decr ", Node_to_sexp(self->operand)), ")");
}

static const char * ArithPreDecr_get_kind(ArithPreDecr *self) {
    return self->kind;
}

static const char * ArithPostDecr_to_sexp(ArithPostDecr *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(post-decr ", Node_to_sexp(self->operand)), ")");
}

static const char * ArithPostDecr_get_kind(ArithPostDecr *self) {
    return self->kind;
}

static const char * ArithAssign_to_sexp(ArithAssign *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(assign \"", self->op), "\" "), Node_to_sexp(self->target)), " "), Node_to_sexp(self->value)), ")");
}

static const char * ArithAssign_get_kind(ArithAssign *self) {
    return self->kind;
}

static const char * ArithTernary_to_sexp(ArithTernary *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(ternary ", Node_to_sexp(self->condition)), " "), Node_to_sexp(self->if_true)), " "), Node_to_sexp(self->if_false)), ")");
}

static const char * ArithTernary_get_kind(ArithTernary *self) {
    return self->kind;
}

static const char * ArithComma_to_sexp(ArithComma *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(comma ", Node_to_sexp(self->left)), " "), Node_to_sexp(self->right)), ")");
}

static const char * ArithComma_get_kind(ArithComma *self) {
    return self->kind;
}

static const char * ArithSubscript_to_sexp(ArithSubscript *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(subscript \"", self->array), "\" "), Node_to_sexp(self->index)), ")");
}

static const char * ArithSubscript_get_kind(ArithSubscript *self) {
    return self->kind;
}

static const char * ArithEscape_to_sexp(ArithEscape *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(escape \"", self->char_), "\")");
}

static const char * ArithEscape_get_kind(ArithEscape *self) {
    return self->kind;
}

static const char * ArithDeprecated_to_sexp(ArithDeprecated *self) {
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, self->expression, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n");
    return _str_concat(g_arena, _str_concat(g_arena, "(arith-deprecated \"", escaped), "\")");
}

static const char * ArithDeprecated_get_kind(ArithDeprecated *self) {
    return self->kind;
}

static const char * ArithConcat_to_sexp(ArithConcat *self) {
    Vec_Str sexps = (Vec_Str){NULL, 0, 0};
    for (size_t _idx = 0; _idx < self->parts.len; _idx++) {
        Node * p = self->parts.data[_idx];
        VEC_PUSH(g_arena, &sexps, (Node_to_sexp(p)));
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(arith-concat ", _str_join(g_arena, " ", sexps)), ")");
}

static const char * ArithConcat_get_kind(ArithConcat *self) {
    return self->kind;
}

static const char * AnsiCQuote_to_sexp(AnsiCQuote *self) {
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, self->content, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n");
    return _str_concat(g_arena, _str_concat(g_arena, "(ansi-c \"", escaped), "\")");
}

static const char * AnsiCQuote_get_kind(AnsiCQuote *self) {
    return self->kind;
}

static const char * LocaleString_to_sexp(LocaleString *self) {
    const char * escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, self->content, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n");
    return _str_concat(g_arena, _str_concat(g_arena, "(locale \"", escaped), "\")");
}

static const char * LocaleString_get_kind(LocaleString *self) {
    return self->kind;
}

static const char * ProcessSubstitution_to_sexp(ProcessSubstitution *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(procsub \"", self->direction), "\" "), Node_to_sexp(self->command)), ")");
}

static const char * ProcessSubstitution_get_kind(ProcessSubstitution *self) {
    return self->kind;
}

static const char * Negation_to_sexp(Negation *self) {
    if ((self->pipeline == NULL)) {
        return "(negation (command))";
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(negation ", Node_to_sexp(self->pipeline)), ")");
}

static const char * Negation_get_kind(Negation *self) {
    return self->kind;
}

static const char * Time_to_sexp(Time *self) {
    if ((self->pipeline == NULL)) {
        if (self->posix) {
            return "(time -p (command))";
        } else {
            return "(time (command))";
        }
    }
    if (self->posix) {
        return _str_concat(g_arena, _str_concat(g_arena, "(time -p ", Node_to_sexp(self->pipeline)), ")");
    }
    return _str_concat(g_arena, _str_concat(g_arena, "(time ", Node_to_sexp(self->pipeline)), ")");
}

static const char * Time_get_kind(Time *self) {
    return self->kind;
}

static const char * ConditionalExpr_to_sexp(ConditionalExpr *self) {
    Any * body = self->body;
    const char * result;
    const char * escaped;
    void *_tsdata58 = body->data;
    if (body->kind == KIND_STRING) {
        const char *body = (const char *)_tsdata58;
        escaped = _str_replace(g_arena, _str_replace(g_arena, _str_replace(g_arena, body, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n");
        result = _str_concat(g_arena, _str_concat(g_arena, "(cond \"", escaped), "\")");
    } else {
        result = _str_concat(g_arena, _str_concat(g_arena, "(cond ", Node_to_sexp(body)), ")");
    }
    if ((self->redirects.len > 0)) {
        Vec_Str redirect_parts = (Vec_Str){NULL, 0, 0};
        for (size_t _idx = 0; _idx < self->redirects.len; _idx++) {
            Node * r = self->redirects.data[_idx];
            VEC_PUSH(g_arena, &redirect_parts, (Node_to_sexp(r)));
        }
        const char * redirect_sexps = _str_join(g_arena, " ", redirect_parts);
        return _str_concat(g_arena, _str_concat(g_arena, result, " "), redirect_sexps);
    }
    return result;
}

static const char * ConditionalExpr_get_kind(ConditionalExpr *self) {
    return self->kind;
}

static const char * UnaryTest_to_sexp(UnaryTest *self) {
    const char * operand_val = Word_get_cond_formatted_value(self->operand);
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(cond-unary \"", self->op), "\" (cond-term \""), operand_val), "\"))");
}

static const char * UnaryTest_get_kind(UnaryTest *self) {
    return self->kind;
}

static const char * BinaryTest_to_sexp(BinaryTest *self) {
    const char * left_val = Word_get_cond_formatted_value(self->left);
    const char * right_val = Word_get_cond_formatted_value(self->right);
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(cond-binary \"", self->op), "\" (cond-term \""), left_val), "\") (cond-term \""), right_val), "\"))");
}

static const char * BinaryTest_get_kind(BinaryTest *self) {
    return self->kind;
}

static const char * CondAnd_to_sexp(CondAnd *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(cond-and ", Node_to_sexp(self->left)), " "), Node_to_sexp(self->right)), ")");
}

static const char * CondAnd_get_kind(CondAnd *self) {
    return self->kind;
}

static const char * CondOr_to_sexp(CondOr *self) {
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(cond-or ", Node_to_sexp(self->left)), " "), Node_to_sexp(self->right)), ")");
}

static const char * CondOr_get_kind(CondOr *self) {
    return self->kind;
}

static const char * CondNot_to_sexp(CondNot *self) {
    return Node_to_sexp(self->operand);
}

static const char * CondNot_get_kind(CondNot *self) {
    return self->kind;
}

static const char * CondParen_to_sexp(CondParen *self) {
    return _str_concat(g_arena, _str_concat(g_arena, "(cond-expr ", Node_to_sexp(self->inner)), ")");
}

static const char * CondParen_get_kind(CondParen *self) {
    return self->kind;
}

static const char * Array_to_sexp(Array *self) {
    if (!((self->elements.len > 0))) {
        return "(array)";
    }
    Vec_Str parts = (Vec_Str){NULL, 0, 0};
    for (size_t _idx = 0; _idx < self->elements.len; _idx++) {
        Word * e = self->elements.data[_idx];
        VEC_PUSH(g_arena, &parts, (Word_to_sexp(e)));
    }
    const char * inner = _str_join(g_arena, " ", parts);
    return _str_concat(g_arena, _str_concat(g_arena, "(array ", inner), ")");
}

static const char * Array_get_kind(Array *self) {
    return self->kind;
}

static const char * Coproc_to_sexp(Coproc *self) {
    const char * name;
    if ((self->name != NULL && self->name[0] != '\0')) {
        name = self->name;
    } else {
        name = "COPROC";
    }
    return _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "(coproc \"", name), "\" "), Node_to_sexp(self->command)), ")");
}

static const char * Coproc_get_kind(Coproc *self) {
    return self->kind;
}

static void Parser_set_state(Parser *self, int64_t flag) {
    self->parser_state = (self->parser_state | flag);
}

static void Parser_clear_state(Parser *self, int64_t flag) {
    self->parser_state = (self->parser_state & ~(flag));
}

static bool Parser_in_state(Parser *self, int64_t flag) {
    return ((self->parser_state & flag) != 0);
}

static SavedParserState * Parser_save_parser_state(Parser *self) {
    return SavedParserState_new(self->parser_state, self->dolbrace_state, *(Vec_Node *)&self->pending_heredocs, ContextStack_copy_stack(self->ctx), self->eof_token);
}

static void Parser_restore_parser_state(Parser *self, SavedParserState * saved) {
    self->parser_state = saved->parser_state;
    self->dolbrace_state = saved->dolbrace_state;
    self->eof_token = saved->eof_token;
    ContextStack_restore_from(self->ctx, saved->ctx_stack);
}

static void Parser_record_token(Parser *self, Token * tok) {
    self->token_history = (Vec_Token){(Token *[]){ tok, self->token_history.data[0], self->token_history.data[1], self->token_history.data[2] }, 4, 4};
}

static void Parser_update_dolbrace_for_op(Parser *self, const char * op, bool has_param) {
    if ((self->dolbrace_state == DOLBRACESTATE_NONE)) {
        return;
    }
    if (((strcmp(op, "") == 0) || (_rune_len(op) == 0))) {
        return;
    }
    const char * first_char = (const char *)(_char_at_str(g_arena, op, 0));
    if (((self->dolbrace_state == DOLBRACESTATE_PARAM) && has_param)) {
        if (_str_contains("%#^,", first_char)) {
            self->dolbrace_state = DOLBRACESTATE_QUOTE;
            return;
        }
        if ((strcmp(first_char, "/") == 0)) {
            self->dolbrace_state = DOLBRACESTATE_QUOTE2;
            return;
        }
    }
    if ((self->dolbrace_state == DOLBRACESTATE_PARAM)) {
        if (_str_contains("#%^,~:-=?+/", first_char)) {
            self->dolbrace_state = DOLBRACESTATE_OP;
        }
    }
}

static void Parser_sync_lexer(Parser *self) {
    if ((self->lexer->token_cache != NULL)) {
        if ((((((self->lexer->token_cache->pos != self->pos) || (self->lexer->cached_word_context != self->word_context)) || (self->lexer->cached_at_command_start != self->at_command_start)) || (self->lexer->cached_in_array_literal != self->in_array_literal)) || (self->lexer->cached_in_assign_builtin != self->in_assign_builtin))) {
            self->lexer->token_cache = NULL;
        }
    }
    if ((self->lexer->pos != self->pos)) {
        self->lexer->pos = self->pos;
    }
    self->lexer->eof_token = self->eof_token;
    self->lexer->parser_state = self->parser_state;
    self->lexer->last_read_token = self->token_history.data[0];
    self->lexer->word_context = self->word_context;
    self->lexer->at_command_start = self->at_command_start;
    self->lexer->in_array_literal = self->in_array_literal;
    self->lexer->in_assign_builtin = self->in_assign_builtin;
}

static void Parser_sync_parser(Parser *self) {
    self->pos = self->lexer->pos;
}

static Token * Parser_lex_peek_token(Parser *self) {
    if (((((((self->lexer->token_cache != NULL) && (self->lexer->token_cache->pos == self->pos)) && (self->lexer->cached_word_context == self->word_context)) && (self->lexer->cached_at_command_start == self->at_command_start)) && (self->lexer->cached_in_array_literal == self->in_array_literal)) && (self->lexer->cached_in_assign_builtin == self->in_assign_builtin))) {
        return self->lexer->token_cache;
    }
    int64_t saved_pos = self->pos;
    Parser_sync_lexer(self);
    Token * result = Lexer_peek_token(self->lexer);
    self->lexer->cached_word_context = self->word_context;
    self->lexer->cached_at_command_start = self->at_command_start;
    self->lexer->cached_in_array_literal = self->in_array_literal;
    self->lexer->cached_in_assign_builtin = self->in_assign_builtin;
    self->lexer->post_read_pos = self->lexer->pos;
    self->pos = saved_pos;
    return result;
}

static Token * Parser_lex_next_token(Parser *self) {
    Token * tok;
    if (((((((self->lexer->token_cache != NULL) && (self->lexer->token_cache->pos == self->pos)) && (self->lexer->cached_word_context == self->word_context)) && (self->lexer->cached_at_command_start == self->at_command_start)) && (self->lexer->cached_in_array_literal == self->in_array_literal)) && (self->lexer->cached_in_assign_builtin == self->in_assign_builtin))) {
        tok = Lexer_next_token(self->lexer);
        self->pos = self->lexer->post_read_pos;
        self->lexer->pos = self->lexer->post_read_pos;
    } else {
        Parser_sync_lexer(self);
        tok = Lexer_next_token(self->lexer);
        self->lexer->cached_word_context = self->word_context;
        self->lexer->cached_at_command_start = self->at_command_start;
        self->lexer->cached_in_array_literal = self->in_array_literal;
        self->lexer->cached_in_assign_builtin = self->in_assign_builtin;
        Parser_sync_parser(self);
    }
    Parser_record_token(self, tok);
    return tok;
}

static void Parser_lex_skip_blanks(Parser *self) {
    Parser_sync_lexer(self);
    Lexer_skip_blanks(self->lexer);
    Parser_sync_parser(self);
}

static bool Parser_lex_skip_comment(Parser *self) {
    Parser_sync_lexer(self);
    bool result = Lexer_skip_comment(self->lexer);
    Parser_sync_parser(self);
    return result;
}

static bool Parser_lex_is_command_terminator(Parser *self) {
    Token * tok = Parser_lex_peek_token(self);
    int64_t t = tok->type;
    return (((((((t == TOKENTYPE_EOF) || (t == TOKENTYPE_NEWLINE)) || (t == TOKENTYPE_PIPE)) || (t == TOKENTYPE_SEMI)) || (t == TOKENTYPE_LPAREN)) || (t == TOKENTYPE_RPAREN)) || (t == TOKENTYPE_AMP));
}

static Tuple_int64_t_constcharPtr Parser_lex_peek_operator(Parser *self) {
    Token * tok = Parser_lex_peek_token(self);
    int64_t t = tok->type;
    if ((((t >= TOKENTYPE_SEMI) && (t <= TOKENTYPE_GREATER)) || ((t >= TOKENTYPE_AND_AND) && (t <= TOKENTYPE_PIPE_AMP)))) {
        return (Tuple_int64_t_constcharPtr){t, tok->value};
    }
    return (Tuple_int64_t_constcharPtr){0, ""};
}

static const char * Parser_lex_peek_reserved_word(Parser *self) {
    Token * tok = Parser_lex_peek_token(self);
    if ((tok->type != TOKENTYPE_WORD)) {
        return "";
    }
    const char * word = tok->value;
    if (_str_endswith(word, "\\\n")) {
        word = _substring(g_arena, word, 0, (_rune_len(word) - 2));
    }
    if ((((strcmp(word, "if") == 0) || (strcmp(word, "then") == 0) || (strcmp(word, "elif") == 0) || (strcmp(word, "else") == 0) || (strcmp(word, "fi") == 0) || (strcmp(word, "while") == 0) || (strcmp(word, "until") == 0) || (strcmp(word, "for") == 0) || (strcmp(word, "select") == 0) || (strcmp(word, "do") == 0) || (strcmp(word, "done") == 0) || (strcmp(word, "case") == 0) || (strcmp(word, "esac") == 0) || (strcmp(word, "in") == 0) || (strcmp(word, "function") == 0) || (strcmp(word, "coproc") == 0)) || ((((((strcmp(word, "{") == 0) || (strcmp(word, "}") == 0)) || (strcmp(word, "[[") == 0)) || (strcmp(word, "]]") == 0)) || (strcmp(word, "!") == 0)) || (strcmp(word, "time") == 0)))) {
        return word;
    }
    return "";
}

static bool Parser_lex_is_at_reserved_word(Parser *self, const char * word) {
    const char * reserved = Parser_lex_peek_reserved_word(self);
    return (strcmp(reserved, word) == 0);
}

static bool Parser_lex_consume_word(Parser *self, const char * expected) {
    Token * tok = Parser_lex_peek_token(self);
    if ((tok->type != TOKENTYPE_WORD)) {
        return false;
    }
    const char * word = tok->value;
    if (_str_endswith(word, "\\\n")) {
        word = _substring(g_arena, word, 0, (_rune_len(word) - 2));
    }
    if ((strcmp(word, expected) == 0)) {
        Parser_lex_next_token(self);
        return true;
    }
    return false;
}

static const char * Parser_lex_peek_case_terminator(Parser *self) {
    Token * tok = Parser_lex_peek_token(self);
    int64_t t = tok->type;
    if ((t == TOKENTYPE_SEMI_SEMI)) {
        return ";;";
    }
    if ((t == TOKENTYPE_SEMI_AMP)) {
        return ";&";
    }
    if ((t == TOKENTYPE_SEMI_SEMI_AMP)) {
        return ";;&";
    }
    return "";
}

static bool Parser_at_end(Parser *self) {
    return (self->pos >= self->length);
}

static const char * Parser_peek(Parser *self) {
    if (Parser_at_end(self)) {
        return "";
    }
    return (const char *)(_char_at_str(g_arena, self->source, self->pos));
}

static const char * Parser_advance(Parser *self) {
    if (Parser_at_end(self)) {
        return "";
    }
    const char * ch = (const char *)(_char_at_str(g_arena, self->source, self->pos));
    self->pos += 1;
    return ch;
}

static const char * Parser_peek_at(Parser *self, int64_t offset) {
    int64_t pos = (self->pos + offset);
    if (((pos < 0) || (pos >= self->length))) {
        return "";
    }
    return (const char *)(_char_at_str(g_arena, self->source, pos));
}

static const char * Parser_lookahead(Parser *self, int64_t n) {
    return substring(self->source, self->pos, (self->pos + n));
}

static bool Parser_is_bang_followed_by_procsub(Parser *self) {
    if (((self->pos + 2) >= self->length)) {
        return false;
    }
    const char * next_char = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
    if (((strcmp(next_char, ">") != 0) && (strcmp(next_char, "<") != 0))) {
        return false;
    }
    return (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "(") == 0);
}

static void Parser_skip_whitespace(Parser *self) {
    while (!(Parser_at_end(self))) {
        Parser_lex_skip_blanks(self);
        if (Parser_at_end(self)) {
            break;
        }
        const char * ch = Parser_peek(self);
        if ((strcmp(ch, "#") == 0)) {
            Parser_lex_skip_comment(self);
        } else if (((strcmp(ch, "\\") == 0) && (strcmp(Parser_peek_at(self, 1), "\n") == 0))) {
            Parser_advance(self);
            Parser_advance(self);
        } else {
            break;
        }
    }
}

static void Parser_skip_whitespace_and_newlines(Parser *self) {
    while (!(Parser_at_end(self))) {
        const char * ch = Parser_peek(self);
        if (is_whitespace(ch)) {
            Parser_advance(self);
            if ((strcmp(ch, "\n") == 0)) {
                Parser_gather_heredoc_bodies(self);
                if (((self->cmdsub_heredoc_end != -(1)) && (self->cmdsub_heredoc_end > self->pos))) {
                    self->pos = self->cmdsub_heredoc_end;
                    self->cmdsub_heredoc_end = -(1);
                }
            }
        } else if ((strcmp(ch, "#") == 0)) {
            while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") != 0))) {
                Parser_advance(self);
            }
        } else if (((strcmp(ch, "\\") == 0) && (strcmp(Parser_peek_at(self, 1), "\n") == 0))) {
            Parser_advance(self);
            Parser_advance(self);
        } else {
            break;
        }
    }
}

static bool Parser_at_list_terminating_bracket(Parser *self) {
    if (Parser_at_end(self)) {
        return false;
    }
    const char * ch = Parser_peek(self);
    if (((strcmp(self->eof_token, "") != 0) && (strcmp(ch, self->eof_token) == 0))) {
        return true;
    }
    if ((strcmp(ch, ")") == 0)) {
        return true;
    }
    if ((strcmp(ch, "}") == 0)) {
        int64_t next_pos = (self->pos + 1);
        if ((next_pos >= self->length)) {
            return true;
        }
        return is_word_end_context((const char *)(_char_at_str(g_arena, self->source, next_pos)));
    }
    return false;
}

static bool Parser_at_eof_token(Parser *self) {
    if ((strcmp(self->eof_token, "") == 0)) {
        return false;
    }
    Token * tok = Parser_lex_peek_token(self);
    if ((strcmp(self->eof_token, ")") == 0)) {
        return (tok->type == TOKENTYPE_RPAREN);
    }
    if ((strcmp(self->eof_token, "}") == 0)) {
        return ((tok->type == TOKENTYPE_WORD) && (strcmp(tok->value, "}") == 0));
    }
    return false;
}

static Vec_Node Parser_collect_redirects(Parser *self) {
    Vec_Node redirects = (Vec_Node){NULL, 0, 0};
    while (true) {
        Parser_skip_whitespace(self);
        Node * redirect = Parser_parse_redirect(self);
        if ((redirect == NULL)) {
            break;
        }
        VEC_PUSH(g_arena, &redirects, (redirect));
    }
    return ((redirects.len > 0) ? redirects : (Vec_Node){NULL, 0, 0});
}

static Node * Parser_parse_loop_body(Parser *self, const char * context) {
    if ((strcmp(Parser_peek(self), "{") == 0)) {
        BraceGroup * brace = Parser_parse_brace_group(self);
        if ((brace == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_format(g_arena, "Expected brace group body in %v", context));
            return NULL;
        }
        return (Node *)brace->body;
    }
    if (Parser_lex_consume_word(self, "do")) {
        Node * body = (Node *)Parser_parse_list_until(self, NULL);
        if ((body == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'do'");
            return NULL;
        }
        Parser_skip_whitespace_and_newlines(self);
        if (!(Parser_lex_consume_word(self, "done"))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_format(g_arena, "Expected 'done' to close %v", context));
            return NULL;
        }
        return (Node *)body;
    }
    g_parse_error = 1;
    snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_format(g_arena, "Expected 'do' or '{' in %v", context));
    return NULL;
}

static const char * Parser_peek_word(Parser *self) {
    int64_t saved_pos = self->pos;
    Parser_skip_whitespace(self);
    if ((Parser_at_end(self) || is_metachar(Parser_peek(self)))) {
        self->pos = saved_pos;
        return "";
    }
    Vec_Str chars = (Vec_Str){NULL, 0, 0};
    while ((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self))))) {
        const char * ch = Parser_peek(self);
        if (is_quote(ch)) {
            break;
        }
        if ((((strcmp(ch, "\\") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\n") == 0))) {
            break;
        }
        if (((strcmp(ch, "\\") == 0) && ((self->pos + 1) < self->length))) {
            VEC_PUSH(g_arena, &chars, (Parser_advance(self)));
            VEC_PUSH(g_arena, &chars, (Parser_advance(self)));
            continue;
        }
        VEC_PUSH(g_arena, &chars, (Parser_advance(self)));
    }
    const char * word;
    if ((chars.len > 0)) {
        word = _str_join(g_arena, "", chars);
    } else {
        word = "";
    }
    self->pos = saved_pos;
    return word;
}

static bool Parser_consume_word(Parser *self, const char * expected) {
    int64_t saved_pos = self->pos;
    Parser_skip_whitespace(self);
    const char * word = Parser_peek_word(self);
    const char * keyword_word = word;
    bool has_leading_brace = false;
    if (((((strcmp(word, "") != 0) && self->in_process_sub) && (_rune_len(word) > 1)) && (strcmp((const char *)(_char_at_str(g_arena, word, 0)), "}") == 0))) {
        keyword_word = _substring(g_arena, word, 1, _rune_len(word));
        has_leading_brace = true;
    }
    if ((strcmp(keyword_word, expected) != 0)) {
        self->pos = saved_pos;
        return false;
    }
    Parser_skip_whitespace(self);
    if (has_leading_brace) {
        Parser_advance(self);
    }
    for (int _idx = 0; _idx < _rune_len(expected); _idx++) {
        Parser_advance(self);
    }
    while ((((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\n") == 0))) {
        Parser_advance(self);
        Parser_advance(self);
    }
    return true;
}

static bool Parser_is_word_terminator(Parser *self, int64_t ctx, const char * ch, int64_t bracket_depth, int64_t paren_depth) {
    Parser_sync_lexer(self);
    return Lexer_is_word_terminator(self->lexer, ctx, ch, bracket_depth, paren_depth);
}

static void Parser_scan_double_quote(Parser *self, Vec_Str * chars, Vec_Node parts, int64_t start, bool handle_line_continuation) {
    VEC_PUSH(g_arena, chars, ("\""));
    while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\"") != 0))) {
        const char * c = Parser_peek(self);
        if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
            const char * next_c = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
            if ((handle_line_continuation && (strcmp(next_c, "\n") == 0))) {
                Parser_advance(self);
                Parser_advance(self);
            } else {
                VEC_PUSH(g_arena, chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, chars, (Parser_advance(self)));
            }
        } else if ((strcmp(c, "$") == 0)) {
            if (!(Parser_parse_dollar_expansion(self, chars, &(parts), true))) {
                VEC_PUSH(g_arena, chars, (Parser_advance(self)));
            }
        } else {
            VEC_PUSH(g_arena, chars, (Parser_advance(self)));
        }
    }
    if (Parser_at_end(self)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated double quote");
        return;
    }
    VEC_PUSH(g_arena, chars, (Parser_advance(self)));
}

static bool Parser_parse_dollar_expansion(Parser *self, Vec_Str * chars, Vec_Node * parts, bool in_dquote) {
    Node * result0;
    const char * result1;
    if (((((self->pos + 2) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "(") == 0))) {
        Tuple_NodePtr_constcharPtr _tup59 = Parser_parse_arithmetic_expansion(self);
        result0 = _tup59.F0;
        result1 = _tup59.F1;
        if ((result0 != NULL)) {
            VEC_PUSH(g_arena, parts, (result0));
            VEC_PUSH(g_arena, chars, (result1));
            return true;
        }
        Tuple_NodePtr_constcharPtr _tup60 = Parser_parse_command_substitution(self);
        result0 = _tup60.F0;
        result1 = _tup60.F1;
        if ((result0 != NULL)) {
            VEC_PUSH(g_arena, parts, (result0));
            VEC_PUSH(g_arena, chars, (result1));
            return true;
        }
        return false;
    }
    if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "[") == 0))) {
        Tuple_NodePtr_constcharPtr _tup61 = Parser_parse_deprecated_arithmetic(self);
        result0 = _tup61.F0;
        result1 = _tup61.F1;
        if ((result0 != NULL)) {
            VEC_PUSH(g_arena, parts, (result0));
            VEC_PUSH(g_arena, chars, (result1));
            return true;
        }
        return false;
    }
    if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
        Tuple_NodePtr_constcharPtr _tup62 = Parser_parse_command_substitution(self);
        result0 = _tup62.F0;
        result1 = _tup62.F1;
        if ((result0 != NULL)) {
            VEC_PUSH(g_arena, parts, (result0));
            VEC_PUSH(g_arena, chars, (result1));
            return true;
        }
        return false;
    }
    Tuple_NodePtr_constcharPtr _tup63 = Parser_parse_param_expansion(self, in_dquote);
    result0 = _tup63.F0;
    result1 = _tup63.F1;
    if ((result0 != NULL)) {
        VEC_PUSH(g_arena, parts, (result0));
        VEC_PUSH(g_arena, chars, (result1));
        return true;
    }
    return false;
}

static Word * Parser_parse_word_internal(Parser *self, int64_t ctx, bool at_command_start, bool in_array_literal) {
    self->word_context = ctx;
    return Parser_parse_word(self, at_command_start, in_array_literal, false);
}

static Word * Parser_parse_word(Parser *self, bool at_command_start, bool in_array_literal, bool in_assign_builtin) {
    Parser_skip_whitespace(self);
    if (Parser_at_end(self)) {
        return NULL;
    }
    self->at_command_start = at_command_start;
    self->in_array_literal = in_array_literal;
    self->in_assign_builtin = in_assign_builtin;
    Token * tok = Parser_lex_peek_token(self);
    if ((tok->type != TOKENTYPE_WORD)) {
        self->at_command_start = false;
        self->in_array_literal = false;
        self->in_assign_builtin = false;
        return NULL;
    }
    Parser_lex_next_token(self);
    self->at_command_start = false;
    self->in_array_literal = false;
    self->in_assign_builtin = false;
    return tok->word;
}

static Tuple_NodePtr_constcharPtr Parser_parse_command_substitution(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    Parser_advance(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0))) {
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    Parser_advance(self);
    SavedParserState * saved = Parser_save_parser_state(self);
    Parser_set_state(self, (PARSERSTATEFLAGS_PST_CMDSUBST | PARSERSTATEFLAGS_PST_EOFTOKEN));
    self->eof_token = ")";
    Node * cmd = (Node *)Parser_parse_list(self, true);
    if ((cmd == NULL)) {
        cmd = (Node *)Empty_new("empty");
    }
    Parser_skip_whitespace_and_newlines(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
        Parser_restore_parser_state(self, saved);
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    Parser_advance(self);
    int64_t text_end = self->pos;
    const char * text = substring(self->source, start, text_end);
    Parser_restore_parser_state(self, saved);
    return (Tuple_NodePtr_constcharPtr){(Node *)CommandSubstitution_new(cmd, false, "cmdsub"), text};
}

static Tuple_NodePtr_constcharPtr Parser_parse_funsub(Parser *self, int64_t start) {
    Parser_sync_parser(self);
    if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "|") == 0))) {
        Parser_advance(self);
    }
    SavedParserState * saved = Parser_save_parser_state(self);
    Parser_set_state(self, (PARSERSTATEFLAGS_PST_CMDSUBST | PARSERSTATEFLAGS_PST_EOFTOKEN));
    self->eof_token = "}";
    Node * cmd = (Node *)Parser_parse_list(self, true);
    if ((cmd == NULL)) {
        cmd = (Node *)Empty_new("empty");
    }
    Parser_skip_whitespace_and_newlines(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "}") != 0))) {
        Parser_restore_parser_state(self, saved);
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `}'");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    Parser_advance(self);
    const char * text = substring(self->source, start, self->pos);
    Parser_restore_parser_state(self, saved);
    Parser_sync_lexer(self);
    return (Tuple_NodePtr_constcharPtr){(Node *)CommandSubstitution_new(cmd, true, "cmdsub"), text};
}

static bool Parser_is_assignment_word(Parser *self, Node * word) {
    return (assignment(((Word *)(word->data))->value, 0) != -(1));
}

static Tuple_NodePtr_constcharPtr Parser_parse_backtick_substitution(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "`") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    Parser_advance(self);
    Vec_Str content_chars = (Vec_Str){NULL, 0, 0};
    Vec_Str text_chars = (Vec_Str){(const char *[]){ "`" }, 1, 1};
    Vec_Tuple_constcharPtr_bool pending_heredocs = (Vec_Tuple_constcharPtr_bool){NULL, 0, 0};
    bool in_heredoc_body = false;
    const char * current_heredoc_delim = "";
    bool current_heredoc_strip = false;
    const char * ch;
    while ((!(Parser_at_end(self)) && (in_heredoc_body || (strcmp(Parser_peek(self), "`") != 0)))) {
        if (in_heredoc_body) {
            int64_t line_start = self->pos;
            int64_t line_end = line_start;
            while (((line_end < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, line_end)), "\n") != 0))) {
                line_end += 1;
            }
            const char * line = substring(self->source, line_start, line_end);
            const char * check_line = (current_heredoc_strip ? _str_ltrim(g_arena, line, "\t") : line);
            if ((strcmp(check_line, current_heredoc_delim) == 0)) {
                for (int _idx = 0; _idx < _rune_len(line); _idx++) {
                    int32_t ch = _rune_at(line, _idx);
                    VEC_PUSH(g_arena, &content_chars, (_rune_to_str(g_arena, ch)));
                    VEC_PUSH(g_arena, &text_chars, (_rune_to_str(g_arena, ch)));
                }
                self->pos = line_end;
                if (((self->pos < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, self->pos)), "\n") == 0))) {
                    VEC_PUSH(g_arena, &content_chars, ("\n"));
                    VEC_PUSH(g_arena, &text_chars, ("\n"));
                    Parser_advance(self);
                }
                in_heredoc_body = false;
                if ((pending_heredocs.len > 0)) {
                    current_heredoc_delim = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[0];
                    current_heredoc_strip = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[1];
                    in_heredoc_body = true;
                }
            } else if ((_str_startswith(check_line, current_heredoc_delim) && (_rune_len(check_line) > _rune_len(current_heredoc_delim)))) {
                int64_t tabs_stripped = (_rune_len(line) - _rune_len(check_line));
                int64_t end_pos = (tabs_stripped + _rune_len(current_heredoc_delim));
                for (int64_t i = 0; (i < end_pos); i++) {
                    VEC_PUSH(g_arena, &content_chars, ((const char *)(_char_at_str(g_arena, line, i))));
                    VEC_PUSH(g_arena, &text_chars, ((const char *)(_char_at_str(g_arena, line, i))));
                }
                self->pos = (line_start + end_pos);
                in_heredoc_body = false;
                if ((pending_heredocs.len > 0)) {
                    current_heredoc_delim = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[0];
                    current_heredoc_strip = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[1];
                    in_heredoc_body = true;
                }
            } else {
                for (int _idx = 0; _idx < _rune_len(line); _idx++) {
                    int32_t ch = _rune_at(line, _idx);
                    VEC_PUSH(g_arena, &content_chars, (_rune_to_str(g_arena, ch)));
                    VEC_PUSH(g_arena, &text_chars, (_rune_to_str(g_arena, ch)));
                }
                self->pos = line_end;
                if (((self->pos < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, self->pos)), "\n") == 0))) {
                    VEC_PUSH(g_arena, &content_chars, ("\n"));
                    VEC_PUSH(g_arena, &text_chars, ("\n"));
                    Parser_advance(self);
                }
            }
            continue;
        }
        const char * c = Parser_peek(self);
        if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
            const char * next_c = (const char *)(_char_at_str(g_arena, self->source, (self->pos + 1)));
            if ((strcmp(next_c, "\n") == 0)) {
                Parser_advance(self);
                Parser_advance(self);
            } else if (is_escape_char_in_backtick(next_c)) {
                Parser_advance(self);
                const char * escaped = Parser_advance(self);
                VEC_PUSH(g_arena, &content_chars, (escaped));
                VEC_PUSH(g_arena, &text_chars, ("\\"));
                VEC_PUSH(g_arena, &text_chars, (escaped));
            } else {
                ch = Parser_advance(self);
                VEC_PUSH(g_arena, &content_chars, (ch));
                VEC_PUSH(g_arena, &text_chars, (ch));
            }
            continue;
        }
        const char * quote;
        const char * dch;
        const char * closing;
        const char * esc;
        if ((((strcmp(c, "<") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "<") == 0))) {
            if ((((self->pos + 2) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "<") == 0))) {
                VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &text_chars, ("<"));
                VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &text_chars, ("<"));
                VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &text_chars, ("<"));
                while ((!(Parser_at_end(self)) && is_whitespace_no_newline(Parser_peek(self)))) {
                    ch = Parser_advance(self);
                    VEC_PUSH(g_arena, &content_chars, (ch));
                    VEC_PUSH(g_arena, &text_chars, (ch));
                }
                while (((!(Parser_at_end(self)) && !(is_whitespace(Parser_peek(self)))) && !_str_contains("()", Parser_peek(self)))) {
                    if (((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length))) {
                        ch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (ch));
                        VEC_PUSH(g_arena, &text_chars, (ch));
                        ch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (ch));
                        VEC_PUSH(g_arena, &text_chars, (ch));
                    } else if (_str_contains("\"'", Parser_peek(self))) {
                        quote = Parser_peek(self);
                        ch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (ch));
                        VEC_PUSH(g_arena, &text_chars, (ch));
                        while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), quote) != 0))) {
                            if (((strcmp(quote, "\"") == 0) && (strcmp(Parser_peek(self), "\\") == 0))) {
                                ch = Parser_advance(self);
                                VEC_PUSH(g_arena, &content_chars, (ch));
                                VEC_PUSH(g_arena, &text_chars, (ch));
                            }
                            ch = Parser_advance(self);
                            VEC_PUSH(g_arena, &content_chars, (ch));
                            VEC_PUSH(g_arena, &text_chars, (ch));
                        }
                        if (!(Parser_at_end(self))) {
                            ch = Parser_advance(self);
                            VEC_PUSH(g_arena, &content_chars, (ch));
                            VEC_PUSH(g_arena, &text_chars, (ch));
                        }
                    } else {
                        ch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (ch));
                        VEC_PUSH(g_arena, &text_chars, (ch));
                    }
                }
                continue;
            }
            VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
            VEC_PUSH(g_arena, &text_chars, ("<"));
            VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
            VEC_PUSH(g_arena, &text_chars, ("<"));
            bool strip_tabs = false;
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
                strip_tabs = true;
                VEC_PUSH(g_arena, &content_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &text_chars, ("-"));
            }
            while ((!(Parser_at_end(self)) && is_whitespace_no_newline(Parser_peek(self)))) {
                ch = Parser_advance(self);
                VEC_PUSH(g_arena, &content_chars, (ch));
                VEC_PUSH(g_arena, &text_chars, (ch));
            }
            Vec_Str delimiter_chars = (Vec_Str){NULL, 0, 0};
            if (!(Parser_at_end(self))) {
                ch = Parser_peek(self);
                if (is_quote(ch)) {
                    quote = Parser_advance(self);
                    VEC_PUSH(g_arena, &content_chars, (quote));
                    VEC_PUSH(g_arena, &text_chars, (quote));
                    while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), quote) != 0))) {
                        dch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (dch));
                        VEC_PUSH(g_arena, &text_chars, (dch));
                        VEC_PUSH(g_arena, &delimiter_chars, (dch));
                    }
                    if (!(Parser_at_end(self))) {
                        closing = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (closing));
                        VEC_PUSH(g_arena, &text_chars, (closing));
                    }
                } else if ((strcmp(ch, "\\") == 0)) {
                    esc = Parser_advance(self);
                    VEC_PUSH(g_arena, &content_chars, (esc));
                    VEC_PUSH(g_arena, &text_chars, (esc));
                    if (!(Parser_at_end(self))) {
                        dch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (dch));
                        VEC_PUSH(g_arena, &text_chars, (dch));
                        VEC_PUSH(g_arena, &delimiter_chars, (dch));
                    }
                    while ((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self))))) {
                        dch = Parser_advance(self);
                        VEC_PUSH(g_arena, &content_chars, (dch));
                        VEC_PUSH(g_arena, &text_chars, (dch));
                        VEC_PUSH(g_arena, &delimiter_chars, (dch));
                    }
                } else {
                    while (((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self)))) && (strcmp(Parser_peek(self), "`") != 0))) {
                        ch = Parser_peek(self);
                        if (is_quote(ch)) {
                            quote = Parser_advance(self);
                            VEC_PUSH(g_arena, &content_chars, (quote));
                            VEC_PUSH(g_arena, &text_chars, (quote));
                            while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), quote) != 0))) {
                                dch = Parser_advance(self);
                                VEC_PUSH(g_arena, &content_chars, (dch));
                                VEC_PUSH(g_arena, &text_chars, (dch));
                                VEC_PUSH(g_arena, &delimiter_chars, (dch));
                            }
                            if (!(Parser_at_end(self))) {
                                closing = Parser_advance(self);
                                VEC_PUSH(g_arena, &content_chars, (closing));
                                VEC_PUSH(g_arena, &text_chars, (closing));
                            }
                        } else if ((strcmp(ch, "\\") == 0)) {
                            esc = Parser_advance(self);
                            VEC_PUSH(g_arena, &content_chars, (esc));
                            VEC_PUSH(g_arena, &text_chars, (esc));
                            if (!(Parser_at_end(self))) {
                                dch = Parser_advance(self);
                                VEC_PUSH(g_arena, &content_chars, (dch));
                                VEC_PUSH(g_arena, &text_chars, (dch));
                                VEC_PUSH(g_arena, &delimiter_chars, (dch));
                            }
                        } else {
                            dch = Parser_advance(self);
                            VEC_PUSH(g_arena, &content_chars, (dch));
                            VEC_PUSH(g_arena, &text_chars, (dch));
                            VEC_PUSH(g_arena, &delimiter_chars, (dch));
                        }
                    }
                }
            }
            const char * delimiter = _str_join(g_arena, "", delimiter_chars);
            if ((delimiter != NULL && delimiter[0] != '\0')) {
                VEC_PUSH(g_arena, &pending_heredocs, ((Tuple_constcharPtr_bool){delimiter, strip_tabs}));
            }
            continue;
        }
        if ((strcmp(c, "\n") == 0)) {
            ch = Parser_advance(self);
            VEC_PUSH(g_arena, &content_chars, (ch));
            VEC_PUSH(g_arena, &text_chars, (ch));
            if ((pending_heredocs.len > 0)) {
                current_heredoc_delim = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[0];
                current_heredoc_strip = ((void **)&(pending_heredocs.data[--pending_heredocs.len]))[1];
                in_heredoc_body = true;
            }
            continue;
        }
        ch = Parser_advance(self);
        VEC_PUSH(g_arena, &content_chars, (ch));
        VEC_PUSH(g_arena, &text_chars, (ch));
    }
    if (Parser_at_end(self)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated backtick");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    Parser_advance(self);
    VEC_PUSH(g_arena, &text_chars, ("`"));
    const char * text = _str_join(g_arena, "", text_chars);
    const char * content = _str_join(g_arena, "", content_chars);
    if ((pending_heredocs.len > 0)) {
        Tuple_int64_t_int64_t _tup64 = find_heredoc_content_end(self->source, self->pos, pending_heredocs);
        int64_t heredoc_start = _tup64.F0;
        int64_t heredoc_end = _tup64.F1;
        if ((heredoc_end > heredoc_start)) {
            content = _str_concat(g_arena, content, substring(self->source, heredoc_start, heredoc_end));
            if ((self->cmdsub_heredoc_end == -(1))) {
                self->cmdsub_heredoc_end = heredoc_end;
            } else {
                self->cmdsub_heredoc_end = ((self->cmdsub_heredoc_end > heredoc_end) ? self->cmdsub_heredoc_end : heredoc_end);
            }
        }
    }
    Parser * sub_parser = new_parser(content, false, self->extglob);
    Node * cmd = (Node *)Parser_parse_list(sub_parser, true);
    if ((cmd == NULL)) {
        cmd = Empty_new("empty");
    }
    return (Tuple_NodePtr_constcharPtr){(Node *)CommandSubstitution_new(cmd, false, "cmdsub"), text};
}

static Tuple_NodePtr_constcharPtr Parser_parse_process_substitution(Parser *self) {
    if ((Parser_at_end(self) || !(is_redirect_char(Parser_peek(self))))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    const char * direction = Parser_advance(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0))) {
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    Parser_advance(self);
    SavedParserState * saved = Parser_save_parser_state(self);
    bool old_in_process_sub = self->in_process_sub;
    self->in_process_sub = true;
    Parser_set_state(self, PARSERSTATEFLAGS_PST_EOFTOKEN);
    self->eof_token = ")";
    // try {
    Node * cmd = (Node *)Parser_parse_list(self, true);
    if ((cmd == NULL)) {
        cmd = (Node *)Empty_new("empty");
    }
    Parser_skip_whitespace_and_newlines(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Invalid process substitution");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    Parser_advance(self);
    int64_t text_end = self->pos;
    const char * text = substring(self->source, start, text_end);
    text = strip_line_continuations_comment_aware(text);
    Parser_restore_parser_state(self, saved);
    self->in_process_sub = old_in_process_sub;
    return (Tuple_NodePtr_constcharPtr){(Node *)ProcessSubstitution_new(direction, cmd, "procsub"), text};
    // } catch handled via error returns
}

static Tuple_NodePtr_constcharPtr Parser_parse_array_literal(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    Parser_advance(self);
    Parser_set_state(self, PARSERSTATEFLAGS_PST_COMPASSIGN);
    Vec_Word elements = (Vec_Word){NULL, 0, 0};
    while (true) {
        Parser_skip_whitespace_and_newlines(self);
        if (Parser_at_end(self)) {
            Parser_clear_state(self, PARSERSTATEFLAGS_PST_COMPASSIGN);
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated array literal");
            return (Tuple_NodePtr_constcharPtr){NULL, NULL};
        }
        if ((strcmp(Parser_peek(self), ")") == 0)) {
            break;
        }
        Word * word = Parser_parse_word(self, false, true, false);
        if ((word == NULL)) {
            if ((strcmp(Parser_peek(self), ")") == 0)) {
                break;
            }
            Parser_clear_state(self, PARSERSTATEFLAGS_PST_COMPASSIGN);
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected word in array literal");
            return (Tuple_NodePtr_constcharPtr){NULL, NULL};
        }
        VEC_PUSH(g_arena, &elements, (word));
    }
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
        Parser_clear_state(self, PARSERSTATEFLAGS_PST_COMPASSIGN);
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ) to close array literal");
        return (Tuple_NodePtr_constcharPtr){NULL, NULL};
    }
    Parser_advance(self);
    const char * text = substring(self->source, start, self->pos);
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_COMPASSIGN);
    return (Tuple_NodePtr_constcharPtr){(Node *)Array_new(elements, "array"), text};
}

static Tuple_NodePtr_constcharPtr Parser_parse_arithmetic_expansion(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    if (((((self->pos + 2) >= self->length) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") != 0)) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2))), "(") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    Parser_advance(self);
    Parser_advance(self);
    Parser_advance(self);
    int64_t content_start = self->pos;
    int64_t depth = 2;
    int64_t first_close_pos = -(1);
    while ((!(Parser_at_end(self)) && (depth > 0))) {
        const char * c = Parser_peek(self);
        if ((strcmp(c, "'") == 0)) {
            Parser_advance(self);
            while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0))) {
                Parser_advance(self);
            }
            if (!(Parser_at_end(self))) {
                Parser_advance(self);
            }
        } else if ((strcmp(c, "\"") == 0)) {
            Parser_advance(self);
            while (!(Parser_at_end(self))) {
                if (((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length))) {
                    Parser_advance(self);
                    Parser_advance(self);
                } else if ((strcmp(Parser_peek(self), "\"") == 0)) {
                    Parser_advance(self);
                    break;
                } else {
                    Parser_advance(self);
                }
            }
        } else if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
            Parser_advance(self);
            Parser_advance(self);
        } else if ((strcmp(c, "(") == 0)) {
            depth += 1;
            Parser_advance(self);
        } else if ((strcmp(c, ")") == 0)) {
            if ((depth == 2)) {
                int64_t first_close_pos = self->pos;
            }
            depth -= 1;
            if ((depth == 0)) {
                break;
            }
            Parser_advance(self);
        } else {
            if ((depth == 1)) {
                first_close_pos = -(1);
            }
            Parser_advance(self);
        }
    }
    if ((depth != 0)) {
        if (Parser_at_end(self)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `))'");
            return (Tuple_NodePtr_constcharPtr){NULL, NULL};
        }
        self->pos = start;
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    const char * content;
    if ((first_close_pos != -(1))) {
        content = substring(self->source, content_start, first_close_pos);
    } else {
        content = substring(self->source, content_start, self->pos);
    }
    Parser_advance(self);
    const char * text = substring(self->source, start, self->pos);
    // try {
    Node * expr;
    expr = (Node *)Parser_parse_arith_expr(self, content);
    // } catch handled via error returns
    return (Tuple_NodePtr_constcharPtr){(Node *)ArithmeticExpansion_new(expr, "arith"), text};
}

static Node * Parser_parse_arith_expr(Parser *self, const char * content) {
    const char * saved_arith_src = self->arith_src;
    int64_t saved_arith_pos = self->arith_pos;
    int64_t saved_arith_len = self->arith_len;
    int64_t saved_parser_state = self->parser_state;
    Parser_set_state(self, PARSERSTATEFLAGS_PST_ARITH);
    self->arith_src = content;
    self->arith_pos = 0;
    self->arith_len = _rune_len(content);
    Parser_arith_skip_ws(self);
    Node * result;
    if (Parser_arith_at_end(self)) {
        result = (Node *)NULL;
    } else {
        result = (Node *)Parser_arith_parse_comma(self);
    }
    self->parser_state = saved_parser_state;
    if ((strcmp(saved_arith_src, "") != 0)) {
        self->arith_src = saved_arith_src;
        self->arith_pos = saved_arith_pos;
        self->arith_len = saved_arith_len;
    }
    return (Node *)result;
}

static bool Parser_arith_at_end(Parser *self) {
    return (self->arith_pos >= self->arith_len);
}

static const char * Parser_arith_peek(Parser *self, int64_t offset) {
    int64_t pos = (self->arith_pos + offset);
    if ((pos >= self->arith_len)) {
        return "";
    }
    return (const char *)(_char_at_str(g_arena, self->arith_src, pos));
}

static const char * Parser_arith_advance(Parser *self) {
    if (Parser_arith_at_end(self)) {
        return "";
    }
    const char * c = (const char *)(_char_at_str(g_arena, self->arith_src, self->arith_pos));
    self->arith_pos += 1;
    return c;
}

static void Parser_arith_skip_ws(Parser *self) {
    while (!(Parser_arith_at_end(self))) {
        const char * c = (const char *)(_char_at_str(g_arena, self->arith_src, self->arith_pos));
        if (is_whitespace(c)) {
            self->arith_pos += 1;
        } else if ((((strcmp(c, "\\") == 0) && ((self->arith_pos + 1) < self->arith_len)) && (strcmp((const char *)(_char_at_str(g_arena, self->arith_src, (self->arith_pos + 1))), "\n") == 0))) {
            self->arith_pos += 2;
        } else {
            break;
        }
    }
}

static bool Parser_arith_match(Parser *self, const char * s) {
    return starts_with_at(self->arith_src, self->arith_pos, s);
}

static bool Parser_arith_consume(Parser *self, const char * s) {
    if (Parser_arith_match(self, s)) {
        self->arith_pos += _rune_len(s);
        return true;
    }
    return false;
}

static Node * Parser_arith_parse_comma(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_assign(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (Parser_arith_consume(self, ",")) {
            Parser_arith_skip_ws(self);
            Node * right = (Node *)Parser_arith_parse_assign(self);
            left = (Node *)ArithComma_new(left, right, "comma");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_assign(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_ternary(self);
    Parser_arith_skip_ws(self);
    Vec_Str assign_ops = (Vec_Str){(const char *[]){ "<<=", ">>=", "+=", "-=", "*=", "/=", "%=", "&=", "^=", "|=", "=" }, 11, 11};
    for (size_t _idx = 0; _idx < assign_ops.len; _idx++) {
        Any * op = assign_ops.data[_idx];
        if (Parser_arith_match(self, op)) {
            if (((strcmp(op, "=") == 0) && (strcmp(Parser_arith_peek(self, 1), "=") == 0))) {
                break;
            }
            Parser_arith_consume(self, op);
            Parser_arith_skip_ws(self);
            Node * right = (Node *)Parser_arith_parse_assign(self);
            return ArithAssign_new(op, left, right, "assign");
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_ternary(Parser *self) {
    Node * cond = (Node *)Parser_arith_parse_logical_or(self);
    Parser_arith_skip_ws(self);
    Node * if_true;
    Node * if_false;
    if (Parser_arith_consume(self, "?")) {
        Parser_arith_skip_ws(self);
        if (Parser_arith_match(self, ":")) {
            if_true = (Node *)NULL;
        } else {
            if_true = (Node *)Parser_arith_parse_assign(self);
        }
        Parser_arith_skip_ws(self);
        if (Parser_arith_consume(self, ":")) {
            Parser_arith_skip_ws(self);
            if ((Parser_arith_at_end(self) || (strcmp(Parser_arith_peek(self, 0), ")") == 0))) {
                if_false = (Node *)NULL;
            } else {
                if_false = (Node *)Parser_arith_parse_ternary(self);
            }
        } else {
            if_false = (Node *)NULL;
        }
        return ArithTernary_new(cond, if_true, if_false, "ternary");
    }
    return (Node *)cond;
}

static Node * Parser_arith_parse_left_assoc(Parser *self, Vec_Str ops, Node * (*parsefn)(Parser *)) {
    Any * left = parsefn(self);
    while (true) {
        Parser_arith_skip_ws(self);
        bool matched = false;
        for (size_t _idx = 0; _idx < ops.len; _idx++) {
            const char * op = ops.data[_idx];
            if (Parser_arith_match(self, op)) {
                Parser_arith_consume(self, op);
                Parser_arith_skip_ws(self);
                left = ArithBinaryOp_new(op, left, parsefn(self), "binary-op");
                matched = true;
                break;
            }
        }
        if (!(matched)) {
            break;
        }
    }
    return left;
}

static Node * Parser_arith_parse_logical_or(Parser *self) {
    return (Node *)Parser_arith_parse_left_assoc(self, (Vec_Str){(const char *[]){ "||" }, 1, 1}, Parser_arith_parse_logical_and);
}

static Node * Parser_arith_parse_logical_and(Parser *self) {
    return (Node *)Parser_arith_parse_left_assoc(self, (Vec_Str){(const char *[]){ "&&" }, 1, 1}, Parser_arith_parse_bitwise_or);
}

static Node * Parser_arith_parse_bitwise_or(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_bitwise_xor(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (((strcmp(Parser_arith_peek(self, 0), "|") == 0) && ((strcmp(Parser_arith_peek(self, 1), "|") != 0) && (strcmp(Parser_arith_peek(self, 1), "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            Node * right = (Node *)Parser_arith_parse_bitwise_xor(self);
            left = (Node *)ArithBinaryOp_new("|", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_bitwise_xor(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_bitwise_and(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (((strcmp(Parser_arith_peek(self, 0), "^") == 0) && (strcmp(Parser_arith_peek(self, 1), "=") != 0))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            Node * right = (Node *)Parser_arith_parse_bitwise_and(self);
            left = (Node *)ArithBinaryOp_new("^", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_bitwise_and(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_equality(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (((strcmp(Parser_arith_peek(self, 0), "&") == 0) && ((strcmp(Parser_arith_peek(self, 1), "&") != 0) && (strcmp(Parser_arith_peek(self, 1), "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            Node * right = (Node *)Parser_arith_parse_equality(self);
            left = (Node *)ArithBinaryOp_new("&", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_equality(Parser *self) {
    return (Node *)Parser_arith_parse_left_assoc(self, (Vec_Str){(const char *[]){ "==", "!=" }, 2, 2}, Parser_arith_parse_comparison);
}

static Node * Parser_arith_parse_comparison(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_shift(self);
    while (true) {
        Parser_arith_skip_ws(self);
        Node * right;
        if (Parser_arith_match(self, "<=")) {
            Parser_arith_consume(self, "<=");
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_shift(self);
            left = (Node *)ArithBinaryOp_new("<=", left, right, "binary-op");
        } else if (Parser_arith_match(self, ">=")) {
            Parser_arith_consume(self, ">=");
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_shift(self);
            left = (Node *)ArithBinaryOp_new(">=", left, right, "binary-op");
        } else if (((strcmp(Parser_arith_peek(self, 0), "<") == 0) && ((strcmp(Parser_arith_peek(self, 1), "<") != 0) && (strcmp(Parser_arith_peek(self, 1), "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_shift(self);
            left = (Node *)ArithBinaryOp_new("<", left, right, "binary-op");
        } else if (((strcmp(Parser_arith_peek(self, 0), ">") == 0) && ((strcmp(Parser_arith_peek(self, 1), ">") != 0) && (strcmp(Parser_arith_peek(self, 1), "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_shift(self);
            left = (Node *)ArithBinaryOp_new(">", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_shift(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_additive(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (Parser_arith_match(self, "<<=")) {
            break;
        }
        if (Parser_arith_match(self, ">>=")) {
            break;
        }
        Node * right;
        if (Parser_arith_match(self, "<<")) {
            Parser_arith_consume(self, "<<");
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_additive(self);
            left = (Node *)ArithBinaryOp_new("<<", left, right, "binary-op");
        } else if (Parser_arith_match(self, ">>")) {
            Parser_arith_consume(self, ">>");
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_additive(self);
            left = (Node *)ArithBinaryOp_new(">>", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_additive(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_multiplicative(self);
    while (true) {
        Parser_arith_skip_ws(self);
        const char * c = Parser_arith_peek(self, 0);
        const char * c2 = Parser_arith_peek(self, 1);
        Node * right;
        if (((strcmp(c, "+") == 0) && ((strcmp(c2, "+") != 0) && (strcmp(c2, "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_multiplicative(self);
            left = (Node *)ArithBinaryOp_new("+", left, right, "binary-op");
        } else if (((strcmp(c, "-") == 0) && ((strcmp(c2, "-") != 0) && (strcmp(c2, "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_multiplicative(self);
            left = (Node *)ArithBinaryOp_new("-", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_multiplicative(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_exponentiation(self);
    while (true) {
        Parser_arith_skip_ws(self);
        const char * c = Parser_arith_peek(self, 0);
        const char * c2 = Parser_arith_peek(self, 1);
        Node * right;
        if (((strcmp(c, "*") == 0) && ((strcmp(c2, "*") != 0) && (strcmp(c2, "=") != 0)))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_exponentiation(self);
            left = (Node *)ArithBinaryOp_new("*", left, right, "binary-op");
        } else if (((strcmp(c, "/") == 0) && (strcmp(c2, "=") != 0))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_exponentiation(self);
            left = (Node *)ArithBinaryOp_new("/", left, right, "binary-op");
        } else if (((strcmp(c, "%") == 0) && (strcmp(c2, "=") != 0))) {
            Parser_arith_advance(self);
            Parser_arith_skip_ws(self);
            right = (Node *)Parser_arith_parse_exponentiation(self);
            left = (Node *)ArithBinaryOp_new("%", left, right, "binary-op");
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_exponentiation(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_unary(self);
    Parser_arith_skip_ws(self);
    if (Parser_arith_match(self, "**")) {
        Parser_arith_consume(self, "**");
        Parser_arith_skip_ws(self);
        Node * right = (Node *)Parser_arith_parse_exponentiation(self);
        return ArithBinaryOp_new("**", left, right, "binary-op");
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_unary(Parser *self) {
    Parser_arith_skip_ws(self);
    Node * operand;
    if (Parser_arith_match(self, "++")) {
        Parser_arith_consume(self, "++");
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithPreIncr_new(operand, "pre-incr");
    }
    if (Parser_arith_match(self, "--")) {
        Parser_arith_consume(self, "--");
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithPreDecr_new(operand, "pre-decr");
    }
    const char * c = Parser_arith_peek(self, 0);
    if ((strcmp(c, "!") == 0)) {
        Parser_arith_advance(self);
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithUnaryOp_new("!", operand, "unary-op");
    }
    if ((strcmp(c, "~") == 0)) {
        Parser_arith_advance(self);
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithUnaryOp_new("~", operand, "unary-op");
    }
    if (((strcmp(c, "+") == 0) && (strcmp(Parser_arith_peek(self, 1), "+") != 0))) {
        Parser_arith_advance(self);
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithUnaryOp_new("+", operand, "unary-op");
    }
    if (((strcmp(c, "-") == 0) && (strcmp(Parser_arith_peek(self, 1), "-") != 0))) {
        Parser_arith_advance(self);
        Parser_arith_skip_ws(self);
        operand = (Node *)Parser_arith_parse_unary(self);
        return ArithUnaryOp_new("-", operand, "unary-op");
    }
    return (Node *)Parser_arith_parse_postfix(self);
}

static Node * Parser_arith_parse_postfix(Parser *self) {
    Node * left = (Node *)Parser_arith_parse_primary(self);
    while (true) {
        Parser_arith_skip_ws(self);
        if (Parser_arith_match(self, "++")) {
            Parser_arith_consume(self, "++");
            left = (Node *)ArithPostIncr_new(left, "post-incr");
        } else if (Parser_arith_match(self, "--")) {
            Parser_arith_consume(self, "--");
            left = (Node *)ArithPostDecr_new(left, "post-decr");
        } else if ((strcmp(Parser_arith_peek(self, 0), "[") == 0)) {
            Node * index;
            void *_data65 = left->data;
            switch (left->kind) {
            case KIND_ARITHVAR: {
                ArithVar *left = (ArithVar *)_data65;
                Parser_arith_advance(self);
                Parser_arith_skip_ws(self);
                index = (Node *)Parser_arith_parse_comma(self);
                Parser_arith_skip_ws(self);
                if (!(Parser_arith_consume(self, "]"))) {
                    g_parse_error = 1;
                    snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ']' in array subscript");
                    return NULL;
                }
                left = ArithSubscript_new(left->name, index, "subscript");
                break;
            }
            default: {
                break;
            }
            }
        } else {
            break;
        }
    }
    return (Node *)left;
}

static Node * Parser_arith_parse_primary(Parser *self) {
    Parser_arith_skip_ws(self);
    const char * c = Parser_arith_peek(self, 0);
    if ((strcmp(c, "(") == 0)) {
        Parser_arith_advance(self);
        Parser_arith_skip_ws(self);
        Node * expr = (Node *)Parser_arith_parse_comma(self);
        Parser_arith_skip_ws(self);
        if (!(Parser_arith_consume(self, ")"))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ')' in arithmetic expression");
            return NULL;
        }
        return (Node *)expr;
    }
    if (((strcmp(c, "#") == 0) && (strcmp(Parser_arith_peek(self, 1), "$") == 0))) {
        Parser_arith_advance(self);
        return (Node *)Parser_arith_parse_expansion(self);
    }
    if ((strcmp(c, "$") == 0)) {
        return (Node *)Parser_arith_parse_expansion(self);
    }
    if ((strcmp(c, "'") == 0)) {
        return (Node *)Parser_arith_parse_single_quote(self);
    }
    if ((strcmp(c, "\"") == 0)) {
        return (Node *)Parser_arith_parse_double_quote(self);
    }
    if ((strcmp(c, "`") == 0)) {
        return (Node *)Parser_arith_parse_backtick(self);
    }
    if ((strcmp(c, "\\") == 0)) {
        Parser_arith_advance(self);
        if (Parser_arith_at_end(self)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unexpected end after backslash in arithmetic");
            return NULL;
        }
        const char * escaped_char = Parser_arith_advance(self);
        return ArithEscape_new(escaped_char, "escape");
    }
    if ((Parser_arith_at_end(self) || _str_contains(")]:,;?|&<>=!+-*/%^~#{}", c))) {
        return ArithEmpty_new("empty");
    }
    return (Node *)Parser_arith_parse_number_or_var(self);
}

static Node * Parser_arith_parse_expansion(Parser *self) {
    if (!(Parser_arith_consume(self, "$"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected '$'");
        return NULL;
    }
    const char * c = Parser_arith_peek(self, 0);
    if ((strcmp(c, "(") == 0)) {
        return (Node *)Parser_arith_parse_cmdsub(self);
    }
    if ((strcmp(c, "{") == 0)) {
        return (Node *)Parser_arith_parse_braced_param(self);
    }
    Vec_Str name_chars = (Vec_Str){NULL, 0, 0};
    while (!(Parser_arith_at_end(self))) {
        const char * ch = Parser_arith_peek(self, 0);
        if ((_str_is_alnum(ch) || (strcmp(ch, "_") == 0))) {
            VEC_PUSH(g_arena, &name_chars, (Parser_arith_advance(self)));
        } else if (((is_special_param_or_digit(ch) || (strcmp(ch, "#") == 0)) && !((name_chars.len > 0)))) {
            VEC_PUSH(g_arena, &name_chars, (Parser_arith_advance(self)));
            break;
        } else {
            break;
        }
    }
    if (!((name_chars.len > 0))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected variable name after $");
        return NULL;
    }
    return ParamExpansion_new(_str_join(g_arena, "", name_chars), NULL, NULL, "param");
}

static Node * Parser_arith_parse_cmdsub(Parser *self) {
    Parser_arith_advance(self);
    int64_t depth;
    int64_t content_start;
    const char * ch;
    const char * content;
    if ((strcmp(Parser_arith_peek(self, 0), "(") == 0)) {
        Parser_arith_advance(self);
        depth = 1;
        content_start = self->arith_pos;
        while ((!(Parser_arith_at_end(self)) && (depth > 0))) {
            ch = Parser_arith_peek(self, 0);
            if ((strcmp(ch, "(") == 0)) {
                depth += 1;
                Parser_arith_advance(self);
            } else if ((strcmp(ch, ")") == 0)) {
                if (((depth == 1) && (strcmp(Parser_arith_peek(self, 1), ")") == 0))) {
                    break;
                }
                depth -= 1;
                Parser_arith_advance(self);
            } else {
                Parser_arith_advance(self);
            }
        }
        content = substring(self->arith_src, content_start, self->arith_pos);
        Parser_arith_advance(self);
        Parser_arith_advance(self);
        Node * inner_expr = (Node *)Parser_parse_arith_expr(self, content);
        return ArithmeticExpansion_new(inner_expr, "arith");
    }
    depth = 1;
    content_start = self->arith_pos;
    while ((!(Parser_arith_at_end(self)) && (depth > 0))) {
        ch = Parser_arith_peek(self, 0);
        if ((strcmp(ch, "(") == 0)) {
            depth += 1;
            Parser_arith_advance(self);
        } else if ((strcmp(ch, ")") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                break;
            }
            Parser_arith_advance(self);
        } else {
            Parser_arith_advance(self);
        }
    }
    content = substring(self->arith_src, content_start, self->arith_pos);
    Parser_arith_advance(self);
    Parser * sub_parser = new_parser(content, false, self->extglob);
    Node * cmd = (Node *)Parser_parse_list(sub_parser, true);
    return CommandSubstitution_new(cmd, false, "cmdsub");
}

static Node * Parser_arith_parse_braced_param(Parser *self) {
    Parser_arith_advance(self);
    Vec_Str name_chars;
    if ((strcmp(Parser_arith_peek(self, 0), "!") == 0)) {
        Parser_arith_advance(self);
        name_chars = (Vec_Str){NULL, 0, 0};
        while ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "}") != 0))) {
            VEC_PUSH(g_arena, &name_chars, (Parser_arith_advance(self)));
        }
        Parser_arith_consume(self, "}");
        return ParamIndirect_new(_str_join(g_arena, "", name_chars), NULL, NULL, "param-indirect");
    }
    if ((strcmp(Parser_arith_peek(self, 0), "#") == 0)) {
        Parser_arith_advance(self);
        name_chars = (Vec_Str){NULL, 0, 0};
        while ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "}") != 0))) {
            VEC_PUSH(g_arena, &name_chars, (Parser_arith_advance(self)));
        }
        Parser_arith_consume(self, "}");
        return ParamLength_new(_str_join(g_arena, "", name_chars), "param-len");
    }
    name_chars = (Vec_Str){NULL, 0, 0};
    const char * ch;
    while (!(Parser_arith_at_end(self))) {
        ch = Parser_arith_peek(self, 0);
        if ((strcmp(ch, "}") == 0)) {
            Parser_arith_advance(self);
            return ParamExpansion_new(_str_join(g_arena, "", name_chars), NULL, NULL, "param");
        }
        if (is_param_expansion_op(ch)) {
            break;
        }
        VEC_PUSH(g_arena, &name_chars, (Parser_arith_advance(self)));
    }
    const char * name = _str_join(g_arena, "", name_chars);
    Vec_Str op_chars = (Vec_Str){NULL, 0, 0};
    int64_t depth = 1;
    while ((!(Parser_arith_at_end(self)) && (depth > 0))) {
        ch = Parser_arith_peek(self, 0);
        if ((strcmp(ch, "{") == 0)) {
            depth += 1;
            VEC_PUSH(g_arena, &op_chars, (Parser_arith_advance(self)));
        } else if ((strcmp(ch, "}") == 0)) {
            depth -= 1;
            if ((depth == 0)) {
                break;
            }
            VEC_PUSH(g_arena, &op_chars, (Parser_arith_advance(self)));
        } else {
            VEC_PUSH(g_arena, &op_chars, (Parser_arith_advance(self)));
        }
    }
    Parser_arith_consume(self, "}");
    const char * op_str = _str_join(g_arena, "", op_chars);
    if (_str_startswith(op_str, ":-")) {
        return ParamExpansion_new(name, ":-", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, ":=")) {
        return ParamExpansion_new(name, ":=", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, ":+")) {
        return ParamExpansion_new(name, ":+", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, ":?")) {
        return ParamExpansion_new(name, ":?", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, ":")) {
        return ParamExpansion_new(name, ":", substring(op_str, 1, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "##")) {
        return ParamExpansion_new(name, "##", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "#")) {
        return ParamExpansion_new(name, "#", substring(op_str, 1, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "%%")) {
        return ParamExpansion_new(name, "%%", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "%")) {
        return ParamExpansion_new(name, "%", substring(op_str, 1, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "//")) {
        return ParamExpansion_new(name, "//", substring(op_str, 2, _rune_len(op_str)), "param");
    }
    if (_str_startswith(op_str, "/")) {
        return ParamExpansion_new(name, "/", substring(op_str, 1, _rune_len(op_str)), "param");
    }
    return ParamExpansion_new(name, "", op_str, "param");
}

static Node * Parser_arith_parse_single_quote(Parser *self) {
    Parser_arith_advance(self);
    int64_t content_start = self->arith_pos;
    while ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "'") != 0))) {
        Parser_arith_advance(self);
    }
    const char * content = substring(self->arith_src, content_start, self->arith_pos);
    if (!(Parser_arith_consume(self, "'"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated single quote in arithmetic");
        return NULL;
    }
    return ArithNumber_new(content, "number");
}

static Node * Parser_arith_parse_double_quote(Parser *self) {
    Parser_arith_advance(self);
    int64_t content_start = self->arith_pos;
    while ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "\"") != 0))) {
        const char * c = Parser_arith_peek(self, 0);
        if (((strcmp(c, "\\") == 0) && !(Parser_arith_at_end(self)))) {
            Parser_arith_advance(self);
            Parser_arith_advance(self);
        } else {
            Parser_arith_advance(self);
        }
    }
    const char * content = substring(self->arith_src, content_start, self->arith_pos);
    if (!(Parser_arith_consume(self, "\""))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated double quote in arithmetic");
        return NULL;
    }
    return ArithNumber_new(content, "number");
}

static Node * Parser_arith_parse_backtick(Parser *self) {
    Parser_arith_advance(self);
    int64_t content_start = self->arith_pos;
    while ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "`") != 0))) {
        const char * c = Parser_arith_peek(self, 0);
        if (((strcmp(c, "\\") == 0) && !(Parser_arith_at_end(self)))) {
            Parser_arith_advance(self);
            Parser_arith_advance(self);
        } else {
            Parser_arith_advance(self);
        }
    }
    const char * content = substring(self->arith_src, content_start, self->arith_pos);
    if (!(Parser_arith_consume(self, "`"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unterminated backtick in arithmetic");
        return NULL;
    }
    Parser * sub_parser = new_parser(content, false, self->extglob);
    Node * cmd = (Node *)Parser_parse_list(sub_parser, true);
    return CommandSubstitution_new(cmd, false, "cmdsub");
}

static Node * Parser_arith_parse_number_or_var(Parser *self) {
    Parser_arith_skip_ws(self);
    Vec_Str chars = (Vec_Str){NULL, 0, 0};
    const char * c = Parser_arith_peek(self, 0);
    const char * ch;
    if (_str_is_digit(c)) {
        while (!(Parser_arith_at_end(self))) {
            ch = Parser_arith_peek(self, 0);
            if ((_str_is_alnum(ch) || ((strcmp(ch, "#") == 0) || (strcmp(ch, "_") == 0)))) {
                VEC_PUSH(g_arena, &chars, (Parser_arith_advance(self)));
            } else {
                break;
            }
        }
        const char * prefix = _str_join(g_arena, "", chars);
        if ((!(Parser_arith_at_end(self)) && (strcmp(Parser_arith_peek(self, 0), "$") == 0))) {
            Node * expansion = (Node *)Parser_arith_parse_expansion(self);
            return ArithConcat_new((Vec_Node){(Node *[]){ ArithNumber_new(prefix, "number"), expansion }, 2, 2}, "arith-concat");
        }
        return ArithNumber_new(prefix, "number");
    }
    if ((_str_is_alpha(c) || (strcmp(c, "_") == 0))) {
        while (!(Parser_arith_at_end(self))) {
            ch = Parser_arith_peek(self, 0);
            if ((_str_is_alnum(ch) || (strcmp(ch, "_") == 0))) {
                VEC_PUSH(g_arena, &chars, (Parser_arith_advance(self)));
            } else {
                break;
            }
        }
        return ArithVar_new(_str_join(g_arena, "", chars), "var");
    }
    g_parse_error = 1;
    snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, _str_concat(g_arena, "Unexpected character '", c), "' in arithmetic expression"));
    return NULL;
}

static Tuple_NodePtr_constcharPtr Parser_parse_deprecated_arithmetic(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "$") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    int64_t start = self->pos;
    if ((((self->pos + 1) >= self->length) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "[") != 0))) {
        return (Tuple_NodePtr_constcharPtr){(Node *)NULL, ""};
    }
    Parser_advance(self);
    Parser_advance(self);
    self->lexer->pos = self->pos;
    const char * content = Lexer_parse_matched_pair(self->lexer, "[", "]", MATCHEDPAIRFLAGS_ARITH, false);
    self->pos = self->lexer->pos;
    const char * text = substring(self->source, start, self->pos);
    return (Tuple_NodePtr_constcharPtr){(Node *)ArithDeprecated_new(content, "arith-deprecated"), text};
}

static Tuple_NodePtr_constcharPtr Parser_parse_param_expansion(Parser *self, bool in_dquote) {
    Parser_sync_lexer(self);
    Tuple_NodePtr_constcharPtr _tup66 = Lexer_read_param_expansion(self->lexer, in_dquote);
    Node * result0 = _tup66.F0;
    const char * result1 = _tup66.F1;
    Parser_sync_parser(self);
    return (Tuple_NodePtr_constcharPtr){(Node *)result0, result1};
}

static Node * Parser_parse_redirect(Parser *self) {
    Parser_skip_whitespace(self);
    if (Parser_at_end(self)) {
        return NULL;
    }
    int64_t start = self->pos;
    int64_t fd = -(1);
    const char * varfd = "";
    const char * ch;
    if ((strcmp(Parser_peek(self), "{") == 0)) {
        int64_t saved = self->pos;
        Parser_advance(self);
        Vec_Str varname_chars = (Vec_Str){NULL, 0, 0};
        bool in_bracket = false;
        while ((!(Parser_at_end(self)) && !(is_redirect_char(Parser_peek(self))))) {
            ch = Parser_peek(self);
            if (((strcmp(ch, "}") == 0) && !(in_bracket))) {
                break;
            } else if ((strcmp(ch, "[") == 0)) {
                in_bracket = true;
                VEC_PUSH(g_arena, &varname_chars, (Parser_advance(self)));
            } else if ((strcmp(ch, "]") == 0)) {
                in_bracket = false;
                VEC_PUSH(g_arena, &varname_chars, (Parser_advance(self)));
            } else if ((_str_is_alnum(ch) || (strcmp(ch, "_") == 0))) {
                VEC_PUSH(g_arena, &varname_chars, (Parser_advance(self)));
            } else if ((in_bracket && !(is_metachar(ch)))) {
                VEC_PUSH(g_arena, &varname_chars, (Parser_advance(self)));
            } else {
                break;
            }
        }
        const char * varname = _str_join(g_arena, "", varname_chars);
        bool is_valid_varfd = false;
        if ((varname != NULL && varname[0] != '\0')) {
            if ((_str_is_alpha((const char *)(_char_at_str(g_arena, varname, 0))) || (strcmp((const char *)(_char_at_str(g_arena, varname, 0)), "_") == 0))) {
                if ((_str_contains(varname, "[") || _str_contains(varname, "]"))) {
                    int64_t left = _str_find(varname, "[");
                    int64_t right = _str_rfind(varname, "]");
                    if ((((left != -(1)) && (right == (_rune_len(varname) - 1))) && (right > (left + 1)))) {
                        const char * base = _substring(g_arena, varname, 0, left);
                        if (((base != NULL && base[0] != '\0') && (_str_is_alpha((const char *)(_char_at_str(g_arena, base, 0))) || (strcmp((const char *)(_char_at_str(g_arena, base, 0)), "_") == 0)))) {
                            is_valid_varfd = true;
                            for (int _idx = 0; _idx < _rune_len(_substring(g_arena, base, 1, _rune_len(base))); _idx++) {
                                int32_t c = _rune_at(_substring(g_arena, base, 1, _rune_len(base)), _idx);
                                if (!((_rune_is_alnum(c) || (c == '_')))) {
                                    is_valid_varfd = false;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    is_valid_varfd = true;
                    for (int _idx = 0; _idx < _rune_len(_substring(g_arena, varname, 1, _rune_len(varname))); _idx++) {
                        int32_t c = _rune_at(_substring(g_arena, varname, 1, _rune_len(varname)), _idx);
                        if (!((_rune_is_alnum(c) || (c == '_')))) {
                            is_valid_varfd = false;
                            break;
                        }
                    }
                }
            }
        }
        if (((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "}") == 0)) && is_valid_varfd)) {
            Parser_advance(self);
            varfd = varname;
        } else {
            self->pos = saved;
        }
    }
    Vec_Str fd_chars;
    if ((((strcmp(varfd, "") == 0) && (Parser_peek(self) != NULL && Parser_peek(self)[0] != '\0')) && _str_is_digit(Parser_peek(self)))) {
        fd_chars = (Vec_Str){NULL, 0, 0};
        while ((!(Parser_at_end(self)) && _str_is_digit(Parser_peek(self)))) {
            VEC_PUSH(g_arena, &fd_chars, (Parser_advance(self)));
        }
        int64_t fd = _parse_int(_str_join(g_arena, "", fd_chars), 10);
    }
    ch = Parser_peek(self);
    const char * op;
    Word * target;
    if ((((strcmp(ch, "&") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ">") == 0))) {
        if (((fd != -(1)) || (strcmp(varfd, "") != 0))) {
            self->pos = start;
            return NULL;
        }
        Parser_advance(self);
        Parser_advance(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), ">") == 0))) {
            Parser_advance(self);
            op = "&>>";
        } else {
            op = "&>";
        }
        Parser_skip_whitespace(self);
        target = Parser_parse_word(self, false, false, false);
        if ((target == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected target for redirect ", op));
            return NULL;
        }
        return Redirect_new(op, target, 0, "redirect");
    }
    if (((strcmp(ch, "") == 0) || !(is_redirect_char(ch)))) {
        self->pos = start;
        return NULL;
    }
    if ((((fd == -(1)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
        self->pos = start;
        return NULL;
    }
    op = Parser_advance(self);
    bool strip_tabs = false;
    if (!(Parser_at_end(self))) {
        const char * next_ch = Parser_peek(self);
        if (((strcmp(op, ">") == 0) && (strcmp(next_ch, ">") == 0))) {
            Parser_advance(self);
            op = ">>";
        } else if (((strcmp(op, "<") == 0) && (strcmp(next_ch, "<") == 0))) {
            Parser_advance(self);
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "<") == 0))) {
                Parser_advance(self);
                op = "<<<";
            } else if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
                Parser_advance(self);
                op = "<<";
                strip_tabs = true;
            } else {
                op = "<<";
            }
        } else if (((strcmp(op, "<") == 0) && (strcmp(next_ch, ">") == 0))) {
            Parser_advance(self);
            op = "<>";
        } else if (((strcmp(op, ">") == 0) && (strcmp(next_ch, "|") == 0))) {
            Parser_advance(self);
            op = ">|";
        } else if (((((fd == -(1)) && (strcmp(varfd, "") == 0)) && (strcmp(op, ">") == 0)) && (strcmp(next_ch, "&") == 0))) {
            if ((((self->pos + 1) >= self->length) || !(is_digit_or_dash((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))))) {
                Parser_advance(self);
                op = ">&";
            }
        } else if (((((fd == -(1)) && (strcmp(varfd, "") == 0)) && (strcmp(op, "<") == 0)) && (strcmp(next_ch, "&") == 0))) {
            if ((((self->pos + 1) >= self->length) || !(is_digit_or_dash((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))))) {
                Parser_advance(self);
                op = "<&";
            }
        }
    }
    if ((strcmp(op, "<<") == 0)) {
        return Parser_parse_heredoc(self, fd, strip_tabs);
    }
    if ((strcmp(varfd, "") != 0)) {
        op = _str_concat(g_arena, _str_concat(g_arena, _str_concat(g_arena, "{", varfd), "}"), op);
    } else if ((fd != -(1))) {
        op = _str_concat(g_arena, _int_to_str(g_arena, fd), op);
    }
    Word * inner_word;
    const char * fd_target;
    if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "&") == 0))) {
        Parser_advance(self);
        Parser_skip_whitespace(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
            if ((((self->pos + 1) < self->length) && !(is_metachar((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))))) {
                Parser_advance(self);
                target = Word_new("&-", (Vec_Node){NULL, 0, 0}, "word");
            } else {
                target = NULL;
            }
        } else {
            target = NULL;
        }
        if ((target == NULL)) {
            if ((!(Parser_at_end(self)) && (_str_is_digit(Parser_peek(self)) || (strcmp(Parser_peek(self), "-") == 0)))) {
                int64_t word_start = self->pos;
                fd_chars = (Vec_Str){NULL, 0, 0};
                while ((!(Parser_at_end(self)) && _str_is_digit(Parser_peek(self)))) {
                    VEC_PUSH(g_arena, &fd_chars, (Parser_advance(self)));
                }
                if ((fd_chars.len > 0)) {
                    fd_target = _str_join(g_arena, "", fd_chars);
                } else {
                    fd_target = "";
                }
                if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
                    fd_target = _str_concat(g_arena, fd_target, Parser_advance(self));
                }
                if ((((strcmp(fd_target, "-") != 0) && !(Parser_at_end(self))) && !(is_metachar(Parser_peek(self))))) {
                    self->pos = word_start;
                    inner_word = Parser_parse_word(self, false, false, false);
                    if ((inner_word != NULL)) {
                        target = Word_new(_str_concat(g_arena, "&", inner_word->value), (Vec_Node){NULL, 0, 0}, "word");
                        target->parts = inner_word->parts;
                    } else {
                        g_parse_error = 1;
                        snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected target for redirect ", op));
                        return NULL;
                    }
                } else {
                    target = Word_new(_str_concat(g_arena, "&", fd_target), (Vec_Node){NULL, 0, 0}, "word");
                }
            } else {
                inner_word = Parser_parse_word(self, false, false, false);
                if ((inner_word != NULL)) {
                    target = Word_new(_str_concat(g_arena, "&", inner_word->value), (Vec_Node){NULL, 0, 0}, "word");
                    target->parts = inner_word->parts;
                } else {
                    g_parse_error = 1;
                    snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected target for redirect ", op));
                    return NULL;
                }
            }
        }
    } else {
        Parser_skip_whitespace(self);
        if (((((strcmp(op, ">&") == 0) || (strcmp(op, "<&") == 0)) && !(Parser_at_end(self))) && (strcmp(Parser_peek(self), "-") == 0))) {
            if ((((self->pos + 1) < self->length) && !(is_metachar((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))))) {
                Parser_advance(self);
                target = Word_new("&-", (Vec_Node){NULL, 0, 0}, "word");
            } else {
                target = Parser_parse_word(self, false, false, false);
            }
        } else {
            target = Parser_parse_word(self, false, false, false);
        }
    }
    if ((target == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected target for redirect ", op));
        return NULL;
    }
    return Redirect_new(op, target, 0, "redirect");
}

static Tuple_constcharPtr_bool Parser_parse_heredoc_delimiter(Parser *self) {
    Parser_skip_whitespace(self);
    bool quoted = false;
    Vec_Str delimiter_chars = (Vec_Str){NULL, 0, 0};
    while (true) {
        const char * c;
        int64_t depth;
        while ((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self))))) {
            const char * ch = Parser_peek(self);
            int64_t dollar_count;
            int64_t j;
            if ((strcmp(ch, "\"") == 0)) {
                quoted = true;
                Parser_advance(self);
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\"") != 0))) {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                }
                if (!(Parser_at_end(self))) {
                    Parser_advance(self);
                }
            } else if ((strcmp(ch, "'") == 0)) {
                quoted = true;
                Parser_advance(self);
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0))) {
                    c = Parser_advance(self);
                    if ((strcmp(c, "\n") == 0)) {
                        self->saw_newline_in_single_quote = true;
                    }
                    VEC_PUSH(g_arena, &delimiter_chars, (c));
                }
                if (!(Parser_at_end(self))) {
                    Parser_advance(self);
                }
            } else if ((strcmp(ch, "\\") == 0)) {
                Parser_advance(self);
                if (!(Parser_at_end(self))) {
                    const char * next_ch = Parser_peek(self);
                    if ((strcmp(next_ch, "\n") == 0)) {
                        Parser_advance(self);
                    } else {
                        quoted = true;
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    }
                }
            } else if ((((strcmp(ch, "$") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "'") == 0))) {
                quoted = true;
                Parser_advance(self);
                Parser_advance(self);
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0))) {
                    c = Parser_peek(self);
                    if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
                        Parser_advance(self);
                        const char * esc = Parser_peek(self);
                        int64_t esc_val = get_ansi_escape(esc);
                        if ((esc_val >= 0)) {
                            VEC_PUSH(g_arena, &delimiter_chars, ((const char *)((int32_t)(esc_val))));
                            Parser_advance(self);
                        } else if ((strcmp(esc, "'") == 0)) {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        } else {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        }
                    } else {
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    }
                }
                if (!(Parser_at_end(self))) {
                    Parser_advance(self);
                }
            } else if (is_expansion_start(self->source, self->pos, "$(")) {
                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                depth = 1;
                while ((!(Parser_at_end(self)) && (depth > 0))) {
                    c = Parser_peek(self);
                    if ((strcmp(c, "(") == 0)) {
                        depth += 1;
                    } else if ((strcmp(c, ")") == 0)) {
                        depth -= 1;
                    }
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                }
            } else if ((((strcmp(ch, "$") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "{") == 0))) {
                dollar_count = 0;
                j = (self->pos - 1);
                while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, self->source, j)), "$") == 0))) {
                    dollar_count += 1;
                    j -= 1;
                }
                if (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, self->source, j)), "\\") == 0))) {
                    dollar_count -= 1;
                }
                if (((dollar_count % 2) == 1)) {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                } else {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    depth = 0;
                    while (!(Parser_at_end(self))) {
                        c = Parser_peek(self);
                        if ((strcmp(c, "{") == 0)) {
                            depth += 1;
                        } else if ((strcmp(c, "}") == 0)) {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                            if ((depth == 0)) {
                                break;
                            }
                            depth -= 1;
                            if ((((depth == 0) && !(Parser_at_end(self))) && is_metachar(Parser_peek(self)))) {
                                break;
                            }
                            continue;
                        }
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    }
                }
            } else if ((((strcmp(ch, "$") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "[") == 0))) {
                dollar_count = 0;
                j = (self->pos - 1);
                while (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, self->source, j)), "$") == 0))) {
                    dollar_count += 1;
                    j -= 1;
                }
                if (((j >= 0) && (strcmp((const char *)(_char_at_str(g_arena, self->source, j)), "\\") == 0))) {
                    dollar_count -= 1;
                }
                if (((dollar_count % 2) == 1)) {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                } else {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    depth = 1;
                    while ((!(Parser_at_end(self)) && (depth > 0))) {
                        c = Parser_peek(self);
                        if ((strcmp(c, "[") == 0)) {
                            depth += 1;
                        } else if ((strcmp(c, "]") == 0)) {
                            depth -= 1;
                        }
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    }
                }
            } else if ((strcmp(ch, "`") == 0)) {
                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "`") != 0))) {
                    c = Parser_peek(self);
                    if ((strcmp(c, "'") == 0)) {
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        while (((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0)) && (strcmp(Parser_peek(self), "`") != 0))) {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        }
                        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") == 0))) {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        }
                    } else if ((strcmp(c, "\"") == 0)) {
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        while (((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\"") != 0)) && (strcmp(Parser_peek(self), "`") != 0))) {
                            if (((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length))) {
                                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                            }
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        }
                        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\"") == 0))) {
                            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        }
                    } else if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    } else {
                        VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                    }
                }
                if (!(Parser_at_end(self))) {
                    VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
                }
            } else {
                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
            }
        }
        if ((((!(Parser_at_end(self)) && _str_contains("<>", Parser_peek(self))) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
            VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
            depth = 1;
            while ((!(Parser_at_end(self)) && (depth > 0))) {
                c = Parser_peek(self);
                if ((strcmp(c, "(") == 0)) {
                    depth += 1;
                } else if ((strcmp(c, ")") == 0)) {
                    depth -= 1;
                }
                VEC_PUSH(g_arena, &delimiter_chars, (Parser_advance(self)));
            }
            continue;
        }
        break;
    }
    return (Tuple_constcharPtr_bool){_str_join(g_arena, "", delimiter_chars), quoted};
}

static Tuple_constcharPtr_int64_t Parser_read_heredoc_line(Parser *self, bool quoted) {
    int64_t line_start = self->pos;
    int64_t line_end = self->pos;
    while (((line_end < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, line_end)), "\n") != 0))) {
        line_end += 1;
    }
    const char * line = substring(self->source, line_start, line_end);
    if (!(quoted)) {
        while ((line_end < self->length)) {
            int64_t trailing_bs = count_trailing_backslashes(line);
            if (((trailing_bs % 2) == 0)) {
                break;
            }
            line = substring(line, 0, (_rune_len(line) - 1));
            line_end += 1;
            int64_t next_line_start = line_end;
            while (((line_end < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, line_end)), "\n") != 0))) {
                line_end += 1;
            }
            line = _str_concat(g_arena, line, substring(self->source, next_line_start, line_end));
        }
    }
    return (Tuple_constcharPtr_int64_t){line, line_end};
}

static Tuple_bool_constcharPtr Parser_line_matches_delimiter(Parser *self, const char * line, const char * delimiter, bool strip_tabs) {
    const char * check_line = (strip_tabs ? _str_ltrim(g_arena, line, "\t") : line);
    const char * normalized_check = normalize_heredoc_delimiter(check_line);
    const char * normalized_delim = normalize_heredoc_delimiter(delimiter);
    return (Tuple_bool_constcharPtr){(strcmp(normalized_check, normalized_delim) == 0), check_line};
}

static void Parser_gather_heredoc_bodies(Parser *self) {
    for (size_t _idx = 0; _idx < self->pending_heredocs.len; _idx++) {
        HereDoc * heredoc = self->pending_heredocs.data[_idx];
        Vec_Str content_lines = (Vec_Str){NULL, 0, 0};
        int64_t line_start = self->pos;
        while ((self->pos < self->length)) {
            line_start = self->pos;
            Tuple_constcharPtr_int64_t _tup67 = Parser_read_heredoc_line(self, heredoc->quoted);
            const char * line = _tup67.F0;
            int64_t line_end = _tup67.F1;
            Tuple_bool_constcharPtr _tup68 = Parser_line_matches_delimiter(self, line, heredoc->delimiter, heredoc->strip_tabs);
            bool matches = _tup68.F0;
            const char * check_line = _tup68.F1;
            if (matches) {
                self->pos = ((line_end < self->length) ? (line_end + 1) : line_end);
                break;
            }
            const char * normalized_check = normalize_heredoc_delimiter(check_line);
            const char * normalized_delim = normalize_heredoc_delimiter(heredoc->delimiter);
            int64_t tabs_stripped;
            if (((strcmp(self->eof_token, ")") == 0) && _str_startswith(normalized_check, normalized_delim))) {
                tabs_stripped = (_rune_len(line) - _rune_len(check_line));
                self->pos = ((line_start + tabs_stripped) + _rune_len(heredoc->delimiter));
                break;
            }
            if ((((line_end >= self->length) && _str_startswith(normalized_check, normalized_delim)) && self->in_process_sub)) {
                tabs_stripped = (_rune_len(line) - _rune_len(check_line));
                self->pos = ((line_start + tabs_stripped) + _rune_len(heredoc->delimiter));
                break;
            }
            if (heredoc->strip_tabs) {
                line = _str_ltrim(g_arena, line, "\t");
            }
            if ((line_end < self->length)) {
                VEC_PUSH(g_arena, &content_lines, (_str_concat(g_arena, line, "\n")));
                self->pos = (line_end + 1);
            } else {
                bool add_newline = true;
                if ((!(heredoc->quoted) && ((count_trailing_backslashes(line) % 2) == 1))) {
                    add_newline = false;
                }
                VEC_PUSH(g_arena, &content_lines, (_str_concat(g_arena, line, (add_newline ? "\n" : ""))));
                self->pos = self->length;
            }
        }
        heredoc->content = _str_join(g_arena, "", content_lines);
    }
    self->pending_heredocs = (Vec_HereDoc){NULL, 0, 0};
}

static HereDoc * Parser_parse_heredoc(Parser *self, int64_t fd, bool strip_tabs) {
    int64_t start_pos = self->pos;
    Parser_set_state(self, PARSERSTATEFLAGS_PST_HEREDOC);
    Tuple_constcharPtr_bool _tup69 = Parser_parse_heredoc_delimiter(self);
    const char * delimiter = _tup69.F0;
    bool quoted = _tup69.F1;
    for (size_t _idx = 0; _idx < self->pending_heredocs.len; _idx++) {
        HereDoc * existing = self->pending_heredocs.data[_idx];
        if (((existing->start_pos == start_pos) && (strcmp(existing->delimiter, delimiter) == 0))) {
            Parser_clear_state(self, PARSERSTATEFLAGS_PST_HEREDOC);
            return existing;
        }
    }
    HereDoc * heredoc = HereDoc_new(delimiter, "", strip_tabs, quoted, fd, false, 0, "heredoc");
    heredoc->start_pos = start_pos;
    VEC_PUSH(g_arena, &self->pending_heredocs, (heredoc));
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_HEREDOC);
    return heredoc;
}

static Command * Parser_parse_command(Parser *self) {
    Vec_Word words = (Vec_Word){NULL, 0, 0};
    Vec_Node redirects = (Vec_Node){NULL, 0, 0};
    while (true) {
        Parser_skip_whitespace(self);
        if (Parser_lex_is_command_terminator(self)) {
            break;
        }
        if ((words.len == 0)) {
            const char * reserved = Parser_lex_peek_reserved_word(self);
            if (((strcmp(reserved, "}") == 0) || (strcmp(reserved, "]]") == 0))) {
                break;
            }
        }
        Node * redirect = Parser_parse_redirect(self);
        if ((redirect != NULL)) {
            VEC_PUSH(g_arena, &redirects, (redirect));
            continue;
        }
        bool all_assignments = true;
        for (size_t _idx = 0; _idx < words.len; _idx++) {
            Word * w = words.data[_idx];
            if (!(Parser_is_assignment_word(self, w))) {
                all_assignments = false;
                break;
            }
        }
        bool in_assign_builtin = ((words.len > 0) && ((strcmp(words.data[0]->value, "alias") == 0) || (strcmp(words.data[0]->value, "declare") == 0) || (strcmp(words.data[0]->value, "typeset") == 0) || (strcmp(words.data[0]->value, "local") == 0) || (strcmp(words.data[0]->value, "export") == 0) || (strcmp(words.data[0]->value, "readonly") == 0) || (strcmp(words.data[0]->value, "eval") == 0) || (strcmp(words.data[0]->value, "let") == 0)));
        Word * word = Parser_parse_word(self, (!((words.len > 0)) || (all_assignments && (redirects.len == 0))), false, in_assign_builtin);
        if ((word == NULL)) {
            break;
        }
        VEC_PUSH(g_arena, &words, (word));
    }
    if ((!((words.len > 0)) && !((redirects.len > 0)))) {
        return NULL;
    }
    return Command_new(words, redirects, "command");
}

static Subshell * Parser_parse_subshell(Parser *self) {
    Parser_skip_whitespace(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0))) {
        return NULL;
    }
    Parser_advance(self);
    Parser_set_state(self, PARSERSTATEFLAGS_PST_SUBSHELL);
    Node * body = (Node *)Parser_parse_list(self, true);
    if ((body == NULL)) {
        Parser_clear_state(self, PARSERSTATEFLAGS_PST_SUBSHELL);
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected command in subshell");
        return NULL;
    }
    Parser_skip_whitespace(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
        Parser_clear_state(self, PARSERSTATEFLAGS_PST_SUBSHELL);
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ) to close subshell");
        return NULL;
    }
    Parser_advance(self);
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_SUBSHELL);
    return Subshell_new(body, &Parser_collect_redirects(self), "subshell");
}

static ArithmeticCommand * Parser_parse_arithmetic_command(Parser *self) {
    Parser_skip_whitespace(self);
    if ((((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0)) || ((self->pos + 1) >= self->length)) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") != 0))) {
        return NULL;
    }
    int64_t saved_pos = self->pos;
    Parser_advance(self);
    Parser_advance(self);
    int64_t content_start = self->pos;
    int64_t depth = 1;
    while ((!(Parser_at_end(self)) && (depth > 0))) {
        const char * c = Parser_peek(self);
        if ((strcmp(c, "'") == 0)) {
            Parser_advance(self);
            while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0))) {
                Parser_advance(self);
            }
            if (!(Parser_at_end(self))) {
                Parser_advance(self);
            }
        } else if ((strcmp(c, "\"") == 0)) {
            Parser_advance(self);
            while (!(Parser_at_end(self))) {
                if (((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length))) {
                    Parser_advance(self);
                    Parser_advance(self);
                } else if ((strcmp(Parser_peek(self), "\"") == 0)) {
                    Parser_advance(self);
                    break;
                } else {
                    Parser_advance(self);
                }
            }
        } else if (((strcmp(c, "\\") == 0) && ((self->pos + 1) < self->length))) {
            Parser_advance(self);
            Parser_advance(self);
        } else if ((strcmp(c, "(") == 0)) {
            depth += 1;
            Parser_advance(self);
        } else if ((strcmp(c, ")") == 0)) {
            if ((((depth == 1) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ")") == 0))) {
                break;
            }
            depth -= 1;
            if ((depth == 0)) {
                self->pos = saved_pos;
                return NULL;
            }
            Parser_advance(self);
        } else {
            Parser_advance(self);
        }
    }
    if (Parser_at_end(self)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "unexpected EOF looking for `))'");
        return NULL;
    }
    if ((depth != 1)) {
        self->pos = saved_pos;
        return NULL;
    }
    const char * content = substring(self->source, content_start, self->pos);
    content = _str_replace(g_arena, content, "\\\n", "");
    Parser_advance(self);
    Parser_advance(self);
    Node * expr = (Node *)Parser_parse_arith_expr(self, content);
    return ArithmeticCommand_new(expr, Parser_collect_redirects(self), content, "arith-cmd");
}

static ConditionalExpr * Parser_parse_conditional_expr(Parser *self) {
    Parser_skip_whitespace(self);
    if ((((Parser_at_end(self) || (strcmp(Parser_peek(self), "[") != 0)) || ((self->pos + 1) >= self->length)) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "[") != 0))) {
        return NULL;
    }
    int64_t next_pos = (self->pos + 2);
    if (((next_pos < self->length) && !((is_whitespace((const char *)(_char_at_str(g_arena, self->source, next_pos))) || (((strcmp((const char *)(_char_at_str(g_arena, self->source, next_pos)), "\\") == 0) && ((next_pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (next_pos + 1))), "\n") == 0)))))) {
        return NULL;
    }
    Parser_advance(self);
    Parser_advance(self);
    Parser_set_state(self, PARSERSTATEFLAGS_PST_CONDEXPR);
    self->word_context = WORD_CTX_COND;
    Node * body = (Node *)Parser_parse_cond_or(self);
    while ((!(Parser_at_end(self)) && is_whitespace_no_newline(Parser_peek(self)))) {
        Parser_advance(self);
    }
    if ((((Parser_at_end(self) || (strcmp(Parser_peek(self), "]") != 0)) || ((self->pos + 1) >= self->length)) || (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") != 0))) {
        Parser_clear_state(self, PARSERSTATEFLAGS_PST_CONDEXPR);
        self->word_context = WORD_CTX_NORMAL;
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ]] to close conditional expression");
        return NULL;
    }
    Parser_advance(self);
    Parser_advance(self);
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_CONDEXPR);
    self->word_context = WORD_CTX_NORMAL;
    return ConditionalExpr_new(body, Parser_collect_redirects(self), "cond-expr");
}

static void Parser_cond_skip_whitespace(Parser *self) {
    while (!(Parser_at_end(self))) {
        if (is_whitespace_no_newline(Parser_peek(self))) {
            Parser_advance(self);
        } else if ((((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\n") == 0))) {
            Parser_advance(self);
            Parser_advance(self);
        } else if ((strcmp(Parser_peek(self), "\n") == 0)) {
            Parser_advance(self);
        } else {
            break;
        }
    }
}

static bool Parser_cond_at_end(Parser *self) {
    return (Parser_at_end(self) || (((strcmp(Parser_peek(self), "]") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "]") == 0)));
}

static Node * Parser_parse_cond_or(Parser *self) {
    Parser_cond_skip_whitespace(self);
    Node * left = (Node *)Parser_parse_cond_and(self);
    Parser_cond_skip_whitespace(self);
    if ((((!(Parser_cond_at_end(self)) && (strcmp(Parser_peek(self), "|") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "|") == 0))) {
        Parser_advance(self);
        Parser_advance(self);
        Node * right = (Node *)Parser_parse_cond_or(self);
        return CondOr_new(left, right, "cond-or");
    }
    return (Node *)left;
}

static Node * Parser_parse_cond_and(Parser *self) {
    Parser_cond_skip_whitespace(self);
    Node * left = (Node *)Parser_parse_cond_term(self);
    Parser_cond_skip_whitespace(self);
    if ((((!(Parser_cond_at_end(self)) && (strcmp(Parser_peek(self), "&") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "&") == 0))) {
        Parser_advance(self);
        Parser_advance(self);
        Node * right = (Node *)Parser_parse_cond_and(self);
        return CondAnd_new(left, right, "cond-and");
    }
    return (Node *)left;
}

static Node * Parser_parse_cond_term(Parser *self) {
    Parser_cond_skip_whitespace(self);
    if (Parser_cond_at_end(self)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Unexpected end of conditional expression");
        return NULL;
    }
    if ((strcmp(Parser_peek(self), "!") == 0)) {
        if ((((self->pos + 1) < self->length) && !(is_whitespace_no_newline((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))))) {
        } else {
            Parser_advance(self);
            Node * operand = (Node *)Parser_parse_cond_term(self);
            return CondNot_new(operand, "cond-not");
        }
    }
    if ((strcmp(Parser_peek(self), "(") == 0)) {
        Parser_advance(self);
        Node * inner = (Node *)Parser_parse_cond_or(self);
        Parser_cond_skip_whitespace(self);
        if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ) in conditional expression");
            return NULL;
        }
        Parser_advance(self);
        return CondParen_new(inner, "cond-paren");
    }
    Word * word1 = Parser_parse_cond_word(self);
    if ((word1 == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected word in conditional expression");
        return NULL;
    }
    Parser_cond_skip_whitespace(self);
    if (((strcmp(word1->value, "-a") == 0) || (strcmp(word1->value, "-b") == 0) || (strcmp(word1->value, "-c") == 0) || (strcmp(word1->value, "-d") == 0) || (strcmp(word1->value, "-e") == 0) || (strcmp(word1->value, "-f") == 0) || (strcmp(word1->value, "-g") == 0) || (strcmp(word1->value, "-h") == 0) || (strcmp(word1->value, "-k") == 0) || (strcmp(word1->value, "-p") == 0) || (strcmp(word1->value, "-r") == 0) || (strcmp(word1->value, "-s") == 0) || (strcmp(word1->value, "-t") == 0) || (strcmp(word1->value, "-u") == 0) || (strcmp(word1->value, "-w") == 0) || (strcmp(word1->value, "-x") == 0) || (strcmp(word1->value, "-G") == 0) || (strcmp(word1->value, "-L") == 0) || (strcmp(word1->value, "-N") == 0) || (strcmp(word1->value, "-O") == 0) || (strcmp(word1->value, "-S") == 0) || (strcmp(word1->value, "-z") == 0) || (strcmp(word1->value, "-n") == 0) || (strcmp(word1->value, "-o") == 0) || (strcmp(word1->value, "-v") == 0) || (strcmp(word1->value, "-R") == 0))) {
        Word * unary_operand = Parser_parse_cond_word(self);
        if ((unary_operand == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected operand after ", word1->value));
            return NULL;
        }
        return UnaryTest_new(word1->value, unary_operand, "unary-test");
    }
    Word * word2;
    if ((!(Parser_cond_at_end(self)) && (((strcmp(Parser_peek(self), "&") != 0) && (strcmp(Parser_peek(self), "|") != 0)) && (strcmp(Parser_peek(self), ")") != 0)))) {
        if ((is_redirect_char(Parser_peek(self)) && !((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))))) {
            const char * op = Parser_advance(self);
            Parser_cond_skip_whitespace(self);
            word2 = Parser_parse_cond_word(self);
            if ((word2 == NULL)) {
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected operand after ", op));
                return NULL;
            }
            return BinaryTest_new(op, word1, word2, "binary-test");
        }
        int64_t saved_pos = self->pos;
        Word * op_word = Parser_parse_cond_word(self);
        if (((op_word != NULL) && ((strcmp(op_word->value, "==") == 0) || (strcmp(op_word->value, "!=") == 0) || (strcmp(op_word->value, "=~") == 0) || (strcmp(op_word->value, "=") == 0) || (strcmp(op_word->value, "<") == 0) || (strcmp(op_word->value, ">") == 0) || (strcmp(op_word->value, "-eq") == 0) || (strcmp(op_word->value, "-ne") == 0) || (strcmp(op_word->value, "-lt") == 0) || (strcmp(op_word->value, "-le") == 0) || (strcmp(op_word->value, "-gt") == 0) || (strcmp(op_word->value, "-ge") == 0) || (strcmp(op_word->value, "-nt") == 0) || (strcmp(op_word->value, "-ot") == 0) || (strcmp(op_word->value, "-ef") == 0)))) {
            Parser_cond_skip_whitespace(self);
            if ((strcmp(op_word->value, "=~") == 0)) {
                word2 = Parser_parse_cond_regex_word(self);
            } else {
                word2 = Parser_parse_cond_word(self);
            }
            if ((word2 == NULL)) {
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected operand after ", op_word->value));
                return NULL;
            }
            return BinaryTest_new(op_word->value, word1, word2, "binary-test");
        } else {
            self->pos = saved_pos;
        }
    }
    return UnaryTest_new("-n", word1, "unary-test");
}

static Word * Parser_parse_cond_word(Parser *self) {
    Parser_cond_skip_whitespace(self);
    if (Parser_cond_at_end(self)) {
        return NULL;
    }
    const char * c = Parser_peek(self);
    if (is_paren(c)) {
        return NULL;
    }
    if ((((strcmp(c, "&") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "&") == 0))) {
        return NULL;
    }
    if ((((strcmp(c, "|") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "|") == 0))) {
        return NULL;
    }
    return Parser_parse_word_internal(self, WORD_CTX_COND, false, false);
}

static Word * Parser_parse_cond_regex_word(Parser *self) {
    Parser_cond_skip_whitespace(self);
    if (Parser_cond_at_end(self)) {
        return NULL;
    }
    Parser_set_state(self, PARSERSTATEFLAGS_PST_REGEXP);
    Word * result = Parser_parse_word_internal(self, WORD_CTX_REGEX, false, false);
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_REGEXP);
    self->word_context = WORD_CTX_COND;
    return result;
}

static BraceGroup * Parser_parse_brace_group(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "{"))) {
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    Node * body = (Node *)Parser_parse_list(self, true);
    if ((body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected command in brace group");
        return NULL;
    }
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "}"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected } to close brace group");
        return NULL;
    }
    return BraceGroup_new(body, &Parser_collect_redirects(self), "brace-group");
}

static If * Parser_parse_if(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "if"))) {
        return NULL;
    }
    Node * condition = (Node *)Parser_parse_list_until(self, NULL);
    if ((condition == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected condition after 'if'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "then"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'then' after if condition");
        return NULL;
    }
    Node * then_body = (Node *)Parser_parse_list_until(self, NULL);
    if ((then_body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'then'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    Node * else_body = (Node *)NULL;
    if (Parser_lex_is_at_reserved_word(self, "elif")) {
        Parser_lex_consume_word(self, "elif");
        Node * elif_condition = (Node *)Parser_parse_list_until(self, NULL);
        if ((elif_condition == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected condition after 'elif'");
            return NULL;
        }
        Parser_skip_whitespace_and_newlines(self);
        if (!(Parser_lex_consume_word(self, "then"))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'then' after elif condition");
            return NULL;
        }
        Node * elif_then_body = (Node *)Parser_parse_list_until(self, NULL);
        if ((elif_then_body == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'then'");
            return NULL;
        }
        Parser_skip_whitespace_and_newlines(self);
        Node * inner_else = (Node *)NULL;
        if (Parser_lex_is_at_reserved_word(self, "elif")) {
            inner_else = (Node *)Parser_parse_elif_chain(self);
        } else if (Parser_lex_is_at_reserved_word(self, "else")) {
            Parser_lex_consume_word(self, "else");
            inner_else = (Node *)Parser_parse_list_until(self, NULL);
            if ((inner_else == NULL)) {
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'else'");
                return NULL;
            }
        }
        else_body = (Node *)If_new(elif_condition, elif_then_body, inner_else, (Vec_Node){NULL, 0, 0}, "if");
    } else if (Parser_lex_is_at_reserved_word(self, "else")) {
        Parser_lex_consume_word(self, "else");
        else_body = (Node *)Parser_parse_list_until(self, NULL);
        if ((else_body == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'else'");
            return NULL;
        }
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "fi"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'fi' to close if statement");
        return NULL;
    }
    return If_new(condition, then_body, else_body, Parser_collect_redirects(self), "if");
}

static If * Parser_parse_elif_chain(Parser *self) {
    Parser_lex_consume_word(self, "elif");
    Node * condition = (Node *)Parser_parse_list_until(self, NULL);
    if ((condition == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected condition after 'elif'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "then"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'then' after elif condition");
        return NULL;
    }
    Node * then_body = (Node *)Parser_parse_list_until(self, NULL);
    if ((then_body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'then'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    Node * else_body = (Node *)NULL;
    if (Parser_lex_is_at_reserved_word(self, "elif")) {
        else_body = (Node *)Parser_parse_elif_chain(self);
    } else if (Parser_lex_is_at_reserved_word(self, "else")) {
        Parser_lex_consume_word(self, "else");
        else_body = (Node *)Parser_parse_list_until(self, NULL);
        if ((else_body == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'else'");
            return NULL;
        }
    }
    return If_new(condition, then_body, else_body, (Vec_Node){NULL, 0, 0}, "if");
}

static While * Parser_parse_while(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "while"))) {
        return NULL;
    }
    Node * condition = (Node *)Parser_parse_list_until(self, NULL);
    if ((condition == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected condition after 'while'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "do"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'do' after while condition");
        return NULL;
    }
    Node * body = (Node *)Parser_parse_list_until(self, NULL);
    if ((body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'do'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "done"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'done' to close while loop");
        return NULL;
    }
    return While_new(condition, body, Parser_collect_redirects(self), "while");
}

static Until * Parser_parse_until(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "until"))) {
        return NULL;
    }
    Node * condition = (Node *)Parser_parse_list_until(self, NULL);
    if ((condition == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected condition after 'until'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "do"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'do' after until condition");
        return NULL;
    }
    Node * body = (Node *)Parser_parse_list_until(self, NULL);
    if ((body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'do'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "done"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'done' to close until loop");
        return NULL;
    }
    return Until_new(condition, body, Parser_collect_redirects(self), "until");
}

static Node * Parser_parse_for(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "for"))) {
        return NULL;
    }
    Parser_skip_whitespace(self);
    if ((((strcmp(Parser_peek(self), "(") == 0) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
        return Parser_parse_for_arith(self);
    }
    const char * var_name;
    if ((strcmp(Parser_peek(self), "$") == 0)) {
        Word * var_word = Parser_parse_word(self, false, false, false);
        if ((var_word == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected variable name after 'for'");
            return NULL;
        }
        var_name = var_word->value;
    } else {
        var_name = Parser_peek_word(self);
        if ((strcmp(var_name, "") == 0)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected variable name after 'for'");
            return NULL;
        }
        Parser_consume_word(self, var_name);
    }
    Parser_skip_whitespace(self);
    if ((strcmp(Parser_peek(self), ";") == 0)) {
        Parser_advance(self);
    }
    Parser_skip_whitespace_and_newlines(self);
    Vec_Word words = (Vec_Word){NULL, 0, 0};
    if (Parser_lex_is_at_reserved_word(self, "in")) {
        Parser_lex_consume_word(self, "in");
        Parser_skip_whitespace(self);
        bool saw_delimiter = is_semicolon_or_newline(Parser_peek(self));
        if ((strcmp(Parser_peek(self), ";") == 0)) {
            Parser_advance(self);
        }
        Parser_skip_whitespace_and_newlines(self);
        words = (Vec_Word){NULL, 0, 0};
        while (true) {
            Parser_skip_whitespace(self);
            if (Parser_at_end(self)) {
                break;
            }
            if (is_semicolon_or_newline(Parser_peek(self))) {
                saw_delimiter = true;
                if ((strcmp(Parser_peek(self), ";") == 0)) {
                    Parser_advance(self);
                }
                break;
            }
            if (Parser_lex_is_at_reserved_word(self, "do")) {
                if (saw_delimiter) {
                    break;
                }
                g_parse_error = 1;
                snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected ';' or newline before 'do'");
                return NULL;
            }
            Word * word = Parser_parse_word(self, false, false, false);
            if ((word == NULL)) {
                break;
            }
            VEC_PUSH(g_arena, &words, (word));
        }
    }
    Parser_skip_whitespace_and_newlines(self);
    if ((strcmp(Parser_peek(self), "{") == 0)) {
        BraceGroup * brace_group = Parser_parse_brace_group(self);
        if ((brace_group == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected brace group in for loop");
            return NULL;
        }
        return For_new(var_name, &words, brace_group->body, Parser_collect_redirects(self), "for");
    }
    if (!(Parser_lex_consume_word(self, "do"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'do' in for loop");
        return NULL;
    }
    Node * body = (Node *)Parser_parse_list_until(self, NULL);
    if ((body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected commands after 'do'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "done"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'done' to close for loop");
        return NULL;
    }
    return For_new(var_name, &words, body, Parser_collect_redirects(self), "for");
}

static ForArith * Parser_parse_for_arith(Parser *self) {
    Parser_advance(self);
    Parser_advance(self);
    Vec_Str parts = (Vec_Str){NULL, 0, 0};
    Vec_Str current = (Vec_Str){NULL, 0, 0};
    int64_t paren_depth = 0;
    while (!(Parser_at_end(self))) {
        const char * ch = Parser_peek(self);
        if ((strcmp(ch, "(") == 0)) {
            paren_depth += 1;
            VEC_PUSH(g_arena, &current, (Parser_advance(self)));
        } else if ((strcmp(ch, ")") == 0)) {
            if ((paren_depth > 0)) {
                paren_depth -= 1;
                VEC_PUSH(g_arena, &current, (Parser_advance(self)));
            } else if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ")") == 0))) {
                VEC_PUSH(g_arena, &parts, (_str_ltrim(g_arena, _str_join(g_arena, "", current), " \t")));
                Parser_advance(self);
                Parser_advance(self);
                break;
            } else {
                VEC_PUSH(g_arena, &current, (Parser_advance(self)));
            }
        } else if (((strcmp(ch, ";") == 0) && (paren_depth == 0))) {
            VEC_PUSH(g_arena, &parts, (_str_ltrim(g_arena, _str_join(g_arena, "", current), " \t")));
            current = (Vec_Str){NULL, 0, 0};
            Parser_advance(self);
        } else {
            VEC_PUSH(g_arena, &current, (Parser_advance(self)));
        }
    }
    if ((parts.len != 3)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected three expressions in for ((;;))");
        return NULL;
    }
    const char * init = parts.data[0];
    const char * cond = parts.data[1];
    const char * incr = parts.data[2];
    Parser_skip_whitespace(self);
    if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), ";") == 0))) {
        Parser_advance(self);
    }
    Parser_skip_whitespace_and_newlines(self);
    Node * body = (Node *)Parser_parse_loop_body(self, "for loop");
    return ForArith_new(init, cond, incr, body, Parser_collect_redirects(self), "for-arith");
}

static Select * Parser_parse_select(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "select"))) {
        return NULL;
    }
    Parser_skip_whitespace(self);
    const char * var_name = Parser_peek_word(self);
    if ((strcmp(var_name, "") == 0)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected variable name after 'select'");
        return NULL;
    }
    Parser_consume_word(self, var_name);
    Parser_skip_whitespace(self);
    if ((strcmp(Parser_peek(self), ";") == 0)) {
        Parser_advance(self);
    }
    Parser_skip_whitespace_and_newlines(self);
    Vec_Word words = (Vec_Word){NULL, 0, 0};
    if (Parser_lex_is_at_reserved_word(self, "in")) {
        Parser_lex_consume_word(self, "in");
        Parser_skip_whitespace_and_newlines(self);
        words = (Vec_Word){NULL, 0, 0};
        while (true) {
            Parser_skip_whitespace(self);
            if (Parser_at_end(self)) {
                break;
            }
            if (is_semicolon_newline_brace(Parser_peek(self))) {
                if ((strcmp(Parser_peek(self), ";") == 0)) {
                    Parser_advance(self);
                }
                break;
            }
            if (Parser_lex_is_at_reserved_word(self, "do")) {
                break;
            }
            Word * word = Parser_parse_word(self, false, false, false);
            if ((word == NULL)) {
                break;
            }
            VEC_PUSH(g_arena, &words, (word));
        }
    }
    Parser_skip_whitespace_and_newlines(self);
    Node * body = (Node *)Parser_parse_loop_body(self, "select");
    return Select_new(var_name, &words, body, Parser_collect_redirects(self), "select");
}

static const char * Parser_consume_case_terminator(Parser *self) {
    const char * term = Parser_lex_peek_case_terminator(self);
    if ((strcmp(term, "") != 0)) {
        Parser_lex_next_token(self);
        return term;
    }
    return ";;";
}

static Case * Parser_parse_case(Parser *self) {
    if (!(Parser_consume_word(self, "case"))) {
        return NULL;
    }
    Parser_set_state(self, PARSERSTATEFLAGS_PST_CASESTMT);
    Parser_skip_whitespace(self);
    Word * word = Parser_parse_word(self, false, false, false);
    if ((word == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected word after 'case'");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "in"))) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'in' after case word");
        return NULL;
    }
    Parser_skip_whitespace_and_newlines(self);
    Vec_CasePattern patterns = (Vec_CasePattern){NULL, 0, 0};
    Parser_set_state(self, PARSERSTATEFLAGS_PST_CASEPAT);
    while (true) {
        Parser_skip_whitespace_and_newlines(self);
        if (Parser_lex_is_at_reserved_word(self, "esac")) {
            int64_t saved = self->pos;
            Parser_skip_whitespace(self);
            while (((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self)))) && !(is_quote(Parser_peek(self))))) {
                Parser_advance(self);
            }
            Parser_skip_whitespace(self);
            bool is_pattern = false;
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), ")") == 0))) {
                if ((strcmp(self->eof_token, ")") == 0)) {
                    is_pattern = false;
                } else {
                    Parser_advance(self);
                    Parser_skip_whitespace(self);
                    if (!(Parser_at_end(self))) {
                        const char * next_ch = Parser_peek(self);
                        if ((strcmp(next_ch, ";") == 0)) {
                            is_pattern = true;
                        } else if (!(is_newline_or_right_paren(next_ch))) {
                            is_pattern = true;
                        }
                    }
                }
            }
            self->pos = saved;
            if (!(is_pattern)) {
                break;
            }
        }
        Parser_skip_whitespace_and_newlines(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "(") == 0))) {
            Parser_advance(self);
            Parser_skip_whitespace_and_newlines(self);
        }
        Vec_Str pattern_chars = (Vec_Str){NULL, 0, 0};
        int64_t extglob_depth = 0;
        while (!(Parser_at_end(self))) {
            const char * ch = Parser_peek(self);
            if ((strcmp(ch, ")") == 0)) {
                if ((extglob_depth > 0)) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    extglob_depth -= 1;
                } else {
                    Parser_advance(self);
                    break;
                }
            } else if ((strcmp(ch, "\\") == 0)) {
                if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "\n") == 0))) {
                    Parser_advance(self);
                    Parser_advance(self);
                } else {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    if (!(Parser_at_end(self))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                }
            } else if (is_expansion_start(self->source, self->pos, "$(")) {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "(") == 0))) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    int64_t paren_depth = 2;
                    while ((!(Parser_at_end(self)) && (paren_depth > 0))) {
                        const char * c = Parser_peek(self);
                        if ((strcmp(c, "(") == 0)) {
                            paren_depth += 1;
                        } else if ((strcmp(c, ")") == 0)) {
                            paren_depth -= 1;
                        }
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                } else {
                    extglob_depth += 1;
                }
            } else if (((strcmp(ch, "(") == 0) && (extglob_depth > 0))) {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                extglob_depth += 1;
            } else if ((((self->extglob && is_extglob_prefix(ch)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                extglob_depth += 1;
            } else if ((strcmp(ch, "[") == 0)) {
                bool is_char_class = false;
                int64_t scan_pos = (self->pos + 1);
                int64_t scan_depth = 0;
                bool has_first_bracket_literal = false;
                if (((scan_pos < self->length) && is_caret_or_bang((const char *)(_char_at_str(g_arena, self->source, scan_pos))))) {
                    scan_pos += 1;
                }
                if (((scan_pos < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, scan_pos)), "]") == 0))) {
                    if ((_str_find(self->source, "]") != -(1))) {
                        scan_pos += 1;
                        has_first_bracket_literal = true;
                    }
                }
                while ((scan_pos < self->length)) {
                    const char * sc = (const char *)(_char_at_str(g_arena, self->source, scan_pos));
                    if (((strcmp(sc, "]") == 0) && (scan_depth == 0))) {
                        is_char_class = true;
                        break;
                    } else if ((strcmp(sc, "[") == 0)) {
                        scan_depth += 1;
                    } else if (((strcmp(sc, ")") == 0) && (scan_depth == 0))) {
                        break;
                    } else if (((strcmp(sc, "|") == 0) && (scan_depth == 0))) {
                        break;
                    }
                    scan_pos += 1;
                }
                if (is_char_class) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    if ((!(Parser_at_end(self)) && is_caret_or_bang(Parser_peek(self)))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                    if (((has_first_bracket_literal && !(Parser_at_end(self))) && (strcmp(Parser_peek(self), "]") == 0))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                    while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "]") != 0))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                    if (!(Parser_at_end(self))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                } else {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                }
            } else if ((strcmp(ch, "'") == 0)) {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "'") != 0))) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                }
                if (!(Parser_at_end(self))) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                }
            } else if ((strcmp(ch, "\"") == 0)) {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\"") != 0))) {
                    if (((strcmp(Parser_peek(self), "\\") == 0) && ((self->pos + 1) < self->length))) {
                        VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                    }
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                }
                if (!(Parser_at_end(self))) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                }
            } else if (is_whitespace(ch)) {
                if ((extglob_depth > 0)) {
                    VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
                } else {
                    Parser_advance(self);
                }
            } else {
                VEC_PUSH(g_arena, &pattern_chars, (Parser_advance(self)));
            }
        }
        const char * pattern = _str_join(g_arena, "", pattern_chars);
        if (!((pattern != NULL && pattern[0] != '\0'))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected pattern in case statement");
            return NULL;
        }
        Parser_skip_whitespace(self);
        Node * body = (Node *)NULL;
        bool is_empty_body = (strcmp(Parser_lex_peek_case_terminator(self), "") != 0);
        if (!(is_empty_body)) {
            Parser_skip_whitespace_and_newlines(self);
            if ((!(Parser_at_end(self)) && !(Parser_lex_is_at_reserved_word(self, "esac")))) {
                bool is_at_terminator = (strcmp(Parser_lex_peek_case_terminator(self), "") != 0);
                if (!(is_at_terminator)) {
                    body = (Node *)Parser_parse_list_until(self, NULL);
                    Parser_skip_whitespace(self);
                }
            }
        }
        const char * terminator = Parser_consume_case_terminator(self);
        Parser_skip_whitespace_and_newlines(self);
        VEC_PUSH(g_arena, &patterns, (CasePattern_new(pattern, body, terminator, "pattern")));
    }
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_CASEPAT);
    Parser_skip_whitespace_and_newlines(self);
    if (!(Parser_lex_consume_word(self, "esac"))) {
        Parser_clear_state(self, PARSERSTATEFLAGS_PST_CASESTMT);
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected 'esac' to close case statement");
        return NULL;
    }
    Parser_clear_state(self, PARSERSTATEFLAGS_PST_CASESTMT);
    return Case_new(word, patterns, Parser_collect_redirects(self), "case");
}

static Coproc * Parser_parse_coproc(Parser *self) {
    Parser_skip_whitespace(self);
    if (!(Parser_lex_consume_word(self, "coproc"))) {
        return NULL;
    }
    Parser_skip_whitespace(self);
    const char * name = "";
    const char * ch = "";
    if (!(Parser_at_end(self))) {
        ch = Parser_peek(self);
    }
    Node * body;
    if ((strcmp(ch, "{") == 0)) {
        body = (Node *)Parser_parse_brace_group(self);
        if ((body != NULL)) {
            return Coproc_new(body, name, "coproc");
        }
    }
    if ((strcmp(ch, "(") == 0)) {
        if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
            body = (Node *)Parser_parse_arithmetic_command(self);
            if ((body != NULL)) {
                return Coproc_new(body, name, "coproc");
            }
        }
        body = (Node *)Parser_parse_subshell(self);
        if ((body != NULL)) {
            return Coproc_new(body, name, "coproc");
        }
    }
    const char * next_word = Parser_lex_peek_reserved_word(self);
    if (((strcmp(next_word, "") != 0) && ((strcmp(next_word, "while") == 0) || (strcmp(next_word, "until") == 0) || (strcmp(next_word, "for") == 0) || (strcmp(next_word, "if") == 0) || (strcmp(next_word, "case") == 0) || (strcmp(next_word, "select") == 0)))) {
        body = (Node *)Parser_parse_compound_command(self);
        if ((body != NULL)) {
            return Coproc_new(body, name, "coproc");
        }
    }
    int64_t word_start = self->pos;
    const char * potential_name = Parser_peek_word(self);
    if ((potential_name != NULL && potential_name[0] != '\0')) {
        while (((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self)))) && !(is_quote(Parser_peek(self))))) {
            Parser_advance(self);
        }
        Parser_skip_whitespace(self);
        ch = "";
        if (!(Parser_at_end(self))) {
            ch = Parser_peek(self);
        }
        next_word = Parser_lex_peek_reserved_word(self);
        if (is_valid_identifier(potential_name)) {
            if ((strcmp(ch, "{") == 0)) {
                name = potential_name;
                body = (Node *)Parser_parse_brace_group(self);
                if ((body != NULL)) {
                    return Coproc_new(body, name, "coproc");
                }
            } else if ((strcmp(ch, "(") == 0)) {
                name = potential_name;
                if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
                    body = (Node *)Parser_parse_arithmetic_command(self);
                } else {
                    body = (Node *)Parser_parse_subshell(self);
                }
                if ((body != NULL)) {
                    return Coproc_new(body, name, "coproc");
                }
            } else if (((strcmp(next_word, "") != 0) && ((strcmp(next_word, "while") == 0) || (strcmp(next_word, "until") == 0) || (strcmp(next_word, "for") == 0) || (strcmp(next_word, "if") == 0) || (strcmp(next_word, "case") == 0) || (strcmp(next_word, "select") == 0)))) {
                name = potential_name;
                body = (Node *)Parser_parse_compound_command(self);
                if ((body != NULL)) {
                    return Coproc_new(body, name, "coproc");
                }
            }
        }
        self->pos = word_start;
    }
    body = (Node *)Parser_parse_command(self);
    if ((body != NULL)) {
        return Coproc_new(body, name, "coproc");
    }
    g_parse_error = 1;
    snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected command after coproc");
    return NULL;
}

static Function * Parser_parse_function(Parser *self) {
    Parser_skip_whitespace(self);
    if (Parser_at_end(self)) {
        return NULL;
    }
    int64_t saved_pos = self->pos;
    const char * name;
    Node * body;
    if (Parser_lex_is_at_reserved_word(self, "function")) {
        Parser_lex_consume_word(self, "function");
        Parser_skip_whitespace(self);
        name = Parser_peek_word(self);
        if ((strcmp(name, "") == 0)) {
            self->pos = saved_pos;
            return NULL;
        }
        Parser_consume_word(self, name);
        Parser_skip_whitespace(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "(") == 0))) {
            if ((((self->pos + 1) < self->length) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), ")") == 0))) {
                Parser_advance(self);
                Parser_advance(self);
            }
        }
        Parser_skip_whitespace_and_newlines(self);
        body = (Node *)Parser_parse_compound_command(self);
        if ((body == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected function body");
            return NULL;
        }
        return Function_new(name, body, "function");
    }
    name = Parser_peek_word(self);
    if (((strcmp(name, "") == 0) || ((strcmp(name, "if") == 0) || (strcmp(name, "then") == 0) || (strcmp(name, "elif") == 0) || (strcmp(name, "else") == 0) || (strcmp(name, "fi") == 0) || (strcmp(name, "while") == 0) || (strcmp(name, "until") == 0) || (strcmp(name, "for") == 0) || (strcmp(name, "select") == 0) || (strcmp(name, "do") == 0) || (strcmp(name, "done") == 0) || (strcmp(name, "case") == 0) || (strcmp(name, "esac") == 0) || (strcmp(name, "in") == 0) || (strcmp(name, "function") == 0) || (strcmp(name, "coproc") == 0)))) {
        return NULL;
    }
    if (looks_like_assignment(name)) {
        return NULL;
    }
    Parser_skip_whitespace(self);
    int64_t name_start = self->pos;
    while ((((!(Parser_at_end(self)) && !(is_metachar(Parser_peek(self)))) && !(is_quote(Parser_peek(self)))) && !(is_paren(Parser_peek(self))))) {
        Parser_advance(self);
    }
    name = substring(self->source, name_start, self->pos);
    if (!((name != NULL && name[0] != '\0'))) {
        self->pos = saved_pos;
        return NULL;
    }
    int64_t brace_depth = 0;
    int64_t i = 0;
    while ((i < _rune_len(name))) {
        if (is_expansion_start(name, i, "${")) {
            brace_depth += 1;
            i += 2;
            continue;
        }
        if ((strcmp((const char *)(_char_at_str(g_arena, name, i)), "}") == 0)) {
            brace_depth -= 1;
        }
        i += 1;
    }
    if ((brace_depth > 0)) {
        self->pos = saved_pos;
        return NULL;
    }
    int64_t pos_after_name = self->pos;
    Parser_skip_whitespace(self);
    bool has_whitespace = (self->pos > pos_after_name);
    if (((!(has_whitespace) && (name != NULL && name[0] != '\0')) && _str_contains("*?@+!$", (const char *)(_char_at_str(g_arena, name, (_rune_len(name) - 1)))))) {
        self->pos = saved_pos;
        return NULL;
    }
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "(") != 0))) {
        self->pos = saved_pos;
        return NULL;
    }
    Parser_advance(self);
    Parser_skip_whitespace(self);
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), ")") != 0))) {
        self->pos = saved_pos;
        return NULL;
    }
    Parser_advance(self);
    Parser_skip_whitespace_and_newlines(self);
    body = (Node *)Parser_parse_compound_command(self);
    if ((body == NULL)) {
        g_parse_error = 1;
        snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected function body");
        return NULL;
    }
    return Function_new(name, body, "function");
}

static Node * Parser_parse_compound_command(Parser *self) {
    Node * result = (Node *)Parser_parse_brace_group(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    if ((((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "(") == 0)) && ((self->pos + 1) < self->length)) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))), "(") == 0))) {
        result = (Node *)Parser_parse_arithmetic_command(self);
        if ((result != NULL)) {
            return (Node *)result;
        }
    }
    result = (Node *)Parser_parse_subshell(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_conditional_expr(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_if(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_while(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_until(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_for(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_case(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    result = (Node *)Parser_parse_select(self);
    if ((result != NULL)) {
        return (Node *)result;
    }
    return (Node *)NULL;
}

static bool Parser_at_list_until_terminator(Parser *self, void * stop_words) {
    if (Parser_at_end(self)) {
        return true;
    }
    if ((strcmp(Parser_peek(self), ")") == 0)) {
        return true;
    }
    if ((strcmp(Parser_peek(self), "}") == 0)) {
        int64_t next_pos = (self->pos + 1);
        if (((next_pos >= self->length) || is_word_end_context((const char *)(_char_at_str(g_arena, self->source, next_pos))))) {
            return true;
        }
    }
    const char * reserved = Parser_lex_peek_reserved_word(self);
    if (((strcmp(reserved, "") != 0) && _set_contains(stop_words, reserved))) {
        return true;
    }
    if ((strcmp(Parser_lex_peek_case_terminator(self), "") != 0)) {
        return true;
    }
    return false;
}

static Node * Parser_parse_list_until(Parser *self, void * stop_words) {
    Parser_skip_whitespace_and_newlines(self);
    const char * reserved = Parser_lex_peek_reserved_word(self);
    if (((strcmp(reserved, "") != 0) && _set_contains(stop_words, reserved))) {
        return (Node *)NULL;
    }
    Node * pipeline = (Node *)Parser_parse_pipeline(self);
    if ((pipeline == NULL)) {
        return (Node *)NULL;
    }
    Vec_Node parts = (Vec_Node){(Node *[]){ pipeline }, 1, 1};
    while (true) {
        Parser_skip_whitespace(self);
        const char * op = Parser_parse_list_operator(self);
        if ((strcmp(op, "") == 0)) {
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") == 0))) {
                Parser_advance(self);
                Parser_gather_heredoc_bodies(self);
                if (((self->cmdsub_heredoc_end != -(1)) && (self->cmdsub_heredoc_end > self->pos))) {
                    self->pos = self->cmdsub_heredoc_end;
                    self->cmdsub_heredoc_end = -(1);
                }
                Parser_skip_whitespace_and_newlines(self);
                if (Parser_at_list_until_terminator(self, stop_words)) {
                    break;
                }
                const char * next_op = Parser_peek_list_operator(self);
                if (((strcmp(next_op, "&") == 0) || (strcmp(next_op, ";") == 0))) {
                    break;
                }
                op = "\n";
            } else {
                break;
            }
        }
        if ((strcmp(op, "") == 0)) {
            break;
        }
        if ((strcmp(op, ";") == 0)) {
            Parser_skip_whitespace_and_newlines(self);
            if (Parser_at_list_until_terminator(self, stop_words)) {
                break;
            }
            VEC_PUSH(g_arena, &parts, (Operator_new(op, "operator")));
        } else if ((strcmp(op, "&") == 0)) {
            VEC_PUSH(g_arena, &parts, (Operator_new(op, "operator")));
            Parser_skip_whitespace_and_newlines(self);
            if (Parser_at_list_until_terminator(self, stop_words)) {
                break;
            }
        } else if (((strcmp(op, "&&") == 0) || (strcmp(op, "||") == 0))) {
            VEC_PUSH(g_arena, &parts, (Operator_new(op, "operator")));
            Parser_skip_whitespace_and_newlines(self);
        } else {
            VEC_PUSH(g_arena, &parts, (Operator_new(op, "operator")));
        }
        if (Parser_at_list_until_terminator(self, stop_words)) {
            break;
        }
        pipeline = (Node *)Parser_parse_pipeline(self);
        if ((pipeline == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected command after ", op));
            return NULL;
        }
        VEC_PUSH(g_arena, &parts, (pipeline));
    }
    if ((parts.len == 1)) {
        return (Node *)parts.data[0];
    }
    return List_new(parts, "list");
}

static Node * Parser_parse_pipeline(Parser *self) {
    Parser_skip_whitespace(self);
    const char * prefix_order = "";
    bool time_posix = false;
    int64_t saved;
    if (Parser_lex_is_at_reserved_word(self, "time")) {
        Parser_lex_consume_word(self, "time");
        prefix_order = "time";
        Parser_skip_whitespace(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
            saved = self->pos;
            Parser_advance(self);
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "p") == 0))) {
                Parser_advance(self);
                if ((Parser_at_end(self) || is_metachar(Parser_peek(self)))) {
                    time_posix = true;
                } else {
                    self->pos = saved;
                }
            } else {
                self->pos = saved;
            }
        }
        Parser_skip_whitespace(self);
        if ((!(Parser_at_end(self)) && starts_with_at(self->source, self->pos, "--"))) {
            if ((((self->pos + 2) >= self->length) || is_whitespace((const char *)(_char_at_str(g_arena, self->source, (self->pos + 2)))))) {
                Parser_advance(self);
                Parser_advance(self);
                time_posix = true;
                Parser_skip_whitespace(self);
            }
        }
        while (Parser_lex_is_at_reserved_word(self, "time")) {
            Parser_lex_consume_word(self, "time");
            Parser_skip_whitespace(self);
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "-") == 0))) {
                saved = self->pos;
                Parser_advance(self);
                if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "p") == 0))) {
                    Parser_advance(self);
                    if ((Parser_at_end(self) || is_metachar(Parser_peek(self)))) {
                        time_posix = true;
                    } else {
                        self->pos = saved;
                    }
                } else {
                    self->pos = saved;
                }
            }
        }
        Parser_skip_whitespace(self);
        if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "!") == 0))) {
            if (((((self->pos + 1) >= self->length) || is_negation_boundary((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))) && !(Parser_is_bang_followed_by_procsub(self)))) {
                Parser_advance(self);
                prefix_order = "time_negation";
                Parser_skip_whitespace(self);
            }
        }
    } else if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "!") == 0))) {
        if (((((self->pos + 1) >= self->length) || is_negation_boundary((const char *)(_char_at_str(g_arena, self->source, (self->pos + 1))))) && !(Parser_is_bang_followed_by_procsub(self)))) {
            Parser_advance(self);
            Parser_skip_whitespace(self);
            Node * inner = (Node *)Parser_parse_pipeline(self);
            if (((inner != NULL) && (strcmp(_kind_to_str(inner->kind), "negation") == 0))) {
                if ((((Negation *)(inner->data))->pipeline != NULL)) {
                    return (Node *)((Negation *)(inner->data))->pipeline;
                } else {
                    return Command_new((Vec_Word){NULL, 0, 0}, (Vec_Node){NULL, 0, 0}, "command");
                }
            }
            return Negation_new(inner, "negation");
        }
    }
    Node * result = (Node *)Parser_parse_simple_pipeline(self);
    if ((strcmp(prefix_order, "time") == 0)) {
        result = (Node *)Time_new(result, time_posix, "time");
    } else if ((strcmp(prefix_order, "negation") == 0)) {
        result = (Node *)Negation_new(result, "negation");
    } else if ((strcmp(prefix_order, "time_negation") == 0)) {
        result = (Node *)Time_new(result, time_posix, "time");
        result = (Node *)Negation_new(result, "negation");
    } else if ((strcmp(prefix_order, "negation_time") == 0)) {
        result = (Node *)Time_new(result, time_posix, "time");
        result = (Node *)Negation_new(result, "negation");
    } else if ((result == NULL)) {
        return (Node *)NULL;
    }
    return (Node *)result;
}

static Node * Parser_parse_simple_pipeline(Parser *self) {
    Node * cmd = (Node *)Parser_parse_compound_command(self);
    if ((cmd == NULL)) {
        return (Node *)NULL;
    }
    Vec_Node commands = (Vec_Node){(Node *[]){ cmd }, 1, 1};
    while (true) {
        Parser_skip_whitespace(self);
        Tuple_int64_t_constcharPtr _tup70 = Parser_lex_peek_operator(self);
        int64_t token_type = _tup70.F0;
        const char * value = _tup70.F1;
        if ((token_type == 0)) {
            break;
        }
        if (((token_type != TOKENTYPE_PIPE) && (token_type != TOKENTYPE_PIPE_AMP))) {
            break;
        }
        Parser_lex_next_token(self);
        bool is_pipe_both = (token_type == TOKENTYPE_PIPE_AMP);
        Parser_skip_whitespace_and_newlines(self);
        if (is_pipe_both) {
            VEC_PUSH(g_arena, &commands, (PipeBoth_new("pipe-both")));
        }
        cmd = (Node *)Parser_parse_compound_command(self);
        if ((cmd == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Expected command after |");
            return NULL;
        }
        VEC_PUSH(g_arena, &commands, (cmd));
    }
    if ((commands.len == 1)) {
        return (Node *)commands.data[0];
    }
    return Pipeline_new(commands, "pipeline");
}

static const char * Parser_parse_list_operator(Parser *self) {
    Parser_skip_whitespace(self);
    Tuple_int64_t_constcharPtr _tup71 = Parser_lex_peek_operator(self);
    int64_t token_type = _tup71.F0;
    if ((token_type == 0)) {
        return "";
    }
    if ((token_type == TOKENTYPE_AND_AND)) {
        Parser_lex_next_token(self);
        return "&&";
    }
    if ((token_type == TOKENTYPE_OR_OR)) {
        Parser_lex_next_token(self);
        return "||";
    }
    if ((token_type == TOKENTYPE_SEMI)) {
        Parser_lex_next_token(self);
        return ";";
    }
    if ((token_type == TOKENTYPE_AMP)) {
        Parser_lex_next_token(self);
        return "&";
    }
    return "";
}

static const char * Parser_peek_list_operator(Parser *self) {
    int64_t saved_pos = self->pos;
    const char * op = Parser_parse_list_operator(self);
    self->pos = saved_pos;
    return op;
}

static Node * Parser_parse_list(Parser *self, bool newline_as_separator) {
    if (newline_as_separator) {
        Parser_skip_whitespace_and_newlines(self);
    } else {
        Parser_skip_whitespace(self);
    }
    Node * pipeline = (Node *)Parser_parse_pipeline(self);
    if ((pipeline == NULL)) {
        return (Node *)NULL;
    }
    Vec_Node parts = (Vec_Node){(Node *[]){ pipeline }, 1, 1};
    if ((Parser_in_state(self, PARSERSTATEFLAGS_PST_EOFTOKEN) && Parser_at_eof_token(self))) {
        return (Node *)((parts.len == 1) ? parts.data[0] : List_new(parts, "list"));
    }
    while (true) {
        Parser_skip_whitespace(self);
        const char * op = Parser_parse_list_operator(self);
        if ((strcmp(op, "") == 0)) {
            if ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") == 0))) {
                if (!(newline_as_separator)) {
                    break;
                }
                Parser_advance(self);
                Parser_gather_heredoc_bodies(self);
                if (((self->cmdsub_heredoc_end != -(1)) && (self->cmdsub_heredoc_end > self->pos))) {
                    self->pos = self->cmdsub_heredoc_end;
                    self->cmdsub_heredoc_end = -(1);
                }
                Parser_skip_whitespace_and_newlines(self);
                if ((Parser_at_end(self) || Parser_at_list_terminating_bracket(self))) {
                    break;
                }
                const char * next_op = Parser_peek_list_operator(self);
                if (((strcmp(next_op, "&") == 0) || (strcmp(next_op, ";") == 0))) {
                    break;
                }
                op = "\n";
            } else {
                break;
            }
        }
        if ((strcmp(op, "") == 0)) {
            break;
        }
        VEC_PUSH(g_arena, &parts, (Operator_new(op, "operator")));
        if (((strcmp(op, "&&") == 0) || (strcmp(op, "||") == 0))) {
            Parser_skip_whitespace_and_newlines(self);
        } else if ((strcmp(op, "&") == 0)) {
            Parser_skip_whitespace(self);
            if ((Parser_at_end(self) || Parser_at_list_terminating_bracket(self))) {
                break;
            }
            if ((strcmp(Parser_peek(self), "\n") == 0)) {
                if (newline_as_separator) {
                    Parser_skip_whitespace_and_newlines(self);
                    if ((Parser_at_end(self) || Parser_at_list_terminating_bracket(self))) {
                        break;
                    }
                } else {
                    break;
                }
            }
        } else if ((strcmp(op, ";") == 0)) {
            Parser_skip_whitespace(self);
            if ((Parser_at_end(self) || Parser_at_list_terminating_bracket(self))) {
                break;
            }
            if ((strcmp(Parser_peek(self), "\n") == 0)) {
                if (newline_as_separator) {
                    Parser_skip_whitespace_and_newlines(self);
                    if ((Parser_at_end(self) || Parser_at_list_terminating_bracket(self))) {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
        pipeline = (Node *)Parser_parse_pipeline(self);
        if ((pipeline == NULL)) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", _str_concat(g_arena, "Expected command after ", op));
            return NULL;
        }
        VEC_PUSH(g_arena, &parts, (pipeline));
        if ((Parser_in_state(self, PARSERSTATEFLAGS_PST_EOFTOKEN) && Parser_at_eof_token(self))) {
            break;
        }
    }
    if ((parts.len == 1)) {
        return (Node *)parts.data[0];
    }
    return List_new(parts, "list");
}

static Node * Parser_parse_comment(Parser *self) {
    if ((Parser_at_end(self) || (strcmp(Parser_peek(self), "#") != 0))) {
        return (Node *)NULL;
    }
    int64_t start = self->pos;
    while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") != 0))) {
        Parser_advance(self);
    }
    const char * text = substring(self->source, start, self->pos);
    return Comment_new(text, "comment");
}

static Vec_Node Parser_parse(Parser *self) {
    const char * source = _str_trim(g_arena, self->source, " \t\n\r");
    if (!((source != NULL && source[0] != '\0'))) {
        return (Vec_Node){(Node *[]){ Empty_new("empty") }, 1, 1};
    }
    Vec_Node results = (Vec_Node){NULL, 0, 0};
    while (true) {
        Parser_skip_whitespace(self);
        while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") == 0))) {
            Parser_advance(self);
        }
        if (Parser_at_end(self)) {
            break;
        }
        Node * comment = (Node *)Parser_parse_comment(self);
        if (!((comment != NULL))) {
            break;
        }
    }
    while (!(Parser_at_end(self))) {
        Node * result = (Node *)Parser_parse_list(self, false);
        if ((result != NULL)) {
            VEC_PUSH(g_arena, &results, (result));
        }
        Parser_skip_whitespace(self);
        bool found_newline = false;
        while ((!(Parser_at_end(self)) && (strcmp(Parser_peek(self), "\n") == 0))) {
            found_newline = true;
            Parser_advance(self);
            Parser_gather_heredoc_bodies(self);
            if (((self->cmdsub_heredoc_end != -(1)) && (self->cmdsub_heredoc_end > self->pos))) {
                self->pos = self->cmdsub_heredoc_end;
                self->cmdsub_heredoc_end = -(1);
            }
            Parser_skip_whitespace(self);
        }
        if ((!(found_newline) && !(Parser_at_end(self)))) {
            g_parse_error = 1;
            snprintf(g_error_msg, sizeof(g_error_msg), "%s", "Syntax error");
            return (Vec_Node){NULL, 0, 0};
        }
    }
    if (!((results.len > 0))) {
        return (Vec_Node){(Node *[]){ Empty_new("empty") }, 1, 1};
    }
    if ((((self->saw_newline_in_single_quote && (self->source != NULL && self->source[0] != '\0')) && (strcmp((const char *)(_char_at_str(g_arena, self->source, (_rune_len(self->source) - 1))), "\\") == 0)) && !(((_rune_len(self->source) >= 3) && (strcmp(_substring(g_arena, self->source, (_rune_len(self->source) - 3), (_rune_len(self->source) - 1)), "\\\n") == 0))))) {
        if (!(Parser_last_word_on_own_line(self, results))) {
            Parser_strip_trailing_backslash_from_last_word(self, results);
        }
    }
    return results;
}

static bool Parser_last_word_on_own_line(Parser *self, Vec_Node nodes) {
    return (nodes.len >= 2);
}

static void Parser_strip_trailing_backslash_from_last_word(Parser *self, Vec_Node nodes) {
    if (!((nodes.len > 0))) {
        return;
    }
    Node * last_node = (Node *)nodes.data[(nodes.len - 1)];
    Word * last_word = Parser_find_last_word(self, last_node);
    if (((last_word != NULL) && _str_endswith(last_word->value, "\\"))) {
        last_word->value = substring(last_word->value, 0, (_rune_len(last_word->value) - 1));
        if (((!((last_word->value != NULL && last_word->value[0] != '\0')) && (last_node->kind == KIND_COMMAND)) && (((Command *)(last_node->data))->words.len > 0))) {
            ((Command *)(last_node))->words.data[--((Command *)(last_node))->words.len];
        }
    }
}

static Word * Parser_find_last_word(Parser *self, Node * node) {
    void *_data72 = node->data;
    switch (node->kind) {
    case KIND_WORD: {
        Word *node = (Word *)_data72;
        return node;
        break;
    }
    }
    Word * last_word;
    Node * last_redirect;
    void *_data73 = node->data;
    switch (node->kind) {
    case KIND_COMMAND: {
        Command *node = (Command *)_data73;
        if ((node->words.len > 0)) {
            last_word = node->words.data[(node->words.len - 1)];
            if (_str_endswith(last_word->value, "\\")) {
                return last_word;
            }
        }
        if ((node->redirects.len > 0)) {
            last_redirect = (Node *)node->redirects.data[(node->redirects.len - 1)];
            void *_data74 = last_redirect->data;
            switch (last_redirect->kind) {
            case KIND_REDIRECT: {
                Redirect *last_redirect = (Redirect *)_data74;
                return last_redirect->target;
                break;
            }
            }
        }
        if ((node->words.len > 0)) {
            return node->words.data[(node->words.len - 1)];
        }
        break;
    }
    }
    void *_data75 = node->data;
    switch (node->kind) {
    case KIND_PIPELINE: {
        Pipeline *node = (Pipeline *)_data75;
        if ((node->commands.len > 0)) {
            return Parser_find_last_word(self, node->commands.data[(node->commands.len - 1)]);
        }
        break;
    }
    }
    void *_data76 = node->data;
    switch (node->kind) {
    case KIND_LIST: {
        List *node = (List *)_data76;
        if ((node->parts.len > 0)) {
            return Parser_find_last_word(self, node->parts.data[(node->parts.len - 1)]);
        }
        break;
    }
    }
    return NULL;
}

static const char * Node_get_kind(Node *self) {
    switch (self->kind) {
    case 1:
        return Word_get_kind((Word *)self->data);
    case 2:
        return Command_get_kind((Command *)self->data);
    case 3:
        return Pipeline_get_kind((Pipeline *)self->data);
    case 4:
        return List_get_kind((List *)self->data);
    case 5:
        return Operator_get_kind((Operator *)self->data);
    case 6:
        return PipeBoth_get_kind((PipeBoth *)self->data);
    case 7:
        return Empty_get_kind((Empty *)self->data);
    case 8:
        return Comment_get_kind((Comment *)self->data);
    case 9:
        return Redirect_get_kind((Redirect *)self->data);
    case 10:
        return HereDoc_get_kind((HereDoc *)self->data);
    case 11:
        return Subshell_get_kind((Subshell *)self->data);
    case 12:
        return BraceGroup_get_kind((BraceGroup *)self->data);
    case 13:
        return If_get_kind((If *)self->data);
    case 14:
        return While_get_kind((While *)self->data);
    case 15:
        return Until_get_kind((Until *)self->data);
    case 16:
        return For_get_kind((For *)self->data);
    case 17:
        return ForArith_get_kind((ForArith *)self->data);
    case 18:
        return Select_get_kind((Select *)self->data);
    case 19:
        return Case_get_kind((Case *)self->data);
    case 20:
        return CasePattern_get_kind((CasePattern *)self->data);
    case 21:
        return Function_get_kind((Function *)self->data);
    case 22:
        return ParamExpansion_get_kind((ParamExpansion *)self->data);
    case 23:
        return ParamLength_get_kind((ParamLength *)self->data);
    case 24:
        return ParamIndirect_get_kind((ParamIndirect *)self->data);
    case 25:
        return CommandSubstitution_get_kind((CommandSubstitution *)self->data);
    case 26:
        return ArithmeticExpansion_get_kind((ArithmeticExpansion *)self->data);
    case 27:
        return ArithmeticCommand_get_kind((ArithmeticCommand *)self->data);
    case 28:
        return ArithNumber_get_kind((ArithNumber *)self->data);
    case 29:
        return ArithEmpty_get_kind((ArithEmpty *)self->data);
    case 30:
        return ArithVar_get_kind((ArithVar *)self->data);
    case 31:
        return ArithBinaryOp_get_kind((ArithBinaryOp *)self->data);
    case 32:
        return ArithUnaryOp_get_kind((ArithUnaryOp *)self->data);
    case 33:
        return ArithPreIncr_get_kind((ArithPreIncr *)self->data);
    case 34:
        return ArithPostIncr_get_kind((ArithPostIncr *)self->data);
    case 35:
        return ArithPreDecr_get_kind((ArithPreDecr *)self->data);
    case 36:
        return ArithPostDecr_get_kind((ArithPostDecr *)self->data);
    case 37:
        return ArithAssign_get_kind((ArithAssign *)self->data);
    case 38:
        return ArithTernary_get_kind((ArithTernary *)self->data);
    case 39:
        return ArithComma_get_kind((ArithComma *)self->data);
    case 40:
        return ArithSubscript_get_kind((ArithSubscript *)self->data);
    case 41:
        return ArithEscape_get_kind((ArithEscape *)self->data);
    case 42:
        return ArithDeprecated_get_kind((ArithDeprecated *)self->data);
    case 43:
        return ArithConcat_get_kind((ArithConcat *)self->data);
    case 44:
        return AnsiCQuote_get_kind((AnsiCQuote *)self->data);
    case 45:
        return LocaleString_get_kind((LocaleString *)self->data);
    case 46:
        return ProcessSubstitution_get_kind((ProcessSubstitution *)self->data);
    case 47:
        return Negation_get_kind((Negation *)self->data);
    case 48:
        return Time_get_kind((Time *)self->data);
    case 49:
        return ConditionalExpr_get_kind((ConditionalExpr *)self->data);
    case 50:
        return UnaryTest_get_kind((UnaryTest *)self->data);
    case 51:
        return BinaryTest_get_kind((BinaryTest *)self->data);
    case 52:
        return CondAnd_get_kind((CondAnd *)self->data);
    case 53:
        return CondOr_get_kind((CondOr *)self->data);
    case 54:
        return CondNot_get_kind((CondNot *)self->data);
    case 55:
        return CondParen_get_kind((CondParen *)self->data);
    case 56:
        return Array_get_kind((Array *)self->data);
    case 57:
        return Coproc_get_kind((Coproc *)self->data);
    default:
        return NULL;
    }
}

static const char * Node_to_sexp(Node *self) {
    switch (self->kind) {
    case 1:
        return Word_to_sexp((Word *)self->data);
    case 2:
        return Command_to_sexp((Command *)self->data);
    case 3:
        return Pipeline_to_sexp((Pipeline *)self->data);
    case 4:
        return List_to_sexp((List *)self->data);
    case 5:
        return Operator_to_sexp((Operator *)self->data);
    case 6:
        return PipeBoth_to_sexp((PipeBoth *)self->data);
    case 7:
        return Empty_to_sexp((Empty *)self->data);
    case 8:
        return Comment_to_sexp((Comment *)self->data);
    case 9:
        return Redirect_to_sexp((Redirect *)self->data);
    case 10:
        return HereDoc_to_sexp((HereDoc *)self->data);
    case 11:
        return Subshell_to_sexp((Subshell *)self->data);
    case 12:
        return BraceGroup_to_sexp((BraceGroup *)self->data);
    case 13:
        return If_to_sexp((If *)self->data);
    case 14:
        return While_to_sexp((While *)self->data);
    case 15:
        return Until_to_sexp((Until *)self->data);
    case 16:
        return For_to_sexp((For *)self->data);
    case 17:
        return ForArith_to_sexp((ForArith *)self->data);
    case 18:
        return Select_to_sexp((Select *)self->data);
    case 19:
        return Case_to_sexp((Case *)self->data);
    case 20:
        return CasePattern_to_sexp((CasePattern *)self->data);
    case 21:
        return Function_to_sexp((Function *)self->data);
    case 22:
        return ParamExpansion_to_sexp((ParamExpansion *)self->data);
    case 23:
        return ParamLength_to_sexp((ParamLength *)self->data);
    case 24:
        return ParamIndirect_to_sexp((ParamIndirect *)self->data);
    case 25:
        return CommandSubstitution_to_sexp((CommandSubstitution *)self->data);
    case 26:
        return ArithmeticExpansion_to_sexp((ArithmeticExpansion *)self->data);
    case 27:
        return ArithmeticCommand_to_sexp((ArithmeticCommand *)self->data);
    case 28:
        return ArithNumber_to_sexp((ArithNumber *)self->data);
    case 29:
        return ArithEmpty_to_sexp((ArithEmpty *)self->data);
    case 30:
        return ArithVar_to_sexp((ArithVar *)self->data);
    case 31:
        return ArithBinaryOp_to_sexp((ArithBinaryOp *)self->data);
    case 32:
        return ArithUnaryOp_to_sexp((ArithUnaryOp *)self->data);
    case 33:
        return ArithPreIncr_to_sexp((ArithPreIncr *)self->data);
    case 34:
        return ArithPostIncr_to_sexp((ArithPostIncr *)self->data);
    case 35:
        return ArithPreDecr_to_sexp((ArithPreDecr *)self->data);
    case 36:
        return ArithPostDecr_to_sexp((ArithPostDecr *)self->data);
    case 37:
        return ArithAssign_to_sexp((ArithAssign *)self->data);
    case 38:
        return ArithTernary_to_sexp((ArithTernary *)self->data);
    case 39:
        return ArithComma_to_sexp((ArithComma *)self->data);
    case 40:
        return ArithSubscript_to_sexp((ArithSubscript *)self->data);
    case 41:
        return ArithEscape_to_sexp((ArithEscape *)self->data);
    case 42:
        return ArithDeprecated_to_sexp((ArithDeprecated *)self->data);
    case 43:
        return ArithConcat_to_sexp((ArithConcat *)self->data);
    case 44:
        return AnsiCQuote_to_sexp((AnsiCQuote *)self->data);
    case 45:
        return LocaleString_to_sexp((LocaleString *)self->data);
    case 46:
        return ProcessSubstitution_to_sexp((ProcessSubstitution *)self->data);
    case 47:
        return Negation_to_sexp((Negation *)self->data);
    case 48:
        return Time_to_sexp((Time *)self->data);
    case 49:
        return ConditionalExpr_to_sexp((ConditionalExpr *)self->data);
    case 50:
        return UnaryTest_to_sexp((UnaryTest *)self->data);
    case 51:
        return BinaryTest_to_sexp((BinaryTest *)self->data);
    case 52:
        return CondAnd_to_sexp((CondAnd *)self->data);
    case 53:
        return CondOr_to_sexp((CondOr *)self->data);
    case 54:
        return CondNot_to_sexp((CondNot *)self->data);
    case 55:
        return CondParen_to_sexp((CondParen *)self->data);
    case 56:
        return Array_to_sexp((Array *)self->data);
    case 57:
        return Coproc_to_sexp((Coproc *)self->data);
    default:
        return NULL;
    }
}

