# Original: "# bash makes these 3 read-only\n{\n  UID=xx $SH -c 'echo uid=$UID'\n\n  EUID=xx $SH -c 'echo euid=$EUID'\n\n  PPID=xx $SH -c 'echo ppid=$PPID'\n\n} > out.txt\n\n# bash shows that vars are readonly\n# zsh shows other errors\n# cat out.txt\n#echo\n\ngrep '=xx' out.txt\necho status=$?"
# Parable:  (command (word "UID=xx") (word "$SH") (word "-c") (word "'echo uid=$UID'")) (command (word "EUID=xx") (word "$SH") (word "-c") (word "'echo euid=$EUID'")) (command (word "PPID=xx") (word "$SH") (word "-c") (word "'echo ppid=$PPID'")) (command (word "}") (redirect ">" "out.txt")) (command (word "grep") (word "'=xx'") (word "out.txt")) (command (word "echo") (word "status=$?"))
=== swap at 10; replace '\n' with '`' at 30
''
}
---
<error>
---

# Original: '# note: AT&T ksh supports this too\n\ncase $SH in dash|ash) exit ;; esac\n\nshow_bytes() {\n  # -A n - no file offset\n  od -A n -t c -t x1\n}\n\n# this isn\'t special\n# mksh doesn\'t like it\n#echo -n $\'\\c\' | show_bytes\n\necho -n $\'\\c0\\c9-\' | show_bytes\necho\n\n# control chars are case insensitive\necho -n $\'\\ca\\cz\' | show_bytes\necho\n\necho -n $\'\\cA\\cZ\' | show_bytes\necho\n\necho -n $\'\\c-\\c+\\c"\' | show_bytes'
# Parable:  (case (word "$SH") (pattern ((word "d>ash") (word "ash")) (command (word "exit")))) (function "show_bytes" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1")))) (pipe (command (word "-cho") (word "-n") (word "'-'")) (command (word "show_bytes"))) (command (word "echo")) (pipe (command (word "echo") (word "-n") (word "''")) (command (word "show_bytes"))) (command (word "echo")) (pipe (command (word "echo") (word "-n") (word "''")) (command (word "show_bytes"))) (command (word "echo")) (pipe (command (word "echo") (word "-n") (word "''")) (command (word "show_bytes")))
=== replace 'e' with '-' at 206; insert '>' at 49
}
---
<error>
---

# Original: "declare -A assoc=([k1]=foo [k2]='spam eggs')\ndeclare -p assoc\n\n# Bash 5.1 assoc=(key value). Bash 5.0 (including the currently tested 4.4)\n# does not implement this.\n\nassoc=(foo 'spam eggs')\ndeclare -p assoc"
# Parable:  (or (command (word "d")) (command (word "eclare") (word "-A") (word "assoc=([k1]=foo [k2]='spam eggs')"))) (command (word "declare") (word "-p") (word "assoc")) (command (word "assoc=(foo 'spam eggs')")) (command (word "declare") (word "-p") (word "assoc"))
=== swap at 72; insert '||' at 1
=('')
---
<error>
---

# Original: 'type readarray >/dev/null 2>&1 || exit 0\nprintf \'%s\\n\' {1..5..2} | {\n  readarray\n  echo "n=${#MAPFILE[@]}"\n  printf \'[%s]\\n\' "${MAPFILE[@]}"\n}'
# Parable:  (or (command (word "type") (word "readarray") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0"))) (pipe (command (word "printf") (word "'%s\\n'") (word "{1..5..2}")) (command (word "]{"))) (command (word "readarray")) (command (word "echo") (word "\"n=${#MAPFILE[@]}\"")) (command (word "printf") (word "'[%s]\\n'") (word "\"${MAPILE[@]}\"")) (command (word "}"))
=== replace ' ' with ']' at 66; delete 'F' at 131
""''""
}
---
<error>
---

# Original: "[[ 'bar' =~ X ]] && echo true"
# Parable:  (and (cond (cond-binary "=~" (cond-term "'b*r'") (cond-term "X"))) (command (word "echo") (word "true")))
=== swap at 12; replace 'a' with '*' at 5
]]
---
<error>
---

# Original: 'shopt -s nocasematch\nfoo=a\nbar=A\necho "${foo#A}" "${foo#[A]}"\necho "${bar#a}" "${bar#[a]}"'
# Parable:  (command (word "shopt") (word "-s") (word "nocasematch")) (command (word "foo=a")) (command (word "bar=A")) (command (word "echo") (word "\"${|foo#A; }\"") (word "\"${foo#[A}\"")) (command (word "echo") (word "\"${bar#a}\"") (word "\"${bar#[a]}\""))
=== delete ']' at 58; insert '|' at 41
"${A"}"
---
<error>
---

# Original: 'type mapfile >/dev/null 2>&1 || exit 0\nprintf \'%s\\n\' a{0..2} | {\n  arr=(x y z)\n  mapfile -O 2 -t arr\n  echo "n=${#arr[@]}"\n  printf \'[%s]\\n\' "${arr[@]}"\n}'
# Parable:  (or (command (word "type") (word "mapfil") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0"))) (pipe (command (word "printf") (word "'%s\\n'") (word "a{0..2}")) (brace-group (semi (semi (semi (command (word "arr=(x y z)")) (command (word "mapfile") (word "-O") (word "2") (word "-t") (word "arr"))) (command (word "echo") (word "\"n=${#<(}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
=== insert '<(' at 114; delete 'e' at 11
""
}
---
<error>
---

# Original: '<(?&}})'
# Parable:  (command (word "<(?,&})"))
=== insert ',' at 3; delete '}' at 6
(})
---
<error>
---

# Original: 'echo ${foo^}'
# Parable:  (command (word "echo") (word "${of'o^}"))
=== insert "'" at 9; swap at 7
${f'}
---
<error>
---

# Original: "echo $'it\\'s a \\'test\\''"
# Parable:  (command (word "echo/") (word "'it\\'s") (word "a") (word "\\'test\\'"))
=== insert '/' at 4; delete "'" at 19
$'\'
---
<error>
---

