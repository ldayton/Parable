# Iteration 12: Command Substitution

# === Basic $(...) form ===

=== simple command substitution
echo $(pwd)
---
(command (word "echo") (word "$(pwd)"))


=== command substitution with args
echo $(ls -la)
---
(command (word "echo") (word "$(ls -la)"))


=== command substitution in middle of word
echo prefix$(pwd)suffix
---
(command (word "echo") (word "prefix$(pwd)suffix"))


=== command substitution at start
echo $(echo hi)there
---
(command (word "echo") (word "$(echo hi)there"))


=== command substitution at end
echo hello$(echo world)
---
(command (word "echo") (word "hello$(echo world)"))


=== multiple command substitutions
echo $(echo a)$(echo b)
---
(command (word "echo") (word "$(echo a)$(echo b)"))


=== command substitution with pipeline
echo $(cat file | grep pattern)
---
(command (word "echo") (word "$(cat file | grep pattern)"))


=== command substitution with list
echo $(echo a; echo b)
---
(command (word "echo") (word "$(echo a; echo b)"))


=== nested command substitution
echo $(echo $(pwd))
---
(command (word "echo") (word "$(echo $(pwd))"))


=== deeply nested substitution
echo $(echo $(echo $(pwd)))
---
(command (word "echo") (word "$(echo $(echo $(pwd)))"))


# === In double quotes ===

=== command substitution in double quotes
echo "$(pwd)"
---
(command (word "echo") (word "\"$(pwd)\""))


=== command substitution with text in quotes
echo "Current dir: $(pwd)"
---
(command (word "echo") (word "\"Current dir: $(pwd)\""))


=== command substitution and variable in quotes
echo "User $(whoami) at $PWD"
---
(command (word "echo") (word "\"User $(whoami) at $PWD\""))


# === Backtick form ===

=== backtick simple
echo `pwd`
---
(command (word "echo") (word "`pwd`"))


=== backtick with args
echo `ls -la`
---
(command (word "echo") (word "`ls -la`"))


=== backtick in word
echo prefix`pwd`suffix
---
(command (word "echo") (word "prefix`pwd`suffix"))


=== backtick in double quotes
echo "`pwd`"
---
(command (word "echo") (word "\"`pwd`\""))


=== backtick with pipeline
echo `cat file | head -1`
---
(command (word "echo") (word "`cat file | head -1`"))


# === Mixed forms ===

=== dollar and backtick
echo $(pwd) `date`
---
(command (word "echo") (word "$(pwd)") (word "`date`"))


=== dollar inside backtick
echo `echo $(pwd)`
---
(command (word "echo") (word "`echo $(pwd)`"))


# === With redirections inside ===

=== command substitution with redirect
echo $(cat < file)
---
(command (word "echo") (word "$(cat < file)"))


=== command substitution with output redirect
x=$(cmd > /dev/null)
---
(command (word "x=$(cmd > /dev/null)"))


# === With control structures inside ===

=== command substitution with if
echo $(if true; then echo yes; fi)
---
(command (word "echo") (word "$(if true; then\n    echo yes;\nfi)"))


=== command substitution with for
echo $(for i in a b; do echo $i; done)
---
(command (word "echo") (word "$(for i in a b;\ndo\n    echo $i;\ndone)"))


=== command substitution with case
echo $(case $x in a) echo a;; esac)
---
(command (word "echo") (word "$(case $x in a)\n        echo a\n    ;;\nesac)"))


# === In assignments ===

=== simple assignment with cmdsub
foo=$(pwd)
---
(command (word "foo=$(pwd)"))


=== export with cmdsub
export PATH=$(pwd):$PATH
---
(command (word "export") (word "PATH=$(pwd):$PATH"))


# === Empty and edge cases ===

=== empty command substitution
echo $()
---
(command (word "echo") (word "$()"))


=== command substitution whitespace only
echo $(   )
---
(command (word "echo") (word "$()"))


=== command substitution with newline
echo $(
pwd
)
---
(command (word "echo") (word "$(pwd)"))


# === Brutal edge cases ===

# Subshell inside command substitution - note space after $(
=== subshell inside cmdsub
echo $( (echo in subshell) )
---
(command (word "echo") (word "$( ( echo in subshell ))"))


=== brace group inside cmdsub
echo $( { echo brace; } )
---
(command (word "echo") (word "$({ echo brace; })"))


=== while inside cmdsub
echo $(while false; do echo x; done)
---
(command (word "echo") (word "$(while false; do\n    echo x;\ndone)"))


=== until inside cmdsub
echo $(until true; do echo x; done)
---
(command (word "echo") (word "$(until true; do\n    echo x;\ndone)"))


=== function definition inside cmdsub
echo $(f() { echo hi; }; f)
---
(command (word "echo") (word "$(function f () \n{ \n    echo hi\n}; f)"))


=== background job in cmdsub
echo $(echo bg &)
---
(command (word "echo") (word "$(echo bg &)"))


=== multiple statements in cmdsub
echo $(echo a; echo b; echo c)
---
(command (word "echo") (word "$(echo a; echo b; echo c)"))


=== and list inside cmdsub
echo $(true && echo yes)
---
(command (word "echo") (word "$(true && echo yes)"))


=== or list inside cmdsub
echo $(false || echo fallback)
---
(command (word "echo") (word "$(false || echo fallback)"))


# Complex case statements inside command substitution
=== case with multiple patterns in cmdsub
echo $(case $x in a) echo a;; b) echo b;; *) echo default;; esac)
---
(command (word "echo") (word "$(case $x in a)\n        echo a\n    ;;\n    b)\n        echo b\n    ;;\n    *)\n        echo default\n    ;;\nesac)"))


=== case with or pattern in cmdsub
echo $(case $x in a|b|c) echo match;; esac)
---
(command (word "echo") (word "$(case $x in a | b | c)\n        echo match\n    ;;\nesac)"))


=== nested case in cmdsub
echo $(case $a in x) case $b in y) echo xy;; esac;; esac)
---
(command (word "echo") (word "$(case $a in x)\n        case $b in y)\n                echo xy\n            ;;\n        esac\n    ;;\nesac)"))


# Nested if/elif/else inside cmdsub
=== if else inside cmdsub
echo $(if true; then echo yes; else echo no; fi)
---
(command (word "echo") (word "$(if true; then\n    echo yes;\nelse\n    echo no;\nfi)"))


=== elif chain inside cmdsub
echo $(if false; then echo a; elif true; then echo b; else echo c; fi)
---
(command (word "echo") (word "$(if false; then\n    echo a;\nelse\n    if true; then\n        echo b;\n    else\n        echo c;\n    fi;\nfi)"))


# Quotes inside command substitution
=== double quotes inside cmdsub
echo $(echo "hello world")
---
(command (word "echo") (word "$(echo \"hello world\")"))


=== single quotes inside cmdsub
echo $(echo 'hello world')
---
(command (word "echo") (word "$(echo 'hello world')"))


=== mixed quotes inside cmdsub
echo $(echo "it's" 'a "test"')
---
(command (word "echo") (word "$(echo \"it's\" 'a \"test\"')"))


=== escaped quotes in cmdsub
echo $(echo \"quoted\")
---
(command (word "echo") (word "$(echo \\\"quoted\\\")"))


# Nested command substitution variations
=== triple nested cmdsub
echo $(echo $(echo $(echo deep)))
---
(command (word "echo") (word "$(echo $(echo $(echo deep)))"))


=== cmdsub in middle of other cmdsub
echo $(echo start $(pwd) end)
---
(command (word "echo") (word "$(echo start $(pwd) end)"))


=== multiple cmdsubs in one inner command
echo $(echo $(whoami) at $(pwd))
---
(command (word "echo") (word "$(echo $(whoami) at $(pwd))"))


# Backtick edge cases
=== empty backtick
echo ``
---
(command (word "echo") (word "``"))


=== backtick with variable
echo `echo $HOME`
---
(command (word "echo") (word "`echo $HOME`"))


=== backtick with quotes
echo `echo "hello"`
---
(command (word "echo") (word "`echo \"hello\"`"))


# File reading shortcut (bash extension)
=== file reading shortcut
echo $(<file.txt)
---
(command (word "echo") (word "$(< file.txt)"))


=== file reading with path
echo $(</etc/passwd)
---
(command (word "echo") (word "$(< /etc/passwd)"))


# Command substitution as command itself
=== cmdsub as command
$(echo echo) hello
---
(command (word "$(echo echo)") (word "hello"))


=== cmdsub produces pipeline
$(echo "cat | head") file
---
(command (word "$(echo \"cat | head\")") (word "file"))


# Parameter expansion inside command substitution
=== param expansion inside cmdsub
echo $(echo ${foo:-default})
---
(command (word "echo") (word "$(echo ${foo:-default})"))


=== complex param in cmdsub
echo $(echo ${x##*/})
---
(command (word "echo") (word "$(echo ${x##*/})"))


# Special characters
=== cmdsub with semicolons
echo $(echo a; echo b; echo c;)
---
(command (word "echo") (word "$(echo a; echo b; echo c)"))


=== cmdsub with newlines and semicolons
echo $(
echo a
echo b
)
---
(command (word "echo") (word "$(echo a\necho b)"))


# NOTE: $((expr)) is now properly parsed as arithmetic expansion (see 13_arithmetic.tests)

# Command substitution with special positional params
=== cmdsub with positional param
echo $(echo $1)
---
(command (word "echo") (word "$(echo $1)"))


=== cmdsub with all args
echo $(echo $@)
---
(command (word "echo") (word "$(echo $@)"))


=== cmdsub with exit status
echo $(echo $?)
---
(command (word "echo") (word "$(echo $?)"))


# Real-world patterns
=== dirname pattern
dir=$(cd "$(dirname "$0")" && pwd)
---
(command (word "dir=$(cd \"$(dirname \"$0\")\" && pwd)"))


=== basename pattern
name=$(basename "$file" .txt)
---
(command (word "name=$(basename \"$file\" .txt)"))


=== find exec pattern
files=$(find . -name "*.txt")
---
(command (word "files=$(find . -name \"*.txt\")"))


=== command -v check
if cmd=$(command -v git); then echo found; fi
---
(if (command (word "cmd=$(command -v git)")) (command (word "echo") (word "found")))
