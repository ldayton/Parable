# Iteration 26: Variable fd redirections ({varname}>file)

# === Basic variable fd output ===

=== variable fd output redirect
exec {fd}>file.txt
---
(command (word "exec") (redirect ">" "file.txt"))


=== variable fd append
exec {fd}>>file.txt
---
(command (word "exec") (redirect ">>" "file.txt"))


=== variable fd input
exec {fd}<file.txt
---
(command (word "exec") (redirect "<" "file.txt"))


=== variable fd read-write
exec {fd}<>file.txt
---
(command (word "exec") (redirect "<>" "file.txt"))


# === Variable fd with dup ===

=== variable fd dup output
exec {fd}>&1
---
(command (word "exec") (redirect ">&" 1))


=== variable fd dup input
exec {fd}<&0
---
(command (word "exec") (redirect "<&" 0))


=== variable fd close
exec {fd}>&-
---
(command (word "exec") (redirect ">&-" 0))


# === Different variable names ===

=== single letter varname
exec {f}>file
---
(command (word "exec") (redirect ">" "file"))


=== uppercase varname
exec {FD}>file
---
(command (word "exec") (redirect ">" "file"))


=== underscore varname
exec {my_fd}>file
---
(command (word "exec") (redirect ">" "file"))


=== mixed case varname
exec {myFd}>file
---
(command (word "exec") (redirect ">" "file"))


# === Spacing variations ===

=== no space before target
exec {fd}>file
---
(command (word "exec") (redirect ">" "file"))


=== space before target
exec {fd}> file
---
(command (word "exec") (redirect ">" "file"))


# === In context ===

=== variable fd in function
f() { exec {fd}>log; }
---
(function "f" (brace-group (command (word "exec") (redirect ">" "log"))))


=== variable fd in subshell
(exec {fd}>file)
---
(subshell (command (word "exec") (redirect ">" "file")))


=== multiple variable fds
exec {in}<input {out}>output
---
(command (word "exec") (redirect "<" "input") (redirect ">" "output"))


=== variable fd with regular redirect
exec {fd}>out 2>&1
---
(command (word "exec") (redirect ">" "out") (redirect ">&" 1))


=== variable fd with quoted target
exec {fd}>"file name"
---
(command (word "exec") (redirect ">" ""file name""))


# === Brutal edge cases ===

=== variable fd noclobber
exec {fd}>|file
---
(command (word "exec") (redirect ">|" "file"))


=== variable fd here string
cat {fd}<<<text
---
(command (word "cat") (redirect "<<<" "text"))


=== variable fd close input
exec {fd}<&-
---
(command (word "exec") (redirect ">&-" 0))


=== long variable name
exec {very_long_variable_name_for_fd}>file
---
(command (word "exec") (redirect ">" "file"))


=== variable fd with numbers in name
exec {fd3}>file
---
(command (word "exec") (redirect ">" "file"))


=== variable fd underscore prefix
exec {_fd}>file
---
(command (word "exec") (redirect ">" "file"))


=== variable fd in while loop
while read line; do echo "$line"; done {fd}<file
---
(while (command (word "read") (word "line")) (command (word "echo") (word "\"$line\""))) (redirect "<" "file")


=== variable fd in for loop
for i in 1 2 3; do echo $i; done {fd}>out
---
(for (word "i") (in (word "1") (word "2") (word "3")) (command (word "echo") (word "$i"))) (redirect ">" "out")


=== variable fd in if statement
if true; then echo yes; fi {fd}>log
---
(if (command (word "true")) (command (word "echo") (word "yes"))) (redirect ">" "log")


=== variable fd in pipeline
cmd1 {fd}>out | cmd2
---
(pipe (command (word "cmd1") (redirect ">" "out")) (command (word "cmd2")))


=== variable fd with variable expansion target
exec {fd}>$logfile
---
(command (word "exec") (redirect ">" "$logfile"))


=== variable fd with command substitution target
exec {fd}>$(mktemp)
---
(command (word "exec") (redirect ">" "$(mktemp)"))


=== variable fd in background
exec {fd}>file &
---
(background (command (word "exec") (redirect ">" "file")))


=== variable fd in list
exec {fd1}>out && exec {fd2}>err
---
(and (command (word "exec") (redirect ">" "out")) (command (word "exec") (redirect ">" "err")))


=== variable fd with process substitution
diff {fd1}< <(cmd1) {fd2}< <(cmd2)
---
(command (word "diff") (redirect "<" "<(cmd1)") (redirect "<" "<(cmd2)"))


=== variable fd in case
case $x in a) exec {fd}>log;; esac
---
(case (word "$x") (pattern ((word "a")) (command (word "exec") (redirect ">" "log"))))


=== variable fd with brace expansion after
cmd {fd}>file{1,2}
---
(command (word "cmd") (redirect ">" "file{1,2}"))


=== multiple variable fds same line different types
exec {r}<in {w}>out {rw}<>both
---
(command (word "exec") (redirect "<" "in") (redirect ">" "out") (redirect "<>" "both"))


=== variable fd dup to another varfd
exec {fd2}>&$fd1
---
(command (word "exec") (redirect ">&" "$fd1"))
