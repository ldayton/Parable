# Converted from GNU Bash test suite

=== alias
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# place holder for future alias testing
shopt -s expand_aliases

# alias/unalias tests originally in builtins.tests

unalias -a
# this should return success, according to POSIX.2
alias
echo alias: $?
alias foo=bar
unalias foo
# this had better return success, according to POSIX.2
alias
echo alias: $?

# bug in all versions through bash-2.05b

unalias qfoo qbar qbaz quux 2>/dev/null

alias qfoo=qbar
alias qbar=qbaz
alias qbaz=quux
alias quux=qfoo

qfoo

unalias qfoo qbar qbaz quux

unalias -a
# error
unalias foo

alias foo='echo '
alias bar=baz
alias baz=quux

foo bar

unalias foo bar baz

# post bash-5.1 problems with compound array assignment during multiline
# alias expansion
alias foo='a=() b=""
for i in 1; do echo hi; done'
foo
unalias foo

alias L='m=("x")'
L
declare -p m

# invalid alias names generate errors
alias '\$'=xx
BASH_ALIASES['\$']=xx

${THIS_SH} ./alias1.sub
${THIS_SH} ./alias2.sub
${THIS_SH} ./alias3.sub
${THIS_SH} ./alias4.sub
${THIS_SH} ./alias5.sub
${THIS_SH} ./alias6.sub
${THIS_SH} ./alias7.sub

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "unalias") (word "-a"))
(command (word "alias"))
(command (word "echo") (word "alias:") (word "$?"))
(command (word "alias") (word "foo=bar"))
(command (word "unalias") (word "foo"))
(command (word "alias"))
(command (word "echo") (word "alias:") (word "$?"))
(command (word "unalias") (word "qfoo") (word "qbar") (word "qbaz") (word "quux") (redirect ">" "/dev/null"))
(command (word "alias") (word "qfoo=qbar"))
(command (word "alias") (word "qbar=qbaz"))
(command (word "alias") (word "qbaz=quux"))
(command (word "alias") (word "quux=qfoo"))
(command (word "qfoo"))
(command (word "unalias") (word "qfoo") (word "qbar") (word "qbaz") (word "quux"))
(command (word "unalias") (word "-a"))
(command (word "unalias") (word "foo"))
(command (word "alias") (word "foo='echo '"))
(command (word "alias") (word "bar=baz"))
(command (word "alias") (word "baz=quux"))
(command (word "foo") (word "bar"))
(command (word "unalias") (word "foo") (word "bar") (word "baz"))
(command (word "alias") (word "foo='a=() b=\"\"\nfor i in 1; do echo hi; done'"))
(command (word "foo"))
(command (word "unalias") (word "foo"))
(command (word "alias") (word "L='m=(\"x\")'"))
(command (word "L"))
(command (word "declare") (word "-p") (word "m"))
(command (word "alias") (word "'\\$'=xx"))
(command (word "BASH_ALIASES['\\$']=xx"))
(command (word "${THIS_SH}") (word "./alias1.sub"))
(command (word "${THIS_SH}") (word "./alias2.sub"))
(command (word "${THIS_SH}") (word "./alias3.sub"))
(command (word "${THIS_SH}") (word "./alias4.sub"))
(command (word "${THIS_SH}") (word "./alias5.sub"))
(command (word "${THIS_SH}") (word "./alias6.sub"))
(command (word "${THIS_SH}") (word "./alias7.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== appendop
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# basic cases
a=1
a+=4
echo $a

x=(1 2 3)
x+=(4 5 6)

echo ${x[@]}

x[4]+=1
echo ${x[@]}

# trickier cases
# post-bash-4.2: bash understands += in environment assignments preceding
# command names
a+=5 printenv a
echo $a

# if the integer flag is set, ksh93 appears to do arithmetic += and evaluate
# old value as an arithmetic expression
a=
typeset -i a
a+=7
echo $a

b=4+1
typeset -i b
b+=37

echo $b

unset x
x=(1 2 3 4 5)

typeset -i x

x[4]+=7

echo ${x[@]}

unset x
typeset -i x

x=([0]=7+11)
echo ${x[@]}

unset x
x=(1 2 3 4 5)

typeset -i x

#x[4]=7+11

x=(1 2 3 4 [4]=7+11 )
echo ${x[@]}

x=( 1 2 [2]+=7 4 5 )
echo ${x[@]}

x+=( [3]+=9 [5]=9 )
echo ${x[@]}

unset a
a=1
export a+=4
printenv a
printenv a+

unset x
typeset -i x=4+5
echo $x

unset x
typeset x+=4
echo $x

typeset -i x+=5
echo $x

readonly x+=7
echo $x

x+=5

${THIS_SH} ./appendop1.sub
${THIS_SH} ./appendop2.sub

--------------------------------------------------------------------------------
---
(command (word "a=1"))
(command (word "a+=4"))
(command (word "echo") (word "$a"))
(command (word "x=(1 2 3)"))
(command (word "x+=(4 5 6)"))
(command (word "echo") (word "${x[@]}"))
(command (word "x[4]+=1"))
(command (word "echo") (word "${x[@]}"))
(command (word "a+=5") (word "printenv") (word "a"))
(command (word "echo") (word "$a"))
(command (word "a="))
(command (word "typeset") (word "-i") (word "a"))
(command (word "a+=7"))
(command (word "echo") (word "$a"))
(command (word "b=4+1"))
(command (word "typeset") (word "-i") (word "b"))
(command (word "b+=37"))
(command (word "echo") (word "$b"))
(command (word "unset") (word "x"))
(command (word "x=(1 2 3 4 5)"))
(command (word "typeset") (word "-i") (word "x"))
(command (word "x[4]+=7"))
(command (word "echo") (word "${x[@]}"))
(command (word "unset") (word "x"))
(command (word "typeset") (word "-i") (word "x"))
(command (word "x=([0]=7+11)"))
(command (word "echo") (word "${x[@]}"))
(command (word "unset") (word "x"))
(command (word "x=(1 2 3 4 5)"))
(command (word "typeset") (word "-i") (word "x"))
(command (word "x=(1 2 3 4 [4]=7+11)"))
(command (word "echo") (word "${x[@]}"))
(command (word "x=(1 2 [2]+=7 4 5)"))
(command (word "echo") (word "${x[@]}"))
(command (word "x+=([3]+=9 [5]=9)"))
(command (word "echo") (word "${x[@]}"))
(command (word "unset") (word "a"))
(command (word "a=1"))
(command (word "export") (word "a+=4"))
(command (word "printenv") (word "a"))
(command (word "printenv") (word "a+"))
(command (word "unset") (word "x"))
(command (word "typeset") (word "-i") (word "x=4+5"))
(command (word "echo") (word "$x"))
(command (word "unset") (word "x"))
(command (word "typeset") (word "x+=4"))
(command (word "echo") (word "$x"))
(command (word "typeset") (word "-i") (word "x+=5"))
(command (word "echo") (word "$x"))
(command (word "readonly") (word "x+=7"))
(command (word "echo") (word "$x"))
(command (word "x+=5"))
(command (word "${THIS_SH}") (word "./appendop1.sub"))
(command (word "${THIS_SH}") (word "./appendop2.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== arith
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
set +o posix
declare -i iv jv

iv=$(( 3 + 5 * 32 ))
echo $iv
iv=iv+3
echo $iv
iv=2
jv=iv

let "jv *= 2"
echo $jv
jv=$(( $jv << 2 ))
echo $jv

let jv="$jv / 2"
echo $jv
jv="jv >> 2"
echo $jv

iv=$((iv+ $jv))
echo $iv
echo $((iv -= jv))
echo $iv
echo $(( iv == jv ))
echo $(( iv != $jv ))
echo $(( iv < jv ))
echo $(( $iv > $jv ))
echo $(( iv <= $jv ))
echo $(( $iv >= jv ))

echo $jv
echo $(( ~$jv ))
echo $(( ~1 ))
echo $(( ! 0 ))

echo $(( jv % 2 ))
echo $(( $iv % 4 ))

echo $(( iv <<= 16 ))
echo $(( iv %= 33 ))

echo $(( 33 & 55 ))
echo $(( 33 | 17 ))

echo $(( iv && $jv ))
echo $(( $iv || jv ))

echo $(( iv && 0 ))
echo $(( iv & 0 ))
echo $(( iv && 1 ))
echo $(( iv & 1 ))

echo $(( $jv || 0 ))
echo $(( jv | 0 ))
echo $(( jv | 1 ))
echo $(( $jv || 1 ))

let 'iv *= jv'
echo $iv
echo $jv
let "jv += $iv"
echo $jv

echo $(( jv /= iv ))
echo $(( jv <<= 8 ))
echo $(( jv >>= 4 ))

echo $(( iv |= 4 ))
echo $(( iv &= 4 ))

echo $(( iv += (jv + 9)))
echo $(( (iv + 4) % 7 ))

# unary plus, minus
echo $(( +4 - 8 ))
echo $(( -4 + 8 ))

# conditional expressions
echo $(( 4<5 ? 1 : 32))
echo $(( 4>5 ? 1 : 32))
echo $(( 4>(2+3) ? 1 : 32))
echo $(( 4<(2+3) ? 1 : 32))
echo $(( (2+2)<(2+3) ? 1 : 32))
echo $(( (2+2)>(2+3) ? 1 : 32))

echo $(( (2+2)>(2+3) ? 2**0 : 32))

# bug in bash versions through bash-3.2
S=105
W=$((S>99?4:S>9?3:S>0?2:0))
echo $W
unset W S

# check that the unevaluated part of the ternary operator does not do
# evaluation or assignment
x=i+=2
y=j+=2
declare -i i=1 j=1
echo $((1 ? 20 : (x+=2)))
echo $i,$x
echo $((0 ? (y+=2) : 30))
echo $j,$y

x=i+=2
y=j+=2
declare -i i=1 j=1
echo $((1 ? 20 : (x+=2)))
echo $i,$x
echo $((0 ? (y+=2) : 30))
echo $i,$y

# check precedence of assignment vs. conditional operator
# should be an error
declare -i x=2
y=$((1 ? 20 : x+=2))

# check precedence of assignment vs. conditional operator
declare -i x=2
echo $((0 ? x+=2 : 20))

# associativity of assignment-operator operator
declare -i i=1 j=2 k=3
echo $((i += j += k))
echo $i,$j,$k

# octal, hex
echo $(( 0x100 | 007 ))
echo $(( 0xff ))
echo $(( 16#ff ))
echo $(( 16#FF/2 ))
echo $(( 8#44 ))

echo $(( 8 ^ 32 ))
a=8
echo $(( a ^ 32 ))
echo $(( a ^= 32 ))
unset -v a

# other bases
echo $(( 16#a ))
echo $(( 32#a ))
echo $(( 56#a ))
echo $(( 64#a ))

echo $(( 16#A ))
echo $(( 32#A ))
echo $(( 56#A ))
echo $(( 64#A ))

echo $(( 64#@ ))
echo $(( 64#_ ))

# weird bases
echo $(( 3425#56 ))

# missing number after base now generates an error
echo $(( 2# ))

# these should generate errors
echo $(( 7 = 43 ))
echo $(( 2#44 ))
echo $(( 44 / 0 ))
let 'jv += $iv'
echo $(( jv += \$iv ))
let 'rv = 7 + (43 * 6'

b=44
echo $(( b / 0 ))
echo $(( b /= 0 ))
unset -v b

# more errors
declare -i i
i=0#4
i=2#110#11

((echo abc; echo def;); echo ghi)

if (((4+4) + (4 + 7))); then
	echo ok
fi

(())	# make sure the null expression works OK

a=(0 2 4 6)
echo $(( a[1] + a[2] ))
echo $(( (a[1] + a[2]) == a[3] ))
(( (a[1] + a[2]) == a[3] )) ; echo $?

# test pushing and popping the expression stack
unset A
A="4 + "
echo $(( ( 4 + A ) + 4 ))
A="3 + 5"
echo $(( ( 4 + A ) + 4 ))

# badly-formed conditional expressions
echo $(( 4 ? : $A ))
echo $(( 1 ? 20 ))
echo $(( 4 ? 20 : ))

# precedence and short-circuit evaluation
B=9
echo $B

echo $(( 0 && B=42 ))
echo $B

echo $(( 1 || B=88 ))
echo $B

echo $(( 0 && (B=42) ))
echo $B

echo $(( (${$} - $$) && (B=42) ))
echo $B

echo $(( 1 || (B=88) ))
echo $B

# until command with (( )) command
x=7

echo $x
until (( x == 4 ))
do
	echo $x
	x=4
done

echo $x

# exponentiation
echo $(( 2**15 - 1))
echo $(( 2**(16-1)))
echo $(( 2**16*2 ))
echo $(( 2**31-1))
echo $(( 2**0 ))

# error
echo $(( 2**-1 ))

# {pre,post}-{inc,dec}rement and associated errors

x=4

echo $x
echo $(( x++ ))
echo $x
echo $(( x-- ))
echo $x

echo $(( --x ))
echo $x

echo $(( ++x ))
echo $x

echo $(( ++7 ))
echo $(( 7-- ))

echo $(( --x=7 ))
echo $(( ++x=7 ))

echo $(( x++=7 ))
echo $(( x--=7 ))

echo $x

echo $(( +7 ))
echo $(( -7 ))

echo $(( ++7 ))
echo $(( --7 ))

unset -v x
x=8
echo $(( --x++ ))	# error
unset -v x

# combinations of expansions
echo $(( "`echo 1+1`" ))
echo $(( `echo 1+1` ))

${THIS_SH} ./arith1.sub
${THIS_SH} ./arith2.sub
${THIS_SH} ./arith3.sub
${THIS_SH} ./arith4.sub

# make sure arithmetic expansion handles ints > 2**31 - 1 using intmax_t
echo $(( 2147483645 + 4 ))

# other tests using INTMAX_MIN and INTMAX_MAX that cause exceptions if not
# handled correctly -- problem through bash-4.2
${THIS_SH} ./arith5.sub

# problems with suppressing evaluation present through bash-4.2
${THIS_SH} ./arith6.sub

# problems with parsing arithmetic expressions containing colons that are
# part of word expansions such as substring extraction
${THIS_SH} ./arith7.sub

# problems with evaluation of conditional expressions
${THIS_SH} ./arith8.sub

# expressions with unset variables and nounset enabled
${THIS_SH} ./arith9.sub

# empty expressions in various arithmetic evaluation contexts
${THIS_SH} ./arith10.sub

x=4
y=7

(( x=8 , y=12 ))

echo $x $y

# should be an error
(( x=9 y=41 ))

# These are errors
unset b
echo $((a b))
((a b))

n=42
printf "%d\n" $n
printf "%i\n" $n
echo $(( 8#$(printf "%o\n" $n) ))
printf "%u\n" $n
echo $(( 16#$(printf "%x\n" $n) ))
echo $(( 16#$(printf "%X\n" $n) ))

# allow reserved words after an arithmetic command just because
if ((expr)) then ((expr)) fi

# these are errors
foo=1
echo $(( 'foo' ))

# causes longjmp botches through bash-2.05b
a[b[c]d]=e

--------------------------------------------------------------------------------
---
(command (word "set") (word "+o") (word "posix"))
(command (word "declare") (word "-i") (word "iv") (word "jv"))
(command (word "iv=$(( 3 + 5 * 32 ))"))
(command (word "echo") (word "$iv"))
(command (word "iv=iv+3"))
(command (word "echo") (word "$iv"))
(command (word "iv=2"))
(command (word "jv=iv"))
(command (word "let") (word "\"jv *= 2\""))
(command (word "echo") (word "$jv"))
(command (word "jv=$(( $jv << 2 ))"))
(command (word "echo") (word "$jv"))
(command (word "let") (word "jv=\"$jv / 2\""))
(command (word "echo") (word "$jv"))
(command (word "jv=\"jv >> 2\""))
(command (word "echo") (word "$jv"))
(command (word "iv=$((iv+ $jv))"))
(command (word "echo") (word "$iv"))
(command (word "echo") (word "$((iv -= jv))"))
(command (word "echo") (word "$iv"))
(command (word "echo") (word "$(( iv == jv ))"))
(command (word "echo") (word "$(( iv != $jv ))"))
(command (word "echo") (word "$(( iv < jv ))"))
(command (word "echo") (word "$(( $iv > $jv ))"))
(command (word "echo") (word "$(( iv <= $jv ))"))
(command (word "echo") (word "$(( $iv >= jv ))"))
(command (word "echo") (word "$jv"))
(command (word "echo") (word "$(( ~$jv ))"))
(command (word "echo") (word "$(( ~1 ))"))
(command (word "echo") (word "$(( ! 0 ))"))
(command (word "echo") (word "$(( jv % 2 ))"))
(command (word "echo") (word "$(( $iv % 4 ))"))
(command (word "echo") (word "$(( iv <<= 16 ))"))
(command (word "echo") (word "$(( iv %= 33 ))"))
(command (word "echo") (word "$(( 33 & 55 ))"))
(command (word "echo") (word "$(( 33 | 17 ))"))
(command (word "echo") (word "$(( iv && $jv ))"))
(command (word "echo") (word "$(( $iv || jv ))"))
(command (word "echo") (word "$(( iv && 0 ))"))
(command (word "echo") (word "$(( iv & 0 ))"))
(command (word "echo") (word "$(( iv && 1 ))"))
(command (word "echo") (word "$(( iv & 1 ))"))
(command (word "echo") (word "$(( $jv || 0 ))"))
(command (word "echo") (word "$(( jv | 0 ))"))
(command (word "echo") (word "$(( jv | 1 ))"))
(command (word "echo") (word "$(( $jv || 1 ))"))
(command (word "let") (word "'iv *= jv'"))
(command (word "echo") (word "$iv"))
(command (word "echo") (word "$jv"))
(command (word "let") (word "\"jv += $iv\""))
(command (word "echo") (word "$jv"))
(command (word "echo") (word "$(( jv /= iv ))"))
(command (word "echo") (word "$(( jv <<= 8 ))"))
(command (word "echo") (word "$(( jv >>= 4 ))"))
(command (word "echo") (word "$(( iv |= 4 ))"))
(command (word "echo") (word "$(( iv &= 4 ))"))
(command (word "echo") (word "$(( iv += (jv + 9)))"))
(command (word "echo") (word "$(( (iv + 4) % 7 ))"))
(command (word "echo") (word "$(( +4 - 8 ))"))
(command (word "echo") (word "$(( -4 + 8 ))"))
(command (word "echo") (word "$(( 4<5 ? 1 : 32))"))
(command (word "echo") (word "$(( 4>5 ? 1 : 32))"))
(command (word "echo") (word "$(( 4>(2+3) ? 1 : 32))"))
(command (word "echo") (word "$(( 4<(2+3) ? 1 : 32))"))
(command (word "echo") (word "$(( (2+2)<(2+3) ? 1 : 32))"))
(command (word "echo") (word "$(( (2+2)>(2+3) ? 1 : 32))"))
(command (word "echo") (word "$(( (2+2)>(2+3) ? 2**0 : 32))"))
(command (word "S=105"))
(command (word "W=$((S>99?4:S>9?3:S>0?2:0))"))
(command (word "echo") (word "$W"))
(command (word "unset") (word "W") (word "S"))
(command (word "x=i+=2"))
(command (word "y=j+=2"))
(command (word "declare") (word "-i") (word "i=1") (word "j=1"))
(command (word "echo") (word "$((1 ? 20 : (x+=2)))"))
(command (word "echo") (word "$i,$x"))
(command (word "echo") (word "$((0 ? (y+=2) : 30))"))
(command (word "echo") (word "$j,$y"))
(command (word "x=i+=2"))
(command (word "y=j+=2"))
(command (word "declare") (word "-i") (word "i=1") (word "j=1"))
(command (word "echo") (word "$((1 ? 20 : (x+=2)))"))
(command (word "echo") (word "$i,$x"))
(command (word "echo") (word "$((0 ? (y+=2) : 30))"))
(command (word "echo") (word "$i,$y"))
(command (word "declare") (word "-i") (word "x=2"))
(command (word "y=$((1 ? 20 : x+=2))"))
(command (word "declare") (word "-i") (word "x=2"))
(command (word "echo") (word "$((0 ? x+=2 : 20))"))
(command (word "declare") (word "-i") (word "i=1") (word "j=2") (word "k=3"))
(command (word "echo") (word "$((i += j += k))"))
(command (word "echo") (word "$i,$j,$k"))
(command (word "echo") (word "$(( 0x100 | 007 ))"))
(command (word "echo") (word "$(( 0xff ))"))
(command (word "echo") (word "$(( 16#ff ))"))
(command (word "echo") (word "$(( 16#FF/2 ))"))
(command (word "echo") (word "$(( 8#44 ))"))
(command (word "echo") (word "$(( 8 ^ 32 ))"))
(command (word "a=8"))
(command (word "echo") (word "$(( a ^ 32 ))"))
(command (word "echo") (word "$(( a ^= 32 ))"))
(command (word "unset") (word "-v") (word "a"))
(command (word "echo") (word "$(( 16#a ))"))
(command (word "echo") (word "$(( 32#a ))"))
(command (word "echo") (word "$(( 56#a ))"))
(command (word "echo") (word "$(( 64#a ))"))
(command (word "echo") (word "$(( 16#A ))"))
(command (word "echo") (word "$(( 32#A ))"))
(command (word "echo") (word "$(( 56#A ))"))
(command (word "echo") (word "$(( 64#A ))"))
(command (word "echo") (word "$(( 64#@ ))"))
(command (word "echo") (word "$(( 64#_ ))"))
(command (word "echo") (word "$(( 3425#56 ))"))
(command (word "echo") (word "$(( 2# ))"))
(command (word "echo") (word "$(( 7 = 43 ))"))
(command (word "echo") (word "$(( 2#44 ))"))
(command (word "echo") (word "$(( 44 / 0 ))"))
(command (word "let") (word "'jv += $iv'"))
(command (word "echo") (word "$(( jv += \\$iv ))"))
(command (word "let") (word "'rv = 7 + (43 * 6'"))
(command (word "b=44"))
(command (word "echo") (word "$(( b / 0 ))"))
(command (word "echo") (word "$(( b /= 0 ))"))
(command (word "unset") (word "-v") (word "b"))
(command (word "declare") (word "-i") (word "i"))
(command (word "i=0#4"))
(command (word "i=2#110#11"))
(subshell (semi (subshell (semi (command (word "echo") (word "abc")) (command (word "echo") (word "def")))) (command (word "echo") (word "ghi"))))
(if (arith (word "(4+4) + (4 + 7)")) (command (word "echo") (word "ok")))
(arith (word ""))
(command (word "a=(0 2 4 6)"))
(command (word "echo") (word "$(( a[1] + a[2] ))"))
(command (word "echo") (word "$(( (a[1] + a[2]) == a[3] ))"))
(semi (arith (word " (a[1] + a[2]) == a[3] ")) (command (word "echo") (word "$?")))
(command (word "unset") (word "A"))
(command (word "A=\"4 + \""))
(command (word "echo") (word "$(( ( 4 + A ) + 4 ))"))
(command (word "A=\"3 + 5\""))
(command (word "echo") (word "$(( ( 4 + A ) + 4 ))"))
(command (word "echo") (word "$(( 4 ? : $A ))"))
(command (word "echo") (word "$(( 1 ? 20 ))"))
(command (word "echo") (word "$(( 4 ? 20 : ))"))
(command (word "B=9"))
(command (word "echo") (word "$B"))
(command (word "echo") (word "$(( 0 && B=42 ))"))
(command (word "echo") (word "$B"))
(command (word "echo") (word "$(( 1 || B=88 ))"))
(command (word "echo") (word "$B"))
(command (word "echo") (word "$(( 0 && (B=42) ))"))
(command (word "echo") (word "$B"))
(command (word "echo") (word "$(( (${$} - $$) && (B=42) ))"))
(command (word "echo") (word "$B"))
(command (word "echo") (word "$(( 1 || (B=88) ))"))
(command (word "echo") (word "$B"))
(command (word "x=7"))
(command (word "echo") (word "$x"))
(until (arith (word " x == 4 ")) (semi (command (word "echo") (word "$x")) (command (word "x=4"))))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( 2**15 - 1))"))
(command (word "echo") (word "$(( 2**(16-1)))"))
(command (word "echo") (word "$(( 2**16*2 ))"))
(command (word "echo") (word "$(( 2**31-1))"))
(command (word "echo") (word "$(( 2**0 ))"))
(command (word "echo") (word "$(( 2**-1 ))"))
(command (word "x=4"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( x++ ))"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( x-- ))"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( --x ))"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( ++x ))"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( ++7 ))"))
(command (word "echo") (word "$(( 7-- ))"))
(command (word "echo") (word "$(( --x=7 ))"))
(command (word "echo") (word "$(( ++x=7 ))"))
(command (word "echo") (word "$(( x++=7 ))"))
(command (word "echo") (word "$(( x--=7 ))"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "$(( +7 ))"))
(command (word "echo") (word "$(( -7 ))"))
(command (word "echo") (word "$(( ++7 ))"))
(command (word "echo") (word "$(( --7 ))"))
(command (word "unset") (word "-v") (word "x"))
(command (word "x=8"))
(command (word "echo") (word "$(( --x++ ))"))
(command (word "unset") (word "-v") (word "x"))
(command (word "echo") (word "$(( \"`echo 1+1`\" ))"))
(command (word "echo") (word "$(( `echo 1+1` ))"))
(command (word "${THIS_SH}") (word "./arith1.sub"))
(command (word "${THIS_SH}") (word "./arith2.sub"))
(command (word "${THIS_SH}") (word "./arith3.sub"))
(command (word "${THIS_SH}") (word "./arith4.sub"))
(command (word "echo") (word "$(( 2147483645 + 4 ))"))
(command (word "${THIS_SH}") (word "./arith5.sub"))
(command (word "${THIS_SH}") (word "./arith6.sub"))
(command (word "${THIS_SH}") (word "./arith7.sub"))
(command (word "${THIS_SH}") (word "./arith8.sub"))
(command (word "${THIS_SH}") (word "./arith9.sub"))
(command (word "${THIS_SH}") (word "./arith10.sub"))
(command (word "x=4"))
(command (word "y=7"))
(arith (word " x=8 , y=12 "))
(command (word "echo") (word "$x") (word "$y"))
(arith (word " x=9 y=41 "))
(command (word "unset") (word "b"))
(command (word "echo") (word "$((a b))"))
(arith (word "a b"))
(command (word "n=42"))
(command (word "printf") (word "\"%d\\n\"") (word "$n"))
(command (word "printf") (word "\"%i\\n\"") (word "$n"))
(command (word "echo") (word "$(( 8#$(printf \"%o\\n\" $n) ))"))
(command (word "printf") (word "\"%u\\n\"") (word "$n"))
(command (word "echo") (word "$(( 16#$(printf \"%x\\n\" $n) ))"))
(command (word "echo") (word "$(( 16#$(printf \"%X\\n\" $n) ))"))
(if (arith (word "expr")) (arith (word "expr")))
(command (word "foo=1"))
(command (word "echo") (word "$(( 'foo' ))"))
(command (word "a[b[c]d]=e"))
(command (word "--------------------------------------------------------------------------------"))
---

=== assoc
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# TEST - basic declaration and assignment
typeset -A fluff
declare -A

fluff[foo]=one
fluff[bar]=two

declare -A
declare -p fluff

unset fluff[foo]
declare -p fluff

fluff[bar]=newval
declare fluff[qux]=assigned

declare -p fluff

unset fluff

# TEST - compound assignment and variable attributes
declare -A wheat chaff
wheat=( [zero]=0 [one]=a [two]=b [three]=c )

declare -i chaff
chaff=( [zero]=1+4 [one]=3+7 four )

declare -A waste=( [pid]=42134 [version]=4.0-devel [source]=$0 [lineno]=$LINENO )
declare -r waste

declare -A

declare +i chaff
chaff[hello world]=flip
declare -p chaff

# TEST - no longer errors
waste[stuff]=other
unset waste
chaff[*]=12
chaff=( [one]=a [*]=12 )

# TEST - key expansion -- no word splitting
chaff[hello world]=flip
declare -p chaff
echo ${chaff[hello world]}

chaff[box]="multiple words"

recho ${chaff[@]}
recho "${chaff[@]}"

recho ${chaff[*]}
recho "${chaff[*]}"

unset chaff
declare -A chaff[200]
declare +A chaff

chaff[*]=12
chaff=( [one]=a [*]=12 )

# TEST - keys and values containing spaces
unset wheat
declare -A wheat
wheat=([six]=6 [foo bar]="qux qix" )

declare -p wheat

unset wheat
declare -A wheat=([six]=6 [foo bar]="qux qix" )

recho ${wheat[foo bar]}
recho "${wheat[foo bar]}"

declare -p wheat

# TEST - basic expansions: number of elements and value length
unset wheat
typeset -A wheat
wheat=([six]=6 [foo bar]="qux qix" )

recho ${#wheat[@]}

# and error
echo ${#wheat[$unset]}
# zero length for unset element
echo ${#wheat[unset]}

recho ${#wheat[foo bar]}

# TEST - appending assignment operator
unset wheat
typeset -A wheat
wheat=([six]=6 [foo bar]="qux qix" )

wheat[foo bar]+=' blat'

recho ${wheat[foo bar]}
recho "${wheat[foo bar]}"
unset wheat

flix=9
typeset -Ai wheat
wheat=([six]=6 [foo bar]=flix )

wheat[foo bar]+=7

recho ${wheat[foo bar]}
recho "${wheat[foo bar]}"
unset flix wheat

# TEST - index expansion: no word splitting or globbing
typeset -A wheat
cd ${TMPDIR:=/tmp}
touch '[sfiri]'
wheat=([s*]=6 [foo bar]=flix )

recho ${wheat[@]}
rm '[sfiri]'
cd $OLDPWD

# TEST -- associative array keys expansion
unset wheat
typeset -A wheat

wheat=([six]=6 [foo bar]=flix )

recho ${!wheat[@]}
recho "${!wheat[@]}"

# TEST -- associative array pattern removal
unset xpath
typeset -A xpath

xpath=( [0]=/bin [one]=/bin [two]=/usr/bin [three]=/usr/ucb [four]=/usr/local/bin)
xpath+=( [five]=/sbin [six]=/usr/sbin [seven]=. )

echo ${#xpath[@]}

echo ${xpath[@]}
echo ${xpath[@]##*/}
echo ${xpath[0]##*/}
echo ${xpath[@]%%[!/]*}
echo ${xpath[0]%%[!/]*}
recho ${xpath##*/}
recho ${xpath%%[!/]*}
recho ${xpath[five]##*/}
recho ${xpath[five]%%[!/]*}

echo ${#xpath[*]}

echo ${xpath[*]}
echo ${xpath[*]##*/}
echo ${xpath[*]%%[!/]*}

# TEST -- associative array pattern substitution
unset xpath
typeset -A xpath

xpath=( [0]=/bin [one]=/bin [two]=/usr/bin [three]=/usr/ucb [four]=/usr/local/bin)
xpath+=( [five]=/sbin [six]=/usr/sbin [seven]=. )

echo ${#xpath[@]}
# default element is "0" (as a string)
echo ${#xpath} -- ${xpath["0"]}

echo ${xpath[@]//\//^}
echo "${xpath[@]//\//^}" | cat -v

zecho "${xpath[@]/\//\\}"
zecho "${xpath[@]//\//\\}"
zecho "${xpath[@]//[\/]/\\}"

# test assignment to key "0"
unset T
declare -A T
T='([a]=1)'
echo "${T[@]}"
unset T

# peculiar ksh93 semantics for unsubscripted assoc variable reference
declare -A T
T[0]='zero'
if [ "$T" != "${T[0]}" ]; then
	echo 'assoc.tests: $T and ${T[0]} mismatch'
fi

${THIS_SH} ./assoc1.sub

${THIS_SH} ./assoc2.sub

${THIS_SH} ./assoc3.sub

${THIS_SH} ./assoc4.sub

${THIS_SH} ./assoc5.sub

${THIS_SH} ./assoc6.sub

${THIS_SH} ./assoc7.sub

# test converting between scalars and assoc arrays
unset assoc
assoc=assoc
declare -A assoc
declare -p assoc
echo ${assoc[@]}

# weird syntax required to append to multiple existing array elements using
# compound assignment syntax
unset assoc
declare -A assoc 
assoc=( [one]=one [two]=two [three]=three )
assoc+=( [one]+=more [two]+=less )
declare -p assoc

readonly -A assoc
declare -p assoc

declare -A hash

hash=(["key"]="value1")
declare -p hash
hash=(["key"]="${hash["key"]} value2")
declare -p hash

unset hash

${THIS_SH} ./assoc8.sub

# new shopt option to prevent multiple expansion of assoc array subscripts
${THIS_SH} ./assoc9.sub

${THIS_SH} ./assoc10.sub

# test assigning associative arrays using compound key/value pair assignments
${THIS_SH} ./assoc11.sub

# more kvpair associative array assignment tests
${THIS_SH} ./assoc12.sub

# assignment to @ and *
${THIS_SH} ./assoc13.sub

# tests of the @k transformation on associative arrays
${THIS_SH} ./assoc14.sub

# tests with subscripts and values containing 0x01 (some indexed array tests too)
${THIS_SH} ./assoc15.sub

# tests with subscripts being expanded more than one in ${xxx} word expansions
${THIS_SH} ./assoc16.sub

# tests with `[' and `]' subscripts and `unset'
${THIS_SH} ./assoc17.sub

# tests with `[' and `]' subscripts and printf/read/wait builtins
${THIS_SH} ./assoc18.sub

# tests with tilde expansion in keys and values post-bash-5.2
${THIS_SH} ./assoc19.sub

--------------------------------------------------------------------------------
---
(command (word "typeset") (word "-A") (word "fluff"))
(command (word "declare") (word "-A"))
(command (word "fluff[foo]=one"))
(command (word "fluff[bar]=two"))
(command (word "declare") (word "-A"))
(command (word "declare") (word "-p") (word "fluff"))
(command (word "unset") (word "fluff[foo]"))
(command (word "declare") (word "-p") (word "fluff"))
(command (word "fluff[bar]=newval"))
(command (word "declare") (word "fluff[qux]=assigned"))
(command (word "declare") (word "-p") (word "fluff"))
(command (word "unset") (word "fluff"))
(command (word "declare") (word "-A") (word "wheat") (word "chaff"))
(command (word "wheat=([zero]=0 [one]=a [two]=b [three]=c)"))
(command (word "declare") (word "-i") (word "chaff"))
(command (word "chaff=([zero]=1+4 [one]=3+7 four)"))
(command (word "declare") (word "-A") (word "waste=([pid]=42134 [version]=4.0-devel [source]=$0 [lineno]=$LINENO)"))
(command (word "declare") (word "-r") (word "waste"))
(command (word "declare") (word "-A"))
(command (word "declare") (word "+i") (word "chaff"))
(command (word "chaff[hello world]=flip"))
(command (word "declare") (word "-p") (word "chaff"))
(command (word "waste[stuff]=other"))
(command (word "unset") (word "waste"))
(command (word "chaff[*]=12"))
(command (word "chaff=([one]=a [*]=12)"))
(command (word "chaff[hello world]=flip"))
(command (word "declare") (word "-p") (word "chaff"))
(command (word "echo") (word "${chaff[hello world]}"))
(command (word "chaff[box]=\"multiple words\""))
(command (word "recho") (word "${chaff[@]}"))
(command (word "recho") (word "\"${chaff[@]}\""))
(command (word "recho") (word "${chaff[*]}"))
(command (word "recho") (word "\"${chaff[*]}\""))
(command (word "unset") (word "chaff"))
(command (word "declare") (word "-A") (word "chaff[200]"))
(command (word "declare") (word "+A") (word "chaff"))
(command (word "chaff[*]=12"))
(command (word "chaff=([one]=a [*]=12)"))
(command (word "unset") (word "wheat"))
(command (word "declare") (word "-A") (word "wheat"))
(command (word "wheat=([six]=6 [foo bar]=\"qux qix\")"))
(command (word "declare") (word "-p") (word "wheat"))
(command (word "unset") (word "wheat"))
(command (word "declare") (word "-A") (word "wheat=([six]=6 [foo bar]=\"qux qix\")"))
(command (word "recho") (word "${wheat[foo bar]}"))
(command (word "recho") (word "\"${wheat[foo bar]}\""))
(command (word "declare") (word "-p") (word "wheat"))
(command (word "unset") (word "wheat"))
(command (word "typeset") (word "-A") (word "wheat"))
(command (word "wheat=([six]=6 [foo bar]=\"qux qix\")"))
(command (word "recho") (word "${#wheat[@]}"))
(command (word "echo") (word "${#wheat[$unset]}"))
(command (word "echo") (word "${#wheat[unset]}"))
(command (word "recho") (word "${#wheat[foo bar]}"))
(command (word "unset") (word "wheat"))
(command (word "typeset") (word "-A") (word "wheat"))
(command (word "wheat=([six]=6 [foo bar]=\"qux qix\")"))
(command (word "wheat[foo bar]+=' blat'"))
(command (word "recho") (word "${wheat[foo bar]}"))
(command (word "recho") (word "\"${wheat[foo bar]}\""))
(command (word "unset") (word "wheat"))
(command (word "flix=9"))
(command (word "typeset") (word "-Ai") (word "wheat"))
(command (word "wheat=([six]=6 [foo bar]=flix)"))
(command (word "wheat[foo bar]+=7"))
(command (word "recho") (word "${wheat[foo bar]}"))
(command (word "recho") (word "\"${wheat[foo bar]}\""))
(command (word "unset") (word "flix") (word "wheat"))
(command (word "typeset") (word "-A") (word "wheat"))
(command (word "cd") (word "${TMPDIR:=/tmp}"))
(command (word "touch") (word "'[sfiri]'"))
(command (word "wheat=([s*]=6 [foo bar]=flix)"))
(command (word "recho") (word "${wheat[@]}"))
(command (word "rm") (word "'[sfiri]'"))
(command (word "cd") (word "$OLDPWD"))
(command (word "unset") (word "wheat"))
(command (word "typeset") (word "-A") (word "wheat"))
(command (word "wheat=([six]=6 [foo bar]=flix)"))
(command (word "recho") (word "${!wheat[@]}"))
(command (word "recho") (word "\"${!wheat[@]}\""))
(command (word "unset") (word "xpath"))
(command (word "typeset") (word "-A") (word "xpath"))
(command (word "xpath=([0]=/bin [one]=/bin [two]=/usr/bin [three]=/usr/ucb [four]=/usr/local/bin)"))
(command (word "xpath+=([five]=/sbin [six]=/usr/sbin [seven]=.)"))
(command (word "echo") (word "${#xpath[@]}"))
(command (word "echo") (word "${xpath[@]}"))
(command (word "echo") (word "${xpath[@]##*/}"))
(command (word "echo") (word "${xpath[0]##*/}"))
(command (word "echo") (word "${xpath[@]%%[!/]*}"))
(command (word "echo") (word "${xpath[0]%%[!/]*}"))
(command (word "recho") (word "${xpath##*/}"))
(command (word "recho") (word "${xpath%%[!/]*}"))
(command (word "recho") (word "${xpath[five]##*/}"))
(command (word "recho") (word "${xpath[five]%%[!/]*}"))
(command (word "echo") (word "${#xpath[*]}"))
(command (word "echo") (word "${xpath[*]}"))
(command (word "echo") (word "${xpath[*]##*/}"))
(command (word "echo") (word "${xpath[*]%%[!/]*}"))
(command (word "unset") (word "xpath"))
(command (word "typeset") (word "-A") (word "xpath"))
(command (word "xpath=([0]=/bin [one]=/bin [two]=/usr/bin [three]=/usr/ucb [four]=/usr/local/bin)"))
(command (word "xpath+=([five]=/sbin [six]=/usr/sbin [seven]=.)"))
(command (word "echo") (word "${#xpath[@]}"))
(command (word "echo") (word "${#xpath}") (word "--") (word "${xpath[\"0\"]}"))
(command (word "echo") (word "${xpath[@]//\\//^}"))
(pipe (command (word "echo") (word "\"${xpath[@]//\\//^}\"")) (command (word "cat") (word "-v")))
(command (word "zecho") (word "\"${xpath[@]/\\//\\\\}\""))
(command (word "zecho") (word "\"${xpath[@]//\\//\\\\}\""))
(command (word "zecho") (word "\"${xpath[@]//[\\/]/\\\\}\""))
(command (word "unset") (word "T"))
(command (word "declare") (word "-A") (word "T"))
(command (word "T='([a]=1)'"))
(command (word "echo") (word "\"${T[@]}\""))
(command (word "unset") (word "T"))
(command (word "declare") (word "-A") (word "T"))
(command (word "T[0]='zero'"))
(if (command (word "[") (word "\"$T\"") (word "!=") (word "\"${T[0]}\"") (word "]")) (command (word "echo") (word "'assoc.tests: $T and ${T[0]} mismatch'")))
(command (word "${THIS_SH}") (word "./assoc1.sub"))
(command (word "${THIS_SH}") (word "./assoc2.sub"))
(command (word "${THIS_SH}") (word "./assoc3.sub"))
(command (word "${THIS_SH}") (word "./assoc4.sub"))
(command (word "${THIS_SH}") (word "./assoc5.sub"))
(command (word "${THIS_SH}") (word "./assoc6.sub"))
(command (word "${THIS_SH}") (word "./assoc7.sub"))
(command (word "unset") (word "assoc"))
(command (word "assoc=assoc"))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "echo") (word "${assoc[@]}"))
(command (word "unset") (word "assoc"))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc=([one]=one [two]=two [three]=three)"))
(command (word "assoc+=([one]+=more [two]+=less)"))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "readonly") (word "-A") (word "assoc"))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "declare") (word "-A") (word "hash"))
(command (word "hash=([\"key\"]=\"value1\")"))
(command (word "declare") (word "-p") (word "hash"))
(command (word "hash=([\"key\"]=\"${hash[\"key\"]} value2\")"))
(command (word "declare") (word "-p") (word "hash"))
(command (word "unset") (word "hash"))
(command (word "${THIS_SH}") (word "./assoc8.sub"))
(command (word "${THIS_SH}") (word "./assoc9.sub"))
(command (word "${THIS_SH}") (word "./assoc10.sub"))
(command (word "${THIS_SH}") (word "./assoc11.sub"))
(command (word "${THIS_SH}") (word "./assoc12.sub"))
(command (word "${THIS_SH}") (word "./assoc13.sub"))
(command (word "${THIS_SH}") (word "./assoc14.sub"))
(command (word "${THIS_SH}") (word "./assoc15.sub"))
(command (word "${THIS_SH}") (word "./assoc16.sub"))
(command (word "${THIS_SH}") (word "./assoc17.sub"))
(command (word "${THIS_SH}") (word "./assoc18.sub"))
(command (word "${THIS_SH}") (word "./assoc19.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== attr
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
a=(outside)

f1() { readonly a=(1) ; }
f2() { readonly -a a=(2) ; }
f3() { readonly 'a=(3)' ; }
f4() { readonly -a 'a=(4)' ; }

f1
echo -n after f1:
declare -p a
f2
echo -n after f2:
declare -p a
f3
echo -n after f3:
declare -p a
f4
echo -n after f4:
declare -p a

b=(outside)
c=(outside)
d=(outside)

f2() { readonly -a b=(2) ; }
f3() { readonly 'c=(3)' ; }
f4() { readonly -a 'd=(4)' ; }

f2
echo -n after f2:
declare -p b
f3
echo -n after f3:
declare -p c
f4
echo -n after f4:
declare -p d

${THIS_SH} ./attr1.sub
${THIS_SH} ./attr2.sub

--------------------------------------------------------------------------------
---
(command (word "a=(outside)"))
(function "f1" (brace-group (command (word "readonly") (word "a=(1)"))))
(function "f2" (brace-group (command (word "readonly") (word "-a") (word "a=(2)"))))
(function "f3" (brace-group (command (word "readonly") (word "'a=(3)'"))))
(function "f4" (brace-group (command (word "readonly") (word "-a") (word "'a=(4)'"))))
(command (word "f1"))
(command (word "echo") (word "-n") (word "after") (word "f1:"))
(command (word "declare") (word "-p") (word "a"))
(command (word "f2"))
(command (word "echo") (word "-n") (word "after") (word "f2:"))
(command (word "declare") (word "-p") (word "a"))
(command (word "f3"))
(command (word "echo") (word "-n") (word "after") (word "f3:"))
(command (word "declare") (word "-p") (word "a"))
(command (word "f4"))
(command (word "echo") (word "-n") (word "after") (word "f4:"))
(command (word "declare") (word "-p") (word "a"))
(command (word "b=(outside)"))
(command (word "c=(outside)"))
(command (word "d=(outside)"))
(function "f2" (brace-group (command (word "readonly") (word "-a") (word "b=(2)"))))
(function "f3" (brace-group (command (word "readonly") (word "'c=(3)'"))))
(function "f4" (brace-group (command (word "readonly") (word "-a") (word "'d=(4)'"))))
(command (word "f2"))
(command (word "echo") (word "-n") (word "after") (word "f2:"))
(command (word "declare") (word "-p") (word "b"))
(command (word "f3"))
(command (word "echo") (word "-n") (word "after") (word "f3:"))
(command (word "declare") (word "-p") (word "c"))
(command (word "f4"))
(command (word "echo") (word "-n") (word "after") (word "f4:"))
(command (word "declare") (word "-p") (word "d"))
(command (word "${THIS_SH}") (word "./attr1.sub"))
(command (word "${THIS_SH}") (word "./attr2.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== braces
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
echo ff{c,b,a}
echo f{d,e,f}g
echo {l,n,m}xyz
echo {abc\,def}
echo {abc}

echo \{a,b,c,d,e}
echo {x,y,\{a,b,c}}
echo {x\,y,\{abc\},trie}

echo /usr/{ucb/{ex,edit},lib/{ex,how_ex}}

echo XXXX\{`echo a b c | tr ' ' ','`\}
eval echo XXXX\{`echo a b c | tr ' ' ','`\}

echo {}
echo { }
echo }
echo {
echo abcd{efgh

echo foo {1,2} bar
echo `zecho foo {1,2} bar`
echo $(zecho foo {1,2} bar)

var=baz
varx=vx
vary=vy

echo foo{bar,${var}.}
echo foo{bar,${var}}

echo "${var}"{x,y}
echo $var{x,y}
echo ${var}{x,y}

unset var varx vary

# make sure ${ is parsed as a word expansion, since it may contain other
# expansions
a=4
echo "${a#'$('\'}"
echo "${a-'$('\'}"
echo "${a+'$('\'}"

echo "${a#aaaa'$(aaaa'aaa)aaa\'}"
echo "${a#aaaa'$(aaaa)'aaaa\'}"
unset -v a

# new sequence brace operators
echo {1..10}

# this doesn't work yet
echo {0..10,braces}
# but this does
echo {{0..10},braces}
echo x{{0..10},braces}y

echo {3..3}
echo x{3..3}y
echo {10..1}
echo {10..1}y
echo x{10..1}y

echo {a..f}
echo {f..a}

echo {a..A}
echo {A..a}

echo {f..f}

# mixes are incorrectly-formed brace expansions
echo {1..f}
echo {f..1}

echo 0{1..9} {10..20}

# do negative numbers work?
echo {-1..-10}
echo {-20..0}

# weirdly-formed brace expansions -- fixed in post-bash-3.1
echo a-{b{d,e}}-c

echo a-{bdef-{g,i}-c

echo {"klklkl"}{1,2,3}
echo {"x,x"}

echo {1..10..2}
echo {-1..-10..2}
echo {-1..-10..-2}

echo {10..1..-2}
echo {10..1..2}

echo {1..20..2}
echo {1..20..20}

echo {100..0..5}
echo {100..0..-5}

echo {a..z}
echo {a..z..2}
echo {z..a..-2}

# make sure brace expansion handles ints > 2**31 - 1 using intmax_t
echo {2147483645..2147483649}

# want zero-padding here
echo {00..10}
echo {00..10..2}

# unwanted zero-padding -- fixed post-bash-4.0
echo {10..0..2}
echo {10..0..-2}
echo {-50..-0..5}

# the outer sequence expression is invalid but the other brace expansions are ok
# fixed post-bash-5.2

echo {{1,2,3}..{7,8,9}}
echo {{a..c}..{1..3}}
echo {{a..c}..{1,10}}
echo {{a,c}..{1..4}}

echo {{1,2,3}..4}
echo {6..{7,8,9}}

# these are not valid sequence expressions but are valid brace expansions
echo {a,../a.cfg}
echo {a..,/a.cfg}
echo {a..b,/a.cfg}
echo {a,b../a.cfg}

echo {1..4,5..8}
echo {1..4,8}
echo {1,5..8}

# these are all invalid brace expansions

echo {abcde.f}
echo X{..a}Z
echo 0{1..}2
echo {a..1..5}
echo {x,y}{1..a}{0,1,2}

# bad
echo {1..10.f}
echo {1..ff}
echo {1..10..ff}
echo {1.20..2}
echo {1..20..f2}
echo {1..20..2f}
echo {1..2f..2}
echo {1..ff..2}
echo {1..ff}
echo {1..f}
echo {1..0f}
echo {1..10f}
echo {1..10.f}
echo {1..10.f}

--------------------------------------------------------------------------------
---
(command (word "echo") (word "ff{c,b,a}"))
(command (word "echo") (word "f{d,e,f}g"))
(command (word "echo") (word "{l,n,m}xyz"))
(command (word "echo") (word "{abc\\,def}"))
(command (word "echo") (word "{abc}"))
(command (word "echo") (word "\\{a,b,c,d,e}"))
(command (word "echo") (word "{x,y,\\{a,b,c}}"))
(command (word "echo") (word "{x\\,y,\\{abc\\},trie}"))
(command (word "echo") (word "/usr/{ucb/{ex,edit},lib/{ex,how_ex}}"))
(command (word "echo") (word "XXXX\\{`echo a b c | tr ' ' ','`\\}"))
(command (word "eval") (word "echo") (word "XXXX\\{`echo a b c | tr ' ' ','`\\}"))
(command (word "echo") (word "{}"))
(command (word "echo") (word "{") (word "}"))
(command (word "echo") (word "}"))
(command (word "echo") (word "{"))
(command (word "echo") (word "abcd{efgh"))
(command (word "echo") (word "foo") (word "{1,2}") (word "bar"))
(command (word "echo") (word "`zecho foo {1,2} bar`"))
(command (word "echo") (word "$(zecho foo {1,2} bar)"))
(command (word "var=baz"))
(command (word "varx=vx"))
(command (word "vary=vy"))
(command (word "echo") (word "foo{bar,${var}.}"))
(command (word "echo") (word "foo{bar,${var}}"))
(command (word "echo") (word "\"${var}\"{x,y}"))
(command (word "echo") (word "$var{x,y}"))
(command (word "echo") (word "${var}{x,y}"))
(command (word "unset") (word "var") (word "varx") (word "vary"))
(command (word "a=4"))
(command (word "echo") (word "\"${a#'$('\\'}\""))
(command (word "echo") (word "\"${a-'$('\\'}\""))
(command (word "echo") (word "\"${a+'$('\\'}\""))
(command (word "echo") (word "\"${a#aaaa'$(aaaa'aaa)aaa\\'}\""))
(command (word "echo") (word "\"${a#aaaa'$(aaaa)'aaaa\\'}\""))
(command (word "unset") (word "-v") (word "a"))
(command (word "echo") (word "{1..10}"))
(command (word "echo") (word "{0..10,braces}"))
(command (word "echo") (word "{{0..10},braces}"))
(command (word "echo") (word "x{{0..10},braces}y"))
(command (word "echo") (word "{3..3}"))
(command (word "echo") (word "x{3..3}y"))
(command (word "echo") (word "{10..1}"))
(command (word "echo") (word "{10..1}y"))
(command (word "echo") (word "x{10..1}y"))
(command (word "echo") (word "{a..f}"))
(command (word "echo") (word "{f..a}"))
(command (word "echo") (word "{a..A}"))
(command (word "echo") (word "{A..a}"))
(command (word "echo") (word "{f..f}"))
(command (word "echo") (word "{1..f}"))
(command (word "echo") (word "{f..1}"))
(command (word "echo") (word "0{1..9}") (word "{10..20}"))
(command (word "echo") (word "{-1..-10}"))
(command (word "echo") (word "{-20..0}"))
(command (word "echo") (word "a-{b{d,e}}-c"))
(command (word "echo") (word "a-{bdef-{g,i}-c"))
(command (word "echo") (word "{\"klklkl\"}{1,2,3}"))
(command (word "echo") (word "{\"x,x\"}"))
(command (word "echo") (word "{1..10..2}"))
(command (word "echo") (word "{-1..-10..2}"))
(command (word "echo") (word "{-1..-10..-2}"))
(command (word "echo") (word "{10..1..-2}"))
(command (word "echo") (word "{10..1..2}"))
(command (word "echo") (word "{1..20..2}"))
(command (word "echo") (word "{1..20..20}"))
(command (word "echo") (word "{100..0..5}"))
(command (word "echo") (word "{100..0..-5}"))
(command (word "echo") (word "{a..z}"))
(command (word "echo") (word "{a..z..2}"))
(command (word "echo") (word "{z..a..-2}"))
(command (word "echo") (word "{2147483645..2147483649}"))
(command (word "echo") (word "{00..10}"))
(command (word "echo") (word "{00..10..2}"))
(command (word "echo") (word "{10..0..2}"))
(command (word "echo") (word "{10..0..-2}"))
(command (word "echo") (word "{-50..-0..5}"))
(command (word "echo") (word "{{1,2,3}..{7,8,9}}"))
(command (word "echo") (word "{{a..c}..{1..3}}"))
(command (word "echo") (word "{{a..c}..{1,10}}"))
(command (word "echo") (word "{{a,c}..{1..4}}"))
(command (word "echo") (word "{{1,2,3}..4}"))
(command (word "echo") (word "{6..{7,8,9}}"))
(command (word "echo") (word "{a,../a.cfg}"))
(command (word "echo") (word "{a..,/a.cfg}"))
(command (word "echo") (word "{a..b,/a.cfg}"))
(command (word "echo") (word "{a,b../a.cfg}"))
(command (word "echo") (word "{1..4,5..8}"))
(command (word "echo") (word "{1..4,8}"))
(command (word "echo") (word "{1,5..8}"))
(command (word "echo") (word "{abcde.f}"))
(command (word "echo") (word "X{..a}Z"))
(command (word "echo") (word "0{1..}2"))
(command (word "echo") (word "{a..1..5}"))
(command (word "echo") (word "{x,y}{1..a}{0,1,2}"))
(command (word "echo") (word "{1..10.f}"))
(command (word "echo") (word "{1..ff}"))
(command (word "echo") (word "{1..10..ff}"))
(command (word "echo") (word "{1.20..2}"))
(command (word "echo") (word "{1..20..f2}"))
(command (word "echo") (word "{1..20..2f}"))
(command (word "echo") (word "{1..2f..2}"))
(command (word "echo") (word "{1..ff..2}"))
(command (word "echo") (word "{1..ff}"))
(command (word "echo") (word "{1..f}"))
(command (word "echo") (word "{1..0f}"))
(command (word "echo") (word "{1..10f}"))
(command (word "echo") (word "{1..10.f}"))
(command (word "echo") (word "{1..10.f}"))
(command (word "--------------------------------------------------------------------------------"))
---

=== builtins
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# tests for miscellaneous builtins not tested elsewhere
set +p
set +o posix

# check that break breaks loops
for i in a b c; do echo $i; break; echo bad-$i; done
echo end-1
for i in a b c; do echo $i; break 1; echo bad-$i; done
echo end-2
for i in a b c; do
	for j in x y z; do
		echo $i:$j
		break
		echo bad-$i
	done
	echo end-$i
done
echo end-3

# check that break breaks nested loops
for i in a b c; do
	for j in x y z; do
		echo $i:$j
		break 2
		echo bad-$i
	done
	echo end-$i
done
echo end

# check that continue continues loops
for i in a b c; do echo $i; continue; echo bad-$i ; done
echo end-1
for i in a b c; do echo $i; continue 1; echo bad-$i; done
echo end-2
for i in a b c; do
	for j in x y z; do
		echo $i:$j
		continue
		echo bad-$i-$j
	done
	echo end-$i
done
echo end-3

# check that continue breaks out of nested loops
for i in a b c; do
	for j in x y z; do
		echo $i:$j
		continue 2
		echo bad-$i-$j
	done
	echo end-$i
done
echo end

# check arguments to break and continue that exceed the loop level
for f in 1 2 3; do break -- 5; done
for f in 1 2 3; do continue -- 5; done

# check that `eval' re-evaluates arguments, but `builtin' and `command' do not
AVAR='$BVAR'
BVAR=foo

echo $AVAR
builtin echo $AVAR
command echo $AVAR
eval echo \$AVAR
eval echo $AVAR

# test out eval with a temp environment
AVAR=bar eval echo \$AVAR
BVAR=xxx eval echo $AVAR

unset -v AVAR BVAR

# basic umask tests
mask=$(umask)
umask 022
umask
umask -S
umask -S u=rwx,g=rwx,o=rx >/dev/null # 002
umask
umask -S
umask -p
umask -p -S
umask 0
umask -S
umask ${mask}	# restore original mask

# builtin/command without arguments should do nothing.  maybe someday they will
builtin
command

# test enable
enable -ps

enable -aps ; enable -nps

enable -n test
case "$(type -t test)" in
builtin)	echo oops -- enable -n test failed ;;
*)	echo enable -n test worked ;;
esac
enable -n | grep test

enable test
case "$(type -t test)" in
builtin)	echo enable test worked ;;
*)	echo oops -- enable test failed ;;
esac

enable -d notbuiltin
enable -d test

# test options to exec
(exec -a specialname ${THIS_SH} -c 'echo $0' )
(exec -l -a specialname ${THIS_SH} -c 'echo $0' )
# test `clean' environment.  if /bin/sh is bash, and the script version of
# printenv is run, there will be variables in the environment that bash
# sets on startup.  Also test code that prefixes argv[0] with a dash.
(export FOO=BAR ; exec -c -l printenv ) | grep FOO
(FOO=BAR exec -c printenv ) | grep FOO

(export FOO=BAR ; exec printenv ) | grep FOO
(FOO=BAR exec printenv ) | grep FOO

# ok, forget everything about hashed commands
hash -r
hash

# this had better succeed, since command -p guarantees we will find the
# standard utilities
command -p hash rm

# check out source/.

# sourcing a zero-length-file had better not be an error
rm -f $TMPDIR/zero-length-file-$$
cp /dev/null $TMPDIR/zero-length-file-$$
. $TMPDIR/zero-length-file-$$
echo $?
rm $TMPDIR/zero-length-file-$$

# and sourcing a file that doesn't end in a newline had better work too
SFILE=$TMPDIR/sourced-file-$$
printf 'echo no-newline' > $SFILE
. $SFILE
rm -f $SFILE
unset -v SFILE

AVAR=AVAR

. ./source1.sub
AVAR=foo . ./source1.sub

. ./source2.sub
echo $?

set -- a b c
. ./source3.sub

# make sure source with arguments does not change the shell's positional
# parameters, but that the sourced file sees the arguments as its
# positional parameters
echo "$@"
. ./source3.sub x y z
echo "$@"

# but if the sourced script sets the positional parameters explicitly, they
# should be reflected in the calling shell's positional parameters.  this
# also tests one of the shopt options that controls source using $PATH to
# find the script
echo "$@"
shopt -u sourcepath
. source4.sub
echo "$@"

# this is complicated when the sourced scripts gets its own positional
# parameters from arguments to `.'
set -- a b c
echo "$@"
. source4.sub x y z
echo "$@"

# test out cd and $CDPATH
${THIS_SH} ./builtins1.sub

# test behavior of `.' when given a non-existent file argument
${THIS_SH} ./source5.sub

# test bugs in sourcing non-regular files, fixed post-bash-3.2
${THIS_SH} ./source6.sub

# test bugs with source called from multiline aliases and other contexts
${THIS_SH} ./source7.sub

# test source/. -p path
${THIS_SH} ./source8.sub

# in posix mode, assignment statements preceding special builtins are
# reflected in the shell environment.  `.' and `eval' need special-case
# code.
set -o posix
echo $AVAR
AVAR=foo . ./source1.sub
echo $AVAR

AVAR=AVAR
echo $AVAR
AVAR=foo eval echo \$AVAR
echo $AVAR

AVAR=AVAR
echo $AVAR
AVAR=foo :
echo $AVAR
set +o posix

# but assignment statements preceding `export' are always reflected in 
# the environment
foo="" export foo
declare -p foo
unset foo

# assignment statements preceding `declare' should be displayed correctly,
# but not persist after the command
FOO='$$' declare -p FOO
declare -p FOO
unset FOO

# except for `declare -x', which should be equivalent to `export'
FOO='$$' declare -x FOO
declare -p FOO
unset FOO

# test out kill -l.  bash versions prior to 2.01 did `kill -l num' wrong
sigone=$(kill -l | sed -n 's:^ 1) *\([^ 	]*\)[ 	].*$:\1:p')

case "$(kill -l 1)" in
${sigone/SIG/})	echo ok;;
*)	echo oops -- kill -l failure;;
esac

# kill -l and trap -l should display exactly the same output
sigonea=$(trap -l | sed -n 's:^ 1) *\([^ 	]*\)[ 	].*$:\1:p')

if [ "$sigone" != "$sigonea" ]; then
	echo oops -- kill -l and trap -l differ
fi

# POSIX.2 says that exit statuses > 128 are mapped to signal names by
# subtracting 128 so you can find out what signal killed a process
case "$(kill -l $(( 128 + 1)) )" in
${sigone/SIG/})	echo ok;;
*)	echo oops -- kill -l 129 failure;;
esac

# out-of-range signal numbers should report the argument in the error
# message, not 128 less than the argument
kill -l 4096

# kill -l NAME should return the signal number
kill -l ${sigone/SIG/}

# kill -l NAME should work with and without the SIG prefix
x=$(kill -l INT)
y=$(kill -l SIGINT)

[[ $x == $y ]] || echo kill -l error with SIG prefix
unset -v x y

# test behavior of shopt xpg_echo
${THIS_SH} ./builtins2.sub

# test behavior of declare -g
${THIS_SH} ./builtins3.sub

# test behavior of using declare to create variables without assigning values
${THIS_SH} ./builtins4.sub

# test behavior of set and unset array variables
${THIS_SH} ./builtins5.sub

# test behavior of unset builtin with -f and -v options
${THIS_SH} ./builtins6.sub

# test behavior of command builtin after changing it to a pseudo-keyword
${THIS_SH} ./builtins7.sub

# POSIX complete symbolic umask tests
${THIS_SH} ./builtins8.sub

# hash tests
${THIS_SH} ./builtins9.sub

# help tests
${THIS_SH} ./builtins10.sub

# ulimit tests
${THIS_SH} ./builtins11.sub

# pushd/popd/dirs
${THIS_SH} ./builtins12.sub

shift 0	# succeeds silently

options=$(set -o -B 2>&1 | wc -l)
[[ $options -gt 3 ]] || echo 'set: bad -o option name parsing'

# this no longer must be last -- it is no longer a fatal error
exit status
echo after non-numeric arg to exit: $?

--------------------------------------------------------------------------------
---
(command (word "set") (word "+p"))
(command (word "set") (word "+o") (word "posix"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (semi (command (word "echo") (word "$i")) (command (word "break"))) (command (word "echo") (word "bad-$i"))))
(command (word "echo") (word "end-1"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (semi (command (word "echo") (word "$i")) (command (word "break") (word "1"))) (command (word "echo") (word "bad-$i"))))
(command (word "echo") (word "end-2"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (for (word "j") (in (word "x") (word "y") (word "z")) (semi (semi (command (word "echo") (word "$i:$j")) (command (word "break"))) (command (word "echo") (word "bad-$i")))) (command (word "echo") (word "end-$i"))))
(command (word "echo") (word "end-3"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (for (word "j") (in (word "x") (word "y") (word "z")) (semi (semi (command (word "echo") (word "$i:$j")) (command (word "break") (word "2"))) (command (word "echo") (word "bad-$i")))) (command (word "echo") (word "end-$i"))))
(command (word "echo") (word "end"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (semi (command (word "echo") (word "$i")) (command (word "continue"))) (command (word "echo") (word "bad-$i"))))
(command (word "echo") (word "end-1"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (semi (command (word "echo") (word "$i")) (command (word "continue") (word "1"))) (command (word "echo") (word "bad-$i"))))
(command (word "echo") (word "end-2"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (for (word "j") (in (word "x") (word "y") (word "z")) (semi (semi (command (word "echo") (word "$i:$j")) (command (word "continue"))) (command (word "echo") (word "bad-$i-$j")))) (command (word "echo") (word "end-$i"))))
(command (word "echo") (word "end-3"))
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (for (word "j") (in (word "x") (word "y") (word "z")) (semi (semi (command (word "echo") (word "$i:$j")) (command (word "continue") (word "2"))) (command (word "echo") (word "bad-$i-$j")))) (command (word "echo") (word "end-$i"))))
(command (word "echo") (word "end"))
(for (word "f") (in (word "1") (word "2") (word "3")) (command (word "break") (word "--") (word "5")))
(for (word "f") (in (word "1") (word "2") (word "3")) (command (word "continue") (word "--") (word "5")))
(command (word "AVAR='$BVAR'"))
(command (word "BVAR=foo"))
(command (word "echo") (word "$AVAR"))
(command (word "builtin") (word "echo") (word "$AVAR"))
(command (word "command") (word "echo") (word "$AVAR"))
(command (word "eval") (word "echo") (word "\\$AVAR"))
(command (word "eval") (word "echo") (word "$AVAR"))
(command (word "AVAR=bar") (word "eval") (word "echo") (word "\\$AVAR"))
(command (word "BVAR=xxx") (word "eval") (word "echo") (word "$AVAR"))
(command (word "unset") (word "-v") (word "AVAR") (word "BVAR"))
(command (word "mask=$(umask)"))
(command (word "umask") (word "022"))
(command (word "umask"))
(command (word "umask") (word "-S"))
(command (word "umask") (word "-S") (word "u=rwx,g=rwx,o=rx") (redirect ">" "/dev/null"))
(command (word "umask"))
(command (word "umask") (word "-S"))
(command (word "umask") (word "-p"))
(command (word "umask") (word "-p") (word "-S"))
(command (word "umask") (word "0"))
(command (word "umask") (word "-S"))
(command (word "umask") (word "${mask}"))
(command (word "builtin"))
(command (word "command"))
(command (word "enable") (word "-ps"))
(semi (command (word "enable") (word "-aps")) (command (word "enable") (word "-nps")))
(command (word "enable") (word "-n") (word "test"))
(case (word "\"$(type -t test)\"") (pattern ((word "builtin")) (command (word "echo") (word "oops") (word "--") (word "enable") (word "-n") (word "test") (word "failed"))) (pattern ((word "*")) (command (word "echo") (word "enable") (word "-n") (word "test") (word "worked"))))
(pipe (command (word "enable") (word "-n")) (command (word "grep") (word "test")))
(command (word "enable") (word "test"))
(case (word "\"$(type -t test)\"") (pattern ((word "builtin")) (command (word "echo") (word "enable") (word "test") (word "worked"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "enable") (word "test") (word "failed"))))
(command (word "enable") (word "-d") (word "notbuiltin"))
(command (word "enable") (word "-d") (word "test"))
(subshell (command (word "exec") (word "-a") (word "specialname") (word "${THIS_SH}") (word "-c") (word "'echo $0'")))
(subshell (command (word "exec") (word "-l") (word "-a") (word "specialname") (word "${THIS_SH}") (word "-c") (word "'echo $0'")))
(pipe (subshell (semi (command (word "export") (word "FOO=BAR")) (command (word "exec") (word "-c") (word "-l") (word "printenv")))) (command (word "grep") (word "FOO")))
(pipe (subshell (command (word "FOO=BAR") (word "exec") (word "-c") (word "printenv"))) (command (word "grep") (word "FOO")))
(pipe (subshell (semi (command (word "export") (word "FOO=BAR")) (command (word "exec") (word "printenv")))) (command (word "grep") (word "FOO")))
(pipe (subshell (command (word "FOO=BAR") (word "exec") (word "printenv"))) (command (word "grep") (word "FOO")))
(command (word "hash") (word "-r"))
(command (word "hash"))
(command (word "command") (word "-p") (word "hash") (word "rm"))
(command (word "rm") (word "-f") (word "$TMPDIR/zero-length-file-$$"))
(command (word "cp") (word "/dev/null") (word "$TMPDIR/zero-length-file-$$"))
(command (word ".") (word "$TMPDIR/zero-length-file-$$"))
(command (word "echo") (word "$?"))
(command (word "rm") (word "$TMPDIR/zero-length-file-$$"))
(command (word "SFILE=$TMPDIR/sourced-file-$$"))
(command (word "printf") (word "'echo no-newline'") (redirect ">" "$SFILE"))
(command (word ".") (word "$SFILE"))
(command (word "rm") (word "-f") (word "$SFILE"))
(command (word "unset") (word "-v") (word "SFILE"))
(command (word "AVAR=AVAR"))
(command (word ".") (word "./source1.sub"))
(command (word "AVAR=foo") (word ".") (word "./source1.sub"))
(command (word ".") (word "./source2.sub"))
(command (word "echo") (word "$?"))
(command (word "set") (word "--") (word "a") (word "b") (word "c"))
(command (word ".") (word "./source3.sub"))
(command (word "echo") (word "\"$@\""))
(command (word ".") (word "./source3.sub") (word "x") (word "y") (word "z"))
(command (word "echo") (word "\"$@\""))
(command (word "echo") (word "\"$@\""))
(command (word "shopt") (word "-u") (word "sourcepath"))
(command (word ".") (word "source4.sub"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "--") (word "a") (word "b") (word "c"))
(command (word "echo") (word "\"$@\""))
(command (word ".") (word "source4.sub") (word "x") (word "y") (word "z"))
(command (word "echo") (word "\"$@\""))
(command (word "${THIS_SH}") (word "./builtins1.sub"))
(command (word "${THIS_SH}") (word "./source5.sub"))
(command (word "${THIS_SH}") (word "./source6.sub"))
(command (word "${THIS_SH}") (word "./source7.sub"))
(command (word "${THIS_SH}") (word "./source8.sub"))
(command (word "set") (word "-o") (word "posix"))
(command (word "echo") (word "$AVAR"))
(command (word "AVAR=foo") (word ".") (word "./source1.sub"))
(command (word "echo") (word "$AVAR"))
(command (word "AVAR=AVAR"))
(command (word "echo") (word "$AVAR"))
(command (word "AVAR=foo") (word "eval") (word "echo") (word "\\$AVAR"))
(command (word "echo") (word "$AVAR"))
(command (word "AVAR=AVAR"))
(command (word "echo") (word "$AVAR"))
(command (word "AVAR=foo") (word ":"))
(command (word "echo") (word "$AVAR"))
(command (word "set") (word "+o") (word "posix"))
(command (word "foo=\"\"") (word "export") (word "foo"))
(command (word "declare") (word "-p") (word "foo"))
(command (word "unset") (word "foo"))
(command (word "FOO='$$'") (word "declare") (word "-p") (word "FOO"))
(command (word "declare") (word "-p") (word "FOO"))
(command (word "unset") (word "FOO"))
(command (word "FOO='$$'") (word "declare") (word "-x") (word "FOO"))
(command (word "declare") (word "-p") (word "FOO"))
(command (word "unset") (word "FOO"))
(command (word "sigone=$(kill -l | sed -n 's:^ 1) *\\([^ \t]*\\)[ \t].*$:\\1:p')"))
(case (word "\"$(kill -l 1)\"") (pattern ((word "${sigone/SIG/}")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "kill") (word "-l") (word "failure"))))
(command (word "sigonea=$(trap -l | sed -n 's:^ 1) *\\([^ \t]*\\)[ \t].*$:\\1:p')"))
(if (command (word "[") (word "\"$sigone\"") (word "!=") (word "\"$sigonea\"") (word "]")) (command (word "echo") (word "oops") (word "--") (word "kill") (word "-l") (word "and") (word "trap") (word "-l") (word "differ")))
(case (word "\"$(kill -l $(( 128 + 1)))\"") (pattern ((word "${sigone/SIG/}")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "kill") (word "-l") (word "129") (word "failure"))))
(command (word "kill") (word "-l") (word "4096"))
(command (word "kill") (word "-l") (word "${sigone/SIG/}"))
(command (word "x=$(kill -l INT)"))
(command (word "y=$(kill -l SIGINT)"))
(or (cond (cond-binary "==" (cond-term "$x") (cond-term "$y"))) (command (word "echo") (word "kill") (word "-l") (word "error") (word "with") (word "SIG") (word "prefix")))
(command (word "unset") (word "-v") (word "x") (word "y"))
(command (word "${THIS_SH}") (word "./builtins2.sub"))
(command (word "${THIS_SH}") (word "./builtins3.sub"))
(command (word "${THIS_SH}") (word "./builtins4.sub"))
(command (word "${THIS_SH}") (word "./builtins5.sub"))
(command (word "${THIS_SH}") (word "./builtins6.sub"))
(command (word "${THIS_SH}") (word "./builtins7.sub"))
(command (word "${THIS_SH}") (word "./builtins8.sub"))
(command (word "${THIS_SH}") (word "./builtins9.sub"))
(command (word "${THIS_SH}") (word "./builtins10.sub"))
(command (word "${THIS_SH}") (word "./builtins11.sub"))
(command (word "${THIS_SH}") (word "./builtins12.sub"))
(command (word "shift") (word "0"))
(command (word "options=$(set -o -B 2>&1 | wc -l)"))
(or (cond (cond-binary "-gt" (cond-term "$options") (cond-term "3"))) (command (word "echo") (word "'set: bad -o option name parsing'")))
(command (word "exit") (word "status"))
(command (word "echo") (word "after") (word "non-numeric") (word "arg") (word "to") (word "exit:") (word "$?"))
(command (word "--------------------------------------------------------------------------------"))
---

=== case
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
case foo in
bar)	echo skip ;;
foo)	echo fallthrough ;&
bax)	echo to here ;&
qux)	echo and here;;
fop)	echo but not here;;
esac

case foobar in
bar)	echo skip ;;
foo*)	echo retest ;;&
*bar)	echo and match ;;&
qux)	echo but not this ;;
esac

case a in
a)	echo no more clauses;&
esac

x=0 y=1
case 1 in
  $((y=0)) ) ;;
  $((x=1)) ) ;&
  $((x=2)) ) echo $x.$y ;;
esac

unset x
readonly xx=1
case 1 in $((xx++)) ) echo hi1 ;; *) echo hi2; esac
echo ${xx}.$?

unset var empty

var=
case ']' in
[$var]*[$var])	echo matches 1;;
*)		echo no match 1 ;;
esac

case abc in ( [] ) echo yes ;; ( * ) echo no ;; esac
empty=''
case abc in ( ["$empty"] ) echo yes ;; ( * ) echo no ;; esac

case abc in ( [] | [!a-z]* ) echo yes ;; ( * ) echo no ;; esac
empty=''
case abc in ( ["$empty"] | [!a-z]* ) echo yes ;; ( * ) echo no ;; esac

case abc in (["$empty"]|[!a-z]*) echo yes ;; (*) echo no ;; esac

case " " in ( [" "] ) echo ok;; ( * ) echo no;; esac

# posix issue discovered after bash-5.1 was released
case esac in (esac) echo esac;; esac
case k in else|done|time|esac) for f in 1 2 3 ; do :; done esac

# null words and patterns
var=value
case $unset in
'')	echo unset word ok 1 ;;&
$unset|$var)	echo unset word ok 2 ;;&
unset|$unset)	echo unset word ok 3 ;;
*)	echo unset word bad ;;
esac

# tests of quote removal and pattern matching
${THIS_SH} ./case1.sub
${THIS_SH} ./case2.sub
${THIS_SH} ./case3.sub
${THIS_SH} ./case4.sub

--------------------------------------------------------------------------------
---
(case (word "foo") (pattern ((word "bar")) (command (word "echo") (word "skip"))) (pattern ((word "foo")) (command (word "echo") (word "fallthrough"))) (pattern ((word "bax")) (command (word "echo") (word "to") (word "here"))) (pattern ((word "qux")) (command (word "echo") (word "and") (word "here"))) (pattern ((word "fop")) (command (word "echo") (word "but") (word "not") (word "here"))))
(case (word "foobar") (pattern ((word "bar")) (command (word "echo") (word "skip"))) (pattern ((word "foo*")) (command (word "echo") (word "retest"))) (pattern ((word "*bar")) (command (word "echo") (word "and") (word "match"))) (pattern ((word "qux")) (command (word "echo") (word "but") (word "not") (word "this"))))
(case (word "a") (pattern ((word "a")) (command (word "echo") (word "no") (word "more") (word "clauses"))))
(command (word "x=0") (word "y=1"))
(case (word "1") (pattern ((word "$((y=0))")) ()) (pattern ((word "$((x=1))")) ()) (pattern ((word "$((x=2))")) (command (word "echo") (word "$x.$y"))))
(command (word "unset") (word "x"))
(command (word "readonly") (word "xx=1"))
(case (word "1") (pattern ((word "$((xx++))")) (command (word "echo") (word "hi1"))) (pattern ((word "*")) (command (word "echo") (word "hi2"))))
(command (word "echo") (word "${xx}.$?"))
(command (word "unset") (word "var") (word "empty"))
(command (word "var="))
(case (word "']'") (pattern ((word "[$var]*[$var]")) (command (word "echo") (word "matches") (word "1"))) (pattern ((word "*")) (command (word "echo") (word "no") (word "match") (word "1"))))
(case (word "abc") (pattern ((word "[]")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(command (word "empty=''"))
(case (word "abc") (pattern ((word "[\"$empty\"]")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(case (word "abc") (pattern ((word "[]") (word "[!a-z]*")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(command (word "empty=''"))
(case (word "abc") (pattern ((word "[\"$empty\"]") (word "[!a-z]*")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(case (word "abc") (pattern ((word "[\"$empty\"]") (word "[!a-z]*")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(case (word "\" \"") (pattern ((word "[\" \"]")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(case (word "esac") (pattern ((word "esac")) (command (word "echo") (word "esac"))))
(case (word "k") (pattern ((word "else") (word "done") (word "time") (word "esac")) (for (word "f") (in (word "1") (word "2") (word "3")) (command (word ":")))))
(command (word "var=value"))
(case (word "$unset") (pattern ((word "''")) (command (word "echo") (word "unset") (word "word") (word "ok") (word "1"))) (pattern ((word "$unset") (word "$var")) (command (word "echo") (word "unset") (word "word") (word "ok") (word "2"))) (pattern ((word "unset") (word "$unset")) (command (word "echo") (word "unset") (word "word") (word "ok") (word "3"))) (pattern ((word "*")) (command (word "echo") (word "unset") (word "word") (word "bad"))))
(command (word "${THIS_SH}") (word "./case1.sub"))
(command (word "${THIS_SH}") (word "./case2.sub"))
(command (word "${THIS_SH}") (word "./case3.sub"))
(command (word "${THIS_SH}") (word "./case4.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== casemod
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
S1=acknowledgement
S2=oenophile

echo ${S1^}
echo ${S1^^}

echo ${S2^[aeiou]}
echo ${S2^^[aeiou]}

U1=${S1^^}
U2=${S2^^}

echo ${U1,}
echo ${U1,,}

echo ${U2,}
echo ${U2,[AEIOU]}
echo ${U2,,[AEIOU]}

A1=( $S1 $S2 )

echo ${A1[@]^[aeiou]}
echo ${A1[@]^^[aeiou]}

A2=( $U1 $U2 )

echo ${A2[@],[AEIOU]}
echo ${A2[@],,[AEIOU]}

echo ${A2[@],?}
echo ${A2[@],,?}

declare -A AA1 AA2

AA1[ack]=$S1
AA1[oen]=$S2

echo ${AA1[@]^}
echo ${AA1[@]^^}

echo ${AA1[@]^[aeiou]}
echo ${AA1[@]^^[aeiou]}

AA2[ACK]=$U1
AA2[OEN]=$U2

echo ${AA2[@],}
echo ${AA2[@],,}

echo ${AA2[@],[AEIOU]}
echo ${AA2[@],,[AEIOU]}

set -- $S1 $S2

echo ${@^}
echo ${@^^}


echo ${S1^[rstlne]} ${S2^[rstlne]}
echo ${S1^^[rstlne]} ${S2^^[rstlne]}

echo ${@^[rstlne]}
echo ${@^^[rstlne]}

echo ${S1,[rstlne]} ${S2,[rstlne]}
echo ${S1,,[rstlne]} ${S2,,[rstlne]}

echo ${@,[rstlne]}
echo ${@,,[rstlne]}

echo ${@^?}
echo ${@^^?}

# make sure that multiple words in the string are handled as other expansions
TEXT="Be Conservative in what you send and Liberal in what you accept"
TEXT2="be conservative in what you send and liberal in what you accept"

declare -u foo
foo=$TEXT
echo $foo

declare -l bar
bar=$TEXT
echo $bar

declare -c qux
qux=$TEXT
echo $qux
qux=$TEXT2
echo $qux

echo ${TEXT,}
echo ${TEXT,,}

echo ${TEXT^}
echo ${TEXT^^}

echo ${TEXT2^}
echo ${TEXT2^^}

M1=${S1^^[aeiou]}
M2=${U2,,[AEIOU]}

# case-toggling modifiers are still in there for now
Z1=AcKnowledGEmEnt
Z2=OenOphIlE
echo ${Z1~}
echo ${Z2~~}

declare -l lower=aBcDe
lower+=XyZ
echo $lower

declare -u upper=aBcDe
upper+=xYZ
echo $upper

--------------------------------------------------------------------------------
---
(command (word "S1=acknowledgement"))
(command (word "S2=oenophile"))
(command (word "echo") (word "${S1^}"))
(command (word "echo") (word "${S1^^}"))
(command (word "echo") (word "${S2^[aeiou]}"))
(command (word "echo") (word "${S2^^[aeiou]}"))
(command (word "U1=${S1^^}"))
(command (word "U2=${S2^^}"))
(command (word "echo") (word "${U1,}"))
(command (word "echo") (word "${U1,,}"))
(command (word "echo") (word "${U2,}"))
(command (word "echo") (word "${U2,[AEIOU]}"))
(command (word "echo") (word "${U2,,[AEIOU]}"))
(command (word "A1=($S1 $S2)"))
(command (word "echo") (word "${A1[@]^[aeiou]}"))
(command (word "echo") (word "${A1[@]^^[aeiou]}"))
(command (word "A2=($U1 $U2)"))
(command (word "echo") (word "${A2[@],[AEIOU]}"))
(command (word "echo") (word "${A2[@],,[AEIOU]}"))
(command (word "echo") (word "${A2[@],?}"))
(command (word "echo") (word "${A2[@],,?}"))
(command (word "declare") (word "-A") (word "AA1") (word "AA2"))
(command (word "AA1[ack]=$S1"))
(command (word "AA1[oen]=$S2"))
(command (word "echo") (word "${AA1[@]^}"))
(command (word "echo") (word "${AA1[@]^^}"))
(command (word "echo") (word "${AA1[@]^[aeiou]}"))
(command (word "echo") (word "${AA1[@]^^[aeiou]}"))
(command (word "AA2[ACK]=$U1"))
(command (word "AA2[OEN]=$U2"))
(command (word "echo") (word "${AA2[@],}"))
(command (word "echo") (word "${AA2[@],,}"))
(command (word "echo") (word "${AA2[@],[AEIOU]}"))
(command (word "echo") (word "${AA2[@],,[AEIOU]}"))
(command (word "set") (word "--") (word "$S1") (word "$S2"))
(command (word "echo") (word "${@^}"))
(command (word "echo") (word "${@^^}"))
(command (word "echo") (word "${S1^[rstlne]}") (word "${S2^[rstlne]}"))
(command (word "echo") (word "${S1^^[rstlne]}") (word "${S2^^[rstlne]}"))
(command (word "echo") (word "${@^[rstlne]}"))
(command (word "echo") (word "${@^^[rstlne]}"))
(command (word "echo") (word "${S1,[rstlne]}") (word "${S2,[rstlne]}"))
(command (word "echo") (word "${S1,,[rstlne]}") (word "${S2,,[rstlne]}"))
(command (word "echo") (word "${@,[rstlne]}"))
(command (word "echo") (word "${@,,[rstlne]}"))
(command (word "echo") (word "${@^?}"))
(command (word "echo") (word "${@^^?}"))
(command (word "TEXT=\"Be Conservative in what you send and Liberal in what you accept\""))
(command (word "TEXT2=\"be conservative in what you send and liberal in what you accept\""))
(command (word "declare") (word "-u") (word "foo"))
(command (word "foo=$TEXT"))
(command (word "echo") (word "$foo"))
(command (word "declare") (word "-l") (word "bar"))
(command (word "bar=$TEXT"))
(command (word "echo") (word "$bar"))
(command (word "declare") (word "-c") (word "qux"))
(command (word "qux=$TEXT"))
(command (word "echo") (word "$qux"))
(command (word "qux=$TEXT2"))
(command (word "echo") (word "$qux"))
(command (word "echo") (word "${TEXT,}"))
(command (word "echo") (word "${TEXT,,}"))
(command (word "echo") (word "${TEXT^}"))
(command (word "echo") (word "${TEXT^^}"))
(command (word "echo") (word "${TEXT2^}"))
(command (word "echo") (word "${TEXT2^^}"))
(command (word "M1=${S1^^[aeiou]}"))
(command (word "M2=${U2,,[AEIOU]}"))
(command (word "Z1=AcKnowledGEmEnt"))
(command (word "Z2=OenOphIlE"))
(command (word "echo") (word "${Z1~}"))
(command (word "echo") (word "${Z2~~}"))
(command (word "declare") (word "-l") (word "lower=aBcDe"))
(command (word "lower+=XyZ"))
(command (word "echo") (word "$lower"))
(command (word "declare") (word "-u") (word "upper=aBcDe"))
(command (word "upper+=xYZ"))
(command (word "echo") (word "$upper"))
(command (word "--------------------------------------------------------------------------------"))
---

=== complete
#  Chet Ramey <chet.ramey@case.edu>
#
#  Copyright 2002-2020 Chester Ramey
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   TThis program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

complete

# from zsh, just for testing
complete -A stopped -P '%' bg
complete -j -P '%' fg jobs disown
# this is wrong at this point
complete -j -P '%' -W '$(ps -x | tail +2 | cut -c1-5)' wait
complete -c type
complete -a unalias
complete -v getopts read unset
complete -v -S '=' declare export local readonly typeset
complete -f -- . source
complete -A shopt shopt
complete -e printenv

complete -A helptopic help

complete -c nohup exec nice eval
complete -c -k time

complete -A signal trap kill

complete -f chown ln more cat
complete -d mkdir rmdir

complete -f -X '!*.+(gz|tgz)' gunzip gzcat zcat zmore
complete -f -X '!*.Z' uncompress zmore zcat
complete -f gzip

complete -o dirnames -o filenames -o nospace -d pushd popd

_comp_cd()
{
	local IFS=$' \t\n'	# normalize IFS
	local cur _skipdot _cdpath
	local i j k

	# Tilde expansion, with side effect of expanding tilde to full pathname
	case "$2" in
	\~*)	eval cur="$2" ;;
	*)	cur=$2 ;;
	esac

	# no cdpath or absolute pathname -- straight directory completion
	if [[ -z "${CDPATH:-}" ]] || [[ "$cur" == @(./*|../*|/*) ]]; then
		# compgen prints paths one per line; could also use while loop
		IFS=$'\n'
		COMPREPLY=( $(compgen -d -- "$cur") )
		IFS=$' \t\n'
	# CDPATH+directories in the current directory if not in CDPATH
	else
		IFS=$'\n'
		_skipdot=false
		# preprocess CDPATH to convert null directory names to .
		_cdpath=${CDPATH/#:/.:}
		_cdpath=${_cdpath//::/:.:}
		_cdpath=${_cdpath/%:/:.}
		for i in ${_cdpath//:/$'\n'}; do
			if [[ $i -ef . ]]; then _skipdot=true; fi
			k="${#COMPREPLY[@]}"
			for j in $( compgen -d -- "$i/$cur" ); do
				COMPREPLY[k++]=${j#$i/}		# cut off directory
			done
		done
		$_skipdot || COMPREPLY+=( $(compgen -d -- "$cur") )
		IFS=$' \t\n'
	fi

	# variable names if appropriate shell option set and no completions
	if shopt -q cdable_vars && [[ ${#COMPREPLY[@]} -eq 0 ]]; then
		COMPREPLY=( $(compgen -v -- "$cur") )
	fi

	# append slash to passed directory name that is the only completion.
	# readline will not do this if we complete from CDPATH
	if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
		i=${COMPREPLY[0]}	# shorthand
		if [[ "$cur" == "$i" ]] && [[ "$i" != "*/" ]]; then
			COMPREPLY[0]+=/
		fi
	fi
	return 0
}

complete -o filenames -o nospace -o bashdefault -F _comp_cd cd

complete -A hostname rsh telnet rlogin ftp

complete -u su
complete -W '"${GROUPS[@]}"' newgrp
complete -g groupdel groupmod

complete -f -X '!*.+(ps|PS)' gs gv ghostview
complete -f -X '!*.dvi' dvips xdvi
complete -f -X '!*.pdf' acroread

complete -f -X '!*.texi*' makeinfo texi2dvi texi2html

complete -c gdb make

complete -p gs
complete -p

complete -r xdvi
complete -r notthere

complete -r
complete

# new complete/compgen -V option
# doesn't work for complete
complete -V name

compgen -V invalid-name -b
compgen -V array -b
echo ${array[0]}

# a more complicated example
unalias -a
alias fee=one fi=two fo=three fum=four
compgen -a -X 'fo*' -V vv -P 'unalias -- ' f
printf '%s\n' "${vv[@]}"

# some random compgen topics

compgen -A helptopic
builtin compgen -A setopt
compgen -A shopt
command compgen -b 
compgen -A enabled
compgen -k

# and some errors
complete -z
complete -b
compgen -r
compgen -A noaction
compgen -D
compgen -o nooption

compopt -o nooption

--------------------------------------------------------------------------------
---
(command (word "complete"))
(command (word "complete") (word "-A") (word "stopped") (word "-P") (word "'%'") (word "bg"))
(command (word "complete") (word "-j") (word "-P") (word "'%'") (word "fg") (word "jobs") (word "disown"))
(command (word "complete") (word "-j") (word "-P") (word "'%'") (word "-W") (word "'$(ps -x | tail +2 | cut -c1-5)'") (word "wait"))
(command (word "complete") (word "-c") (word "type"))
(command (word "complete") (word "-a") (word "unalias"))
(command (word "complete") (word "-v") (word "getopts") (word "read") (word "unset"))
(command (word "complete") (word "-v") (word "-S") (word "'='") (word "declare") (word "export") (word "local") (word "readonly") (word "typeset"))
(command (word "complete") (word "-f") (word "--") (word ".") (word "source"))
(command (word "complete") (word "-A") (word "shopt") (word "shopt"))
(command (word "complete") (word "-e") (word "printenv"))
(command (word "complete") (word "-A") (word "helptopic") (word "help"))
(command (word "complete") (word "-c") (word "nohup") (word "exec") (word "nice") (word "eval"))
(command (word "complete") (word "-c") (word "-k") (word "time"))
(command (word "complete") (word "-A") (word "signal") (word "trap") (word "kill"))
(command (word "complete") (word "-f") (word "chown") (word "ln") (word "more") (word "cat"))
(command (word "complete") (word "-d") (word "mkdir") (word "rmdir"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.+(gz|tgz)'") (word "gunzip") (word "gzcat") (word "zcat") (word "zmore"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.Z'") (word "uncompress") (word "zmore") (word "zcat"))
(command (word "complete") (word "-f") (word "gzip"))
(command (word "complete") (word "-o") (word "dirnames") (word "-o") (word "filenames") (word "-o") (word "nospace") (word "-d") (word "pushd") (word "popd"))
(function "_comp_cd" (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "local") (word "IFS=' \t\n'")) (command (word "local") (word "cur") (word "_skipdot") (word "_cdpath"))) (command (word "local") (word "i") (word "j") (word "k"))) (case (word "\"$2\"") (pattern ((word "\\~*")) (command (word "eval") (word "cur=\"$2\""))) (pattern ((word "*")) (command (word "cur=$2"))))) (if (or (cond (cond-unary "-z" (cond-term ""${CDPATH:-}""))) (cond (cond-binary "==" (cond-term ""$cur"") (cond-term "@(./*|../*|/*)")))) (semi (semi (command (word "IFS='\n'")) (command (word "COMPREPLY=($(compgen -d -- \"$cur\"))"))) (command (word "IFS=' \t\n'"))) (semi (semi (semi (semi (semi (semi (semi (command (word "IFS='\n'")) (command (word "_skipdot=false"))) (command (word "_cdpath=${CDPATH/#:/.:}"))) (command (word "_cdpath=${_cdpath//::/:.:}"))) (command (word "_cdpath=${_cdpath/%:/:.}"))) (for (word "i") (in (word "${_cdpath//:/'\n'}")) (semi (semi (if (cond (cond-binary "-ef" (cond-term "$i") (cond-term "."))) (command (word "_skipdot=true"))) (command (word "k=\"${#COMPREPLY[@]}\""))) (for (word "j") (in (word "$(compgen -d -- \"$i/$cur\")")) (command (word "COMPREPLY[k++]=${j#$i/}")))))) (or (command (word "$_skipdot")) (command (word "COMPREPLY+=($(compgen -d -- \"$cur\"))")))) (command (word "IFS=' \t\n'"))))) (if (and (command (word "shopt") (word "-q") (word "cdable_vars")) (cond (cond-binary "-eq" (cond-term "${#COMPREPLY[@]}") (cond-term "0")))) (command (word "COMPREPLY=($(compgen -v -- \"$cur\"))")))) (if (cond (cond-binary "-eq" (cond-term "${#COMPREPLY[@]}") (cond-term "1"))) (semi (command (word "i=${COMPREPLY[0]}")) (if (and (cond (cond-binary "==" (cond-term ""$cur"") (cond-term ""$i""))) (cond (cond-binary "!=" (cond-term ""$i"") (cond-term ""*/"")))) (command (word "COMPREPLY[0]+=/")))))) (command (word "return") (word "0")))))
(command (word "complete") (word "-o") (word "filenames") (word "-o") (word "nospace") (word "-o") (word "bashdefault") (word "-F") (word "_comp_cd") (word "cd"))
(command (word "complete") (word "-A") (word "hostname") (word "rsh") (word "telnet") (word "rlogin") (word "ftp"))
(command (word "complete") (word "-u") (word "su"))
(command (word "complete") (word "-W") (word "'\"${GROUPS[@]}\"'") (word "newgrp"))
(command (word "complete") (word "-g") (word "groupdel") (word "groupmod"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.+(ps|PS)'") (word "gs") (word "gv") (word "ghostview"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.dvi'") (word "dvips") (word "xdvi"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.pdf'") (word "acroread"))
(command (word "complete") (word "-f") (word "-X") (word "'!*.texi*'") (word "makeinfo") (word "texi2dvi") (word "texi2html"))
(command (word "complete") (word "-c") (word "gdb") (word "make"))
(command (word "complete") (word "-p") (word "gs"))
(command (word "complete") (word "-p"))
(command (word "complete") (word "-r") (word "xdvi"))
(command (word "complete") (word "-r") (word "notthere"))
(command (word "complete") (word "-r"))
(command (word "complete"))
(command (word "complete") (word "-V") (word "name"))
(command (word "compgen") (word "-V") (word "invalid-name") (word "-b"))
(command (word "compgen") (word "-V") (word "array") (word "-b"))
(command (word "echo") (word "${array[0]}"))
(command (word "unalias") (word "-a"))
(command (word "alias") (word "fee=one") (word "fi=two") (word "fo=three") (word "fum=four"))
(command (word "compgen") (word "-a") (word "-X") (word "'fo*'") (word "-V") (word "vv") (word "-P") (word "'unalias -- '") (word "f"))
(command (word "printf") (word "'%s\\n'") (word "\"${vv[@]}\""))
(command (word "compgen") (word "-A") (word "helptopic"))
(command (word "builtin") (word "compgen") (word "-A") (word "setopt"))
(command (word "compgen") (word "-A") (word "shopt"))
(command (word "command") (word "compgen") (word "-b"))
(command (word "compgen") (word "-A") (word "enabled"))
(command (word "compgen") (word "-k"))
(command (word "complete") (word "-z"))
(command (word "complete") (word "-b"))
(command (word "compgen") (word "-r"))
(command (word "compgen") (word "-A") (word "noaction"))
(command (word "compgen") (word "-D"))
(command (word "compgen") (word "-o") (word "nooption"))
(command (word "compopt") (word "-o") (word "nooption"))
(command (word "--------------------------------------------------------------------------------"))
---

=== comsub-eof
${THIS_SH} ./comsub-eof0.sub

${THIS_SH} ./comsub-eof1.sub

${THIS_SH} ./comsub-eof2.sub

${THIS_SH} ./comsub-eof3.sub

${THIS_SH} ./comsub-eof4.sub

${THIS_SH} ./comsub-eof5.sub

${THIS_SH} ./comsub-eof6.sub

--------------------------------------------------------------------------------
---
(command (word "${THIS_SH}") (word "./comsub-eof0.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof1.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof2.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof3.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof4.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof5.sub"))
(command (word "${THIS_SH}") (word "./comsub-eof6.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== comsub-posix
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
: ${HOME:=/}

# works right
echo ab$(echo mnop)yz
# works right
echo ab$(echo mnop
)yz
#
# works right
echo $(echo ab
   )
# works right
echo $(
)
echo $()
echo ab$()cd
echo ab$(  )cd
echo mn$(
)op
echo qr$(

    )st

echo $(case a in (a) echo sh_352.26ax; esac )
echo $(case a in (a) echo sh_352.26ay; esac)

echo $((echo sh_352.25a);(echo sh_352.25b))

echo $(echo sh_352.27 ')' ")" \)
	# ) comment
	)

echo $(
echo abc # a comment with )
)

echo $(#a comment with )
echo def)

echo $(
cat <<eof
here doc with )
eof
)

echo $(
echo ')'
)

unset x
x=$(cat <<"EOF"
bad' syntax
EOF
)
echo "$x"
unset x

echo $(for f in \); do echo a; done )
echo $(case a in a) echo sh_352.26a; esac )
echo $(case a in a) echo sh_352.26a; esac)

echo $(case a in
            (a) echo sh_352.26
               ;;
                 esac
          )

echo $(case a in
            a) echo sh_352.26
               ;;
                 esac
          )


echo $(case a in
            a) echo sh_352.26
               ;;


			

    
                 esac

          )

echo $(( 4<(2+3) ? 1 : 32))

echo $(cat << end
sh_352.28 )
end
)

echo $(cat <<- end  
sh_352.28 )
	end
)

k=$(case x in x) echo k;; esac)
echo $k

x=$(
    case $(ls) in
	example) echo foobix;;
    esac
)

echo $( echo ab\
cd)

echo `echo ab
cd`

echo `echo ab #xyz
cd`

echo "$(echo abcde)
"

recho "$(echo abcde)
  "

echo $(echo abcde)\
foo

recho $(echo abcde)\
   foo

recho "wx$(echo abcde)yz"
recho "$(echo abcde)"

echo $(cat <<eof
'
eof
)

echo after 1

echo $(cat <<\eof
'
eof
)

echo after 2

echo "$(cat <<\eof
'
eof
)"

echo after 3

echo "$(cat <<\eof
`
eof
)"

echo after 4

echo $(
cat << ')'
hello
)
)

echo after 5

echo $(cat <<'eof'
'
eof
)

echo after 6

echo $(
  case x in  x) echo x;; esac
)

echo $(
  case x in  x) echo x;; esac # followed by a comment
)

echo $(
  case x in (x) echo x;; esac
)

echo $(
  echo 'quoted )'
)

echo $(
  echo comment # with )
)

echo $(
cat <<\eof
  here-doc with )
eof
)

echo $(
    cat <<\eof
    here-doc with \()
eof
)

echo $(
cat <<\)
	here-doc terminated with a parenthesis
)
)

echo $(
cat <<\eof
	'   # or a single back- or doublequote
eof
)

echo $(
	echo line terminated with a backslash # \
)

${THIS_SH} ./comsub-posix1.sub
${THIS_SH} ./comsub-posix2.sub
${THIS_SH} ./comsub-posix3.sub

#${THIS_SH} ./comsub-posix4.sub
${THIS_SH} ./comsub-posix5.sub
${THIS_SH} ./comsub-posix6.sub

# produced a parse error through bash-4.0-beta2
: $(echo foo)"
"
# produced a parse error through bash-4.1
unset x
x=$(
echo yes
# a comment with " ' \
)
echo $x
unset x

# fixed after bash-4.0 released
: $(case a in a) echo ;; # comment
esac)

: $(case a in 
    a)
        echo
    ;;	# comment
esac)

# fixed after bash-4.3 released
testing=$(
    echo test | while read line; do
        case $line in
             test)  echo saw test ;;
             *)     echo other ;;
        esac
    done
)

# sanity check for empty comsubs
echo $()
echo $(
)

echo $(		

   )

# recommended to be parsed as a nested comsub instead of arithsub
echo $(( echo ab cde ) )

--------------------------------------------------------------------------------
---
(command (word ":") (word "${HOME:=/}"))
(command (word "echo") (word "ab$(echo mnop)yz"))
(command (word "echo") (word "ab$(echo mnop)yz"))
(command (word "echo") (word "$(echo ab)"))
(command (word "echo") (word "$()"))
(command (word "echo") (word "$()"))
(command (word "echo") (word "ab$()cd"))
(command (word "echo") (word "ab$()cd"))
(command (word "echo") (word "mn$()op"))
(command (word "echo") (word "qr$()st"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26ax\n    ;;\nesac)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26ay\n    ;;\nesac)"))
(command (word "echo") (word "$((echo sh_352.25a);(echo sh_352.25b))"))
(command (word "echo") (word "$(echo sh_352.27 ')' \")\" \\))"))
(command (word "echo") (word "$(echo abc)"))
(command (word "echo") (word "$(echo def)"))
(command (word "echo") (word "$(cat <<eof\nhere doc with )\neof\n)"))
(command (word "echo") (word "$(echo ')')"))
(command (word "unset") (word "x"))
(command (word "x=$(cat <<'EOF'\nbad' syntax\nEOF\n)"))
(command (word "echo") (word "\"$x\""))
(command (word "unset") (word "x"))
(command (word "echo") (word "$(for f in \\);\ndo\n    echo a;\ndone)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26a\n    ;;\nesac)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26a\n    ;;\nesac)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26\n    ;;\nesac)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26\n    ;;\nesac)"))
(command (word "echo") (word "$(case a in a)\n        echo sh_352.26\n    ;;\nesac)"))
(command (word "echo") (word "$(( 4<(2+3) ? 1 : 32))"))
(command (word "echo") (word "$(cat <<end\nsh_352.28 )\nend\n)"))
(command (word "echo") (word "$(cat <<-end\nsh_352.28 )\nend\n)"))
(command (word "k=$(case x in x)\n        echo k\n    ;;\nesac)"))
(command (word "echo") (word "$k"))
(command (word "x=$(case $(ls) in example)\n        echo foobix\n    ;;\nesac)"))
(command (word "echo") (word "$(echo abcd)"))
(command (word "echo") (word "`echo ab\ncd`"))
(command (word "echo") (word "`echo ab #xyz\ncd`"))
(command (word "echo") (word "\"$(echo abcde)\n\""))
(command (word "recho") (word "\"$(echo abcde)\n  \""))
(command (word "echo") (word "$(echo abcde)foo"))
(command (word "recho") (word "$(echo abcde)") (word "foo"))
(command (word "recho") (word "\"wx$(echo abcde)yz\""))
(command (word "recho") (word "\"$(echo abcde)\""))
(command (word "echo") (word "$(cat <<eof\n'\neof\n)"))
(command (word "echo") (word "after") (word "1"))
(command (word "echo") (word "$(cat <<'eof'\n'\neof\n)"))
(command (word "echo") (word "after") (word "2"))
(command (word "echo") (word "\"$(cat <<'eof'\n'\neof\n)\""))
(command (word "echo") (word "after") (word "3"))
(command (word "echo") (word "\"$(cat <<'eof'\n`\neof\n)\""))
(command (word "echo") (word "after") (word "4"))
(command (word "echo") (word "$(cat <<')'\nhello\n)\n)"))
(command (word "echo") (word "after") (word "5"))
(command (word "echo") (word "$(cat <<'eof'\n'\neof\n)"))
(command (word "echo") (word "after") (word "6"))
(command (word "echo") (word "$(case x in x)\n        echo x\n    ;;\nesac)"))
(command (word "echo") (word "$(case x in x)\n        echo x\n    ;;\nesac)"))
(command (word "echo") (word "$(case x in x)\n        echo x\n    ;;\nesac)"))
(command (word "echo") (word "$(echo 'quoted )')"))
(command (word "echo") (word "$(echo comment)"))
(command (word "echo") (word "$(cat <<'eof'\n  here-doc with )\neof\n)"))
(command (word "echo") (word "$(cat <<'eof'\n    here-doc with \\()\neof\n)"))
(command (word "echo") (word "$(cat <<')'\n\there-doc terminated with a parenthesis\n)\n)"))
(command (word "echo") (word "$(cat <<'eof'\n\t'   # or a single back- or doublequote\neof\n)"))
(command (word "echo") (word "$(echo line terminated with a backslash)"))
(command (word "${THIS_SH}") (word "./comsub-posix1.sub"))
(command (word "${THIS_SH}") (word "./comsub-posix2.sub"))
(command (word "${THIS_SH}") (word "./comsub-posix3.sub"))
(command (word "${THIS_SH}") (word "./comsub-posix5.sub"))
(command (word "${THIS_SH}") (word "./comsub-posix6.sub"))
(command (word ":") (word "$(echo foo)\"\n\""))
(command (word "unset") (word "x"))
(command (word "x=$(echo yes)"))
(command (word "echo") (word "$x"))
(command (word "unset") (word "x"))
(command (word ":") (word "$(case a in a)\n        echo\n    ;;\nesac)"))
(command (word ":") (word "$(case a in a)\n        echo\n    ;;\nesac)"))
(command (word "testing=$(echo test | while read line; do\n    case $line in test)\n            echo saw test\n        ;;\n        *)\n            echo other\n        ;;\n    esac;\ndone)"))
(command (word "echo") (word "$()"))
(command (word "echo") (word "$()"))
(command (word "echo") (word "$()"))
(command (word "echo") (word "$(( echo ab cde ) )"))
(command (word "--------------------------------------------------------------------------------"))
---

=== comsub
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# command substution parsing tests

TABSIZE=`grep -v '^[ #]' $CAPS </dev/null | grep -v "^$" | grep -v "^capalias"| grep -v "^infoalias" | wc -l`

recho `echo ab cd #efg
hijkl`

recho ab$(echo mn; echo op)yz

a=`echo 'a b c' | sed 's/ /\\
/g' | grep 'b'`
recho $a

recho `echo 'a\' b`

recho `echo '\$' bab`

recho `echo '\`' ab`

recho `echo '\\' ab`

# old-style command substitution parsing compatibility tests -- post bash-3.1
recho 'foo \\
bar'

recho 'foo \
bar'

echo `recho sed -e 's/[	:]/\\
/g'`

echo `recho sed -e 's/[	:]/\
/g'`

echo `recho 'foo\\
bar'`

echo `recho 'foo\
bar'`  

echo $(recho 'foo\
bar')

# long-standing parse error in all versions up through bash-4.3
echo ${foo:-$(echo a{b,c})} >/dev/null

# parsing problem based on recursively calling bison parser through bash-4.4
for (( INDEX=0; INDEX<$((10-$(echo length $V_NAME))); INDEX++ ))
do
	:
done

# problem with four-character words followed by a metachar through bash-4.4
comsub_foo_1()
{
  echo $(while true; do case $HOME in /*) echo abs ;; esac; done)
}

echo $(
echo $(
echo $(echo $( echo nested )
)
)
)

# empty comsubs, fork and nofork
echo blank --$(
)--
echo blank --$()--

echo blank --${ 
}--
echo blank --${  }--


BUILDDIR=/builds/test
read << EOC
Dir: ${BUILDDIR#<(echo a)/}
EOC

# return in a comsub inside a shell function should abort the comsub
func()
{
	local v
	v=$( echo comsub ; return ; echo after)
	echo $FUNCNAME: v = $v
}
func

${THIS_SH} ./comsub1.sub
${THIS_SH} ./comsub2.sub
${THIS_SH} ./comsub3.sub
${THIS_SH} ./comsub4.sub
${THIS_SH} ./comsub5.sub
${THIS_SH} ./comsub6.sub
${THIS_SH} ./comsub7.sub

--------------------------------------------------------------------------------
---
(command (word "TABSIZE=`grep -v '^[ #]' $CAPS </dev/null | grep -v \"^$\" | grep -v \"^capalias\"| grep -v \"^infoalias\" | wc -l`"))
(command (word "recho") (word "`echo ab cd #efg\nhijkl`"))
(command (word "recho") (word "ab$(echo mn; echo op)yz"))
(command (word "a=`echo 'a b c' | sed 's/ /\\\\\n/g' | grep 'b'`"))
(command (word "recho") (word "$a"))
(command (word "recho") (word "`echo 'a\\' b`"))
(command (word "recho") (word "`echo '\\$' bab`"))
(command (word "recho") (word "`echo '\\`' ab`"))
(command (word "recho") (word "`echo '\\\\' ab`"))
(command (word "recho") (word "'foo \\\\\nbar'"))
(command (word "recho") (word "'foo \\\nbar'"))
(command (word "echo") (word "`recho sed -e 's/[\t:]/\\\\\n/g'`"))
(command (word "echo") (word "`recho sed -e 's/[\t:]//g'`"))
(command (word "echo") (word "`recho 'foo\\\\\nbar'`"))
(command (word "echo") (word "`recho 'foobar'`"))
(command (word "echo") (word "$(recho 'foo\\\nbar')"))
(command (word "echo") (word "${foo:-$(echo a{b,c})}") (redirect ">" "/dev/null"))
(arith-for (init (word "INDEX=0")) (test (word "INDEX<$((10-$(echo length $V_NAME)))")) (step (word "INDEX++ ")) (command (word ":")))
(function "comsub_foo_1" (brace-group (command (word "echo") (word "$(while true; do\n    case $HOME in /*)\n            echo abs\n        ;;\n    esac;\ndone)"))))
(command (word "echo") (word "$(echo $(echo $(echo $(echo nested))))"))
(command (word "echo") (word "blank") (word "--$()--"))
(command (word "echo") (word "blank") (word "--$()--"))
(command (word "echo") (word "blank") (word "--${ }--"))
(command (word "echo") (word "blank") (word "--${ }--"))
(command (word "BUILDDIR=/builds/test"))
(command (word "read") (redirect "<<" "Dir: ${BUILDDIR#<(echo a)/}
"))
(function "func" (brace-group (semi (semi (command (word "local") (word "v")) (command (word "v=$(echo comsub; return; echo after)"))) (command (word "echo") (word "$FUNCNAME:") (word "v") (word "=") (word "$v")))))
(command (word "func"))
(command (word "${THIS_SH}") (word "./comsub1.sub"))
(command (word "${THIS_SH}") (word "./comsub2.sub"))
(command (word "${THIS_SH}") (word "./comsub3.sub"))
(command (word "${THIS_SH}") (word "./comsub4.sub"))
(command (word "${THIS_SH}") (word "./comsub5.sub"))
(command (word "${THIS_SH}") (word "./comsub6.sub"))
(command (word "${THIS_SH}") (word "./comsub7.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== cond
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# the test/[ code is tested elsewhere, and the [[...]] just uses the same
# code.  this tests the special features of [[...]]
#
TDIR=/usr/homes/chet

# this one is straight out of the ksh88 book
[[ foo > bar && $PWD -ef . ]]
echo returns: $?

# [[ x ]] is equivalent to [[ -n x ]]
[[ x ]]
echo returns: $?

# [[ ! x ]] is equivalent to [[ ! -n x ]]
[[ ! x ]]
echo returns: $?

# ! binds tighter than test/[ -- it binds to a term, not an expression
[[ ! x || x ]]
echo returns: $?

# ! toggles on and off rather than just setting an `invert result' flag
# this differs from ksh93
[[ ! 1 -eq 1 ]]; echo $?
[[ ! ! 1 -eq 1 ]]; echo $?

[[ ! ! ! 1 -eq 1 ]]; echo $?
[[ ! ! ! ! 1 -eq 1 ]]; echo $?

# parenthesized terms didn't work right until post-2.04
[[ a ]]
echo returns: $?

[[ (a) ]]
echo returns: $?

[[ -n a ]]
echo returns: $?

[[ (-n a) ]]
echo returns: $?

# unset variables don't need to be quoted
[[ -n $UNSET ]]
echo returns: $?

[[ -z $UNSET ]]
echo returns: $?

# need to handle test syntax errors and longjmp
[[ -t X ]]
echo returns: $?

# the ==/= and != operators do pattern matching
[[ $TDIR == /usr/homes/* ]]
echo returns: $?

# ...but you can quote any part of the pattern to have it matched as a string
[[ $TDIR == /usr/homes/\* ]]
echo returns: $?

[[ $TDIR == '/usr/homes/*' ]]
echo returns: $?

# if the first part of && fails, the second is not executed
[[ -n $UNSET && $UNSET == foo ]]
echo returns: $?

[[ -z $UNSET && $UNSET == foo ]]
echo returns: $?

# if the first part of || succeeds, the second is not executed
[[ -z $UNSET || -d $PWD ]]
echo returns: $?

# if the rhs were executed, it would be an error
[[ -n $TDIR || $HOME -ef ${H*} ]]
echo returns: $?

[[ -n $TDIR && -z $UNSET || $HOME -ef ${H*} ]]
echo returns: $?

# && has a higher parsing precedence than ||
[[ -n $TDIR && -n $UNSET || $TDIR -ef . ]]
echo returns: $?

# ...but expressions in parentheses may be used to override precedence rules
[[ -n $TDIR || -n $UNSET && $PWD -ef xyz ]]
echo returns: $?

[[ ( -n $TDIR || -n $UNSET ) && $PWD -ef xyz ]]
echo returns: $?

# some arithmetic tests for completeness -- see what happens with missing
# operands, bad expressions, makes sure arguments are evaluated as
# arithmetic expressions, etc.

unset IVAR A
[[ 7 -gt $IVAR ]]
echo returns: $?

[[ $IVAR -gt 7 ]]
echo returns: $?

IVAR=4
[[ $IVAR -gt 7 ]]
echo returns: $?

[[ 7 -eq 4+3 ]]
echo returns: $?

[[ 7 -eq 4+ ]] 
echo returns: $? 

IVAR=4+3
[[ $IVAR -eq 7 ]]
echo returns: $?

A=7
[[ $IVAR -eq A ]]
echo returns: $?

[[ "$IVAR" -eq "7" ]]
echo returns: $?

A=7
[[ "$IVAR" -eq "A" ]]
echo returns: $?

unset IVAR A

# more pattern matching tests

[[ $filename == *.c ]]
echo returns: $?

filename=patmatch.c

[[ $filename == *.c ]]
echo returns: $?

# the extended globbing features may be used when matching patterns
shopt -s extglob

arg=-7

[[ $arg == -+([0-9]) ]]
echo returns: $?

arg=-H

[[ $arg == -+([0-9]) ]]
echo returns: $?

arg=+4
[[ $arg == ++([0-9]) ]]
echo returns: $?

# make sure the null string is never matched if the string is not null
STR=file.c
PAT=

if [[ $STR = $PAT ]]; then
        echo oops
fi

# but that if the string is null, a null pattern is matched correctly
STR=
PAT=

if [[ $STR = $PAT ]]; then
        echo ok
fi

# test the regular expression conditional operator
[[ jbig2dec-0.9-i586-001.tgz =~ ([^-]+)-([^-]+)-([^-]+)-0*([1-9][0-9]*)\.tgz ]]
echo ${BASH_REMATCH[1]}

# this shouldn't echo anything
[[ jbig2dec-0.9-i586-001.tgz =~ \([^-]+\)-\([^-]+\)-\([^-]+\)-0*\([1-9][0-9]*\)\.tgz ]]
echo ${BASH_REMATCH[1]}

LDD_BASH="       linux-gate.so.1 =>  (0xffffe000)
       libreadline.so.5 => /lib/libreadline.so.5 (0xb7f91000)
       libhistory.so.5 => /lib/libhistory.so.5 (0xb7f8a000)
       libncurses.so.5 => /lib/libncurses.so.5 (0xb7f55000)
       libdl.so.2 => /lib/libdl.so.2 (0xb7f51000)
       libc.so.6 => /lib/libc.so.6 (0xb7e34000)
       /lib/ld-linux.so.2 (0xb7fd0000)"

[[ "$LDD_BASH" =~ "libc" ]] && echo "found 1" 
echo ${BASH_REMATCH[@]}

[[ "$LDD_BASH" =~ libc ]] && echo "found 2" 
echo ${BASH_REMATCH[@]}

# bug in all versions up to and including bash-2.05b
if [[ "123abc" == *?(a)bc ]]; then echo ok 42; else echo bad 42; fi
if [[ "123abc" == *?(a)bc ]]; then echo ok 43; else echo bad 43; fi

match() { [[ $1 == $2 ]]; }
match $'? *x\1y\177z' $'??\\*\\x\\\1\\y\\\177\\z' || echo bad 44

foo=""
[[ bar == *"${foo,,}"* ]] && echo ok 1
[[ bar == *${foo,,}* ]] && echo ok 2

shopt -s extquote
bs='\'
del=$'\177'
[[ bar == *$bs"$del"* ]] || echo ok 3
[[ "" == "$foo" ]] && echo ok 4
[[ "$del" == "${foo,,}" ]] || echo ok 5

# allow reserved words after a conditional command just because
if [[ str ]] then [[ str ]] fi

# make sure pattern matching does the right thing with CTLESC
var=$'ab\001'
[[ $var == $var ]] && echo ok c1
[[ $var == a* ]] && echo ok c2
[[ $var == $'ab\001' ]] && echo ok c3

var=$'ab\001c'
[[ $var == $var ]] && echo ok c4
[[ $var == a* ]] && echo ok c5
[[ $var == $'ab\001'* ]] && echo ok c6

${THIS_SH} ./cond-regexp1.sub
${THIS_SH} ./cond-regexp2.sub
${THIS_SH} ./cond-regexp3.sub

${THIS_SH} ./cond-error1.sub
${THIS_SH} ./cond-xtrace1.sub

--------------------------------------------------------------------------------
---
(command (word "TDIR=/usr/homes/chet"))
(cond (cond-and (cond-binary ">" (cond-term "foo") (cond-term "bar")) (cond-binary "-ef" (cond-term "$PWD") (cond-term "."))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-n" (cond-term "x")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-n" (cond-term "x")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-unary "-n" (cond-term "x")) (cond-unary "-n" (cond-term "x"))))
(command (word "echo") (word "returns:") (word "$?"))
(semi (cond (cond-binary "-eq" (cond-term "1") (cond-term "1"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "-eq" (cond-term "1") (cond-term "1"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "-eq" (cond-term "1") (cond-term "1"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "-eq" (cond-term "1") (cond-term "1"))) (command (word "echo") (word "$?")))
(cond (cond-unary "-n" (cond-term "a")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-expr (cond-unary "-n" (cond-term "a"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-n" (cond-term "a")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-expr (cond-unary "-n" (cond-term "a"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-n" (cond-term "$UNSET")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-z" (cond-term "$UNSET")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-unary "-t" (cond-term "X")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "==" (cond-term "$TDIR") (cond-term "/usr/homes/*")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "==" (cond-term "$TDIR") (cond-term "/usr/homes/\*")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "==" (cond-term "$TDIR") (cond-term "'/usr/homes/*'")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-and (cond-unary "-n" (cond-term "$UNSET")) (cond-binary "==" (cond-term "$UNSET") (cond-term "foo"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-and (cond-unary "-z" (cond-term "$UNSET")) (cond-binary "==" (cond-term "$UNSET") (cond-term "foo"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-unary "-z" (cond-term "$UNSET")) (cond-unary "-d" (cond-term "$PWD"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-unary "-n" (cond-term "$TDIR")) (cond-binary "-ef" (cond-term "$HOME") (cond-term "${H*}"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-and (cond-unary "-n" (cond-term "$TDIR")) (cond-unary "-z" (cond-term "$UNSET"))) (cond-binary "-ef" (cond-term "$HOME") (cond-term "${H*}"))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-and (cond-unary "-n" (cond-term "$TDIR")) (cond-unary "-n" (cond-term "$UNSET"))) (cond-binary "-ef" (cond-term "$TDIR") (cond-term "."))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-or (cond-unary "-n" (cond-term "$TDIR")) (cond-and (cond-unary "-n" (cond-term "$UNSET")) (cond-binary "-ef" (cond-term "$PWD") (cond-term "xyz")))))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-and (cond-expr (cond-or (cond-unary "-n" (cond-term "$TDIR")) (cond-unary "-n" (cond-term "$UNSET")))) (cond-binary "-ef" (cond-term "$PWD") (cond-term "xyz"))))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "unset") (word "IVAR") (word "A"))
(cond (cond-binary "-gt" (cond-term "7") (cond-term "$IVAR")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "-gt" (cond-term "$IVAR") (cond-term "7")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "IVAR=4"))
(cond (cond-binary "-gt" (cond-term "$IVAR") (cond-term "7")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "-eq" (cond-term "7") (cond-term "4+3")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "-eq" (cond-term "7") (cond-term "4+")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "IVAR=4+3"))
(cond (cond-binary "-eq" (cond-term "$IVAR") (cond-term "7")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "A=7"))
(cond (cond-binary "-eq" (cond-term "$IVAR") (cond-term "A")))
(command (word "echo") (word "returns:") (word "$?"))
(cond (cond-binary "-eq" (cond-term ""$IVAR"") (cond-term ""7"")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "A=7"))
(cond (cond-binary "-eq" (cond-term ""$IVAR"") (cond-term ""A"")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "unset") (word "IVAR") (word "A"))
(cond (cond-binary "==" (cond-term "$filename") (cond-term "*.c")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "filename=patmatch.c"))
(cond (cond-binary "==" (cond-term "$filename") (cond-term "*.c")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "arg=-7"))
(cond (cond-binary "==" (cond-term "$arg") (cond-term "-+([0-9])")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "arg=-H"))
(cond (cond-binary "==" (cond-term "$arg") (cond-term "-+([0-9])")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "arg=+4"))
(cond (cond-binary "==" (cond-term "$arg") (cond-term "++([0-9])")))
(command (word "echo") (word "returns:") (word "$?"))
(command (word "STR=file.c"))
(command (word "PAT="))
(if (cond (cond-binary "=" (cond-term "$STR") (cond-term "$PAT"))) (command (word "echo") (word "oops")))
(command (word "STR="))
(command (word "PAT="))
(if (cond (cond-binary "=" (cond-term "$STR") (cond-term "$PAT"))) (command (word "echo") (word "ok")))
(cond (cond-binary "=~" (cond-term "jbig2dec-0.9-i586-001.tgz") (cond-term "([^-]+)-([^-]+)-([^-]+)-0*([1-9][0-9]*)\.tgz")))
(command (word "echo") (word "${BASH_REMATCH[1]}"))
(cond (cond-binary "=~" (cond-term "jbig2dec-0.9-i586-001.tgz") (cond-term "\([^-]+\)-\([^-]+\)-\([^-]+\)-0*\([1-9][0-9]*\)\.tgz")))
(command (word "echo") (word "${BASH_REMATCH[1]}"))
(command (word "LDD_BASH=\"       linux-gate.so.1 =>  (0xffffe000)\n       libreadline.so.5 => /lib/libreadline.so.5 (0xb7f91000)\n       libhistory.so.5 => /lib/libhistory.so.5 (0xb7f8a000)\n       libncurses.so.5 => /lib/libncurses.so.5 (0xb7f55000)\n       libdl.so.2 => /lib/libdl.so.2 (0xb7f51000)\n       libc.so.6 => /lib/libc.so.6 (0xb7e34000)\n       /lib/ld-linux.so.2 (0xb7fd0000)\""))
(and (cond (cond-binary "=~" (cond-term ""$LDD_BASH"") (cond-term ""libc""))) (command (word "echo") (word "\"found 1\"")))
(command (word "echo") (word "${BASH_REMATCH[@]}"))
(and (cond (cond-binary "=~" (cond-term ""$LDD_BASH"") (cond-term "libc"))) (command (word "echo") (word "\"found 2\"")))
(command (word "echo") (word "${BASH_REMATCH[@]}"))
(if (cond (cond-binary "==" (cond-term ""123abc"") (cond-term "*?(a)bc"))) (command (word "echo") (word "ok") (word "42")) (command (word "echo") (word "bad") (word "42")))
(if (cond (cond-binary "==" (cond-term ""123abc"") (cond-term "*?(a)bc"))) (command (word "echo") (word "ok") (word "43")) (command (word "echo") (word "bad") (word "43")))
(function "match" (brace-group (cond (cond-binary "==" (cond-term "$1") (cond-term "$2")))))
(or (command (word "match") (word "'? *xyz'") (word "'??\\*\\x\\\\y\\\\z'")) (command (word "echo") (word "bad") (word "44")))
(command (word "foo=\"\""))
(and (cond (cond-binary "==" (cond-term "bar") (cond-term "*"${foo,,}"*"))) (command (word "echo") (word "ok") (word "1")))
(and (cond (cond-binary "==" (cond-term "bar") (cond-term "*${foo,,}*"))) (command (word "echo") (word "ok") (word "2")))
(command (word "shopt") (word "-s") (word "extquote"))
(command (word "bs='\\'"))
(command (word "del=''"))
(or (cond (cond-binary "==" (cond-term "bar") (cond-term "*$bs"$del"*"))) (command (word "echo") (word "ok") (word "3")))
(and (cond (cond-binary "==" (cond-term """") (cond-term ""$foo""))) (command (word "echo") (word "ok") (word "4")))
(or (cond (cond-binary "==" (cond-term ""$del"") (cond-term ""${foo,,}""))) (command (word "echo") (word "ok") (word "5")))
(if (cond (cond-unary "-n" (cond-term "str"))) (cond (cond-unary "-n" (cond-term "str"))))
(command (word "var='ab'"))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "$var"))) (command (word "echo") (word "ok") (word "c1")))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "a*"))) (command (word "echo") (word "ok") (word "c2")))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "'ab'"))) (command (word "echo") (word "ok") (word "c3")))
(command (word "var='abc'"))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "$var"))) (command (word "echo") (word "ok") (word "c4")))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "a*"))) (command (word "echo") (word "ok") (word "c5")))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "'ab'*"))) (command (word "echo") (word "ok") (word "c6")))
(command (word "${THIS_SH}") (word "./cond-regexp1.sub"))
(command (word "${THIS_SH}") (word "./cond-regexp2.sub"))
(command (word "${THIS_SH}") (word "./cond-regexp3.sub"))
(command (word "${THIS_SH}") (word "./cond-error1.sub"))
(command (word "${THIS_SH}") (word "./cond-xtrace1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== coproc
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
: ${TMPDIR:=/tmp}
TMPOUT=${TMPDIR}/coproc-wait-$BASHPID

coproc { echo a b c; sleep 2; }

case $COPROC_PID in
[0-9]*)	;;
*)	echo COPROC_PID not integer ;;
esac

echo ${COPROC[@]}

read LINE <&${COPROC[0]}
echo $LINE

wait $COPROC_PID

coproc REFLECT { cat - ; }

case $REFLECT_PID in
[0-9]*)	;;
*)	echo REFLECT_PID not integer ;;
esac

echo ${REFLECT[@]}

echo flop >&${REFLECT[1]}
read LINE <&${REFLECT[0]}

echo $LINE

{ sleep 1; kill $REFLECT_PID; } &
wait $REFLECT_PID >$TMPOUT 2>&1 || { status=$? ; echo "coproc.tests: REFLECT: status $status" ; }
[[ $status < 128 || $status == 143 ]] || {
	echo "coproc.tests: wait for REFLECT failed" >&2
}
rm -f $TMPOUT
exec 2>&1

coproc xcase -n -u

case $COPROC_PID in
[0-9]*)	;;
*)	echo COPROC_PID not integer ;;
esac

echo ${COPROC[@]}

echo foo >&${COPROC[1]}
read <&${COPROC[0]}

echo $REPLY
echo ${COPROC[@]}

cat /etc/passwd | grep root | awk -F: '{print $1;}' | sed 1q

exec 4<&${COPROC[0]}-
exec >&${COPROC[1]}-

echo ${COPROC[@]}

read foo <&4
echo $foo >&2

exit 0

--------------------------------------------------------------------------------
---
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "TMPOUT=${TMPDIR}/coproc-wait-$BASHPID"))
(coproc "COPROC" (brace-group (semi (command (word "echo") (word "a") (word "b") (word "c")) (command (word "sleep") (word "2")))))
(case (word "$COPROC_PID") (pattern ((word "[0-9]*")) ()) (pattern ((word "*")) (command (word "echo") (word "COPROC_PID") (word "not") (word "integer"))))
(command (word "echo") (word "${COPROC[@]}"))
(command (word "read") (word "LINE") (redirect "<&" "${COPROC[0]}"))
(command (word "echo") (word "$LINE"))
(command (word "wait") (word "$COPROC_PID"))
(coproc "REFLECT" (brace-group (command (word "cat") (word "-"))))
(case (word "$REFLECT_PID") (pattern ((word "[0-9]*")) ()) (pattern ((word "*")) (command (word "echo") (word "REFLECT_PID") (word "not") (word "integer"))))
(command (word "echo") (word "${REFLECT[@]}"))
(command (word "echo") (word "flop") (redirect ">&" "${REFLECT[1]}"))
(command (word "read") (word "LINE") (redirect "<&" "${REFLECT[0]}"))
(command (word "echo") (word "$LINE"))
(background (brace-group (semi (command (word "sleep") (word "1")) (command (word "kill") (word "$REFLECT_PID")))))
(or (command (word "wait") (word "$REFLECT_PID") (redirect ">" "$TMPOUT") (redirect ">&" 1)) (brace-group (semi (command (word "status=$?")) (command (word "echo") (word "\"coproc.tests: REFLECT: status $status\"")))))
(or (cond (cond-or (cond-binary "<" (cond-term "$status") (cond-term "128")) (cond-binary "==" (cond-term "$status") (cond-term "143")))) (brace-group (command (word "echo") (word "\"coproc.tests: wait for REFLECT failed\"") (redirect ">&" 2))))
(command (word "rm") (word "-f") (word "$TMPOUT"))
(command (word "exec") (redirect ">&" 1))
(coproc "COPROC" (command (word "xcase") (word "-n") (word "-u")))
(case (word "$COPROC_PID") (pattern ((word "[0-9]*")) ()) (pattern ((word "*")) (command (word "echo") (word "COPROC_PID") (word "not") (word "integer"))))
(command (word "echo") (word "${COPROC[@]}"))
(command (word "echo") (word "foo") (redirect ">&" "${COPROC[1]}"))
(command (word "read") (redirect "<&" "${COPROC[0]}"))
(command (word "echo") (word "$REPLY"))
(command (word "echo") (word "${COPROC[@]}"))
(pipe (command (word "cat") (word "/etc/passwd")) (pipe (command (word "grep") (word "root")) (pipe (command (word "awk") (word "-F:") (word "'{print $1;}'")) (command (word "sed") (word "1q")))))
(command (word "exec") (redirect "<&" "${COPROC[0]}"))
(command (word "exec") (redirect ">&" "${COPROC[1]}"))
(command (word "echo") (word "${COPROC[@]}"))
(command (word "read") (word "foo") (redirect "<&" 4))
(command (word "echo") (word "$foo") (redirect ">&" 2))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== cprint
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# a nonsense script and shell function to test out the command printing code
#
tf()
{
	# simple command with redir
	echo this is ${0##*/} > /dev/null

	# pipeline
	echo a | cat - > /dev/null

	test -f ${0##*/} && echo ${0##*/} is a regular file
	test -d ${0##*/} || echo ${0##*/} is not a directory

	echo a ; echo b ; echo c

	echo background >/dev/null &

	( exit 1 )
	echo $?

	{ echo a ; }

	i=0
	while (( i < 3 )); do
		test -r /dev/fd/$i
		i=$(( i + 1 ))
	done

	[[ -r /dev/fd/0 && -w /dev/fd/1 ]] || echo oops > /dev/null

	for name in $( echo 1 2 3 ); do
		test -r /dev/fd/$name
	done

	if [[ -r /dev/fd/0 && -w /dev/fd/1 ]] ; then
		echo ok > /dev/null
	elif (( 7 > 40 )) ; then
		echo oops
	else
		echo done
	fi > /dev/null

	case $PATH in
	*$PWD*)	echo \$PWD in \$PATH ;;
	*)	echo \$PWD not in \$PATH ;;
	esac > /dev/null

	while false; do echo z; done > /dev/null

	until true; do echo z ; done > /dev/null

	echo \&\|'()' \{ echo abcde \; \}
	# when not in POSIX mode, we can have weirdly-named functions
	eval fu\%nc'()' \{ echo abcde \; \}
	type fu\%nc
}

tf2()
{
	( { time -p echo a | cat - > /dev/null ; } ) 2>&1
}

type tf
type tf2

tf

--------------------------------------------------------------------------------
---
(function "tf" (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "this") (word "is") (word "${0##*/}") (redirect ">" "/dev/null")) (pipe (command (word "echo") (word "a")) (command (word "cat") (word "-") (redirect ">" "/dev/null")))) (and (command (word "test") (word "-f") (word "${0##*/}")) (command (word "echo") (word "${0##*/}") (word "is") (word "a") (word "regular") (word "file")))) (or (command (word "test") (word "-d") (word "${0##*/}")) (command (word "echo") (word "${0##*/}") (word "is") (word "not") (word "a") (word "directory")))) (command (word "echo") (word "a"))) (command (word "echo") (word "b"))) (command (word "echo") (word "c"))) (background (command (word "echo") (word "background") (redirect ">" "/dev/null")) (subshell (command (word "exit") (word "1"))))) (command (word "echo") (word "$?"))) (brace-group (command (word "echo") (word "a")))) (command (word "i=0"))) (while (arith (word " i < 3 ")) (semi (command (word "test") (word "-r") (word "/dev/fd/$i")) (command (word "i=$(( i + 1 ))"))))) (or (cond (cond-and (cond-unary "-r" (cond-term "/dev/fd/0")) (cond-unary "-w" (cond-term "/dev/fd/1")))) (command (word "echo") (word "oops") (redirect ">" "/dev/null")))) (for (word "name") (in (word "$(echo 1 2 3)")) (command (word "test") (word "-r") (word "/dev/fd/$name")))) (if (cond (cond-and (cond-unary "-r" (cond-term "/dev/fd/0")) (cond-unary "-w" (cond-term "/dev/fd/1")))) (command (word "echo") (word "ok") (redirect ">" "/dev/null")) (if (arith (word " 7 > 40 ")) (command (word "echo") (word "oops")) (command (word "echo") (word "done")))) (redirect ">" "/dev/null")) (case (word "$PATH") (pattern ((word "*$PWD*")) (command (word "echo") (word "\\$PWD") (word "in") (word "\\$PATH"))) (pattern ((word "*")) (command (word "echo") (word "\\$PWD") (word "not") (word "in") (word "\\$PATH")))) (redirect ">" "/dev/null")) (while (command (word "false")) (command (word "echo") (word "z"))) (redirect ">" "/dev/null")) (until (command (word "true")) (command (word "echo") (word "z"))) (redirect ">" "/dev/null")) (command (word "echo") (word "\\&\\|'()'") (word "\\{") (word "echo") (word "abcde") (word "\\;") (word "\\}"))) (command (word "eval") (word "fu\\%nc'()'") (word "\\{") (word "echo") (word "abcde") (word "\\;") (word "\\}"))) (command (word "type") (word "fu\\%nc")))))
(function "tf2" (brace-group (subshell (brace-group (time -p (pipe (command (word "echo") (word "a")) (command (word "cat") (word "-") (redirect ">" "/dev/null")))))) (redirect ">&" 1)))
(command (word "type") (word "tf"))
(command (word "type") (word "tf2"))
(command (word "tf"))
(command (word "--------------------------------------------------------------------------------"))
---

=== dbg-support
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# Test correct functioning bash debug support not via the bashdb
# debugger but merely by printing via print_trap()
# $Id: dbg-support.tests,v 1.13 2003/02/17 22:02:25 rockyb Exp $
shopt -s extdebug
print_debug_trap() {
   echo "debug lineno: $1 ${FUNCNAME[1]}"
   return
}

print_return_trap() {
   echo "return lineno: $1 ${FUNCNAME[1]}"
   return
}

fn1() {
    echo "LINENO $LINENO"
    echo "LINENO $LINENO"
    echo "BASH_SOURCE[0]" ${BASH_SOURCE[0]}
    echo "FUNCNAME[0]" ${FUNCNAME[0]}
    echo `caller`
    echo `caller 0`
    echo `caller 1`
    echo `caller foo`
}    

fn2() {
    echo "fn2 here. Calling fn1..."
    fn1
}    

fn3() {
    echo "LINENO $LINENO"
    echo "BASH_SOURCE[0]" ${BASH_SOURCE[0]}
    
    # Print a stack trace
    declare -i n
    n=${#FUNCNAME[@]}
    for (( i=0 ; (( i < $n )) ; i++ )) ; do 
        local -i j=i+1
	[ $j -eq $n ] && j=i  # main()'s file is the same as the first caller
	echo "${FUNCNAME[$i]} called from file " \
	    "\`${BASH_SOURCE[$j]}' at line ${BASH_LINENO[$j]}"
    done
    source ./dbg-support.sub
}    

fn4() {
    echo "fn4 here. Calling fn3..."
    fn3
}    

#
# Test of support for debugging facilities in bash
# 

caller
caller -z

# Test debugger set option functrace - set on. Not in vanilla Bash 2.05
#
set -o functrace
trap 'print_debug_trap $LINENO' DEBUG
trap 'print_return_trap $LINENO' RETURN

# Funcname is now an array, but you still can't see it outside a function
echo "FUNCNAME" ${FUNCNAME[0]:-main}

# We should trace into the below. 
# Start easy with a simple function.
fn1
fn2
fn3
source ./dbg-support.sub

# Test debugger set option functrace - set off
set +T

# We should not trace into this.
fn1
fn2
fn3
fn4
source ./dbg-support.sub

# Another way to say: set -o functrace
set -T

# We should trace into this.
source ./dbg-support.sub
set +T

# Test that the line numbers in the presence of conditionals are correct.
for (( i=0 ; (( i <= 2 )) ; i++ )) ; do 
    if [ $i -eq 2 ] ; then
	echo "Hit 2"
    fi
    j=4
done

#
# Check line numbers in command substitution
#
echo $(sourced_fn)
echo `sourced_fn`
x=$((sourced_fn))
x={ sourced_fn }

# Make sure we step into sourced_fn as a command when we request to do so.
# Vanilla bash 2.0 doesn't do.
set -o functrace
x={ sourced_fn }

# Should see line number of xyzzy below. Vanilla bash 2.05b doesn't do
case xyzzy in
 a )
    x=5
    ;; 
 xyzz? )
    case 3 in 
      2 ) 
	x=6 ;;
      3 ) 
	echo "got it" ;;
      * ) echo "no good" ;;
      esac
    ;;
 * )
esac

# Should see line numbers for initial for lines.
for i in 0 1 ; do
  for j in 3 4 ; do
    ((x=i+j))
  done
done

${THIS_SH} ./dbg-support3.sub

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "extdebug"))
(function "print_debug_trap" (brace-group (semi (command (word "echo") (word "\"debug lineno: $1 ${FUNCNAME[1]}\"")) (command (word "return")))))
(function "print_return_trap" (brace-group (semi (command (word "echo") (word "\"return lineno: $1 ${FUNCNAME[1]}\"")) (command (word "return")))))
(function "fn1" (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "\"LINENO $LINENO\"")) (command (word "echo") (word "\"LINENO $LINENO\""))) (command (word "echo") (word "\"BASH_SOURCE[0]\"") (word "${BASH_SOURCE[0]}"))) (command (word "echo") (word "\"FUNCNAME[0]\"") (word "${FUNCNAME[0]}"))) (command (word "echo") (word "`caller`"))) (command (word "echo") (word "`caller 0`"))) (command (word "echo") (word "`caller 1`"))) (command (word "echo") (word "`caller foo`")))))
(function "fn2" (brace-group (semi (command (word "echo") (word "\"fn2 here. Calling fn1...\"")) (command (word "fn1")))))
(function "fn3" (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "\"LINENO $LINENO\"")) (command (word "echo") (word "\"BASH_SOURCE[0]\"") (word "${BASH_SOURCE[0]}"))) (command (word "declare") (word "-i") (word "n"))) (command (word "n=${#FUNCNAME[@]}"))) (arith-for (init (word "i=0 ")) (test (word "(( i < $n )) ")) (step (word "i++ ")) (semi (semi (command (word "local") (word "-i") (word "j=i+1")) (and (command (word "[") (word "$j") (word "-eq") (word "$n") (word "]")) (command (word "j=i")))) (command (word "echo") (word "\"${FUNCNAME[$i]} called from file \"") (word "\"\\`${BASH_SOURCE[$j]}' at line ${BASH_LINENO[$j]}\""))))) (command (word "source") (word "./dbg-support.sub")))))
(function "fn4" (brace-group (semi (command (word "echo") (word "\"fn4 here. Calling fn3...\"")) (command (word "fn3")))))
(command (word "caller"))
(command (word "caller") (word "-z"))
(command (word "set") (word "-o") (word "functrace"))
(command (word "trap") (word "'print_debug_trap $LINENO'") (word "DEBUG"))
(command (word "trap") (word "'print_return_trap $LINENO'") (word "RETURN"))
(command (word "echo") (word "\"FUNCNAME\"") (word "${FUNCNAME[0]:-main}"))
(command (word "fn1"))
(command (word "fn2"))
(command (word "fn3"))
(command (word "source") (word "./dbg-support.sub"))
(command (word "set") (word "+T"))
(command (word "fn1"))
(command (word "fn2"))
(command (word "fn3"))
(command (word "fn4"))
(command (word "source") (word "./dbg-support.sub"))
(command (word "set") (word "-T"))
(command (word "source") (word "./dbg-support.sub"))
(command (word "set") (word "+T"))
(arith-for (init (word "i=0 ")) (test (word "(( i <= 2 )) ")) (step (word "i++ ")) (semi (if (command (word "[") (word "$i") (word "-eq") (word "2") (word "]")) (command (word "echo") (word "\"Hit 2\""))) (command (word "j=4"))))
(command (word "echo") (word "$(sourced_fn)"))
(command (word "echo") (word "`sourced_fn`"))
(command (word "x=$((sourced_fn))"))
(command (word "x={") (word "sourced_fn") (word "}"))
(command (word "set") (word "-o") (word "functrace"))
(command (word "x={") (word "sourced_fn") (word "}"))
(case (word "xyzzy") (pattern ((word "a")) (command (word "x=5"))) (pattern ((word "xyzz?")) (case (word "3") (pattern ((word "2")) (command (word "x=6"))) (pattern ((word "3")) (command (word "echo") (word "\"got it\""))) (pattern ((word "*")) (command (word "echo") (word "\"no good\""))))) (pattern ((word "*")) ()))
(for (word "i") (in (word "0") (word "1")) (for (word "j") (in (word "3") (word "4")) (arith (word "x=i+j"))))
(command (word "${THIS_SH}") (word "./dbg-support3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== dbg-support2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Test correct trap return codes = 2 means skip execution.
shopt -s extdebug
print_trap() {
   echo "lineno: $1 ($LINENO) ${FUNCNAME[1]}"
   if [[ $debug_exit == 2 ]] ; then
     debug_exit=0
     return 2
   fi
   return 0
}

debug_exit=0
trap 'print_trap $LINENO' DEBUG

x=1
echo "x is $x"
debug_exit=2
x=2
echo "x is $x"

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "extdebug"))
(function "print_trap" (brace-group (semi (semi (command (word "echo") (word "\"lineno: $1 ($LINENO) ${FUNCNAME[1]}\"")) (if (cond (cond-binary "==" (cond-term "$debug_exit") (cond-term "2"))) (semi (command (word "debug_exit=0")) (command (word "return") (word "2"))))) (command (word "return") (word "0")))))
(command (word "debug_exit=0"))
(command (word "trap") (word "'print_trap $LINENO'") (word "DEBUG"))
(command (word "x=1"))
(command (word "echo") (word "\"x is $x\""))
(command (word "debug_exit=2"))
(command (word "x=2"))
(command (word "echo") (word "\"x is $x\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== dstack
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
export LC_ALL=C
export LANG=C

dirs -c
# error -- non-existent directory
pushd /tmp/xxx-notthere

# errors -- empty stack
pushd
popd

# errors -- bad numeric arguments -- should not cause the script to exit
pushd -m
popd -m
dirs -m
dirs 7

MYDIR=$PWD
unalias cd 2>/dev/null

unalias -a

command cd -P /
command pwd -P	# better be `/'

case "$OLDPWD" in
$MYDIR)	echo ok ;;
*)	echo oops -- bad \$OLDPWD ;;
esac

pushd /usr
echo $PWD $OLDPWD
dirs
echo ${DIRSTACK[@]}

# this should not change the directory stack at all
pushd -n +0
dirs

popd
pushd /usr

pushd /etc
dirs
dirs -l
dirs -v

# two consecutive `pushd's should swap the top two stack elements, then
# swap them back, leaving the stack intact
pushd
pushd

pushd /tmp
echo ${DIRSTACK[0]} ; dirs +0
echo ${DIRSTACK[2]} ; dirs +2

# these should be errors, but not affect the directory stack
dirs +9; dirs -9
pushd +9 ; pushd -9
popd +9 ; popd -9

popd -n +2
dirs
echo ${DIRSTACK[@]}

pushd -n /usr
echo $PWD
dirs
echo ${DIRSTACK[@]}

builtin pwd

DIRSTACK[1]=/bin
dirs

builtin pwd
popd +2
builtin pwd -L
pushd -1
dirs
echo ${DIRSTACK[0]}

dirs -c
dirs

# this is for the benefit of pure coverage
cd "$MYDIR"

--------------------------------------------------------------------------------
---
(command (word "export") (word "LC_ALL=C"))
(command (word "export") (word "LANG=C"))
(command (word "dirs") (word "-c"))
(command (word "pushd") (word "/tmp/xxx-notthere"))
(command (word "pushd"))
(command (word "popd"))
(command (word "pushd") (word "-m"))
(command (word "popd") (word "-m"))
(command (word "dirs") (word "-m"))
(command (word "dirs") (word "7"))
(command (word "MYDIR=$PWD"))
(command (word "unalias") (word "cd") (redirect ">" "/dev/null"))
(command (word "unalias") (word "-a"))
(command (word "command") (word "cd") (word "-P") (word "/"))
(command (word "command") (word "pwd") (word "-P"))
(case (word "\"$OLDPWD\"") (pattern ((word "$MYDIR")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "bad") (word "\\$OLDPWD"))))
(command (word "pushd") (word "/usr"))
(command (word "echo") (word "$PWD") (word "$OLDPWD"))
(command (word "dirs"))
(command (word "echo") (word "${DIRSTACK[@]}"))
(command (word "pushd") (word "-n") (word "+0"))
(command (word "dirs"))
(command (word "popd"))
(command (word "pushd") (word "/usr"))
(command (word "pushd") (word "/etc"))
(command (word "dirs"))
(command (word "dirs") (word "-l"))
(command (word "dirs") (word "-v"))
(command (word "pushd"))
(command (word "pushd"))
(command (word "pushd") (word "/tmp"))
(semi (command (word "echo") (word "${DIRSTACK[0]}")) (command (word "dirs") (word "+0")))
(semi (command (word "echo") (word "${DIRSTACK[2]}")) (command (word "dirs") (word "+2")))
(semi (command (word "dirs") (word "+9")) (command (word "dirs") (word "-9")))
(semi (command (word "pushd") (word "+9")) (command (word "pushd") (word "-9")))
(semi (command (word "popd") (word "+9")) (command (word "popd") (word "-9")))
(command (word "popd") (word "-n") (word "+2"))
(command (word "dirs"))
(command (word "echo") (word "${DIRSTACK[@]}"))
(command (word "pushd") (word "-n") (word "/usr"))
(command (word "echo") (word "$PWD"))
(command (word "dirs"))
(command (word "echo") (word "${DIRSTACK[@]}"))
(command (word "builtin") (word "pwd"))
(command (word "DIRSTACK[1]=/bin"))
(command (word "dirs"))
(command (word "builtin") (word "pwd"))
(command (word "popd") (word "+2"))
(command (word "builtin") (word "pwd") (word "-L"))
(command (word "pushd") (word "-1"))
(command (word "dirs"))
(command (word "echo") (word "${DIRSTACK[0]}"))
(command (word "dirs") (word "-c"))
(command (word "dirs"))
(command (word "cd") (word "\"$MYDIR\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== dstack2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
wdir=$PWD
cd /

echo expect '~1'
echo ~1

pushd /usr
pushd /tmp
dirs

echo these lines should be the same
dirs +0
echo ~0 ${DIRSTACK[0]}
echo these lines should be the same
dirs +1
echo ~1 ${DIRSTACK[1]}
echo these lines should be the same
dirs +2
echo ~2 ${DIRSTACK[2]}

NDIRS=$(( ${#DIRSTACK[@]} - 1 ))

echo these lines should be the same
dirs -2
echo ~-2 ${DIRSTACK[NDIRS-2]}

echo these lines should be the same
dirs -1
echo ~-1 ${DIRSTACK[NDIRS-1]}
dirs -v -1

echo these lines should be the same
dirs -0
echo ~-0 ${DIRSTACK[NDIRS]}

cd "$wdir"

--------------------------------------------------------------------------------
---
(command (word "wdir=$PWD"))
(command (word "cd") (word "/"))
(command (word "echo") (word "expect") (word "'~1'"))
(command (word "echo") (word "~1"))
(command (word "pushd") (word "/usr"))
(command (word "pushd") (word "/tmp"))
(command (word "dirs"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "+0"))
(command (word "echo") (word "~0") (word "${DIRSTACK[0]}"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "+1"))
(command (word "echo") (word "~1") (word "${DIRSTACK[1]}"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "+2"))
(command (word "echo") (word "~2") (word "${DIRSTACK[2]}"))
(command (word "NDIRS=$(( ${#DIRSTACK[@]} - 1 ))"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "-2"))
(command (word "echo") (word "~-2") (word "${DIRSTACK[NDIRS-2]}"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "-1"))
(command (word "echo") (word "~-1") (word "${DIRSTACK[NDIRS-1]}"))
(command (word "dirs") (word "-v") (word "-1"))
(command (word "echo") (word "these") (word "lines") (word "should") (word "be") (word "the") (word "same"))
(command (word "dirs") (word "-0"))
(command (word "echo") (word "~-0") (word "${DIRSTACK[NDIRS]}"))
(command (word "cd") (word "\"$wdir\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== dynvar
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# specvar -- test some of the dynamic variables

# BASHPID
pid=$$
bpid=$BASHPID
subpid=$( (echo $BASHPID) )

if [ "$bpid" -ne "$subpid" ]; then echo BASHPID ok; fi

# BASH_ARGV0

BASH_ARGV0=hello
case $0 in
hello)	echo BASH_ARGV0 ok ;;
*)	echo "BASH_ARGV0 mismatch: $BASH_ARGV0 ($0)" >&2 ;;
esac

setarg0()
{
	BASH_ARGV0="$1"
}

setarg0 arg0
case $0 in
arg0)	echo BASH_ARGV0 ok ;;
*)	echo "BASH_ARGV0 mismatch: $BASH_ARGV0 ($0)" >&2 ;;
esac

# SECONDS
before=$SECONDS
sleep 2
after=$SECONDS

if (( $after > $before )); then echo SECONDS ok; fi
unset before after

# do the best we can to test assignment to SECONDS
SECONDS=2
sleep 1
[[ $SECONDS -ge 10 ]] && echo 'SECONDS: bad value assignment'

# EPOCHSECONDS

# not exact, but should work
# date +%s should be portable enough now
# then try gawk, perl, python in that order
now1=$(date +%s 2>/dev/null) D=date
[ -z "$now1" ] &&
{
	now1=$(gawk 'BEGIN { print systime(); }' 2>/dev/null) D=gawk
	[ -z "$now1" ] && now1=$(perl -e 'print time' 2>/dev/null) D=perl
	[ -z "$now1" ] && now1=$(python -c 'import time; ts = int(time.time()); print(ts)' 2>/dev/null) D=python
}
now2=$EPOCHSECONDS

# use a window of +-1 second
offset=1
if [[ -z $now1 ]]; then
	echo "cannot get current time using date/gawk/perl/python" >&2
elif (( $now1 - $offset <= $now2 && $now2 <= $now1 + $offset )); then
	echo EPOCHSECONDS ok
else
	echo "current time via $D and EPOCHSECONDS possible mismatch|$now1|$now2|offset=$offset" >&2
fi
unset now1 now2 D

LC_ALL=C		# force decimal point to `.'
now1=$EPOCHREALTIME
now2=$EPOCHREALTIME
sec1=${now1%%.*}
sec2=${now2%%.*}

msec1=${now1##*.}
msec2=${now2##*.}
# cut off leading zeros
shopt -s extglob
msec1=${msec1##*(0)}
msec2=${msec2##*(0)}

dsec=$(( $sec2 - $sec1 ))
dmsec=$(( $msec2 - $msec1 ))
if (( $dmsec < 0 )); then
	dmsec=$(( dmsec + 1000000 ))
	dsec=$(( desc - 1 ))
fi

# not a real test, but ok for a start
if (( $dmsec < 1000000 )); then echo EPOCHREALTIME ok; fi

${THIS_SH} -c 'echo $BASH_COMMAND'

# FUNCNAME tested in func.tests
# RANDOM tested in varenv.sh
# LINENO tested in dbg-support, misc additional tests here
arith_lineno()
{
	echo $LINENO
	for f in 1 ; do echo $LINENO; done
	for (( f=1 ; f < 2; f++ )); do echo $LINENO; done
	echo $(( $LINENO ))
	(( 1 == 1 )) && echo $LINENO
	(( LINENO / 0 ))
}
arith_lineno

# assignments to noassign variables are ignored
FUNCNAME=42
echo $? $FUNCNAME

GROUPS[0]=-1
echo $?

[[ ${GROUPS[0]} != -1 ]] || echo GROUPS noassign error

--------------------------------------------------------------------------------
---
(command (word "pid=$$"))
(command (word "bpid=$BASHPID"))
(command (word "subpid=$( ( echo $BASHPID ))"))
(if (command (word "[") (word "\"$bpid\"") (word "-ne") (word "\"$subpid\"") (word "]")) (command (word "echo") (word "BASHPID") (word "ok")))
(command (word "BASH_ARGV0=hello"))
(case (word "$0") (pattern ((word "hello")) (command (word "echo") (word "BASH_ARGV0") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "\"BASH_ARGV0 mismatch: $BASH_ARGV0 ($0)\"") (redirect ">&" 2))))
(function "setarg0" (brace-group (command (word "BASH_ARGV0=\"$1\""))))
(command (word "setarg0") (word "arg0"))
(case (word "$0") (pattern ((word "arg0")) (command (word "echo") (word "BASH_ARGV0") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "\"BASH_ARGV0 mismatch: $BASH_ARGV0 ($0)\"") (redirect ">&" 2))))
(command (word "before=$SECONDS"))
(command (word "sleep") (word "2"))
(command (word "after=$SECONDS"))
(if (arith (word " $after > $before ")) (command (word "echo") (word "SECONDS") (word "ok")))
(command (word "unset") (word "before") (word "after"))
(command (word "SECONDS=2"))
(command (word "sleep") (word "1"))
(and (cond (cond-binary "-ge" (cond-term "$SECONDS") (cond-term "10"))) (command (word "echo") (word "'SECONDS: bad value assignment'")))
(command (word "now1=$(date +%s 2> /dev/null)") (word "D=date"))
(and (command (word "[") (word "-z") (word "\"$now1\"") (word "]")) (brace-group (semi (semi (command (word "now1=$(gawk 'BEGIN { print systime(); }' 2> /dev/null)") (word "D=gawk")) (and (command (word "[") (word "-z") (word "\"$now1\"") (word "]")) (command (word "now1=$(perl -e 'print time' 2> /dev/null)") (word "D=perl")))) (and (command (word "[") (word "-z") (word "\"$now1\"") (word "]")) (command (word "now1=$(python -c 'import time; ts = int(time.time()); print(ts)' 2> /dev/null)") (word "D=python"))))))
(command (word "now2=$EPOCHSECONDS"))
(command (word "offset=1"))
(if (cond (cond-unary "-z" (cond-term "$now1"))) (command (word "echo") (word "\"cannot get current time using date/gawk/perl/python\"") (redirect ">&" 2)) (if (arith (word " $now1 - $offset <= $now2 && $now2 <= $now1 + $offset ")) (command (word "echo") (word "EPOCHSECONDS") (word "ok")) (command (word "echo") (word "\"current time via $D and EPOCHSECONDS possible mismatch|$now1|$now2|offset=$offset\"") (redirect ">&" 2))))
(command (word "unset") (word "now1") (word "now2") (word "D"))
(command (word "LC_ALL=C"))
(command (word "now1=$EPOCHREALTIME"))
(command (word "now2=$EPOCHREALTIME"))
(command (word "sec1=${now1%%.*}"))
(command (word "sec2=${now2%%.*}"))
(command (word "msec1=${now1##*.}"))
(command (word "msec2=${now2##*.}"))
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "msec1=${msec1##*(0)}"))
(command (word "msec2=${msec2##*(0)}"))
(command (word "dsec=$(( $sec2 - $sec1 ))"))
(command (word "dmsec=$(( $msec2 - $msec1 ))"))
(if (arith (word " $dmsec < 0 ")) (semi (command (word "dmsec=$(( dmsec + 1000000 ))")) (command (word "dsec=$(( desc - 1 ))"))))
(if (arith (word " $dmsec < 1000000 ")) (command (word "echo") (word "EPOCHREALTIME") (word "ok")))
(command (word "${THIS_SH}") (word "-c") (word "'echo $BASH_COMMAND'"))
(function "arith_lineno" (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "$LINENO")) (for (word "f") (in (word "1")) (command (word "echo") (word "$LINENO")))) (arith-for (init (word "f=1 ")) (test (word "f < 2")) (step (word "f++ ")) (command (word "echo") (word "$LINENO")))) (command (word "echo") (word "$(( $LINENO ))"))) (and (arith (word " 1 == 1 ")) (command (word "echo") (word "$LINENO")))) (arith (word " LINENO / 0 ")))))
(command (word "arith_lineno"))
(command (word "FUNCNAME=42"))
(command (word "echo") (word "$?") (word "$FUNCNAME"))
(command (word "GROUPS[0]=-1"))
(command (word "echo") (word "$?"))
(or (cond (cond-binary "!=" (cond-term "${GROUPS[0]}") (cond-term "-1"))) (command (word "echo") (word "GROUPS") (word "noassign") (word "error")))
(command (word "--------------------------------------------------------------------------------"))
---

=== errors
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# These should all be safe
LC_ALL=C
LC_CTYPE=C
LC_COLLATE=C
LC_MESSAGES=C

# these tests should all generate errors

# make sure we don't exit prematurely
set +e
set +o posix

# various alias/unalias errors
unalias

# at some point, this may mean to `export' an alias, like ksh, but
# for now it is an error
alias -x foo=barz
unalias -x fooaha
alias hoowah
unalias hoowah

# the iteration variable must be a valid identifier
for 1 in a b c
do
	echo $1
done
for f\1 in a b c ; do echo $f ; done

# in posix mode, it's a fatal error
(set -o posix
for invalid-name in a b c; do echo $1; done; echo after posix for)
(set -o posix
for f\1 in a b c ; do echo $f ; done; echo after posix for 2)

# same with select
select 1 in a b c; do echo $REPLY; done
select f\1 in a b c ; do echo $REPLY ; done
select invalid-name in a b c; do echo $REPLY; done

(set -o posix ; select 1 in a b c; do echo $REPLY; done; echo after posix select)
(set -o posix ; select f\1 in a b c ; do echo $REPLY ; done ; echo after posix select 2)

# even in functions
bad-select()
{
        select $1 in a b c ; do echo $REPLY ; done
}
bad-select 'a b'
unset -f bad-select

# try to rebind a read-only function
func()
{
	echo func
}
readonly -f func
# make sure `readonly' and `declare' play well together
declare -Fr
func()
{
	echo bar
}

# bad option
unset -x func

# cannot unset readonly functions or variables
unset -f func
# or make them not readonly
declare -fr func
declare -f +r func

# cannot use declare -f in combination with other attributes
a() { echo a; }
declare -f -a a
declare -f -i b c

XPATH=$PATH
declare -r XPATH
unset -v XPATH

# cannot unset invalid identifiers
unset /bin/sh

# cannot unset function and variable at the same time
unset -f -v SHELL

# bad option
declare -z
# cannot declare invalid identifiers
declare -- -z 
declare /bin/sh

# this is the syntax used to export functions in the environment, but
# it cannot be used with `declare'
declare -f func='() { echo "this is func"; }'

# bad option to exec -- this should not exit the script
exec -i /bin/sh

# trying to exec non-executable file is a fatal error
( exec ./errors1.sub 2>/dev/null ; echo after failed exec )

# try to export -f something that is not a function -- this should be
# an error, not create an `invisible function'
export -f XPATH

# this depends on the setting of BREAK_COMPLAINS in config.h.in
break
continue

# this should not exit the shell; it did in versions before 2.01
shift label

# other shells do not complain about the extra arguments; maybe someday
# we won't either
set -- a b c
shift $# label
# and get rid of the positional parameters
shift $#

# let without an expression is an error, though maybe it should just return
# success
let

# local outside a function is an error
local

# logout of a non-login shell is an error
logout

# try to hash a non-existent command
hash notthere

# bad option to hash, although it may mean `verbose' at some future point
hash -v

# hash -d requires an argument
hash -d

# turn off hashing, then try to hash something
set +o hashall
hash -p ${THIS_SH} ${THIS_SH##*/}

declare -a AA
unset AA[-2]

# try to assign to a readonly array
declare -r AA
AA=( one two three )

# make sure `readonly -n' doesn't turn off readonly status
readonly -n AA
AA=(one two three)

# try to assign a readonly array with bad assignment syntax
# NOTE: this works in post-bash-2.05 (at least when I write this)
# readonly -a ZZZ=bbb

# bad counts to `shift'
shopt -s shift_verbose
shift $(( $# + 5 ))
shift -2
shift -- $(( $# + 5 ))
shift -- -2

# bad shell options
shopt -s no_such_option
shopt no_such_option
shopt -s -o no_such_option

# non-octal digits for umask and other errors
umask 09
umask -S u=rwx:g=rwx:o=rx >/dev/null # 002
umask -S u:rwx,g:rwx,o:rx >/dev/null # 002

# at some point, this may mean `invert', but for now it is an error
umask -i

# bad assignments shouldn't change the umask
mask=$(umask)
umask g=p
mask2=$(umask)
if [ "$mask" != "$mask2" ]; then
	echo "umask errors change process umask"
fi

# assignment to a readonly variable in environment
VAR=4
readonly VAR
VAR=7 :

# more readonly variable tests
declare VAR=88
declare +r VAR

declare -p unset

# iteration variable in a for statement being readonly
for VAR in 1 2 3 ; do echo $VAR; done

# parser errors; caught early so we have to run them in subshells
${THIS_SH} -c ': $( for z in 1 2 3; do )' comsub
${THIS_SH} -c ': $( for z in 1 2 3; done )' comsub

# various `cd' errors
( unset HOME ; cd )
( HOME=/tmp/xyz.bash ; cd )
# errors from cd
cd -
cd /bin/sh	# error - not a directory
OLDPWD=/tmp/cd-notthere
cd -
# too many arguments
cd one two three
# cd doesn't like it if PWD is readonly
${THIS_SH} -c 'readonly PWD ; cd / ; echo $?' bash
# or if OLDPWD is readonly
${THIS_SH} -c 'readonly OLDPWD ; cd / ; echo $?' bash

# various `source/.' errors
.
source

# maybe someday this will work like in rc
. -i /dev/tty

# make sure that this gives an error rather than setting $1
set -q

# enable non-builtins
enable sh bash

# try to set and unset shell options simultaneously
shopt -s -u checkhash

# error
read -x

# this is an error -- bad timeout spec
read -t var < /dev/null

# try to read into an invalid identifier
read /bin/sh < /dev/null
read A /bin/sh < /dev/null
read -a invalid-name < /dev/null

# try to read into a readonly variable
read VAR < /dev/null

# invalid file descriptor
read -u XX < /dev/null
read -u 42 < /dev/null

# same with mapfile
mapfile -u XX A < /dev/null
mapfile -u 42 A < /dev/null
unset -v A

# invalid identifier arguments to mapfile
mapfile '' </dev/null
mapfile invalid-var < /dev/null

# bad option to readonly/export
readonly -x foo

# someday these may mean something, but for now they're errors
eval -i "echo $-"
command -i "echo $-"

# this caused a core dump in bash-2.01 (fixed in bash-2.01.1)
eval echo \$[/bin/sh + 0]
eval echo '$((/bin/sh + 0))'

# error to list trap for an unknown signal
trap -p NOSIG

# maybe someday trap will take a -s argument like kill, but not now
trap -p -s NOSIG

# we have a ksh-like ERR trap, post-bash-2.05
#trap 'echo [$LINENO] -- error' ERR

# can only return from a function or sourced script
return 2

# break and continue with arguments <= 0
for z in 1 2 3; do
	break 0
	echo $x
done
for z in 1 2 3; do
	continue 0
	echo $x
done

# invalid option
builtin -x

# builtin with non-builtin
builtin bash

# maybe someday you will be able to use fg/bg when job control is not really
# active, but for now they are errors
bg
fg

# argument required
kill
kill -s
# bad argument
kill -S
# null argument
kill -INT ''
# argument required
kill -INT
# bad signal specification
kill -l SIGBAD
# bad signal specification
kill -l BAD
# bad process specification
kill -HUP @12

# cannot unset non-unsettable variables
unset -v BASH_LINENO BASH_SOURCE

# bad shell option names
set -o trackall		# bash is not ksh
set -q			# this is an error
set -i			# this is not allowed

# problem with versions through bash-4.2
readonly xx=5
echo $((xx=5))
echo $?

${THIS_SH} ./errors1.sub
${THIS_SH} ./errors2.sub
${THIS_SH} ./errors3.sub
${THIS_SH} ./errors4.sub
${THIS_SH} -o posix ./errors4.sub

${THIS_SH} ./errors5.sub

${THIS_SH} ./errors6.sub
THIS_SH="${THIS_SH} -o posix" ${THIS_SH} ./errors6.sub

${THIS_SH} ./errors7.sub
${THIS_SH} -o posix ./errors7.sub

${THIS_SH} ./errors8.sub
${THIS_SH} ./errors9.sub

# invalid numeric arguments and too many arguments
${THIS_SH} ./errors10.sub

# invalid identifiers to readonly/export
${THIS_SH} ./errors11.sub

# EOF when parsing compound commands
${THIS_SH} ./errors12.sub

${THIS_SH} -c 'return ; echo after return' bash
${THIS_SH} -o posix -c 'return ; echo after return' bash

# various posix-mode special builtin fatal (or not) errors

# posix says unsetting readonly variables is a fatal error
${THIS_SH} -o posix -c 'readonly a=a ; unset -v a; echo after unset 1' sh
# the same with non-identifiers
${THIS_SH} -o posix -c 'unset -v a-b; echo after unset 2' sh
# and sourcing a non-existent file is fatal too
${THIS_SH} -o posix -c '. /nosuchfile ; echo after source' sh
# but trap specifying a bad signal nunber is non-fatal
${THIS_SH} -o posix -c 'trap "echo bad" SIGNOSIG; echo after trap' sh

# in posix mode, this is no longer a fatal error
# a function name does not have to be a valid identifier
set -o posix
function !! () { fc -s "$@" ; }
set +o posix

echo end

--------------------------------------------------------------------------------
---
(command (word "LC_ALL=C"))
(command (word "LC_CTYPE=C"))
(command (word "LC_COLLATE=C"))
(command (word "LC_MESSAGES=C"))
(command (word "set") (word "+e"))
(command (word "set") (word "+o") (word "posix"))
(command (word "unalias"))
(command (word "alias") (word "-x") (word "foo=barz"))
(command (word "unalias") (word "-x") (word "fooaha"))
(command (word "alias") (word "hoowah"))
(command (word "unalias") (word "hoowah"))
(for (word "1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$1")))
(for (word "f\\1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$f")))
(subshell (semi (semi (command (word "set") (word "-o") (word "posix")) (for (word "invalid-name") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$1")))) (command (word "echo") (word "after") (word "posix") (word "for"))))
(subshell (semi (semi (command (word "set") (word "-o") (word "posix")) (for (word "f\\1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$f")))) (command (word "echo") (word "after") (word "posix") (word "for") (word "2"))))
(select (word "1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))
(select (word "f\\1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))
(select (word "invalid-name") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))
(subshell (semi (semi (command (word "set") (word "-o") (word "posix")) (select (word "1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))) (command (word "echo") (word "after") (word "posix") (word "select"))))
(subshell (semi (semi (command (word "set") (word "-o") (word "posix")) (select (word "f\\1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))) (command (word "echo") (word "after") (word "posix") (word "select") (word "2"))))
(function "bad-select" (brace-group (select (word "$1") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$REPLY")))))
(command (word "bad-select") (word "'a b'"))
(command (word "unset") (word "-f") (word "bad-select"))
(function "func" (brace-group (command (word "echo") (word "func"))))
(command (word "readonly") (word "-f") (word "func"))
(command (word "declare") (word "-Fr"))
(function "func" (brace-group (command (word "echo") (word "bar"))))
(command (word "unset") (word "-x") (word "func"))
(command (word "unset") (word "-f") (word "func"))
(command (word "declare") (word "-fr") (word "func"))
(command (word "declare") (word "-f") (word "+r") (word "func"))
(function "a" (brace-group (command (word "echo") (word "a"))))
(command (word "declare") (word "-f") (word "-a") (word "a"))
(command (word "declare") (word "-f") (word "-i") (word "b") (word "c"))
(command (word "XPATH=$PATH"))
(command (word "declare") (word "-r") (word "XPATH"))
(command (word "unset") (word "-v") (word "XPATH"))
(command (word "unset") (word "/bin/sh"))
(command (word "unset") (word "-f") (word "-v") (word "SHELL"))
(command (word "declare") (word "-z"))
(command (word "declare") (word "--") (word "-z"))
(command (word "declare") (word "/bin/sh"))
(command (word "declare") (word "-f") (word "func='() { echo \"this is func\"; }'"))
(command (word "exec") (word "-i") (word "/bin/sh"))
(subshell (semi (command (word "exec") (word "./errors1.sub") (redirect ">" "/dev/null")) (command (word "echo") (word "after") (word "failed") (word "exec"))))
(command (word "export") (word "-f") (word "XPATH"))
(command (word "break"))
(command (word "continue"))
(command (word "shift") (word "label"))
(command (word "set") (word "--") (word "a") (word "b") (word "c"))
(command (word "shift") (word "$#") (word "label"))
(command (word "shift") (word "$#"))
(command (word "let"))
(command (word "local"))
(command (word "logout"))
(command (word "hash") (word "notthere"))
(command (word "hash") (word "-v"))
(command (word "hash") (word "-d"))
(command (word "set") (word "+o") (word "hashall"))
(command (word "hash") (word "-p") (word "${THIS_SH}") (word "${THIS_SH##*/}"))
(command (word "declare") (word "-a") (word "AA"))
(command (word "unset") (word "AA[-2]"))
(command (word "declare") (word "-r") (word "AA"))
(command (word "AA=(one two three)"))
(command (word "readonly") (word "-n") (word "AA"))
(command (word "AA=(one two three)"))
(command (word "shopt") (word "-s") (word "shift_verbose"))
(command (word "shift") (word "$(( $# + 5 ))"))
(command (word "shift") (word "-2"))
(command (word "shift") (word "--") (word "$(( $# + 5 ))"))
(command (word "shift") (word "--") (word "-2"))
(command (word "shopt") (word "-s") (word "no_such_option"))
(command (word "shopt") (word "no_such_option"))
(command (word "shopt") (word "-s") (word "-o") (word "no_such_option"))
(command (word "umask") (word "09"))
(command (word "umask") (word "-S") (word "u=rwx:g=rwx:o=rx") (redirect ">" "/dev/null"))
(command (word "umask") (word "-S") (word "u:rwx,g:rwx,o:rx") (redirect ">" "/dev/null"))
(command (word "umask") (word "-i"))
(command (word "mask=$(umask)"))
(command (word "umask") (word "g=p"))
(command (word "mask2=$(umask)"))
(if (command (word "[") (word "\"$mask\"") (word "!=") (word "\"$mask2\"") (word "]")) (command (word "echo") (word "\"umask errors change process umask\"")))
(command (word "VAR=4"))
(command (word "readonly") (word "VAR"))
(command (word "VAR=7") (word ":"))
(command (word "declare") (word "VAR=88"))
(command (word "declare") (word "+r") (word "VAR"))
(command (word "declare") (word "-p") (word "unset"))
(for (word "VAR") (in (word "1") (word "2") (word "3")) (command (word "echo") (word "$VAR")))
(command (word "${THIS_SH}") (word "-c") (word "': $( for z in 1 2 3; do )'") (word "comsub"))
(command (word "${THIS_SH}") (word "-c") (word "': $( for z in 1 2 3; done )'") (word "comsub"))
(subshell (semi (command (word "unset") (word "HOME")) (command (word "cd"))))
(subshell (semi (command (word "HOME=/tmp/xyz.bash")) (command (word "cd"))))
(command (word "cd") (word "-"))
(command (word "cd") (word "/bin/sh"))
(command (word "OLDPWD=/tmp/cd-notthere"))
(command (word "cd") (word "-"))
(command (word "cd") (word "one") (word "two") (word "three"))
(command (word "${THIS_SH}") (word "-c") (word "'readonly PWD ; cd / ; echo $?'") (word "bash"))
(command (word "${THIS_SH}") (word "-c") (word "'readonly OLDPWD ; cd / ; echo $?'") (word "bash"))
(command (word "."))
(command (word "source"))
(command (word ".") (word "-i") (word "/dev/tty"))
(command (word "set") (word "-q"))
(command (word "enable") (word "sh") (word "bash"))
(command (word "shopt") (word "-s") (word "-u") (word "checkhash"))
(command (word "read") (word "-x"))
(command (word "read") (word "-t") (word "var") (redirect "<" "/dev/null"))
(command (word "read") (word "/bin/sh") (redirect "<" "/dev/null"))
(command (word "read") (word "A") (word "/bin/sh") (redirect "<" "/dev/null"))
(command (word "read") (word "-a") (word "invalid-name") (redirect "<" "/dev/null"))
(command (word "read") (word "VAR") (redirect "<" "/dev/null"))
(command (word "read") (word "-u") (word "XX") (redirect "<" "/dev/null"))
(command (word "read") (word "-u") (word "42") (redirect "<" "/dev/null"))
(command (word "mapfile") (word "-u") (word "XX") (word "A") (redirect "<" "/dev/null"))
(command (word "mapfile") (word "-u") (word "42") (word "A") (redirect "<" "/dev/null"))
(command (word "unset") (word "-v") (word "A"))
(command (word "mapfile") (word "''") (redirect "<" "/dev/null"))
(command (word "mapfile") (word "invalid-var") (redirect "<" "/dev/null"))
(command (word "readonly") (word "-x") (word "foo"))
(command (word "eval") (word "-i") (word "\"echo $-\""))
(command (word "command") (word "-i") (word "\"echo $-\""))
(command (word "eval") (word "echo") (word "\\$[/bin/sh") (word "+") (word "0]"))
(command (word "eval") (word "echo") (word "'$((/bin/sh + 0))'"))
(command (word "trap") (word "-p") (word "NOSIG"))
(command (word "trap") (word "-p") (word "-s") (word "NOSIG"))
(command (word "return") (word "2"))
(for (word "z") (in (word "1") (word "2") (word "3")) (semi (command (word "break") (word "0")) (command (word "echo") (word "$x"))))
(for (word "z") (in (word "1") (word "2") (word "3")) (semi (command (word "continue") (word "0")) (command (word "echo") (word "$x"))))
(command (word "builtin") (word "-x"))
(command (word "builtin") (word "bash"))
(command (word "bg"))
(command (word "fg"))
(command (word "kill"))
(command (word "kill") (word "-s"))
(command (word "kill") (word "-S"))
(command (word "kill") (word "-INT") (word "''"))
(command (word "kill") (word "-INT"))
(command (word "kill") (word "-l") (word "SIGBAD"))
(command (word "kill") (word "-l") (word "BAD"))
(command (word "kill") (word "-HUP") (word "@12"))
(command (word "unset") (word "-v") (word "BASH_LINENO") (word "BASH_SOURCE"))
(command (word "set") (word "-o") (word "trackall"))
(command (word "set") (word "-q"))
(command (word "set") (word "-i"))
(command (word "readonly") (word "xx=5"))
(command (word "echo") (word "$((xx=5))"))
(command (word "echo") (word "$?"))
(command (word "${THIS_SH}") (word "./errors1.sub"))
(command (word "${THIS_SH}") (word "./errors2.sub"))
(command (word "${THIS_SH}") (word "./errors3.sub"))
(command (word "${THIS_SH}") (word "./errors4.sub"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "./errors4.sub"))
(command (word "${THIS_SH}") (word "./errors5.sub"))
(command (word "${THIS_SH}") (word "./errors6.sub"))
(command (word "THIS_SH=\"${THIS_SH} -o posix\"") (word "${THIS_SH}") (word "./errors6.sub"))
(command (word "${THIS_SH}") (word "./errors7.sub"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "./errors7.sub"))
(command (word "${THIS_SH}") (word "./errors8.sub"))
(command (word "${THIS_SH}") (word "./errors9.sub"))
(command (word "${THIS_SH}") (word "./errors10.sub"))
(command (word "${THIS_SH}") (word "./errors11.sub"))
(command (word "${THIS_SH}") (word "./errors12.sub"))
(command (word "${THIS_SH}") (word "-c") (word "'return ; echo after return'") (word "bash"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'return ; echo after return'") (word "bash"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'readonly a=a ; unset -v a; echo after unset 1'") (word "sh"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'unset -v a-b; echo after unset 2'") (word "sh"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'. /nosuchfile ; echo after source'") (word "sh"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'trap \"echo bad\" SIGNOSIG; echo after trap'") (word "sh"))
(command (word "set") (word "-o") (word "posix"))
(function "!!" (brace-group (command (word "fc") (word "-s") (word "\"$@\""))))
(command (word "set") (word "+o") (word "posix"))
(command (word "echo") (word "end"))
(command (word "--------------------------------------------------------------------------------"))
---

=== exp
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# A suite of tests for bash word expansions
#
# This tests parameter and variable expansion, with an empahsis on
# proper quoting behavior.
#
# Chet Ramey

#
# If you comment out the body of this function, you can do a diff against
# `expansion-tests.right' to see if the shell is behaving correctly
#
expect()
{
	echo expect "$@"
}

# Test the substitution quoting characters (CTLESC and CTLNUL) in different
# combinations

expect "<^A>"
recho `echo ''`
expect "<^A>"
recho `echo ""`
expect "<^?>"
recho `echo ''`
expect "<^?>"
recho `echo ""`
expect "<^A>"
recho `echo `
expect "<^?>"
recho `echo `

expect "bar"
recho ${foo:-"`echo bar`"}
expect "<^A>"
recho ${foo:-"`echo `"}
expect "<^?>"
recho ${foo:-"`echo `"}

expect "<^A>"
recho "`echo `"
expect "<^?>"
recho "`echo `"

# Test null strings without variable expansion
expect "<abcdefgh>"
recho abcd""efgh
expect "<abcdefgh>"
recho abcd''efgh
expect "<abcdefgh>"
recho ""abcdefgh
expect "<abcdefgh>"
recho ''abcdefgh
expect "<abcd>"
recho abcd""
expect "<abcd>"
recho abcd''

# Test the quirky behavior of $@ in ""
expect nothing
recho "$@"
expect "< >"
recho " $@"
expect "<-->"
recho "-${@}-"

# Test null strings with variable expansion that fails
expect '<>'
recho $xxx""
expect '<>'
recho ""$xxx
expect '<>'
recho $xxx''
expect '<>'
recho ''$xxx
expect '<>'
recho $xxx""$yyy
expect '<>'
recho $xxx''$yyy

# Test null strings with variable expansion that succeeds
xxx=abc
yyy=def

expect '<abc>'
recho $xxx""
expect '<abc>'
recho ""$xxx
expect '<abc>'
recho $xxx''
expect '<abc>'
recho ''$xxx
expect '<abcdef>'
recho $xxx""$yyy
expect '<abcdef>'
recho $xxx''$yyy

unset xxx yyy

# Test the unquoted special quoting characters
expect "<^A>"
recho 
expect "<^?>"
recho 
expect "<^A>"
recho ""
expect "<^?>"
recho ""
expect "<^A>"
recho ''
expect "<^?>"
recho ''

# Test expansion of a variable that is unset
expect nothing
recho $xxx
expect '<>'
recho "$xxx"

expect nothing
recho "$xxx${@}"

# Test empty string expansion
expect '<>'
recho ""
expect '<>'
recho ''

# Test command substitution with (disabled) history substitution
expect '<Hello World!>'
# set +H
recho "`echo \"Hello world!\"`"

# Test some shell special characters
expect '<`>'
recho "\`"
expect '<">'
recho "\""
expect '<\^A>'
recho "\"

expect '<\$>'
recho "\\$"

expect '<\\>'
recho "\\\\"

# This should give argv[1] = a argv[2] = b
expect '<a> <b>'
FOO=`echo 'a b' | tr ' ' '\012'`
recho $FOO

# This should give argv[1] = ^A argv[2] = ^?
expect '<^A> <^?>'
FOO=`echo ' ' | tr ' ' '\012'`
recho $FOO

# Test quoted and unquoted globbing characters
expect '<**>'
recho "*"*

expect '<\.\./*/>'
recho "\.\./*/"

# Test patterns that come up when the shell quotes funny character
# combinations
expect '<^A^?^A^?>'
recho ''
expect '<^A^A>'
recho ''
expect '<^A^?>'
recho ''
expect '<^A^A^?>'
recho ''

# More tests of "$@"
set abc def ghi jkl
expect '<  abc> <def> <ghi> <jkl  >'
recho "  $@  "
expect '<  abc> <def> <ghi> <jkl  >'
recho "${1+  $@  }"

set abc def ghi jkl
expect '<--abc> <def> <ghi> <jkl-->'
recho "--$@--"

set "a b" cd ef gh
expect '<a b> <cd> <ef> <gh>'
recho ${1+"$@"}
expect '<a b> <cd> <ef> <gh>'
recho ${foo:-"$@"}
expect '<a b> <cd> <ef> <gh>'
recho "${@}"

expect '<  >'
recho "  "
expect '< - >'
recho " - "

# Test combinations of different types of quoting in a fully-quoted string
# (so the WHOLLY_QUOTED tests fail and it doesn't get set)
expect '</^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/>'
recho "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/"

# Test the various Posix parameter expansions

expect '<foo bar>'
recho "${x:-$(echo "foo bar")}"
expect '<foo> <bar>'
recho ${x:-$(echo "foo bar")}

unset X
expect '<abc>'
recho ${X:=abc}
expect '<abc>'
recho $X

set a b c
expect '<posix>'
recho ${3:+posix}

POSIX=/usr/posix
expect '<10>'
recho ${#POSIX}

# this was a problem through bash-5.2 -- it would skip random numbers because
# of multiple calls to find_variable
RANDOM=42
expect '<5>'
recho ${#RANDOM}	# 17772
declare -i RANDOM=42
expect '<5>'
recho ${#RANDOM}	# 17772

# remove shortest trailing match
x=file.c
expect '<file.o>'
recho ${x%.c}.o

# remove longest trailing match
x=posix/src/std
expect '<posix>'
recho ${x%%/*}

# remove shortest leading pattern
x=$HOME/src/cmd
expect '</src/cmd>'
recho ${x#$HOME}

# remove longest leading pattern
x=/one/two/three
expect '<three>'
recho ${x##*/}

# pattern removal of patterns that don't match
z=abcdef

expect '<abcdef>'
recho ${z#xyz}
expect '<abcdef>'
recho ${z##xyz}

expect '<abcdef>'
recho ${z%xyz}
expect '<abcdef>'
recho ${z%%xyz}

# Command substitution and the quirky differences between `` and $()

expect '<\$x>'
recho '\$x'

expect '<$x>'
recho `echo '\$x'`

expect '<\$x>'
recho $(echo '\$x')

# The difference between $* "$*" and "$@"

set "abc" "def ghi" "jkl"

expect '<abc> <def> <ghi> <jkl>'
recho $*

expect '<abc def ghi jkl>'
recho "$*"

OIFS="$IFS"
IFS=":$IFS"

# The special behavior of "$*", using the first character of $IFS as separator
expect '<abc:def ghi:jkl>'
recho "$*"

IFS="$OIFS"

expect '<abc> <def ghi> <jkl>'
recho "$@"

expect '<xxabc> <def ghi> <jklyy>'
recho "xx$@yy"

expect '<abc> <def ghi> <jklabc> <def ghi> <jkl>'
recho "$@$@"

foo=abc
bar=def

expect '<abcdef>'
recho "$foo""$bar"

unset foo
set $foo bar '' xyz "$foo" abc

expect '<bar> <> <xyz> <> <abc>'
recho "$@"

# More tests of quoting and deferred evaluation

foo=10 x=foo
y='$'$x
expect '<$foo>'
recho $y
eval y='$'$x
expect '<10>'
recho $y

# case statements

NL='
'
x='ab
cd'

expect '<newline expected>'
case "$x" in
*$NL*)	recho "newline expected" ;;
esac

expect '<got it>'
case \? in
*"?"*) recho "got it" ;;
esac

expect '<got it>'
case \? in
*\?*) recho "got it" ;;
esac

set one two three four five
expect '<one> <three> <five>'
recho $1 $3 ${5} $8 ${9}

# length tests on positional parameters and some special parameters

expect '<5> <5>'
recho $# ${#}
expect '<3>'
recho ${#1}
expect '<1>'
recho ${##}
expect '<1>'
recho ${#?}
expect '<5>'
recho ${#@}
expect '<5>'
recho ${#*}
expect '<5>'
recho "${#@}"
expect '<5>'
recho "${#*}"

expect '<42>'
recho $((28 + 14))
expect '<26>'
recho $[ 13 * 2 ]

expect '<\>'
recho `echo \\\\`

expect '<~>'
recho '~'

expect nothing
recho $!
expect nothing
recho ${!}

# test word splitting of assignment statements not preceding a command
a="a b c d e"
declare b=$a
expect '<a> <b> <c> <d> <e>'
recho $b

a="a?b?c"

echo ${a//\\?/ }

echo ${a//\?/ }

${THIS_SH} -c 'var=a:b: ; IFS=" :" ; recho $var""' bash

${THIS_SH} ./exp1.sub

${THIS_SH} ./exp2.sub

${THIS_SH} ./exp3.sub

${THIS_SH} ./exp4.sub

${THIS_SH} ./exp5.sub

${THIS_SH} ./exp6.sub
${THIS_SH} ./exp7.sub
${THIS_SH} ./exp8.sub
${THIS_SH} ./exp9.sub
${THIS_SH} ./exp10.sub
${THIS_SH} ./exp11.sub
${THIS_SH} ./exp12.sub
${THIS_SH} ./exp13.sub

--------------------------------------------------------------------------------
---
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "`echo ''`"))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "`echo \"\"`"))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "`echo ''`"))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "`echo \"\"`"))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "`echo `"))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "`echo `"))
(command (word "expect") (word "\"bar\""))
(command (word "recho") (word "${foo:-\"`echo bar`\"}"))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "${foo:-\"`echo `\"}"))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "${foo:-\"`echo `\"}"))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "\"`echo `\""))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "\"`echo `\""))
(command (word "expect") (word "\"<abcdefgh>\""))
(command (word "recho") (word "abcd\"\"efgh"))
(command (word "expect") (word "\"<abcdefgh>\""))
(command (word "recho") (word "abcd''efgh"))
(command (word "expect") (word "\"<abcdefgh>\""))
(command (word "recho") (word "\"\"abcdefgh"))
(command (word "expect") (word "\"<abcdefgh>\""))
(command (word "recho") (word "''abcdefgh"))
(command (word "expect") (word "\"<abcd>\""))
(command (word "recho") (word "abcd\"\""))
(command (word "expect") (word "\"<abcd>\""))
(command (word "recho") (word "abcd''"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "\"$@\""))
(command (word "expect") (word "\"< >\""))
(command (word "recho") (word "\" $@\""))
(command (word "expect") (word "\"<-->\""))
(command (word "recho") (word "\"-${@}-\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx\"\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"\"$xxx"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx''"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "''$xxx"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx\"\"$yyy"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx''$yyy"))
(command (word "xxx=abc"))
(command (word "yyy=def"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "$xxx\"\""))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "\"\"$xxx"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "$xxx''"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "''$xxx"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "$xxx\"\"$yyy"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "$xxx''$yyy"))
(command (word "unset") (word "xxx") (word "yyy"))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word ""))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word ""))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "\"\""))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "\"\""))
(command (word "expect") (word "\"<^A>\""))
(command (word "recho") (word "''"))
(command (word "expect") (word "\"<^?>\""))
(command (word "recho") (word "''"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$xxx"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"$xxx\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "\"$xxx${@}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "''"))
(command (word "expect") (word "'<Hello World!>'"))
(command (word "recho") (word "\"`echo \\\"Hello world!\\\"`\""))
(command (word "expect") (word "'<`>'"))
(command (word "recho") (word "\"\\`\""))
(command (word "expect") (word "'<\">'"))
(command (word "recho") (word "\"\\\"\""))
(command (word "expect") (word "'<\\^A>'"))
(command (word "recho") (word "\"\\\""))
(command (word "expect") (word "'<\\$>'"))
(command (word "recho") (word "\"\\\\$\""))
(command (word "expect") (word "'<\\\\>'"))
(command (word "recho") (word "\"\\\\\\\\\""))
(command (word "expect") (word "'<a> <b>'"))
(command (word "FOO=`echo 'a b' | tr ' ' '\\012'`"))
(command (word "recho") (word "$FOO"))
(command (word "expect") (word "'<^A> <^?>'"))
(command (word "FOO=`echo ' ' | tr ' ' '\\012'`"))
(command (word "recho") (word "$FOO"))
(command (word "expect") (word "'<**>'"))
(command (word "recho") (word "\"*\"*"))
(command (word "expect") (word "'<\\.\\./*/>'"))
(command (word "recho") (word "\"\\.\\./*/\""))
(command (word "expect") (word "'<^A^?^A^?>'"))
(command (word "recho") (word "''"))
(command (word "expect") (word "'<^A^A>'"))
(command (word "recho") (word "''"))
(command (word "expect") (word "'<^A^?>'"))
(command (word "recho") (word "''"))
(command (word "expect") (word "'<^A^A^?>'"))
(command (word "recho") (word "''"))
(command (word "set") (word "abc") (word "def") (word "ghi") (word "jkl"))
(command (word "expect") (word "'<  abc> <def> <ghi> <jkl  >'"))
(command (word "recho") (word "\"  $@  \""))
(command (word "expect") (word "'<  abc> <def> <ghi> <jkl  >'"))
(command (word "recho") (word "\"${1+  $@  }\""))
(command (word "set") (word "abc") (word "def") (word "ghi") (word "jkl"))
(command (word "expect") (word "'<--abc> <def> <ghi> <jkl-->'"))
(command (word "recho") (word "\"--$@--\""))
(command (word "set") (word "\"a b\"") (word "cd") (word "ef") (word "gh"))
(command (word "expect") (word "'<a b> <cd> <ef> <gh>'"))
(command (word "recho") (word "${1+\"$@\"}"))
(command (word "expect") (word "'<a b> <cd> <ef> <gh>'"))
(command (word "recho") (word "${foo:-\"$@\"}"))
(command (word "expect") (word "'<a b> <cd> <ef> <gh>'"))
(command (word "recho") (word "\"${@}\""))
(command (word "expect") (word "'<  >'"))
(command (word "recho") (word "\"  \""))
(command (word "expect") (word "'< - >'"))
(command (word "recho") (word "\" - \""))
(command (word "expect") (word "'</^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/>'"))
(command (word "recho") (word "\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*\"'$'\"/\\1/\""))
(command (word "expect") (word "'<foo bar>'"))
(command (word "recho") (word "\"${x:-$(echo \"foo bar\")}\""))
(command (word "expect") (word "'<foo> <bar>'"))
(command (word "recho") (word "${x:-$(echo \"foo bar\")}"))
(command (word "unset") (word "X"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "${X:=abc}"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "$X"))
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "expect") (word "'<posix>'"))
(command (word "recho") (word "${3:+posix}"))
(command (word "POSIX=/usr/posix"))
(command (word "expect") (word "'<10>'"))
(command (word "recho") (word "${#POSIX}"))
(command (word "RANDOM=42"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#RANDOM}"))
(command (word "declare") (word "-i") (word "RANDOM=42"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#RANDOM}"))
(command (word "x=file.c"))
(command (word "expect") (word "'<file.o>'"))
(command (word "recho") (word "${x%.c}.o"))
(command (word "x=posix/src/std"))
(command (word "expect") (word "'<posix>'"))
(command (word "recho") (word "${x%%/*}"))
(command (word "x=$HOME/src/cmd"))
(command (word "expect") (word "'</src/cmd>'"))
(command (word "recho") (word "${x#$HOME}"))
(command (word "x=/one/two/three"))
(command (word "expect") (word "'<three>'"))
(command (word "recho") (word "${x##*/}"))
(command (word "z=abcdef"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${z#xyz}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${z##xyz}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${z%xyz}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${z%%xyz}"))
(command (word "expect") (word "'<\\$x>'"))
(command (word "recho") (word "'\\$x'"))
(command (word "expect") (word "'<$x>'"))
(command (word "recho") (word "`echo '\\$x'`"))
(command (word "expect") (word "'<\\$x>'"))
(command (word "recho") (word "$(echo '\\$x')"))
(command (word "set") (word "\"abc\"") (word "\"def ghi\"") (word "\"jkl\""))
(command (word "expect") (word "'<abc> <def> <ghi> <jkl>'"))
(command (word "recho") (word "$*"))
(command (word "expect") (word "'<abc def ghi jkl>'"))
(command (word "recho") (word "\"$*\""))
(command (word "OIFS=\"$IFS\""))
(command (word "IFS=\":$IFS\""))
(command (word "expect") (word "'<abc:def ghi:jkl>'"))
(command (word "recho") (word "\"$*\""))
(command (word "IFS=\"$OIFS\""))
(command (word "expect") (word "'<abc> <def ghi> <jkl>'"))
(command (word "recho") (word "\"$@\""))
(command (word "expect") (word "'<xxabc> <def ghi> <jklyy>'"))
(command (word "recho") (word "\"xx$@yy\""))
(command (word "expect") (word "'<abc> <def ghi> <jklabc> <def ghi> <jkl>'"))
(command (word "recho") (word "\"$@$@\""))
(command (word "foo=abc"))
(command (word "bar=def"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "\"$foo\"\"$bar\""))
(command (word "unset") (word "foo"))
(command (word "set") (word "$foo") (word "bar") (word "''") (word "xyz") (word "\"$foo\"") (word "abc"))
(command (word "expect") (word "'<bar> <> <xyz> <> <abc>'"))
(command (word "recho") (word "\"$@\""))
(command (word "foo=10") (word "x=foo"))
(command (word "y='$'$x"))
(command (word "expect") (word "'<$foo>'"))
(command (word "recho") (word "$y"))
(command (word "eval") (word "y='$'$x"))
(command (word "expect") (word "'<10>'"))
(command (word "recho") (word "$y"))
(command (word "NL='\n'"))
(command (word "x='ab\ncd'"))
(command (word "expect") (word "'<newline expected>'"))
(case (word "\"$x\"") (pattern ((word "*$NL*")) (command (word "recho") (word "\"newline expected\""))))
(command (word "expect") (word "'<got it>'"))
(case (word "\\?") (pattern ((word "*\"?\"*")) (command (word "recho") (word "\"got it\""))))
(command (word "expect") (word "'<got it>'"))
(case (word "\\?") (pattern ((word "*\\?*")) (command (word "recho") (word "\"got it\""))))
(command (word "set") (word "one") (word "two") (word "three") (word "four") (word "five"))
(command (word "expect") (word "'<one> <three> <five>'"))
(command (word "recho") (word "$1") (word "$3") (word "${5}") (word "$8") (word "${9}"))
(command (word "expect") (word "'<5> <5>'"))
(command (word "recho") (word "$#") (word "${#}"))
(command (word "expect") (word "'<3>'"))
(command (word "recho") (word "${#1}"))
(command (word "expect") (word "'<1>'"))
(command (word "recho") (word "${##}"))
(command (word "expect") (word "'<1>'"))
(command (word "recho") (word "${#?}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#@}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#*}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "\"${#@}\""))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "\"${#*}\""))
(command (word "expect") (word "'<42>'"))
(command (word "recho") (word "$((28 + 14))"))
(command (word "expect") (word "'<26>'"))
(command (word "recho") (word "$[ 13 * 2 ]"))
(command (word "expect") (word "'<\\>'"))
(command (word "recho") (word "`echo \\\\\\\\`"))
(command (word "expect") (word "'<~>'"))
(command (word "recho") (word "'~'"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$!"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${!}"))
(command (word "a=\"a b c d e\""))
(command (word "declare") (word "b=$a"))
(command (word "expect") (word "'<a> <b> <c> <d> <e>'"))
(command (word "recho") (word "$b"))
(command (word "a=\"a?b?c\""))
(command (word "echo") (word "${a//\\\\?/ }"))
(command (word "echo") (word "${a//\\?/ }"))
(command (word "${THIS_SH}") (word "-c") (word "'var=a:b: ; IFS=\" :\" ; recho $var\"\"'") (word "bash"))
(command (word "${THIS_SH}") (word "./exp1.sub"))
(command (word "${THIS_SH}") (word "./exp2.sub"))
(command (word "${THIS_SH}") (word "./exp3.sub"))
(command (word "${THIS_SH}") (word "./exp4.sub"))
(command (word "${THIS_SH}") (word "./exp5.sub"))
(command (word "${THIS_SH}") (word "./exp6.sub"))
(command (word "${THIS_SH}") (word "./exp7.sub"))
(command (word "${THIS_SH}") (word "./exp8.sub"))
(command (word "${THIS_SH}") (word "./exp9.sub"))
(command (word "${THIS_SH}") (word "./exp10.sub"))
(command (word "${THIS_SH}") (word "./exp11.sub"))
(command (word "${THIS_SH}") (word "./exp12.sub"))
(command (word "${THIS_SH}") (word "./exp13.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== exportfunc
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# normal operation
foo()
{
	echo exportfunc ok 1
}
export -f foo
${THIS_SH} -c foo
unset -f foo
foo-a ()
{
	echo exportfunc ok 2
}
export -f foo-a
${THIS_SH} -c 'foo-a'

# CVE-2014-6271

env -i BASH_FUNC_foo%%='() { echo cve6271 ok; } ; echo BAD' ${THIS_SH} -c foo 2>/dev/null

# CVE-2014-7169

rm -f cve7169-bad
env -i BASH_FUNC_X%%='() { (a)=>\' ${THIS_SH} -c cve7169-bad 2>/dev/null
: < cve7169-bad
rm -f cve7169-bad

echo cve7169-bad2 > $TMPDIR/bar
rm -f cve7169-bad2
eval  'X() { (a)>\' ; . ./bar 2>/dev/null
: < cve7169-bad2
rm -f cve7169-bad2 $TMPDIR/bar

# CVE-2014-7186
${THIS_SH} ./exportfunc1.sub

# CVE-2014-7187
${THIS_SH} ./exportfunc2.sub

# CVE-2014-6277
A100=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
A1000=${A100}

for (( i = 0; i < 999; i++ ))
do
	A1000+=${A100}
done

env BASH_FUNC_foo%%="() { 000(){>0;}&000(){ 0;}<<0 0" ${THIS_SH} -c foo 2>/dev/null
env BASH_FUNC_foo%%="() { 000(){>0;}&000(){ 0;}<<${A1000} 0" ${THIS_SH} -c foo 2>/dev/null
${THIS_SH} -c "f(){ x(){ _;}; x(){ _;}<<a;}" 2>/dev/null
unset A100 A1000

# CVE-2014-6278

env 'BASH_FUNC_FOO%%=() { 0;}>r[0${$(}0 {>"$(id >/dev/tty)"; }' ${THIS_SH} -c : 2>/dev/null

rm -f HELLO_WORLD
env BASH_FUNC_FOO%%='() { 0;}>r[0${$(}0 {>HELLO_WORLD; }' ${THIS_SH} -c : 2>/dev/null
: < HELLO_WORLD

env BASH_FUNC_x%%='() { _;}>_[$($())] { echo vuln;}' ${THIS_SH} -c : 2>/dev/null

env -i BASH_FUNC_x%%='() { _; } >_[${ $() }] { id; }' ${THIS_SH} -c : 2>/dev/null

env BASH_FUNC_x%%=$'() { _;}>_[$($())]\n{ echo vuln;}' ${THIS_SH} -c : 2>/dev/null
eval 'x() { _;}>_[$($())] { echo vuln;}' 2>/dev/null

# this fails looking for closing `}' now that `${ ' has syntactic meaning
eval 'foo() { _; } >_[${ $() }] ;{ echo eval ok; }'

# other tests fixed in bash43-030 concerning function name transformation
env $'BASH_FUNC_\nfoo%%=() { echo transform-1; }' ${THIS_SH} -c foo 2>/dev/null
env $'BASH_FUNC_foo\n%%=() { echo transform-2; }' ${THIS_SH} -c foo 2>/dev/null
env $'BASH_FUNC_  foo  %%=() { echo transform-3; }' ${THIS_SH} -c foo 2>/dev/null

unset -f foo
env $'BASH_FUNC_#badname%%'=$'() { :; }\nfoo () { echo transform-4; }  ' ${THIS_SH} -c 'foo' 2>/dev/null

# tests of exported names
${THIS_SH} ./exportfunc3.sub

--------------------------------------------------------------------------------
---
(function "foo" (brace-group (command (word "echo") (word "exportfunc") (word "ok") (word "1"))))
(command (word "export") (word "-f") (word "foo"))
(command (word "${THIS_SH}") (word "-c") (word "foo"))
(command (word "unset") (word "-f") (word "foo"))
(function "foo-a" (brace-group (command (word "echo") (word "exportfunc") (word "ok") (word "2"))))
(command (word "export") (word "-f") (word "foo-a"))
(command (word "${THIS_SH}") (word "-c") (word "'foo-a'"))
(command (word "env") (word "-i") (word "BASH_FUNC_foo%%='() { echo cve6271 ok; } ; echo BAD'") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "rm") (word "-f") (word "cve7169-bad"))
(command (word "env") (word "-i") (word "BASH_FUNC_X%%='() { (a)=>\\'") (word "${THIS_SH}") (word "-c") (word "cve7169-bad") (redirect ">" "/dev/null"))
(command (word ":") (redirect "<" "cve7169-bad"))
(command (word "rm") (word "-f") (word "cve7169-bad"))
(command (word "echo") (word "cve7169-bad2") (redirect ">" "$TMPDIR/bar"))
(command (word "rm") (word "-f") (word "cve7169-bad2"))
(semi (command (word "eval") (word "'X() { (a)>\\'")) (command (word ".") (word "./bar") (redirect ">" "/dev/null")))
(command (word ":") (redirect "<" "cve7169-bad2"))
(command (word "rm") (word "-f") (word "cve7169-bad2") (word "$TMPDIR/bar"))
(command (word "${THIS_SH}") (word "./exportfunc1.sub"))
(command (word "${THIS_SH}") (word "./exportfunc2.sub"))
(command (word "A100=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"))
(command (word "A1000=${A100}"))
(arith-for (init (word "i = 0")) (test (word "i < 999")) (step (word "i++ ")) (command (word "A1000+=${A100}")))
(command (word "env") (word "BASH_FUNC_foo%%=\"() { 000(){>0;}&000(){ 0;}<<0 0\"") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "env") (word "BASH_FUNC_foo%%=\"() { 000(){>0;}&000(){ 0;}<<${A1000} 0\"") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "${THIS_SH}") (word "-c") (word "\"f(){ x(){ _;}; x(){ _;}<<a;}\"") (redirect ">" "/dev/null"))
(command (word "unset") (word "A100") (word "A1000"))
(command (word "env") (word "'BASH_FUNC_FOO%%=() { 0;}>r[0${$(}0 {>\"$(id >/dev/tty)\"; }'") (word "${THIS_SH}") (word "-c") (word ":") (redirect ">" "/dev/null"))
(command (word "rm") (word "-f") (word "HELLO_WORLD"))
(command (word "env") (word "BASH_FUNC_FOO%%='() { 0;}>r[0${$(}0 {>HELLO_WORLD; }'") (word "${THIS_SH}") (word "-c") (word ":") (redirect ">" "/dev/null"))
(command (word ":") (redirect "<" "HELLO_WORLD"))
(command (word "env") (word "BASH_FUNC_x%%='() { _;}>_[$($())] { echo vuln;}'") (word "${THIS_SH}") (word "-c") (word ":") (redirect ">" "/dev/null"))
(command (word "env") (word "-i") (word "BASH_FUNC_x%%='() { _; } >_[${ $() }] { id; }'") (word "${THIS_SH}") (word "-c") (word ":") (redirect ">" "/dev/null"))
(command (word "env") (word "BASH_FUNC_x%%='() { _;}>_[$($())]\n{ echo vuln;}'") (word "${THIS_SH}") (word "-c") (word ":") (redirect ">" "/dev/null"))
(command (word "eval") (word "'x() { _;}>_[$($())] { echo vuln;}'") (redirect ">" "/dev/null"))
(command (word "eval") (word "'foo() { _; } >_[${ $() }] ;{ echo eval ok; }'"))
(command (word "env") (word "'BASH_FUNC_\nfoo%%=() { echo transform-1; }'") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "env") (word "'BASH_FUNC_foo\n%%=() { echo transform-2; }'") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "env") (word "'BASH_FUNC_  foo  %%=() { echo transform-3; }'") (word "${THIS_SH}") (word "-c") (word "foo") (redirect ">" "/dev/null"))
(command (word "unset") (word "-f") (word "foo"))
(command (word "env") (word "'BASH_FUNC_#badname%%'='() { :; }\nfoo () { echo transform-4; }  '") (word "${THIS_SH}") (word "-c") (word "'foo'") (redirect ">" "/dev/null"))
(command (word "${THIS_SH}") (word "./exportfunc3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== extglob
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# test the ksh-like extended globbing features: [!@*?+](patlist)

shopt -s extglob

expect()
{
	echo expect "$@"
}

case "/dev/udp/129.22.8.102/45" in
/dev/@(tcp|udp)/*/*)	echo ok 1;;
*)		echo bad 1;;
esac

# valid numbers
case 12 in
0|[1-9]*([0-9]))	echo ok 2;;
*)			echo bad 2;;
esac

case 12abc in
0|[1-9]*([0-9]))	echo bad 3;;
*)			echo ok 3;;
esac

case 1 in
0|[1-9]*([0-9]))	echo ok 4;;
*)			echo bad 4;;
esac

# octal numbers
case 07 in
+([0-7]))		echo ok 5;;
*)			echo bad 5;;
esac

case 0377 in
+([0-7]))		echo ok 6;;
*)			echo bad 6;;
esac

case 09 in
+([0-7]))		echo bad 7;;
*)			echo ok 7;;
esac

# stuff from korn's book
case paragraph in
para@(chute|graph))	echo ok 8;;
*)			echo bad 8;;
esac

case paramour in
para@(chute|graph))	echo bad 9;;
*)			echo ok 9;;
esac

case para991 in
para?([345]|99)1)	echo ok 10;;
*)			echo bad 10;;
esac

case para381 in
para?([345]|99)1)	echo bad 11;;
*)			echo ok 11;;
esac

case paragraph in
para*([0-9]))		echo bad 12;;
*)			echo ok 12;;
esac

case para in
para*([0-9]))		echo ok 13;;
*)			echo bad 13;;
esac

case para13829383746592 in
para*([0-9]))		echo ok 14;;
*)			echo bad 14;;
esac

case paragraph in
para*([0-9]))		echo bad 15;;
*)			echo ok 15;;
esac

case para in
para+([0-9]))		echo bad 16;;
*)			echo ok 16;;
esac

case para987346523 in
para+([0-9]))		echo ok 17;;
*)			echo bad 17;;
esac

case paragraph in
para!(*.[0-9]))		echo ok 18;;
*)			echo bad 18;;
esac

case para.38 in
para!(*.[0-9]))		echo ok 19;;
*)			echo bad 19;;
esac

case para.graph in
para!(*.[0-9]))		echo ok 20;;
*)			echo bad 20;;
esac

case para39 in
para!(*.[0-9]))		echo ok 21;;
*)			echo bad 21;;
esac

# tests derived from those in rosenblatt's korn shell book

case "" in
*(0|1|3|5|7|9))		echo ok 22;;
*)			echo bad 22;
esac

case 137577991 in
*(0|1|3|5|7|9))		echo ok 23;;
*)			echo bad 23;
esac

case 2468 in
*(0|1|3|5|7|9))		echo bad 24;;
*)			echo ok 24;
esac

case file.c in
*.c?(c))		echo ok 25;;
*)			echo bad 25;;
esac

case file.C in
*.c?(c))		echo bad 26;;
*)			echo ok 26;;
esac

case file.cc in
*.c?(c))		echo ok 27;;
*)			echo bad 27;;
esac

case file.ccc in
*.c?(c))		echo bad 28;;
*)			echo ok 28;;
esac

case parse.y in
!(*.c|*.h|Makefile.in|config*|README))	echo ok 29;;
*)			echo bad 29;;
esac

case shell.c in
!(*.c|*.h|Makefile.in|config*|README))	echo bad 30;;
*)			echo ok 30;;
esac

case Makefile in
!(*.c|*.h|Makefile.in|config*|README))	echo ok 31;;
*)			echo bad 31;;
esac

case "VMS.FILE;1" in
*\;[1-9]*([0-9]))	echo ok 32;;
*)			echo bad 32;;
esac

case "VMS.FILE;0" in
*\;[1-9]*([0-9]))	echo bad 33;;
*)			echo ok 33;;
esac
case "VMS.FILE;" in
*\;[1-9]*([0-9]))	echo bad 34;;
*)			echo ok 34;;
esac
case "VMS.FILE;139" in
*\;[1-9]*([0-9]))	echo ok 35;;
*)			echo bad 35;;
esac
case "VMS.FILE;1N" in
*\;[1-9]*([0-9]))	echo bad 36;;
*)			echo ok 36;;
esac

# tests derived from the pd-ksh test suite

MYDIR=$PWD      # save where we are

: ${TMPDIR:=/var/tmp}
TESTDIR=$TMPDIR/eglob-test-$$
mkdir $TESTDIR
builtin cd $TESTDIR || { echo $0: cannot cd to $TESTDIR >&2 ; exit 1; }
rm -rf *

touch abcx abcz bbc
expect '!([*)*'
echo !([*)*

expect '+(a|b[)*'
echo +(a|b[)*

expect '[a*(]*z'
echo [a*(]*)z

rm -f abcx abcz bbc

touch abc

expect '+()c'
echo +()c
expect '+()x'
echo +()x
expect abc
echo +(*)c
expect '+(*)x'
echo +(*)x

# extended globbing should not be performed on the output of substitutions
x='@(*)'
expect '@(*)'
echo $x

expect 'no-file+(a|b)stuff'
echo no-file+(a|b)stuff
expect 'no-file+(a*(c)|b)stuff'
echo no-file+(a*(c)|b)stuff

touch abd acd

expect 'abd acd'
echo a+(b|c)d

expect 'acd'
echo a!(@(b|B))d

expect 'abd'
echo a[b*(foo|bar)]d

# simple kleene star tests
expect no
case foo in *(a|b[)) echo yes;; *) echo no;; esac

expect yes
case foo in *(a|b[)|f*) echo yes;; *) echo no;; esac

# this doesn't work right yet; it is an incorrectly formed pattern
expect yes
case '*(a|b[)' in *(a|b[)) echo yes;; *) echo no;; esac

# check extended globbing in pattern removal -- these don't work right yet
x=abcdef

expect '1: bcdef'
echo 1: ${x#+(a|abc)}
expect '2: def'
echo 2: ${x##+(a|abc)}
expect '3: abcde'
echo 3: ${x%+(def|f)}
expect '4: abc'
echo 4: ${x%%+(f|def)}

# these work ok

expect '5: ef'
echo 5: ${x#*(a|b)cd}
expect '6: ef'
echo 6: "${x#*(a|b)cd}"
expect '7: abcdef'
echo 7: ${x#"*(a|b)cd"}

# More tests derived from a bug report concerning extended glob patterns
# following a *
builtin cd $TESTDIR || { echo $0: cannot cd to $TESTDIR >&2 ; exit 1; }
rm -rf *

touch ab abcdef abef abcfef

expect 'ab abef'
echo ab*(e|f)

expect 'abcfef abef'
echo ab?*(e|f)

expect abcdef
echo ab*d+(e|f)

expect 'ab abcdef abcfef abef'
echo ab**(e|f)

expect 'abcdef abcfef abef'
echo ab*+(e|f)

case 'abcfefg' in
ab**(e|f))	echo ok 37;;
*)		echo bad 37;;
esac

case 'abcfefg' in
ab**(e|f)g)	echo ok 38;;
*a)		echo bad 38;;
esac

case ab in
ab*+(e|f))	echo bad 39;;
*)		echo ok 39;;
esac

case abef in
ab***ef)	echo ok 40;;
*)		echo bad 40;;
esac

case abef in
ab**)		echo ok 41;;
*)		echo bad 41;;
esac

# bug in all versions up to and including bash-2.05b
case "123abc" in
*?(a)bc)	echo ok 42;;
*)		echo bad 42;;
esac

# clean up and do the next one

builtin cd /
rm -rf $TESTDIR

mkdir $TESTDIR
builtin cd $TESTDIR

LC_COLLATE=C # have to set this; it affects the sorting 
touch a.b a,b a:b a-b a\;b a\ b a_b

echo a[^[:alnum:]]b
echo a[-.,:\;\ _]b

echo a@([^[:alnum:]])b
echo a@([-.,:; _])b
echo a@([.])b
echo a@([^.])b
echo a@([^x])b
echo a+([^[:alnum:]])b

echo a@(.|[^[:alnum:]])b

builtin cd /
rm -rf $TESTDIR

x=abcdef
recho "${x#*(a|b)cd}"

TEST='a , b'
shopt -s globstar
echo ${TEST//*([[:space:]]),*([[:space:]])/,}
shopt -u globstar

# this is for the benefit of pure coverage, so it writes the pcv file
# in the right place
builtin cd "$MYDIR"

# seg fault in bash-5.2
foo=
foo=${foo/#*([.])}
unset foo

${THIS_SH} ./extglob1.sub
${THIS_SH} ./extglob1a.sub
${THIS_SH} ./extglob3.sub
${THIS_SH} ./extglob4.sub
${THIS_SH} ./extglob5.sub
${THIS_SH} ./extglob6.sub
${THIS_SH} ./extglob7.sub
${THIS_SH} ./extglob8.sub

exit 0

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "extglob"))
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(case (word "\"/dev/udp/129.22.8.102/45\"") (pattern ((word "/dev/@(tcp|udp)/*/*")) (command (word "echo") (word "ok") (word "1"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "1"))))
(case (word "12") (pattern ((word "0") (word "[1-9]*([0-9])")) (command (word "echo") (word "ok") (word "2"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "2"))))
(case (word "12abc") (pattern ((word "0") (word "[1-9]*([0-9])")) (command (word "echo") (word "bad") (word "3"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "3"))))
(case (word "1") (pattern ((word "0") (word "[1-9]*([0-9])")) (command (word "echo") (word "ok") (word "4"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "4"))))
(case (word "07") (pattern ((word "+([0-7])")) (command (word "echo") (word "ok") (word "5"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "5"))))
(case (word "0377") (pattern ((word "+([0-7])")) (command (word "echo") (word "ok") (word "6"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "6"))))
(case (word "09") (pattern ((word "+([0-7])")) (command (word "echo") (word "bad") (word "7"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "7"))))
(case (word "paragraph") (pattern ((word "para@(chute|graph)")) (command (word "echo") (word "ok") (word "8"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "8"))))
(case (word "paramour") (pattern ((word "para@(chute|graph)")) (command (word "echo") (word "bad") (word "9"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "9"))))
(case (word "para991") (pattern ((word "para?([345]|99)1")) (command (word "echo") (word "ok") (word "10"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "10"))))
(case (word "para381") (pattern ((word "para?([345]|99)1")) (command (word "echo") (word "bad") (word "11"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "11"))))
(case (word "paragraph") (pattern ((word "para*([0-9])")) (command (word "echo") (word "bad") (word "12"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "12"))))
(case (word "para") (pattern ((word "para*([0-9])")) (command (word "echo") (word "ok") (word "13"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "13"))))
(case (word "para13829383746592") (pattern ((word "para*([0-9])")) (command (word "echo") (word "ok") (word "14"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "14"))))
(case (word "paragraph") (pattern ((word "para*([0-9])")) (command (word "echo") (word "bad") (word "15"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "15"))))
(case (word "para") (pattern ((word "para+([0-9])")) (command (word "echo") (word "bad") (word "16"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "16"))))
(case (word "para987346523") (pattern ((word "para+([0-9])")) (command (word "echo") (word "ok") (word "17"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "17"))))
(case (word "paragraph") (pattern ((word "para!(*.[0-9])")) (command (word "echo") (word "ok") (word "18"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "18"))))
(case (word "para.38") (pattern ((word "para!(*.[0-9])")) (command (word "echo") (word "ok") (word "19"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "19"))))
(case (word "para.graph") (pattern ((word "para!(*.[0-9])")) (command (word "echo") (word "ok") (word "20"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "20"))))
(case (word "para39") (pattern ((word "para!(*.[0-9])")) (command (word "echo") (word "ok") (word "21"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "21"))))
(case (word "\"\"") (pattern ((word "*(0|1|3|5|7|9)")) (command (word "echo") (word "ok") (word "22"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "22"))))
(case (word "137577991") (pattern ((word "*(0|1|3|5|7|9)")) (command (word "echo") (word "ok") (word "23"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "23"))))
(case (word "2468") (pattern ((word "*(0|1|3|5|7|9)")) (command (word "echo") (word "bad") (word "24"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "24"))))
(case (word "file.c") (pattern ((word "*.c?(c)")) (command (word "echo") (word "ok") (word "25"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "25"))))
(case (word "file.C") (pattern ((word "*.c?(c)")) (command (word "echo") (word "bad") (word "26"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "26"))))
(case (word "file.cc") (pattern ((word "*.c?(c)")) (command (word "echo") (word "ok") (word "27"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "27"))))
(case (word "file.ccc") (pattern ((word "*.c?(c)")) (command (word "echo") (word "bad") (word "28"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "28"))))
(case (word "parse.y") (pattern ((word "!(*.c|*.h|Makefile.in|config*|README)")) (command (word "echo") (word "ok") (word "29"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "29"))))
(case (word "shell.c") (pattern ((word "!(*.c|*.h|Makefile.in|config*|README)")) (command (word "echo") (word "bad") (word "30"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "30"))))
(case (word "Makefile") (pattern ((word "!(*.c|*.h|Makefile.in|config*|README)")) (command (word "echo") (word "ok") (word "31"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "31"))))
(case (word "\"VMS.FILE;1\"") (pattern ((word "*\\;[1-9]*([0-9])")) (command (word "echo") (word "ok") (word "32"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "32"))))
(case (word "\"VMS.FILE;0\"") (pattern ((word "*\\;[1-9]*([0-9])")) (command (word "echo") (word "bad") (word "33"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "33"))))
(case (word "\"VMS.FILE;\"") (pattern ((word "*\\;[1-9]*([0-9])")) (command (word "echo") (word "bad") (word "34"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "34"))))
(case (word "\"VMS.FILE;139\"") (pattern ((word "*\\;[1-9]*([0-9])")) (command (word "echo") (word "ok") (word "35"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "35"))))
(case (word "\"VMS.FILE;1N\"") (pattern ((word "*\\;[1-9]*([0-9])")) (command (word "echo") (word "bad") (word "36"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "36"))))
(command (word "MYDIR=$PWD"))
(command (word ":") (word "${TMPDIR:=/var/tmp}"))
(command (word "TESTDIR=$TMPDIR/eglob-test-$$"))
(command (word "mkdir") (word "$TESTDIR"))
(or (command (word "builtin") (word "cd") (word "$TESTDIR")) (brace-group (semi (command (word "echo") (word "$0:") (word "cannot") (word "cd") (word "to") (word "$TESTDIR") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "rm") (word "-rf") (word "*"))
(command (word "touch") (word "abcx") (word "abcz") (word "bbc"))
(command (word "expect") (word "'!([*)*'"))
(command (word "echo") (word "!([*)*"))
(command (word "expect") (word "'+(a|b[)*'"))
(command (word "echo") (word "+(a|b[)*"))
(command (word "expect") (word "'[a*(]*z'"))
(command (word "echo") (word "[a*(]*)z"))
(command (word "rm") (word "-f") (word "abcx") (word "abcz") (word "bbc"))
(command (word "touch") (word "abc"))
(command (word "expect") (word "'+()c'"))
(command (word "echo") (word "+()c"))
(command (word "expect") (word "'+()x'"))
(command (word "echo") (word "+()x"))
(command (word "expect") (word "abc"))
(command (word "echo") (word "+(*)c"))
(command (word "expect") (word "'+(*)x'"))
(command (word "echo") (word "+(*)x"))
(command (word "x='@(*)'"))
(command (word "expect") (word "'@(*)'"))
(command (word "echo") (word "$x"))
(command (word "expect") (word "'no-file+(a|b)stuff'"))
(command (word "echo") (word "no-file+(a|b)stuff"))
(command (word "expect") (word "'no-file+(a*(c)|b)stuff'"))
(command (word "echo") (word "no-file+(a*(c)|b)stuff"))
(command (word "touch") (word "abd") (word "acd"))
(command (word "expect") (word "'abd acd'"))
(command (word "echo") (word "a+(b|c)d"))
(command (word "expect") (word "'acd'"))
(command (word "echo") (word "a!(@(b|B))d"))
(command (word "expect") (word "'abd'"))
(command (word "echo") (word "a[b*(foo|bar)]d"))
(command (word "expect") (word "no"))
(case (word "foo") (pattern ((word "*(a|b[)")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(command (word "expect") (word "yes"))
(case (word "foo") (pattern ((word "*(a|b[)") (word "f*")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(command (word "expect") (word "yes"))
(case (word "'*(a|b[)'") (pattern ((word "*(a|b[)")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
(command (word "x=abcdef"))
(command (word "expect") (word "'1: bcdef'"))
(command (word "echo") (word "1:") (word "${x#+(a|abc)}"))
(command (word "expect") (word "'2: def'"))
(command (word "echo") (word "2:") (word "${x##+(a|abc)}"))
(command (word "expect") (word "'3: abcde'"))
(command (word "echo") (word "3:") (word "${x%+(def|f)}"))
(command (word "expect") (word "'4: abc'"))
(command (word "echo") (word "4:") (word "${x%%+(f|def)}"))
(command (word "expect") (word "'5: ef'"))
(command (word "echo") (word "5:") (word "${x#*(a|b)cd}"))
(command (word "expect") (word "'6: ef'"))
(command (word "echo") (word "6:") (word "\"${x#*(a|b)cd}\""))
(command (word "expect") (word "'7: abcdef'"))
(command (word "echo") (word "7:") (word "${x#\"*(a|b)cd\"}"))
(or (command (word "builtin") (word "cd") (word "$TESTDIR")) (brace-group (semi (command (word "echo") (word "$0:") (word "cannot") (word "cd") (word "to") (word "$TESTDIR") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "rm") (word "-rf") (word "*"))
(command (word "touch") (word "ab") (word "abcdef") (word "abef") (word "abcfef"))
(command (word "expect") (word "'ab abef'"))
(command (word "echo") (word "ab*(e|f)"))
(command (word "expect") (word "'abcfef abef'"))
(command (word "echo") (word "ab?*(e|f)"))
(command (word "expect") (word "abcdef"))
(command (word "echo") (word "ab*d+(e|f)"))
(command (word "expect") (word "'ab abcdef abcfef abef'"))
(command (word "echo") (word "ab**(e|f)"))
(command (word "expect") (word "'abcdef abcfef abef'"))
(command (word "echo") (word "ab*+(e|f)"))
(case (word "'abcfefg'") (pattern ((word "ab**(e|f)")) (command (word "echo") (word "ok") (word "37"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "37"))))
(case (word "'abcfefg'") (pattern ((word "ab**(e|f)g")) (command (word "echo") (word "ok") (word "38"))) (pattern ((word "*a")) (command (word "echo") (word "bad") (word "38"))))
(case (word "ab") (pattern ((word "ab*+(e|f)")) (command (word "echo") (word "bad") (word "39"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "39"))))
(case (word "abef") (pattern ((word "ab***ef")) (command (word "echo") (word "ok") (word "40"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "40"))))
(case (word "abef") (pattern ((word "ab**")) (command (word "echo") (word "ok") (word "41"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "41"))))
(case (word "\"123abc\"") (pattern ((word "*?(a)bc")) (command (word "echo") (word "ok") (word "42"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "42"))))
(command (word "builtin") (word "cd") (word "/"))
(command (word "rm") (word "-rf") (word "$TESTDIR"))
(command (word "mkdir") (word "$TESTDIR"))
(command (word "builtin") (word "cd") (word "$TESTDIR"))
(command (word "LC_COLLATE=C"))
(command (word "touch") (word "a.b") (word "a,b") (word "a:b") (word "a-b") (word "a\\;b") (word "a\\ b") (word "a_b"))
(command (word "echo") (word "a[^[:alnum:]]b"))
(command (word "echo") (word "a[-.,:\\;\\ _]b"))
(command (word "echo") (word "a@([^[:alnum:]])b"))
(command (word "echo") (word "a@([-.,:; _])b"))
(command (word "echo") (word "a@([.])b"))
(command (word "echo") (word "a@([^.])b"))
(command (word "echo") (word "a@([^x])b"))
(command (word "echo") (word "a+([^[:alnum:]])b"))
(command (word "echo") (word "a@(.|[^[:alnum:]])b"))
(command (word "builtin") (word "cd") (word "/"))
(command (word "rm") (word "-rf") (word "$TESTDIR"))
(command (word "x=abcdef"))
(command (word "recho") (word "\"${x#*(a|b)cd}\""))
(command (word "TEST='a , b'"))
(command (word "shopt") (word "-s") (word "globstar"))
(command (word "echo") (word "${TEST//*([[:space:]]),*([[:space:]])/,}"))
(command (word "shopt") (word "-u") (word "globstar"))
(command (word "builtin") (word "cd") (word "\"$MYDIR\""))
(command (word "foo="))
(command (word "foo=${foo/#*([.])}"))
(command (word "unset") (word "foo"))
(command (word "${THIS_SH}") (word "./extglob1.sub"))
(command (word "${THIS_SH}") (word "./extglob1a.sub"))
(command (word "${THIS_SH}") (word "./extglob3.sub"))
(command (word "${THIS_SH}") (word "./extglob4.sub"))
(command (word "${THIS_SH}") (word "./extglob5.sub"))
(command (word "${THIS_SH}") (word "./extglob6.sub"))
(command (word "${THIS_SH}") (word "./extglob7.sub"))
(command (word "${THIS_SH}") (word "./extglob8.sub"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== extglob2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# More ksh-like extended globbing tests, cribbed from zsh-3.1.5
#
shopt -s extglob

failed=0
while read res str pat; do
  [[ $res = '#' ]] && continue
  [[ $str = ${pat} ]]
  ts=$?
  [[ $1 = -q ]] || echo "$ts:  [[ $str = $pat ]]"
  if [[ ( $ts -gt 0 && $res = t) || ($ts -eq 0 && $res = f) ]]; then
    echo "Test failed:  [[ $str = $pat ]]"
    (( failed += 1 ))
  fi
done <<EOT
t fofo                *(f*(o))
t ffo                 *(f*(o))
t foooofo             *(f*(o))
t foooofof            *(f*(o))
t fooofoofofooo       *(f*(o))
f foooofof            *(f+(o))
f xfoooofof           *(f*(o))
f foooofofx           *(f*(o))
t ofxoofxo            *(*(of*(o)x)o)
f ofooofoofofooo      *(f*(o))
t foooxfooxfoxfooox   *(f*(o)x)
f foooxfooxofoxfooox  *(f*(o)x)
t foooxfooxfxfooox    *(f*(o)x)
t ofxoofxo            *(*(of*(o)x)o)
t ofoooxoofxo         *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxo            *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxoo           *(*(of*(o)x)o)
f ofoooxoofxoofoooxoofxofo          *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxooofxofxo    *(*(of*(o)x)o)
t aac    *(@(a))a@(c)
t ac     *(@(a))a@(c)
f c      *(@(a))a@(c)
t aaac   *(@(a))a@(c)
f baaac  *(@(a))a@(c)
t abcd   ?@(a|b)*@(c)d
t abcd   @(ab|a*@(b))*(c)d
t acd    @(ab|a*(b))*(c)d
t abbcd  @(ab|a*(b))*(c)d
t effgz  @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t efgz   @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t egz    @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t egzefffgzbcdij    *(b+(c)d|e*(f)g?|?(h)i@(j|k))
f egz    @(b+(c)d|e+(f)g?|?(h)i@(j|k))
t ofoofo *(of+(o))
t oxfoxoxfox    *(oxf+(ox))
f oxfoxfox      *(oxf+(ox))
t ofoofo        *(of+(o)|f)
# The following is supposed to match only as fo+ofo+ofo
t foofoofo      @(foo|f|fo)*(f|of+(o))
t oofooofo      *(of|oof+(o))
t fffooofoooooffoofffooofff      *(*(f)*(o))
# The following tests backtracking in alternation matches
t fofoofoofofoo *(fo|foo)
# Exclusion
t foo           !(x)
t foo           !(x)*
f foo           !(foo)
t foo           !(foo)*
t foobar        !(foo)
t foobar        !(foo)*
t moo.cow       !(*.*).!(*.*)
f mad.moo.cow   !(*.*).!(*.*)
f mucca.pazza   mu!(*(c))?.pa!(*(z))?
t fff           !(f)
t fff           *(!(f))
t fff           +(!(f))
t ooo           !(f)
t ooo           *(!(f))
t ooo           +(!(f))
t foo           !(f)
t foo           *(!(f))
t foo           +(!(f))
f f             !(f)
f f             *(!(f))
f f             +(!(f))
t foot          @(!(z*)|*x)
f zoot          @(!(z*)|*x)
t foox          @(!(z*)|*x)
t zoox          @(!(z*)|*x)
t foo           *(!(foo))
f foob          !(foo)b*
t foobb         !(foo)b*
EOT
echo "$failed tests failed."

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "failed=0"))
(while (command (word "read") (word "res") (word "str") (word "pat")) (semi (semi (semi (semi (and (cond (cond-binary "=" (cond-term "$res") (cond-term "'#'"))) (command (word "continue"))) (cond (cond-binary "=" (cond-term "$str") (cond-term "${pat}")))) (command (word "ts=$?"))) (or (cond (cond-binary "=" (cond-term "$1") (cond-term "-q"))) (command (word "echo") (word "\"$ts:  [[ $str = $pat ]]\"")))) (if (cond (cond-or (cond-expr (cond-and (cond-binary "-gt" (cond-term "$ts") (cond-term "0")) (cond-binary "=" (cond-term "$res") (cond-term "t")))) (cond-expr (cond-and (cond-binary "-eq" (cond-term "$ts") (cond-term "0")) (cond-binary "=" (cond-term "$res") (cond-term "f")))))) (semi (command (word "echo") (word "\"Test failed:  [[ $str = $pat ]]\"")) (arith (word " failed += 1 ")))))) (redirect "<<" "t fofo                *(f*(o))
t ffo                 *(f*(o))
t foooofo             *(f*(o))
t foooofof            *(f*(o))
t fooofoofofooo       *(f*(o))
f foooofof            *(f+(o))
f xfoooofof           *(f*(o))
f foooofofx           *(f*(o))
t ofxoofxo            *(*(of*(o)x)o)
f ofooofoofofooo      *(f*(o))
t foooxfooxfoxfooox   *(f*(o)x)
f foooxfooxofoxfooox  *(f*(o)x)
t foooxfooxfxfooox    *(f*(o)x)
t ofxoofxo            *(*(of*(o)x)o)
t ofoooxoofxo         *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxo            *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxoo           *(*(of*(o)x)o)
f ofoooxoofxoofoooxoofxofo          *(*(of*(o)x)o)
t ofoooxoofxoofoooxoofxooofxofxo    *(*(of*(o)x)o)
t aac    *(@(a))a@(c)
t ac     *(@(a))a@(c)
f c      *(@(a))a@(c)
t aaac   *(@(a))a@(c)
f baaac  *(@(a))a@(c)
t abcd   ?@(a|b)*@(c)d
t abcd   @(ab|a*@(b))*(c)d
t acd    @(ab|a*(b))*(c)d
t abbcd  @(ab|a*(b))*(c)d
t effgz  @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t efgz   @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t egz    @(b+(c)d|e*(f)g?|?(h)i@(j|k))
t egzefffgzbcdij    *(b+(c)d|e*(f)g?|?(h)i@(j|k))
f egz    @(b+(c)d|e+(f)g?|?(h)i@(j|k))
t ofoofo *(of+(o))
t oxfoxoxfox    *(oxf+(ox))
f oxfoxfox      *(oxf+(ox))
t ofoofo        *(of+(o)|f)
# The following is supposed to match only as fo+ofo+ofo
t foofoofo      @(foo|f|fo)*(f|of+(o))
t oofooofo      *(of|oof+(o))
t fffooofoooooffoofffooofff      *(*(f)*(o))
# The following tests backtracking in alternation matches
t fofoofoofofoo *(fo|foo)
# Exclusion
t foo           !(x)
t foo           !(x)*
f foo           !(foo)
t foo           !(foo)*
t foobar        !(foo)
t foobar        !(foo)*
t moo.cow       !(*.*).!(*.*)
f mad.moo.cow   !(*.*).!(*.*)
f mucca.pazza   mu!(*(c))?.pa!(*(z))?
t fff           !(f)
t fff           *(!(f))
t fff           +(!(f))
t ooo           !(f)
t ooo           *(!(f))
t ooo           +(!(f))
t foo           !(f)
t foo           *(!(f))
t foo           +(!(f))
f f             !(f)
f f             *(!(f))
f f             +(!(f))
t foot          @(!(z*)|*x)
f zoot          @(!(z*)|*x)
t foox          @(!(z*)|*x)
t zoox          @(!(z*)|*x)
t foo           *(!(foo))
f foob          !(foo)b*
t foobb         !(foo)b*
")
(command (word "echo") (word "\"$failed tests failed.\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== extglob3
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
shopt -s extglob

[[ ab/../ == @(ab|+([^/]))/..?(/) ]] && echo match 1

[[ ab/../ == +([^/])/..?(/) ]] && echo match 2

[[ ab/../ == @(ab|?b)/..?(/) ]] && echo match 3

[[ ab/../ == +([^/])/../ ]] && echo match 4

[[ ab/../ == +([!/])/..?(/) ]] && echo match 1a

[[ ab/../ == @(ab|+([!/]))/..?(/) ]] && echo match 1b

[[ ab/../ == +([!/])/../ ]] && echo match 2a

[[ ab/../ == +([!/])/..?(/) ]] && echo match 2b

[[ ab/../ == +([!/])/..@(/) ]] && echo match 3a

[[ ab/../ == +(ab)/..?(/) ]] && echo match 3b

[[ ab/../ == [!/][!/]/../ ]] && echo match 4a

[[ ab/../ == @(ab|?b)/..?(/) ]] && echo match 4b

[[ ab/../ == [^/][^/]/../ ]] && echo match 5

[[ ab/../ == ?b/..?(/) ]] && echo match 6

[[ ab/../ == +(?b)/..?(/) ]] && echo match 7

[[ ab/../ == +(?b|?b)/..?(/) ]] && echo match 8

[[ ab/../ == @(?b|?b)/..?(/) ]] && echo match 9

[[ ab/../ == @(a?|?b)/..?(/) ]] && echo match 10

[[ ab/../ == ?(ab)/..?(/) ]] && echo match 11

[[ ab/../ == ?(ab|??)/..?(/) ]] && echo match 12

[[ ab/../ == @(??)/..?(/) ]] && echo match 13

[[ ab/../ == @(??|a*)/..?(/) ]] && echo match 14

[[ ab/../ == @(a*)/..?(/) ]] && echo match 15

[[ ab/../ == +(??)/..?(/) ]] && echo match 16

[[ ab/../ == +(??|a*)/..?(/) ]] && echo match 17

[[ ab/../ == +(a*)/..?(/) ]] && echo match 18

#
j="@(x)" ; [[ x == $j ]] && echo ok 19

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-s") (word "extglob"))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(ab|+([^/]))/..?(/)"))) (command (word "echo") (word "match") (word "1")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([^/])/..?(/)"))) (command (word "echo") (word "match") (word "2")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(ab|?b)/..?(/)"))) (command (word "echo") (word "match") (word "3")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([^/])/../"))) (command (word "echo") (word "match") (word "4")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([!/])/..?(/)"))) (command (word "echo") (word "match") (word "1a")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(ab|+([!/]))/..?(/)"))) (command (word "echo") (word "match") (word "1b")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([!/])/../"))) (command (word "echo") (word "match") (word "2a")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([!/])/..?(/)"))) (command (word "echo") (word "match") (word "2b")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+([!/])/..@(/)"))) (command (word "echo") (word "match") (word "3a")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(ab)/..?(/)"))) (command (word "echo") (word "match") (word "3b")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "[!/][!/]/../"))) (command (word "echo") (word "match") (word "4a")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(ab|?b)/..?(/)"))) (command (word "echo") (word "match") (word "4b")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "[^/][^/]/../"))) (command (word "echo") (word "match") (word "5")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "?b/..?(/)"))) (command (word "echo") (word "match") (word "6")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(?b)/..?(/)"))) (command (word "echo") (word "match") (word "7")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(?b|?b)/..?(/)"))) (command (word "echo") (word "match") (word "8")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(?b|?b)/..?(/)"))) (command (word "echo") (word "match") (word "9")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(a?|?b)/..?(/)"))) (command (word "echo") (word "match") (word "10")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "?(ab)/..?(/)"))) (command (word "echo") (word "match") (word "11")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "?(ab|??)/..?(/)"))) (command (word "echo") (word "match") (word "12")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(??)/..?(/)"))) (command (word "echo") (word "match") (word "13")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(??|a*)/..?(/)"))) (command (word "echo") (word "match") (word "14")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "@(a*)/..?(/)"))) (command (word "echo") (word "match") (word "15")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(??)/..?(/)"))) (command (word "echo") (word "match") (word "16")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(??|a*)/..?(/)"))) (command (word "echo") (word "match") (word "17")))
(and (cond (cond-binary "==" (cond-term "ab/../") (cond-term "+(a*)/..?(/)"))) (command (word "echo") (word "match") (word "18")))
(semi (command (word "j=\"@(x)\"")) (and (cond (cond-binary "==" (cond-term "x") (cond-term "$j"))) (command (word "echo") (word "ok") (word "19"))))
(command (word "--------------------------------------------------------------------------------"))
---

=== func
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# since we look at functions below, remove all functions now 
funcs=$(compgen -A function)
if [ -n "$funcs" ]; then
        unset -f $funcs
fi

a()
{
	x=$((x - 1))
	return 5
}

b()
{
	x=$((x - 1))
	a
	echo a returns $?
	return 4
}

c()
{
	x=$((x - 1))
	b
	echo b returns $?
	return 3
}

d()
{
	x=$((x - 1))
	c
	echo c returns $?
	return 2
}

e()
{
	d
	echo d returns $?
	echo in e
	x=$((x - 1))
	return $x
}

f()
{
	e
	echo e returned $?
	echo x is $x
	return 0
}

x=30
f

# make sure unsetting a local variable preserves the `local' attribute
f1()
{
	local zz
	zz=abcde
	echo $zz
	unset zz
	zz=defghi
	echo $zz
}

zz=ZZ
echo $zz
f1
echo $zz

unset -f f1
f1()
{
	return 5
}

( f1 )
echo $?

unset -f f1
f1()
{
	sleep 5
	return 5
}

f1 &
wait
echo $?

unset -f f1

f1()
{
	echo $AVAR
	printenv AVAR
}

AVAR=AVAR
echo $AVAR
f1
AVAR=foo f1
echo $AVAR

unset -f f1
# make sure subshells can do a `return' if we're executing in a function
f1()
{
	( return 5 )
	status=$?
	echo $status
	return $status
}

f1
echo $?

declare -F f1	# should print just the name
declare -f f1	# should print the definition, too

# no functions should be exported, right?
declare -xF
declare -xf

# FUNCNAME tests
func2()
{
	echo FUNCNAME = $FUNCNAME
}

func()
{
	echo before: FUNCNAME = $FUNCNAME
	func2
	echo after: FUNCNAME = $FUNCNAME
}

echo before: try to assign to FUNCNAME
FUNCNAME=7

echo outside: FUNCNAME = $FUNCNAME
func
echo outside2: FUNCNAME = $FUNCNAME

# test exported functions (and cached exportstr)
zf()
{
	echo this is zf
}
export -f zf

${THIS_SH} -c 'type -t zf'
${THIS_SH} -c 'type zf'
unset -f zf

${THIS_SH} ./func1.sub

# tests for functions whose bodies are not group commands, with and without
# attached redirections
${THIS_SH} ./func2.sub

# test for some posix-specific function behavior
${THIS_SH} ./func3.sub

# FUNCNEST testing
${THIS_SH} ./func4.sub

# function naming restrictions
${THIS_SH} ./func5.sub

unset -f myfunction
myfunction() {
    echo "bad shell function redirection"
} >> /dev/null

myfunction
myfunction | cat

segv()
{
	echo foo | return 5
}

segv
echo $?

# functions can have attributes
rfunc()
{
	local -
	local var

	local -p
}
readonly -f rfunc
readonly -f

exit 0

--------------------------------------------------------------------------------
---
(command (word "funcs=$(compgen -A function)"))
(if (command (word "[") (word "-n") (word "\"$funcs\"") (word "]")) (command (word "unset") (word "-f") (word "$funcs")))
(function "a" (brace-group (semi (command (word "x=$((x - 1))")) (command (word "return") (word "5")))))
(function "b" (brace-group (semi (semi (semi (command (word "x=$((x - 1))")) (command (word "a"))) (command (word "echo") (word "a") (word "returns") (word "$?"))) (command (word "return") (word "4")))))
(function "c" (brace-group (semi (semi (semi (command (word "x=$((x - 1))")) (command (word "b"))) (command (word "echo") (word "b") (word "returns") (word "$?"))) (command (word "return") (word "3")))))
(function "d" (brace-group (semi (semi (semi (command (word "x=$((x - 1))")) (command (word "c"))) (command (word "echo") (word "c") (word "returns") (word "$?"))) (command (word "return") (word "2")))))
(function "e" (brace-group (semi (semi (semi (semi (command (word "d")) (command (word "echo") (word "d") (word "returns") (word "$?"))) (command (word "echo") (word "in") (word "e"))) (command (word "x=$((x - 1))"))) (command (word "return") (word "$x")))))
(function "f" (brace-group (semi (semi (semi (command (word "e")) (command (word "echo") (word "e") (word "returned") (word "$?"))) (command (word "echo") (word "x") (word "is") (word "$x"))) (command (word "return") (word "0")))))
(command (word "x=30"))
(command (word "f"))
(function "f1" (brace-group (semi (semi (semi (semi (semi (command (word "local") (word "zz")) (command (word "zz=abcde"))) (command (word "echo") (word "$zz"))) (command (word "unset") (word "zz"))) (command (word "zz=defghi"))) (command (word "echo") (word "$zz")))))
(command (word "zz=ZZ"))
(command (word "echo") (word "$zz"))
(command (word "f1"))
(command (word "echo") (word "$zz"))
(command (word "unset") (word "-f") (word "f1"))
(function "f1" (brace-group (command (word "return") (word "5"))))
(subshell (command (word "f1")))
(command (word "echo") (word "$?"))
(command (word "unset") (word "-f") (word "f1"))
(function "f1" (brace-group (semi (command (word "sleep") (word "5")) (command (word "return") (word "5")))))
(background (command (word "f1")))
(command (word "wait"))
(command (word "echo") (word "$?"))
(command (word "unset") (word "-f") (word "f1"))
(function "f1" (brace-group (semi (command (word "echo") (word "$AVAR")) (command (word "printenv") (word "AVAR")))))
(command (word "AVAR=AVAR"))
(command (word "echo") (word "$AVAR"))
(command (word "f1"))
(command (word "AVAR=foo") (word "f1"))
(command (word "echo") (word "$AVAR"))
(command (word "unset") (word "-f") (word "f1"))
(function "f1" (brace-group (semi (semi (semi (subshell (command (word "return") (word "5"))) (command (word "status=$?"))) (command (word "echo") (word "$status"))) (command (word "return") (word "$status")))))
(command (word "f1"))
(command (word "echo") (word "$?"))
(command (word "declare") (word "-F") (word "f1"))
(command (word "declare") (word "-f") (word "f1"))
(command (word "declare") (word "-xF"))
(command (word "declare") (word "-xf"))
(function "func2" (brace-group (command (word "echo") (word "FUNCNAME") (word "=") (word "$FUNCNAME"))))
(function "func" (brace-group (semi (semi (command (word "echo") (word "before:") (word "FUNCNAME") (word "=") (word "$FUNCNAME")) (command (word "func2"))) (command (word "echo") (word "after:") (word "FUNCNAME") (word "=") (word "$FUNCNAME")))))
(command (word "echo") (word "before:") (word "try") (word "to") (word "assign") (word "to") (word "FUNCNAME"))
(command (word "FUNCNAME=7"))
(command (word "echo") (word "outside:") (word "FUNCNAME") (word "=") (word "$FUNCNAME"))
(command (word "func"))
(command (word "echo") (word "outside2:") (word "FUNCNAME") (word "=") (word "$FUNCNAME"))
(function "zf" (brace-group (command (word "echo") (word "this") (word "is") (word "zf"))))
(command (word "export") (word "-f") (word "zf"))
(command (word "${THIS_SH}") (word "-c") (word "'type -t zf'"))
(command (word "${THIS_SH}") (word "-c") (word "'type zf'"))
(command (word "unset") (word "-f") (word "zf"))
(command (word "${THIS_SH}") (word "./func1.sub"))
(command (word "${THIS_SH}") (word "./func2.sub"))
(command (word "${THIS_SH}") (word "./func3.sub"))
(command (word "${THIS_SH}") (word "./func4.sub"))
(command (word "${THIS_SH}") (word "./func5.sub"))
(command (word "unset") (word "-f") (word "myfunction"))
(function "myfunction" (brace-group (command (word "echo") (word "\"bad shell function redirection\""))) (redirect ">>" "/dev/null"))
(command (word "myfunction"))
(pipe (command (word "myfunction")) (command (word "cat")))
(function "segv" (brace-group (pipe (command (word "echo") (word "foo")) (command (word "return") (word "5")))))
(command (word "segv"))
(command (word "echo") (word "$?"))
(function "rfunc" (brace-group (semi (semi (command (word "local") (word "-")) (command (word "local") (word "var"))) (command (word "local") (word "-p")))))
(command (word "readonly") (word "-f") (word "rfunc"))
(command (word "readonly") (word "-f"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== getopts
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# getopts tests
# this should fail
getopts
echo $?
getopts opts
echo $?

# maybe someday we will have a ksh93-like -a argument to set the name
# used in error messages, but not yet
getopts -a opts name

${THIS_SH} ./getopts1.sub -a -b bval one two three
# make sure getopts works when there are more than 9 positional parameters
${THIS_SH} ./getopts1.sub -a -b bval one two three four five six seven eight nine ten eleven twelve
${THIS_SH} ./getopts1.sub -a -b 

${THIS_SH} ./getopts2.sub -ad -c cval three four five

${THIS_SH} ./getopts3.sub

# make sure that `-b bval' and `-bbval' are equivalent
${THIS_SH} ./getopts4.sub -a -b bval one two three
${THIS_SH} ./getopts4.sub -a -bbval one two three
# this tests `silent' error reporting
${THIS_SH} ./getopts4.sub -a -b
${THIS_SH} ./getopts4.sub -a -c

# make sure that `--' can be used to end the list of options
${THIS_SH} ./getopts4.sub -a -- -b bval one two three

${THIS_SH} ./getopts5.sub -a -c

${THIS_SH} ./getopts6.sub -a
${THIS_SH} ./getopts6.sub -a -c
${THIS_SH} ./getopts6.sub -ac
echo $? # this should be 2

${THIS_SH} ./getopts7.sub -a

${THIS_SH} ./getopts8.sub
${THIS_SH} ./getopts9.sub

${THIS_SH} ./getopts10.sub

--------------------------------------------------------------------------------
---
(command (word "getopts"))
(command (word "echo") (word "$?"))
(command (word "getopts") (word "opts"))
(command (word "echo") (word "$?"))
(command (word "getopts") (word "-a") (word "opts") (word "name"))
(command (word "${THIS_SH}") (word "./getopts1.sub") (word "-a") (word "-b") (word "bval") (word "one") (word "two") (word "three"))
(command (word "${THIS_SH}") (word "./getopts1.sub") (word "-a") (word "-b") (word "bval") (word "one") (word "two") (word "three") (word "four") (word "five") (word "six") (word "seven") (word "eight") (word "nine") (word "ten") (word "eleven") (word "twelve"))
(command (word "${THIS_SH}") (word "./getopts1.sub") (word "-a") (word "-b"))
(command (word "${THIS_SH}") (word "./getopts2.sub") (word "-ad") (word "-c") (word "cval") (word "three") (word "four") (word "five"))
(command (word "${THIS_SH}") (word "./getopts3.sub"))
(command (word "${THIS_SH}") (word "./getopts4.sub") (word "-a") (word "-b") (word "bval") (word "one") (word "two") (word "three"))
(command (word "${THIS_SH}") (word "./getopts4.sub") (word "-a") (word "-bbval") (word "one") (word "two") (word "three"))
(command (word "${THIS_SH}") (word "./getopts4.sub") (word "-a") (word "-b"))
(command (word "${THIS_SH}") (word "./getopts4.sub") (word "-a") (word "-c"))
(command (word "${THIS_SH}") (word "./getopts4.sub") (word "-a") (word "--") (word "-b") (word "bval") (word "one") (word "two") (word "three"))
(command (word "${THIS_SH}") (word "./getopts5.sub") (word "-a") (word "-c"))
(command (word "${THIS_SH}") (word "./getopts6.sub") (word "-a"))
(command (word "${THIS_SH}") (word "./getopts6.sub") (word "-a") (word "-c"))
(command (word "${THIS_SH}") (word "./getopts6.sub") (word "-ac"))
(command (word "echo") (word "$?"))
(command (word "${THIS_SH}") (word "./getopts7.sub") (word "-a"))
(command (word "${THIS_SH}") (word "./getopts8.sub"))
(command (word "${THIS_SH}") (word "./getopts9.sub"))
(command (word "${THIS_SH}") (word "./getopts10.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== glob-bracket
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# tests of various aspects of pathname expansion, mostly dealing with bracket
# expressions
#
# Derived from tests contributed by Koichi Murase <myoga.murase@gmail.com>

LC_COLLATE=C

ORIG_DIR=$PWD

: ${TMPDIR:=/tmp} ${BUILD_DIR:=$ORIG_DIR}

trap 'rm -rf $TESTDIR $WORK_DIR' EXIT

WORK_DIR=${TMPDIR}/globtest-$$

mkdir $WORK_DIR || {
	echo "glob-bracket: cannot create directory $WORK_DIR" >&2
	exit 1
}
cd $WORK_DIR || {
	echo "glob-bracket: cannot cd to directory $WORK_DIR" >&2
	exit 1
}

eval $(grep -E '^(CC |SHOBJ_).*=' $BUILD_DIR/examples/loadables/Makefile | sed -e 's/[ ]*=[ ]*/="/' -e 's/\$@/strmatch/' -e 's/$/"/' )

if [ "$SHOBJ_STATUS" != "supported" ]; then
	echo "glob-bracket: shared objects not supported, cannot continue" >&2
	exit 2
fi

# we assume gcc as a default here
: ${CC:=gcc}

cat > fnmatch.c <<-EOF
	#include <fnmatch.h>
	#include <stdlib.h>
	#include <stdio.h>

	int main(int argc, char **argv) {
	  if (2 >= argc) {
	    fprintf(stderr, "usage: fnmatch string pattern\n");
	    exit(2);
	  }

#ifdef FNM_EXTMATCH
	  int flags = FNM_PATHNAME | FNM_PERIOD | FNM_EXTMATCH;
#else
	  int flags = FNM_PATHNAME | FNM_PERIOD;
#endif
	  if (fnmatch(argv[2], argv[1], flags) == 0)
	    return 0;
	  return 1;
	}
EOF
$CC -O2 -o fnmatch fnmatch.c
rm -f fnmatch.c

if [ ! -f fnmatch ] ; then
	echo "glob-bracket: cannot create fnmatch executable" >&2
	exit 2
fi

cat > strmatch.c <<-EOF
	#define BUILTIN_ENABLED 0x01
	struct word_desc { char* word; int flags; };
	struct word_list { struct word_list* next; struct word_desc* word; };
	struct builtin {
	  const char* name;
	  int (*function)(struct word_list*);
	  int flags;
	  const char** long_doc;
	  const char* short_doc;
	  char* handle;
	};

	/*#include <glob/strmatch.h>*/
	int strmatch(char *pattern, char *string, int flags);
	#define FNM_PATHNAME    (1 << 0)
	#define FNM_NOESCAPE    (1 << 1)
	#define FNM_PERIOD      (1 << 2)
	#define FNM_LEADING_DIR (1 << 3)
	#define FNM_CASEFOLD    (1 << 4)
	#define FNM_EXTMATCH    (1 << 5)
	#define FNM_FIRSTCHAR   (1 << 6)
	#define FNM_DOTDOT      (1 << 7)

	static int strmatch_builtin(struct word_list* list) {
	  char *str, *pat;
	  if (!list || !list->word) return 2;
	  str = list->word->word;
	  if (!list->next || !list->next->word) return 2;
	  pat = list->next->word->word;

	  if (strmatch (pat, str, FNM_PATHNAME | FNM_PERIOD | FNM_EXTMATCH) == 0)
	    return 0;
	  return 1;
	}
	static const char* strmatch_doc[] = { "This is a builtin to test the behavior of strmatch", 0 };
	struct builtin strmatch_struct = { "strmatch", strmatch_builtin, BUILTIN_ENABLED, strmatch_doc, "strmatch string pattern", 0, };
EOF

${SHOBJ_CC} ${SHOBJ_CFLAGS} -c -o strmatch.o strmatch.c
rm -f strmatch.c

${SHOBJ_LD} ${SHOBJ_LDFLAGS} ${SHOBJ_XLDFLAGS} -o strmatch.so strmatch.o ${SHOBJ_LIBS}
rm -f strmatch.o

if [ ! -f strmatch.so ] ; then
	echo "glob-bracket: cannot create strmatch loadable builtin" >&2
	exit 2
fi

enable -f ./strmatch.so strmatch || {
	echo "glob-bracket: cannot load strmatch builtin" >&2
	exit 2
}
	
check_count=1

if [ -z "$BASH_TSTOUT" ]; then
	yes=$'\033[32myes\033[m' no=$'\033[31mno\033[m'
else
	yes=yes no=no
fi

function check {
  # bash impl
  if strmatch "$2" "$1"; then
    local strmatch=$yes
  else
    local strmatch=$no
  fi

  # fnmatch
  local expect=${3-}
  if [[ ! $expect ]]; then
    if $WORK_DIR/fnmatch "$2" "$1"; then
      expect=$yes
    else
      expect=$no
    fi
  fi
  printf '#%d: pat=%-20s str=%-16s %s/%s\n' "$((check_count++))" "$1" "$2" "$strmatch" "$expect"
}

function pcheck {
  local GLOBIGNORE=$1

  # bash impl
  local -a f=(*/*/efg*)
  if [[ $f == '*/*/efg*' ]]; then
    local strmatch=$yes
  else
    local strmatch=$no
  fi

  # Linux fnmatch
  local fnmatch=${2-}
  if [[ ! $fnmatch ]]; then
    if $WORK_DIR/fnmatch ab/cd/efg "$1"; then
      fnmatch=$yes
    else
      fnmatch=$no
    fi
  fi

  printf '#%d: pat=%-16s %s/%s\n' "$((check_count++))" "$1" "$strmatch" "$fnmatch"
}

TESTDIR=${TMPDIR}/pathtest-$$
TESTPATH=${TESTDIR}/ab/cd/efg
mkdir -p $TESTPATH

if [ -d "$TESTPATH" ] && cd "$TESTDIR"; then
echo '--- $GLOBIGNORE vs fnmatch(3) ---'
pcheck 'ab/cd/efg'
pcheck 'ab[/]cd/efg'
pcheck 'ab[/a]cd/efg'
pcheck 'ab[a/]cd/efg'
pcheck 'ab[!a]cd/efg'
pcheck 'ab[.-0]cd/efg'
pcheck '*/*/efg'
pcheck '*[/]*/efg'
pcheck '*[/a]*/efg'
pcheck '*[a/]*/efg'
pcheck '*[!a]*/efg'
pcheck '*[.-0]*/efg'

pcheck '*/*/efg'
pcheck '*[b]/*/efg'
pcheck '*[ab]/*/efg'
pcheck '*[ba]/*/efg'
pcheck '*[!a]/*/efg'
pcheck '*[a-c]/*/efg'

shopt -s extglob
pcheck 'ab@(/)cd/efg'	"$yes"
pcheck '*@(/)cd/efg'	"$no"
pcheck '*/cd/efg'
shopt -u extglob

cd "$WORK_DIR"
fi

echo
echo '---Tests for a slash in bracket expressions---'
check 'ab[/]ef'          'ab[/]ef'     "$yes"
check 'ab[/]ef'          'ab/ef'       "$no"
check 'ab[c/d]ef'        'ab[c/d]ef'   "$yes"
check 'ab[c/d]ef'        'abcef'       "$no"
check 'ab[.-/]ef'        'ab[.-/]ef'   "$yes"
check 'ab[.-/]ef'        'ab.ef'       "$no"
check 'ab[[=/=]]ef'      'ab[[=/=]]ef' "$yes"
check 'ab[[=/=]]ef'      'ab/ef'       "$no"
check 'ab[[=c=]/]ef'     'ab[=/]ef'    "$yes"
check 'ab[[=c=]/]ef'     'abcef'       "$no"
check 'ab[[:alpha:]/]ef' 'ab[:/]ef'    "$yes"
check 'ab[[:alpha:]/]ef' 'abxef'       "$no"
check 'ab[/[abc]]ef'     'ab[/c]ef'    "$yes"
check 'ab[/[abc]]ef'     'abc]ef'      "$no"
check 'ab[c[=/=]]ef'     'ab[c[=/=]]ef' "$yes"
check 'ab[c[=/=]]ef'     'abc[=/=]ef'   "$no"
check 'ab[c[=/=]]ef'     'abcef'        "$no"
check 'a[b\/c]'          'a[b/c]'      "$yes"
check 'a[b\/c]'          'ab'          "$no"
check 'a[b\/c]'          'ac'          "$no"

echo
echo '---Tests for incomplete bracket expressions---'
check 'ab[c'             'ab[c'         "$yes"
check 'ab[c'             'abc'          "$no"
check 'ab[c[=d='         'ab[c[=d='     "$yes"
check 'ab[c[=d='         'abc'          "$no"
check 'ab[c[.d'          'ab[c[.d'      "$yes"
check 'ab[c[.d'          'abc'          "$no"
check 'ab[c[:alpha:'     'ab[c[:alpha:' "$yes"
check 'ab[c[:alpha:'     'abc'          "$no"
check 'ab[c-'            'ab[c-'        "$yes"
check 'ab[c-'            'abc'          "$no"
check 'ab[c\'            'ab[c\'        "$yes"
check 'ab[c\'            'abc'          "$no"
check 'ab[[\'            'ab[[\'        "$yes"
check 'ab[[\'            'ab['          "$no"

echo
echo '--- PATSCAN vs BRACKMATCH ---'
check '@([[.].])A])' ']'        "$yes"
check '@([[.].])A])' '==]A])'   "$no"
check '@([[.].])A])' 'AA])'     "$no"
check '@([[=]=])A])' ']'        "$no"
check '@([[=]=])A])' '==]A])'   "$yes"
check '@([[=]=])A])' 'AA])'     "$no"

echo
echo '--- BRACKMATCH: after match vs before match ---'
check '[[=]=]ab]'    'a'     "$no"
check '[[.[=.]ab]'   'a'     "$yes"
check '[[.[==].]ab]' 'a'     "$yes"
echo
check '[a[=]=]b]'    'a'     "$no"
check '[a[.[=.]b]'   'a'     "$yes"
check '[a[.[==].]b]' 'a'     "$yes"
echo
check '[a[=]=]b]'    'b'     "$no"
check '[a[=]=]b]'    'a=]b]' "$yes"
check '[a[.[=.]b]'   'b'     "$yes"
check '[a[.[=.]b]'   'ab]'   "$no"
check '[a[.[==].]b]' 'b'     "$yes"
check '[a[.[==].]b]' 'ab]'   "$no"

echo
echo '--- incomplete POSIX brackets ---'
check 'x[a[:y]' 'x['   "$yes"
check 'x[a[:y]' 'x:'   "$yes"
check 'x[a[:y]' 'xy'   "$yes"
check 'x[a[:y]' 'x[ay' "$no"
echo                   
check 'x[a[.y]' 'x['   "$yes"
check 'x[a[.y]' 'x.'   "$yes"
check 'x[a[.y]' 'xy'   "$yes"
check 'x[a[.y]' 'x[ay' "$no"
echo                   
check 'x[a[=y]' 'x['   "$yes"
check 'x[a[=y]' 'x='   "$yes"
check 'x[a[=y]' 'xy'   "$yes"
check 'x[a[=y]' 'x[ay' "$no"

echo
echo '--- MISC tests ---'
check 'a\'               'a\'          "$yes"

cd $ORIG_DIR

enable -d strmatch	# just testing
exit 0

--------------------------------------------------------------------------------
---
(command (word "LC_COLLATE=C"))
(command (word "ORIG_DIR=$PWD"))
(command (word ":") (word "${TMPDIR:=/tmp}") (word "${BUILD_DIR:=$ORIG_DIR}"))
(command (word "trap") (word "'rm -rf $TESTDIR $WORK_DIR'") (word "EXIT"))
(command (word "WORK_DIR=${TMPDIR}/globtest-$$"))
(or (command (word "mkdir") (word "$WORK_DIR")) (brace-group (semi (command (word "echo") (word "\"glob-bracket: cannot create directory $WORK_DIR\"") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(or (command (word "cd") (word "$WORK_DIR")) (brace-group (semi (command (word "echo") (word "\"glob-bracket: cannot cd to directory $WORK_DIR\"") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "eval") (word "$(grep -E '^(CC |SHOBJ_).*=' $BUILD_DIR/examples/loadables/Makefile | sed -e 's/[ ]*=[ ]*/=\"/' -e 's/\\$@/strmatch/' -e 's/$/\"/')"))
(if (command (word "[") (word "\"$SHOBJ_STATUS\"") (word "!=") (word "\"supported\"") (word "]")) (semi (command (word "echo") (word "\"glob-bracket: shared objects not supported, cannot continue\"") (redirect ">&" 2)) (command (word "exit") (word "2"))))
(command (word ":") (word "${CC:=gcc}"))
(command (word "cat") (redirect ">" "fnmatch.c") (redirect "<<-" "#include <fnmatch.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char **argv) {
  if (2 >= argc) {
    fprintf(stderr, "usage: fnmatch string pattern\n");
    exit(2);
  }

#ifdef FNM_EXTMATCH
  int flags = FNM_PATHNAME | FNM_PERIOD | FNM_EXTMATCH;
#else
  int flags = FNM_PATHNAME | FNM_PERIOD;
#endif
  if (fnmatch(argv[2], argv[1], flags) == 0)
    return 0;
  return 1;
}
"))
(command (word "$CC") (word "-O2") (word "-o") (word "fnmatch") (word "fnmatch.c"))
(command (word "rm") (word "-f") (word "fnmatch.c"))
(if (command (word "[") (word "!") (word "-f") (word "fnmatch") (word "]")) (semi (command (word "echo") (word "\"glob-bracket: cannot create fnmatch executable\"") (redirect ">&" 2)) (command (word "exit") (word "2"))))
(command (word "cat") (redirect ">" "strmatch.c") (redirect "<<-" "#define BUILTIN_ENABLED 0x01
struct word_desc { char* word; int flags; };
struct word_list { struct word_list* next; struct word_desc* word; };
struct builtin {
  const char* name;
  int (*function)(struct word_list*);
  int flags;
  const char** long_doc;
  const char* short_doc;
  char* handle;
};

/*#include <glob/strmatch.h>*/
int strmatch(char *pattern, char *string, int flags);
#define FNM_PATHNAME    (1 << 0)
#define FNM_NOESCAPE    (1 << 1)
#define FNM_PERIOD      (1 << 2)
#define FNM_LEADING_DIR (1 << 3)
#define FNM_CASEFOLD    (1 << 4)
#define FNM_EXTMATCH    (1 << 5)
#define FNM_FIRSTCHAR   (1 << 6)
#define FNM_DOTDOT      (1 << 7)

static int strmatch_builtin(struct word_list* list) {
  char *str, *pat;
  if (!list || !list->word) return 2;
  str = list->word->word;
  if (!list->next || !list->next->word) return 2;
  pat = list->next->word->word;

  if (strmatch (pat, str, FNM_PATHNAME | FNM_PERIOD | FNM_EXTMATCH) == 0)
    return 0;
  return 1;
}
static const char* strmatch_doc[] = { "This is a builtin to test the behavior of strmatch", 0 };
struct builtin strmatch_struct = { "strmatch", strmatch_builtin, BUILTIN_ENABLED, strmatch_doc, "strmatch string pattern", 0, };
"))
(command (word "${SHOBJ_CC}") (word "${SHOBJ_CFLAGS}") (word "-c") (word "-o") (word "strmatch.o") (word "strmatch.c"))
(command (word "rm") (word "-f") (word "strmatch.c"))
(command (word "${SHOBJ_LD}") (word "${SHOBJ_LDFLAGS}") (word "${SHOBJ_XLDFLAGS}") (word "-o") (word "strmatch.so") (word "strmatch.o") (word "${SHOBJ_LIBS}"))
(command (word "rm") (word "-f") (word "strmatch.o"))
(if (command (word "[") (word "!") (word "-f") (word "strmatch.so") (word "]")) (semi (command (word "echo") (word "\"glob-bracket: cannot create strmatch loadable builtin\"") (redirect ">&" 2)) (command (word "exit") (word "2"))))
(or (command (word "enable") (word "-f") (word "./strmatch.so") (word "strmatch")) (brace-group (semi (command (word "echo") (word "\"glob-bracket: cannot load strmatch builtin\"") (redirect ">&" 2)) (command (word "exit") (word "2")))))
(command (word "check_count=1"))
(if (command (word "[") (word "-z") (word "\"$BASH_TSTOUT\"") (word "]")) (command (word "yes='[32myes[m'") (word "no='[31mno[m'")) (command (word "yes=yes") (word "no=no")))
(function "check" (brace-group (semi (semi (semi (if (command (word "strmatch") (word "\"$2\"") (word "\"$1\"")) (command (word "local") (word "strmatch=$yes")) (command (word "local") (word "strmatch=$no"))) (command (word "local") (word "expect=${3-}"))) (if (cond (cond-unary "-n" (cond-term "$expect"))) (if (command (word "$WORK_DIR/fnmatch") (word "\"$2\"") (word "\"$1\"")) (command (word "expect=$yes")) (command (word "expect=$no"))))) (command (word "printf") (word "'#%d: pat=%-20s str=%-16s %s/%s\\n'") (word "\"$((check_count++))\"") (word "\"$1\"") (word "\"$2\"") (word "\"$strmatch\"") (word "\"$expect\"")))))
(function "pcheck" (brace-group (semi (semi (semi (semi (semi (command (word "local") (word "GLOBIGNORE=$1")) (command (word "local") (word "-a") (word "f=(*/*/efg*)"))) (if (cond (cond-binary "==" (cond-term "$f") (cond-term "'*/*/efg*'"))) (command (word "local") (word "strmatch=$yes")) (command (word "local") (word "strmatch=$no")))) (command (word "local") (word "fnmatch=${2-}"))) (if (cond (cond-unary "-n" (cond-term "$fnmatch"))) (if (command (word "$WORK_DIR/fnmatch") (word "ab/cd/efg") (word "\"$1\"")) (command (word "fnmatch=$yes")) (command (word "fnmatch=$no"))))) (command (word "printf") (word "'#%d: pat=%-16s %s/%s\\n'") (word "\"$((check_count++))\"") (word "\"$1\"") (word "\"$strmatch\"") (word "\"$fnmatch\"")))))
(command (word "TESTDIR=${TMPDIR}/pathtest-$$"))
(command (word "TESTPATH=${TESTDIR}/ab/cd/efg"))
(command (word "mkdir") (word "-p") (word "$TESTPATH"))
(if (and (command (word "[") (word "-d") (word "\"$TESTPATH\"") (word "]")) (command (word "cd") (word "\"$TESTDIR\""))) (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "'--- $GLOBIGNORE vs fnmatch(3) ---'")) (command (word "pcheck") (word "'ab/cd/efg'"))) (command (word "pcheck") (word "'ab[/]cd/efg'"))) (command (word "pcheck") (word "'ab[/a]cd/efg'"))) (command (word "pcheck") (word "'ab[a/]cd/efg'"))) (command (word "pcheck") (word "'ab[!a]cd/efg'"))) (command (word "pcheck") (word "'ab[.-0]cd/efg'"))) (command (word "pcheck") (word "'*/*/efg'"))) (command (word "pcheck") (word "'*[/]*/efg'"))) (command (word "pcheck") (word "'*[/a]*/efg'"))) (command (word "pcheck") (word "'*[a/]*/efg'"))) (command (word "pcheck") (word "'*[!a]*/efg'"))) (command (word "pcheck") (word "'*[.-0]*/efg'"))) (command (word "pcheck") (word "'*/*/efg'"))) (command (word "pcheck") (word "'*[b]/*/efg'"))) (command (word "pcheck") (word "'*[ab]/*/efg'"))) (command (word "pcheck") (word "'*[ba]/*/efg'"))) (command (word "pcheck") (word "'*[!a]/*/efg'"))) (command (word "pcheck") (word "'*[a-c]/*/efg'"))) (command (word "shopt") (word "-s") (word "extglob"))) (command (word "pcheck") (word "'ab@(/)cd/efg'") (word "\"$yes\""))) (command (word "pcheck") (word "'*@(/)cd/efg'") (word "\"$no\""))) (command (word "pcheck") (word "'*/cd/efg'"))) (command (word "shopt") (word "-u") (word "extglob"))) (command (word "cd") (word "\"$WORK_DIR\""))))
(command (word "echo"))
(command (word "echo") (word "'---Tests for a slash in bracket expressions---'"))
(command (word "check") (word "'ab[/]ef'") (word "'ab[/]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[/]ef'") (word "'ab/ef'") (word "\"$no\""))
(command (word "check") (word "'ab[c/d]ef'") (word "'ab[c/d]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[c/d]ef'") (word "'abcef'") (word "\"$no\""))
(command (word "check") (word "'ab[.-/]ef'") (word "'ab[.-/]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[.-/]ef'") (word "'ab.ef'") (word "\"$no\""))
(command (word "check") (word "'ab[[=/=]]ef'") (word "'ab[[=/=]]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[[=/=]]ef'") (word "'ab/ef'") (word "\"$no\""))
(command (word "check") (word "'ab[[=c=]/]ef'") (word "'ab[=/]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[[=c=]/]ef'") (word "'abcef'") (word "\"$no\""))
(command (word "check") (word "'ab[[:alpha:]/]ef'") (word "'ab[:/]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[[:alpha:]/]ef'") (word "'abxef'") (word "\"$no\""))
(command (word "check") (word "'ab[/[abc]]ef'") (word "'ab[/c]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[/[abc]]ef'") (word "'abc]ef'") (word "\"$no\""))
(command (word "check") (word "'ab[c[=/=]]ef'") (word "'ab[c[=/=]]ef'") (word "\"$yes\""))
(command (word "check") (word "'ab[c[=/=]]ef'") (word "'abc[=/=]ef'") (word "\"$no\""))
(command (word "check") (word "'ab[c[=/=]]ef'") (word "'abcef'") (word "\"$no\""))
(command (word "check") (word "'a[b\\/c]'") (word "'a[b/c]'") (word "\"$yes\""))
(command (word "check") (word "'a[b\\/c]'") (word "'ab'") (word "\"$no\""))
(command (word "check") (word "'a[b\\/c]'") (word "'ac'") (word "\"$no\""))
(command (word "echo"))
(command (word "echo") (word "'---Tests for incomplete bracket expressions---'"))
(command (word "check") (word "'ab[c'") (word "'ab[c'") (word "\"$yes\""))
(command (word "check") (word "'ab[c'") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[c[=d='") (word "'ab[c[=d='") (word "\"$yes\""))
(command (word "check") (word "'ab[c[=d='") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[c[.d'") (word "'ab[c[.d'") (word "\"$yes\""))
(command (word "check") (word "'ab[c[.d'") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[c[:alpha:'") (word "'ab[c[:alpha:'") (word "\"$yes\""))
(command (word "check") (word "'ab[c[:alpha:'") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[c-'") (word "'ab[c-'") (word "\"$yes\""))
(command (word "check") (word "'ab[c-'") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[c\\'") (word "'ab[c\\'") (word "\"$yes\""))
(command (word "check") (word "'ab[c\\'") (word "'abc'") (word "\"$no\""))
(command (word "check") (word "'ab[[\\'") (word "'ab[[\\'") (word "\"$yes\""))
(command (word "check") (word "'ab[[\\'") (word "'ab['") (word "\"$no\""))
(command (word "echo"))
(command (word "echo") (word "'--- PATSCAN vs BRACKMATCH ---'"))
(command (word "check") (word "'@([[.].])A])'") (word "']'") (word "\"$yes\""))
(command (word "check") (word "'@([[.].])A])'") (word "'==]A])'") (word "\"$no\""))
(command (word "check") (word "'@([[.].])A])'") (word "'AA])'") (word "\"$no\""))
(command (word "check") (word "'@([[=]=])A])'") (word "']'") (word "\"$no\""))
(command (word "check") (word "'@([[=]=])A])'") (word "'==]A])'") (word "\"$yes\""))
(command (word "check") (word "'@([[=]=])A])'") (word "'AA])'") (word "\"$no\""))
(command (word "echo"))
(command (word "echo") (word "'--- BRACKMATCH: after match vs before match ---'"))
(command (word "check") (word "'[[=]=]ab]'") (word "'a'") (word "\"$no\""))
(command (word "check") (word "'[[.[=.]ab]'") (word "'a'") (word "\"$yes\""))
(command (word "check") (word "'[[.[==].]ab]'") (word "'a'") (word "\"$yes\""))
(command (word "echo"))
(command (word "check") (word "'[a[=]=]b]'") (word "'a'") (word "\"$no\""))
(command (word "check") (word "'[a[.[=.]b]'") (word "'a'") (word "\"$yes\""))
(command (word "check") (word "'[a[.[==].]b]'") (word "'a'") (word "\"$yes\""))
(command (word "echo"))
(command (word "check") (word "'[a[=]=]b]'") (word "'b'") (word "\"$no\""))
(command (word "check") (word "'[a[=]=]b]'") (word "'a=]b]'") (word "\"$yes\""))
(command (word "check") (word "'[a[.[=.]b]'") (word "'b'") (word "\"$yes\""))
(command (word "check") (word "'[a[.[=.]b]'") (word "'ab]'") (word "\"$no\""))
(command (word "check") (word "'[a[.[==].]b]'") (word "'b'") (word "\"$yes\""))
(command (word "check") (word "'[a[.[==].]b]'") (word "'ab]'") (word "\"$no\""))
(command (word "echo"))
(command (word "echo") (word "'--- incomplete POSIX brackets ---'"))
(command (word "check") (word "'x[a[:y]'") (word "'x['") (word "\"$yes\""))
(command (word "check") (word "'x[a[:y]'") (word "'x:'") (word "\"$yes\""))
(command (word "check") (word "'x[a[:y]'") (word "'xy'") (word "\"$yes\""))
(command (word "check") (word "'x[a[:y]'") (word "'x[ay'") (word "\"$no\""))
(command (word "echo"))
(command (word "check") (word "'x[a[.y]'") (word "'x['") (word "\"$yes\""))
(command (word "check") (word "'x[a[.y]'") (word "'x.'") (word "\"$yes\""))
(command (word "check") (word "'x[a[.y]'") (word "'xy'") (word "\"$yes\""))
(command (word "check") (word "'x[a[.y]'") (word "'x[ay'") (word "\"$no\""))
(command (word "echo"))
(command (word "check") (word "'x[a[=y]'") (word "'x['") (word "\"$yes\""))
(command (word "check") (word "'x[a[=y]'") (word "'x='") (word "\"$yes\""))
(command (word "check") (word "'x[a[=y]'") (word "'xy'") (word "\"$yes\""))
(command (word "check") (word "'x[a[=y]'") (word "'x[ay'") (word "\"$no\""))
(command (word "echo"))
(command (word "echo") (word "'--- MISC tests ---'"))
(command (word "check") (word "'a\\'") (word "'a\\'") (word "\"$yes\""))
(command (word "cd") (word "$ORIG_DIR"))
(command (word "enable") (word "-d") (word "strmatch"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== glob
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
export LC_COLLATE=C
#
# test the shell globbing
#
expect()
{
:	# if needed, change me to echo expect "$@"
}

# First, a test that bash-2.01.1 fails
${THIS_SH} ./glob1.sub
${THIS_SH} ./glob2.sub
${THIS_SH} ./glob3.sub
${THIS_SH} ./glob4.sub
${THIS_SH} ./glob5.sub
${THIS_SH} ./glob6.sub
${THIS_SH} ./glob7.sub
${THIS_SH} ./glob8.sub
${THIS_SH} ./glob9.sub
${THIS_SH} ./glob10.sub
${THIS_SH} ./glob11.sub

MYDIR=$PWD	# save where we are

TESTDIR=$TMPDIR/glob-test-$$
mkdir $TESTDIR
builtin cd $TESTDIR || { echo $0: cannot cd to $TESTDIR >&2 ; exit 1; }
rm -rf *

touch a b c d abc abd abe bb bcd ca cb dd de Beware
mkdir bdir

# see if `regular' globbing works right
expect '<a> <abc> <abd> <abe> <X*>'
recho a* X*

expect '<a> <abc> <abd> <abe>'
recho \a*

# see if null glob expansion works
shopt -s nullglob

expect '<a> <abc> <abd> <abe>'
recho a* X*

shopt -u nullglob

# see if the failglob option works

mkdir tmp
touch tmp/l1 tmp/l2 tmp/l3
builtin echo tmp/l[12] tmp/*4 tmp/*3
shopt -s failglob
builtin echo tmp/l[12] tmp/*4 tmp/*3
rm -r tmp
shopt -u failglob

# see if the code that expands directories only works
expect '<bdir/>'
recho b*/

# Test quoted and unquoted globbing characters
expect '<*>'
recho \*

expect '<a*>'
recho 'a*'

expect '<a*>'
recho a\*

expect '<c> <ca> <cb> <a*> <*q*>'
recho c* a\* *q*

expect '<**>'
recho "*"*

expect '<**>'
recho \**

expect '<\.\./*/>'
recho "\.\./*/"

expect '<s/\..*//>'
recho 's/\..*//'

# Pattern from Larry Wall's Configure that caused bash to blow up
expect '</^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/>'
recho "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/"

# Make sure character classes work properly

expect '<abc> <abd> <abe> <bb> <cb>'
recho [a-c]b*

expect '<abd> <abe> <bb> <bcd> <bdir> <ca> <cb> <dd> <de>'
recho [a-y]*[^c]

expect '<abd> <abe>'
recho a*[^c]

touch a-b aXb
expect '<a-b> <aXb>'
recho a[X-]b

touch .x .y
expect '<Beware> <d> <dd> <de>'
recho [^a-c]*

# Make sure that filenames with embedded globbing characters are handled
# properly
mkdir a\*b
> a\*b/ooo

expect '<a*b/ooo>'
recho a\*b/*

expect '<a*b/ooo>'
recho a\*?/*

expect '<no match>'
cmd='echo !7'
case "$cmd" in
*\\!*) echo match ;;
*) echo no match ;;
esac

expect '<not there>'
file='r.*'
case $file in
*.\*) echo not there ;;
*) echo there ;;
esac

# examples from the Posix.2 spec (d11.2, p. 243)
expect '<abc>'
recho a[b]c

expect '<abc>'
recho a["b"]c

expect '<abc>'
recho a[\b]c

expect '<abc>'
recho a?c

expect '<match 1>'
case abc in
a"b"c)	echo 'match 1' ;;
*)	echo 'BAD match 1' ;;
esac

expect '<match 2>'
case abc in
a*c)	echo 'match 2' ;;
*)	echo 'BAD match 2' ;;
esac

expect '<ok 1>'
case abc in
"a?c")	echo 'bad 1' ;;
*)	echo 'ok 1' ;;
esac

expect '<ok 2>'
case abc in
a\*c)	echo 'bad 2' ;;
*)	echo 'ok 2' ;;
esac

expect '<ok 3>'
case abc in
a\[b]c)	echo 'bad 3' ;;
*)	echo 'ok 3' ;;
esac

expect '<ok 4>'
case "$nosuchvar" in
"") 	echo 'ok 4' ;;
*)	echo 'bad 4' ;;
esac

# This is very odd, but sh and ksh seem to agree
expect '<ok 5>'
case abc in
a["\b"]c) echo 'ok 5' ;;
*)	echo 'bad 5' ;;
esac

mkdir man
mkdir man/man1
touch man/man1/bash.1
expect '<man/man1/bash.1>'
recho */man*/bash.*
expect '<man/man1/bash.1>'
recho $(echo */man*/bash.*)
expect '<man/man1/bash.1>'
recho "$(echo */man*/bash.*)"

# tests with multiple `*'s
case abc in
a***c)	echo ok 1;;
esac

case abc in
a*****?c)	echo ok 2;;
esac

case abc in
?*****??)	echo ok 3;;
esac

case abc in
*****??)	echo ok 4;;
esac

case abc in
*****??c)	echo ok 5;;
esac

case abc in
?*****?c)	echo ok 6;;
esac

case abc in
?***?****c)	echo ok 7;;
esac

case abc in
?***?****?)	echo ok 8;;
esac

case abc in
?***?****)	echo ok 9;;
esac

case abc in
*******c)	echo ok 10;;
esac

case abc in
*******?)	echo ok 11;;
esac

case abcdecdhjk in
a*cd**?**??k)	echo ok 20;;
esac

case abcdecdhjk in
a**?**cd**?**??k)	echo ok 21;;
esac

case abcdecdhjk in
a**?**cd**?**??k***)	echo ok 22;;
esac

case abcdecdhjk in
a**?**cd**?**??***k)	echo ok 23;;
esac

case abcdecdhjk in
a**?**cd**?**??***k**)	echo ok 24;;
esac

case abcdecdhjk in
a****c**?**??*****)	echo ok 25;;
esac

case '-' in
[-abc])	echo ok 26 ;;
esac

case '-' in
[abc-]) echo ok 27 ;;
esac

case '\' in
\\)	echo ok 28 ;;
esac

case '\' in
[\\])	echo ok 29 ;;
esac

case '\' in
'\')	echo ok 30 ;;
esac

case '[' in
[[])	echo ok 31 ;;
esac

# a `[' without a closing `]' is just another character to match, in the
# bash implementation
case '[' in
[)	echo ok 32 ;;
esac

case '[abc' in
[*)	echo 'ok 33';;
esac

# a right bracket shall lose its special meaning and represent itself in
# a bracket expression if it occurs first in the list.  -- POSIX.2 2.8.3.2
case ']' in
[]])	echo ok 34 ;;
esac

case '-' in
[]-])	echo ok 35 ;;
esac

# a backslash should just escape the next character in this context
case p in
[a-\z])	echo ok 36 ;;
esac

# this was a bug in all versions up to bash-2.04-release
case "/tmp" in
[/\\]*) echo ok 37 ;;
esac

# none of these should output anything

case abc in
??**********?****?)	echo bad 1;;
esac

case abc in
??**********?****c)	echo bad 2;;
esac

case abc in
?************c****?****)	echo bad 3;;
esac

case abc in
*c*?**)	echo bad 4;;
esac

case abc in
a*****c*?**)	echo bad 5;;
esac

case abc in
a********???*******)	echo bad 6;;
esac

case 'a' in
[])	echo bad 7 ;;
esac

case '[' in
[abc)	echo bad 8;;
esac

# let's start testing the case-insensitive globbing code
recho b*

shopt -s nocaseglob
recho b*

recho [b]*
shopt -u nocaseglob

# make sure set -f works right
set -f
recho *
set +f

# test out the GLOBIGNORE code
GLOBIGNORE='.*:*c:*e:?'
recho *

GLOBIGNORE='.*:*b:*d:?'
recho *

# see if GLOBIGNORE can substitute for `set -f'
GLOBIGNORE='.*:*'
recho *

unset GLOBIGNORE
expect '<man/man1/bash.1>'
recho */man*/bash.*

# make sure null values for GLOBIGNORE have no effect
GLOBIGNORE=
expect '<man/man1/bash.1>'
recho */man*/bash.*

# this is for the benefit of pure coverage, so it writes the pcv file
# in the right place, and for gprof
builtin cd $MYDIR

rm -rf $TESTDIR

exit 0

--------------------------------------------------------------------------------
---
(command (word "export") (word "LC_COLLATE=C"))
(function "expect" (brace-group (command (word ":"))))
(command (word "${THIS_SH}") (word "./glob1.sub"))
(command (word "${THIS_SH}") (word "./glob2.sub"))
(command (word "${THIS_SH}") (word "./glob3.sub"))
(command (word "${THIS_SH}") (word "./glob4.sub"))
(command (word "${THIS_SH}") (word "./glob5.sub"))
(command (word "${THIS_SH}") (word "./glob6.sub"))
(command (word "${THIS_SH}") (word "./glob7.sub"))
(command (word "${THIS_SH}") (word "./glob8.sub"))
(command (word "${THIS_SH}") (word "./glob9.sub"))
(command (word "${THIS_SH}") (word "./glob10.sub"))
(command (word "${THIS_SH}") (word "./glob11.sub"))
(command (word "MYDIR=$PWD"))
(command (word "TESTDIR=$TMPDIR/glob-test-$$"))
(command (word "mkdir") (word "$TESTDIR"))
(or (command (word "builtin") (word "cd") (word "$TESTDIR")) (brace-group (semi (command (word "echo") (word "$0:") (word "cannot") (word "cd") (word "to") (word "$TESTDIR") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "rm") (word "-rf") (word "*"))
(command (word "touch") (word "a") (word "b") (word "c") (word "d") (word "abc") (word "abd") (word "abe") (word "bb") (word "bcd") (word "ca") (word "cb") (word "dd") (word "de") (word "Beware"))
(command (word "mkdir") (word "bdir"))
(command (word "expect") (word "'<a> <abc> <abd> <abe> <X*>'"))
(command (word "recho") (word "a*") (word "X*"))
(command (word "expect") (word "'<a> <abc> <abd> <abe>'"))
(command (word "recho") (word "\\a*"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "expect") (word "'<a> <abc> <abd> <abe>'"))
(command (word "recho") (word "a*") (word "X*"))
(command (word "shopt") (word "-u") (word "nullglob"))
(command (word "mkdir") (word "tmp"))
(command (word "touch") (word "tmp/l1") (word "tmp/l2") (word "tmp/l3"))
(command (word "builtin") (word "echo") (word "tmp/l[12]") (word "tmp/*4") (word "tmp/*3"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "builtin") (word "echo") (word "tmp/l[12]") (word "tmp/*4") (word "tmp/*3"))
(command (word "rm") (word "-r") (word "tmp"))
(command (word "shopt") (word "-u") (word "failglob"))
(command (word "expect") (word "'<bdir/>'"))
(command (word "recho") (word "b*/"))
(command (word "expect") (word "'<*>'"))
(command (word "recho") (word "\\*"))
(command (word "expect") (word "'<a*>'"))
(command (word "recho") (word "'a*'"))
(command (word "expect") (word "'<a*>'"))
(command (word "recho") (word "a\\*"))
(command (word "expect") (word "'<c> <ca> <cb> <a*> <*q*>'"))
(command (word "recho") (word "c*") (word "a\\*") (word "*q*"))
(command (word "expect") (word "'<**>'"))
(command (word "recho") (word "\"*\"*"))
(command (word "expect") (word "'<**>'"))
(command (word "recho") (word "\\**"))
(command (word "expect") (word "'<\\.\\./*/>'"))
(command (word "recho") (word "\"\\.\\./*/\""))
(command (word "expect") (word "'<s/\\..*//>'"))
(command (word "recho") (word "'s/\\..*//'"))
(command (word "expect") (word "'</^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/>'"))
(command (word "recho") (word "\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*\"'$'\"/\\1/\""))
(command (word "expect") (word "'<abc> <abd> <abe> <bb> <cb>'"))
(command (word "recho") (word "[a-c]b*"))
(command (word "expect") (word "'<abd> <abe> <bb> <bcd> <bdir> <ca> <cb> <dd> <de>'"))
(command (word "recho") (word "[a-y]*[^c]"))
(command (word "expect") (word "'<abd> <abe>'"))
(command (word "recho") (word "a*[^c]"))
(command (word "touch") (word "a-b") (word "aXb"))
(command (word "expect") (word "'<a-b> <aXb>'"))
(command (word "recho") (word "a[X-]b"))
(command (word "touch") (word ".x") (word ".y"))
(command (word "expect") (word "'<Beware> <d> <dd> <de>'"))
(command (word "recho") (word "[^a-c]*"))
(command (word "mkdir") (word "a\\*b"))
(command (redirect ">" "a\*b/ooo"))
(command (word "expect") (word "'<a*b/ooo>'"))
(command (word "recho") (word "a\\*b/*"))
(command (word "expect") (word "'<a*b/ooo>'"))
(command (word "recho") (word "a\\*?/*"))
(command (word "expect") (word "'<no match>'"))
(command (word "cmd='echo !7'"))
(case (word "\"$cmd\"") (pattern ((word "*\\\\!*")) (command (word "echo") (word "match"))) (pattern ((word "*")) (command (word "echo") (word "no") (word "match"))))
(command (word "expect") (word "'<not there>'"))
(command (word "file='r.*'"))
(case (word "$file") (pattern ((word "*.\\*")) (command (word "echo") (word "not") (word "there"))) (pattern ((word "*")) (command (word "echo") (word "there"))))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "a[b]c"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "a[\"b\"]c"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "a[\\b]c"))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "a?c"))
(command (word "expect") (word "'<match 1>'"))
(case (word "abc") (pattern ((word "a\"b\"c")) (command (word "echo") (word "'match 1'"))) (pattern ((word "*")) (command (word "echo") (word "'BAD match 1'"))))
(command (word "expect") (word "'<match 2>'"))
(case (word "abc") (pattern ((word "a*c")) (command (word "echo") (word "'match 2'"))) (pattern ((word "*")) (command (word "echo") (word "'BAD match 2'"))))
(command (word "expect") (word "'<ok 1>'"))
(case (word "abc") (pattern ((word "\"a?c\"")) (command (word "echo") (word "'bad 1'"))) (pattern ((word "*")) (command (word "echo") (word "'ok 1'"))))
(command (word "expect") (word "'<ok 2>'"))
(case (word "abc") (pattern ((word "a\\*c")) (command (word "echo") (word "'bad 2'"))) (pattern ((word "*")) (command (word "echo") (word "'ok 2'"))))
(command (word "expect") (word "'<ok 3>'"))
(case (word "abc") (pattern ((word "a\\[b]c")) (command (word "echo") (word "'bad 3'"))) (pattern ((word "*")) (command (word "echo") (word "'ok 3'"))))
(command (word "expect") (word "'<ok 4>'"))
(case (word "\"$nosuchvar\"") (pattern ((word "\"\"")) (command (word "echo") (word "'ok 4'"))) (pattern ((word "*")) (command (word "echo") (word "'bad 4'"))))
(command (word "expect") (word "'<ok 5>'"))
(case (word "abc") (pattern ((word "a[\"\\b\"]c")) (command (word "echo") (word "'ok 5'"))) (pattern ((word "*")) (command (word "echo") (word "'bad 5'"))))
(command (word "mkdir") (word "man"))
(command (word "mkdir") (word "man/man1"))
(command (word "touch") (word "man/man1/bash.1"))
(command (word "expect") (word "'<man/man1/bash.1>'"))
(command (word "recho") (word "*/man*/bash.*"))
(command (word "expect") (word "'<man/man1/bash.1>'"))
(command (word "recho") (word "$(echo */man*/bash.*)"))
(command (word "expect") (word "'<man/man1/bash.1>'"))
(command (word "recho") (word "\"$(echo */man*/bash.*)\""))
(case (word "abc") (pattern ((word "a***c")) (command (word "echo") (word "ok") (word "1"))))
(case (word "abc") (pattern ((word "a*****?c")) (command (word "echo") (word "ok") (word "2"))))
(case (word "abc") (pattern ((word "?*****??")) (command (word "echo") (word "ok") (word "3"))))
(case (word "abc") (pattern ((word "*****??")) (command (word "echo") (word "ok") (word "4"))))
(case (word "abc") (pattern ((word "*****??c")) (command (word "echo") (word "ok") (word "5"))))
(case (word "abc") (pattern ((word "?*****?c")) (command (word "echo") (word "ok") (word "6"))))
(case (word "abc") (pattern ((word "?***?****c")) (command (word "echo") (word "ok") (word "7"))))
(case (word "abc") (pattern ((word "?***?****?")) (command (word "echo") (word "ok") (word "8"))))
(case (word "abc") (pattern ((word "?***?****")) (command (word "echo") (word "ok") (word "9"))))
(case (word "abc") (pattern ((word "*******c")) (command (word "echo") (word "ok") (word "10"))))
(case (word "abc") (pattern ((word "*******?")) (command (word "echo") (word "ok") (word "11"))))
(case (word "abcdecdhjk") (pattern ((word "a*cd**?**??k")) (command (word "echo") (word "ok") (word "20"))))
(case (word "abcdecdhjk") (pattern ((word "a**?**cd**?**??k")) (command (word "echo") (word "ok") (word "21"))))
(case (word "abcdecdhjk") (pattern ((word "a**?**cd**?**??k***")) (command (word "echo") (word "ok") (word "22"))))
(case (word "abcdecdhjk") (pattern ((word "a**?**cd**?**??***k")) (command (word "echo") (word "ok") (word "23"))))
(case (word "abcdecdhjk") (pattern ((word "a**?**cd**?**??***k**")) (command (word "echo") (word "ok") (word "24"))))
(case (word "abcdecdhjk") (pattern ((word "a****c**?**??*****")) (command (word "echo") (word "ok") (word "25"))))
(case (word "'-'") (pattern ((word "[-abc]")) (command (word "echo") (word "ok") (word "26"))))
(case (word "'-'") (pattern ((word "[abc-]")) (command (word "echo") (word "ok") (word "27"))))
(case (word "'\\'") (pattern ((word "\\\\")) (command (word "echo") (word "ok") (word "28"))))
(case (word "'\\'") (pattern ((word "[\\\\]")) (command (word "echo") (word "ok") (word "29"))))
(case (word "'\\'") (pattern ((word "'\\'")) (command (word "echo") (word "ok") (word "30"))))
(case (word "'['") (pattern ((word "[[]")) (command (word "echo") (word "ok") (word "31"))))
(case (word "'['") (pattern ((word "[")) (command (word "echo") (word "ok") (word "32"))))
(case (word "'[abc'") (pattern ((word "[*")) (command (word "echo") (word "'ok 33'"))))
(case (word "']'") (pattern ((word "[]]")) (command (word "echo") (word "ok") (word "34"))))
(case (word "'-'") (pattern ((word "[]-]")) (command (word "echo") (word "ok") (word "35"))))
(case (word "p") (pattern ((word "[a-\\z]")) (command (word "echo") (word "ok") (word "36"))))
(case (word "\"/tmp\"") (pattern ((word "[/\\\\]*")) (command (word "echo") (word "ok") (word "37"))))
(case (word "abc") (pattern ((word "??**********?****?")) (command (word "echo") (word "bad") (word "1"))))
(case (word "abc") (pattern ((word "??**********?****c")) (command (word "echo") (word "bad") (word "2"))))
(case (word "abc") (pattern ((word "?************c****?****")) (command (word "echo") (word "bad") (word "3"))))
(case (word "abc") (pattern ((word "*c*?**")) (command (word "echo") (word "bad") (word "4"))))
(case (word "abc") (pattern ((word "a*****c*?**")) (command (word "echo") (word "bad") (word "5"))))
(case (word "abc") (pattern ((word "a********???*******")) (command (word "echo") (word "bad") (word "6"))))
(case (word "'a'") (pattern ((word "[]")) (command (word "echo") (word "bad") (word "7"))))
(case (word "'['") (pattern ((word "[abc")) (command (word "echo") (word "bad") (word "8"))))
(command (word "recho") (word "b*"))
(command (word "shopt") (word "-s") (word "nocaseglob"))
(command (word "recho") (word "b*"))
(command (word "recho") (word "[b]*"))
(command (word "shopt") (word "-u") (word "nocaseglob"))
(command (word "set") (word "-f"))
(command (word "recho") (word "*"))
(command (word "set") (word "+f"))
(command (word "GLOBIGNORE='.*:*c:*e:?'"))
(command (word "recho") (word "*"))
(command (word "GLOBIGNORE='.*:*b:*d:?'"))
(command (word "recho") (word "*"))
(command (word "GLOBIGNORE='.*:*'"))
(command (word "recho") (word "*"))
(command (word "unset") (word "GLOBIGNORE"))
(command (word "expect") (word "'<man/man1/bash.1>'"))
(command (word "recho") (word "*/man*/bash.*"))
(command (word "GLOBIGNORE="))
(command (word "expect") (word "'<man/man1/bash.1>'"))
(command (word "recho") (word "*/man*/bash.*"))
(command (word "builtin") (word "cd") (word "$MYDIR"))
(command (word "rm") (word "-rf") (word "$TESTDIR"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== globstar
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
: ${TMPDIR:=/var/tmp}
dir=$PWD

shopt -s globstar

export LANG=C LC_ALL=C LC_COLLATE=C

GDIR=$TMPDIR/globstar-$$

mkdir $GDIR || exit 1
cd $GDIR || exit 1

mkdir lib builtins
mkdir lib/glob lib/readline lib/sh

touch builtins/history.o builtins/jobs.o builtins/kill.o builtins/let.o builtins/mapfile.o
touch lib/glob/glob.o lib/glob/smatch.o lib/glob/strmatch.o
touch lib/readline/bind.o lib/readline/callback.o lib/readline/compat.o lib/readline/complete.o lib/readline/display.o

touch lib/sh/casemod.o lib/sh/clktck.o lib/sh/clock.o lib/sh/eaccess.o
touch lib/sh/fdprintf.o lib/sh/fmtullong.o lib/sh/fmtulong.o lib/sh/fmtumax.o
touch lib/sh/fpurge.o lib/sh/getenv.o lib/sh/input_avail.o lib/sh/itos.o

touch alias.o
touch pcomplib.o print_cmd.o redir.o shell.o sig.o stringlib.o subst.o syntax.o
touch test.o trap.o unwind_prot.o variables.o version.o xmalloc.o y.tab.o

ls lib/**

ls lib/**/*.o

echo **/*.o

ls **

echo **

cd $dir
rm -rf $GDIR

${THIS_SH} ./globstar1.sub
${THIS_SH} ./globstar2.sub
${THIS_SH} ./globstar3.sub

--------------------------------------------------------------------------------
---
(command (word ":") (word "${TMPDIR:=/var/tmp}"))
(command (word "dir=$PWD"))
(command (word "shopt") (word "-s") (word "globstar"))
(command (word "export") (word "LANG=C") (word "LC_ALL=C") (word "LC_COLLATE=C"))
(command (word "GDIR=$TMPDIR/globstar-$$"))
(or (command (word "mkdir") (word "$GDIR")) (command (word "exit") (word "1")))
(or (command (word "cd") (word "$GDIR")) (command (word "exit") (word "1")))
(command (word "mkdir") (word "lib") (word "builtins"))
(command (word "mkdir") (word "lib/glob") (word "lib/readline") (word "lib/sh"))
(command (word "touch") (word "builtins/history.o") (word "builtins/jobs.o") (word "builtins/kill.o") (word "builtins/let.o") (word "builtins/mapfile.o"))
(command (word "touch") (word "lib/glob/glob.o") (word "lib/glob/smatch.o") (word "lib/glob/strmatch.o"))
(command (word "touch") (word "lib/readline/bind.o") (word "lib/readline/callback.o") (word "lib/readline/compat.o") (word "lib/readline/complete.o") (word "lib/readline/display.o"))
(command (word "touch") (word "lib/sh/casemod.o") (word "lib/sh/clktck.o") (word "lib/sh/clock.o") (word "lib/sh/eaccess.o"))
(command (word "touch") (word "lib/sh/fdprintf.o") (word "lib/sh/fmtullong.o") (word "lib/sh/fmtulong.o") (word "lib/sh/fmtumax.o"))
(command (word "touch") (word "lib/sh/fpurge.o") (word "lib/sh/getenv.o") (word "lib/sh/input_avail.o") (word "lib/sh/itos.o"))
(command (word "touch") (word "alias.o"))
(command (word "touch") (word "pcomplib.o") (word "print_cmd.o") (word "redir.o") (word "shell.o") (word "sig.o") (word "stringlib.o") (word "subst.o") (word "syntax.o"))
(command (word "touch") (word "test.o") (word "trap.o") (word "unwind_prot.o") (word "variables.o") (word "version.o") (word "xmalloc.o") (word "y.tab.o"))
(command (word "ls") (word "lib/**"))
(command (word "ls") (word "lib/**/*.o"))
(command (word "echo") (word "**/*.o"))
(command (word "ls") (word "**"))
(command (word "echo") (word "**"))
(command (word "cd") (word "$dir"))
(command (word "rm") (word "-rf") (word "$GDIR"))
(command (word "${THIS_SH}") (word "./globstar1.sub"))
(command (word "${THIS_SH}") (word "./globstar2.sub"))
(command (word "${THIS_SH}") (word "./globstar3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== heredoc
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# basics
cat <<EOF
a
b
c
EOF
read x <<EOF
a
b
c
EOF
echo "$x"
read x y <<\EOF
$PS4
EOF
echo "$x"

# empty here-documents
read x <<EOF
EOF
echo "$x"
read x <<\EOF
EOF
echo "$x"
read x <<EOF
$empty
EOF
echo "$x"

# check order and content of multiple here docs
cat << EOF1 << EOF2 
hi
EOF1
there
EOF2

while read line1; do
	read line2 <&3
	echo $line1 - $line2
done <<EOF1 3<<EOF2
one
two
three
EOF1
alpha
beta
gamma
EOF2


# check quoted here-doc is protected

a=foo
cat << 'EOF'
hi\
there$a
stuff
EOF

# check that quoted here-documents don't have \newline processing done

cat << 'EOF'
hi\
there
EO\
F
EOF
true

# but unquoted here-documents remove backslash-newline
cat <<EOF
line 1\
line 2
EOF

# check that \newline is removed at start of here-doc
cat << EO\
F
hi
EOF

# check that \newline removal works for here-doc delimiter
cat << EOF
hi
EO\
F

# backslash-newline processing is performed before the check for the delimiter
cat <<EOF
next\
EOF
EOF

# check operation of tab removal in here documents
cat <<- EOF
	tab 1
	tab 2
	tab 3
	EOF

# check appending of text to file from here document
rm -f ${TMPDIR}/bash-zzz-$$
cat > ${TMPDIR}/bash-zzz-$$ << EOF
abc
EOF
cat >> ${TMPDIR}/bash-zzz-$$ << EOF
def ghi
jkl mno
EOF
cat ${TMPDIR}/bash-zzz-$$
rm -f ${TMPDIR}/bash-zzz-$$

# check behavior of double quotes and backslashes in here-documents
cat <<EOF
echo "
EOF

cat <<EOF
echo \"
EOF

# make sure command printing puts the here-document as the last redirection
# on the line, and the function export code preserves syntactic correctness
fff()
{
  ed ${TMPDIR}/foo <<ENDOFINPUT >/dev/null
/^name/d
w
q
ENDOFINPUT
aa=1
}

type fff
export -f fff
${THIS_SH} -c 'type fff'

${THIS_SH} ./heredoc1.sub

# test heredocs in command substitutions
${THIS_SH} ./heredoc2.sub
${THIS_SH} ./heredoc3.sub
${THIS_SH} ./heredoc4.sub

# heredoc tests that use different size documents to test pipe implementation
${THIS_SH} ./heredoc5.sub

# test $'...' and $"..." quoted strings in here-documents
${THIS_SH} ./heredoc6.sub

# interaction between here-documents and command substitutions
${THIS_SH} ./heredoc7.sub
${THIS_SH} ./heredoc8.sub

# various tests for printing here-documents in function bodies
${THIS_SH} ./heredoc9.sub

# test various combinations of here-documents and aliases
${THIS_SH} ./heredoc10.sub

echo $(
	cat <<< "comsub here-string"
)

# check that end of file delimits a here-document
# THIS MUST BE LAST!

cat <<''
hi
there
''

--------------------------------------------------------------------------------
---
(command (word "cat") (redirect "<<" "a
b
c
"))
(command (word "read") (word "x") (redirect "<<" "a
b
c
"))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (word "y") (redirect "<<" "$PS4
"))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<" ""))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<" ""))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<" "$empty
"))
(command (word "echo") (word "\"$x\""))
(command (word "cat") (redirect "<<" "hi
") (redirect "<<" "there
"))
(while (command (word "read") (word "line1")) (semi (command (word "read") (word "line2") (redirect "<&" 3)) (command (word "echo") (word "$line1") (word "-") (word "$line2")))) (redirect "<<" "one
two
three
") (redirect "<<" "alpha
beta
gamma
")
(command (word "a=foo"))
(command (word "cat") (redirect "<<" "hi\
there$a
stuff
"))
(command (word "cat") (redirect "<<" "hi\
there
EO\
F
"))
(command (word "true"))
(command (word "cat") (redirect "<<" "line 1line 2
"))
(command (word "cat") (redirect "<<" "hi
"))
(command (word "cat") (redirect "<<" "hi
"))
(command (word "cat") (redirect "<<" "nextEOF
"))
(command (word "cat") (redirect "<<-" "tab 1
tab 2
tab 3
"))
(command (word "rm") (word "-f") (word "${TMPDIR}/bash-zzz-$$"))
(command (word "cat") (redirect ">" "${TMPDIR}/bash-zzz-$$") (redirect "<<" "abc
"))
(command (word "cat") (redirect ">>" "${TMPDIR}/bash-zzz-$$") (redirect "<<" "def ghi
jkl mno
"))
(command (word "cat") (word "${TMPDIR}/bash-zzz-$$"))
(command (word "rm") (word "-f") (word "${TMPDIR}/bash-zzz-$$"))
(command (word "cat") (redirect "<<" "echo "
"))
(command (word "cat") (redirect "<<" "echo \"
"))
(function "fff" (brace-group (semi (command (word "ed") (word "${TMPDIR}/foo") (redirect "<<" "/^name/d
w
q
") (redirect ">" "/dev/null")) (command (word "aa=1")))))
(command (word "type") (word "fff"))
(command (word "export") (word "-f") (word "fff"))
(command (word "${THIS_SH}") (word "-c") (word "'type fff'"))
(command (word "${THIS_SH}") (word "./heredoc1.sub"))
(command (word "${THIS_SH}") (word "./heredoc2.sub"))
(command (word "${THIS_SH}") (word "./heredoc3.sub"))
(command (word "${THIS_SH}") (word "./heredoc4.sub"))
(command (word "${THIS_SH}") (word "./heredoc5.sub"))
(command (word "${THIS_SH}") (word "./heredoc6.sub"))
(command (word "${THIS_SH}") (word "./heredoc7.sub"))
(command (word "${THIS_SH}") (word "./heredoc8.sub"))
(command (word "${THIS_SH}") (word "./heredoc9.sub"))
(command (word "${THIS_SH}") (word "./heredoc10.sub"))
(command (word "echo") (word "$(cat <<< \"comsub here-string\")"))
(command (word "cat") (redirect "<<" "hi
there
''
"))
(command (word "--------------------------------------------------------------------------------"))
---

=== herestr
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# since we look at functions below, remove all functions now
funcs=$(compgen -A function)
if [ -n "$funcs" ]; then
	unset -f $funcs
fi

# basics
read x <<<"alpha"
echo "$x"
read x <<<beta
echo "$x"
X=4
read x <<<$X
echo "$x"
read x <<<"$X"
echo "$x"
unset X

# empty here-strings
read x <<<""
echo "$x"
read x <<<"$empty"
echo "$x"
read x <<<$empty
echo "$x"

a=hot
b=damn
f1()
{
cat <<< "abcde"

cat <<< "yo"

cat <<< "$a $b"

cat <<< 'what a fabulous window treatment'

cat <<< 'double"quote'
}

f2()
{
cat <<< onetwothree
}

f3()
{
cat <<< "$@"
}

f1
f2
f3 first second third

typeset -f

cat <<< 'echo $(echo hi)'

cat <<< "echo ho"

cat <<< "echo $(echo off to work we go)"

IFS="/" read -r -d $'\000' -a uu <<< /kghfjk/jkfzuk/i
declare -p uu

${THIS_SH} ./herestr1.sub

--------------------------------------------------------------------------------
---
(command (word "funcs=$(compgen -A function)"))
(if (command (word "[") (word "-n") (word "\"$funcs\"") (word "]")) (command (word "unset") (word "-f") (word "$funcs")))
(command (word "read") (word "x") (redirect "<<<" ""alpha""))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<<" "beta"))
(command (word "echo") (word "\"$x\""))
(command (word "X=4"))
(command (word "read") (word "x") (redirect "<<<" "$X"))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<<" ""$X""))
(command (word "echo") (word "\"$x\""))
(command (word "unset") (word "X"))
(command (word "read") (word "x") (redirect "<<<" """"))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<<" ""$empty""))
(command (word "echo") (word "\"$x\""))
(command (word "read") (word "x") (redirect "<<<" "$empty"))
(command (word "echo") (word "\"$x\""))
(command (word "a=hot"))
(command (word "b=damn"))
(function "f1" (brace-group (semi (semi (semi (semi (command (word "cat") (redirect "<<<" ""abcde"")) (command (word "cat") (redirect "<<<" ""yo""))) (command (word "cat") (redirect "<<<" ""$a $b""))) (command (word "cat") (redirect "<<<" "'what a fabulous window treatment'"))) (command (word "cat") (redirect "<<<" "'double"quote'")))))
(function "f2" (brace-group (command (word "cat") (redirect "<<<" "onetwothree"))))
(function "f3" (brace-group (command (word "cat") (redirect "<<<" ""$@""))))
(command (word "f1"))
(command (word "f2"))
(command (word "f3") (word "first") (word "second") (word "third"))
(command (word "typeset") (word "-f"))
(command (word "cat") (redirect "<<<" "'echo $(echo hi)'"))
(command (word "cat") (redirect "<<<" ""echo ho""))
(command (word "cat") (redirect "<<<" ""echo $(echo off to work we go)""))
(command (word "IFS=\"/\"") (word "read") (word "-r") (word "-d") (word "''") (word "-a") (word "uu") (redirect "<<<" "/kghfjk/jkfzuk/i"))
(command (word "declare") (word "-p") (word "uu"))
(command (word "${THIS_SH}") (word "./herestr1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== histexp
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
LC_ALL=C
LANG=C
trap 'rm $TMPDIR/newhistory' 0

file=bax
histchars='!^#'	# make sure history comment char is set correctly

unset HISTFILESIZE HISTTIMEFORMAT

history -c

HISTFILE=history.list
HISTCONTROL=ignoreboth
HISTIGNORE='&:#*:history*:fc*'
# we will end up exercising the history stifling code as a result
HISTSIZE=32

shopt -s cmdhist
set -o history

history -p '!!'

# this should result in a failed history expansion error
history -p '!!:z'

history

HISTFILE=$TMPDIR/newhistory
history -a

history -w

history -s "echo line 2 for history"
history
history -p '!e'
history -p '!!'

set -H
!!
!e

history

echo a b c d e
!?ch?
!-2
^2^8

!2

# we're selecting /bin/sh -c ...; we want `sh'
echo !-1:0:t
# we're selecting /bin/sh -c ...; we want `/bin'
echo !-2:0:h
# we're selecting `echo a b c d e'; we want `e'
echo !?d?:5

echo a b c d e
echo !-1:2-$
echo !-2:2-4
echo !-2:3*
echo !!:*

echo !?a?:2-

echo file.c
echo !!:$:r
echo !-2:$:e
echo !-3:$:r:q

echo $file.c
echo !!:$:r
echo !-2:^:e
echo !-3:$:r:q

echo a b c d e
echo !!:1-$:x
echo !-2:1-$:q

echo foo.c foo.o foo.html foo.h
!!:s/foo/bar/
!-2:gs/foo/bar/
!!:gs/bar/x&/
!-2:g&

# make sure we can use any delimiter in the substitution, not just `/'
!!:gs+bar+whix+

!!:p

# wow
echo !?.o?:%:r:q

!!:0 !?.h?:%:q
!!:-$
!:-$

history

# make sure single quotes inhibit history expansion
echo '!!'

# make sure backslashes can quote the history expansion character
echo \!\!

# but other expansions on the line should still be processed

echo '!!' !!:*
history -c
unset HISTFILE

# make sure that the special bash cases are not history expanded
case p in
[!A-Z])	echo ok 1;;
esac

var1='ok 2'
var2=var1

echo ${!var2}

# Bash-2.01[.1] fails this test -- it attempts history expansion after the
# history_comment_char
echo ok 3 # !1200

# bash versions through bash-4.3 fail this; they make the digit preceding the
# > into a separate word, changing the meaning of the redirection
shopt a b c d 2>/dev/null
echo !shopt-1

echo !shopt*

# make sure a :p modifier anywhere on the line affects all history expansions
echo one two three four
echo !:2:p ; echo !$  
echo one two three four
echo !$ ; echo !:2:p

# problem through bash-5.2 with history word tokenization
echo $((1+2))
echo !!:1

${THIS_SH} ./histexp1.sub
${THIS_SH} ./histexp2.sub
${THIS_SH} ./histexp3.sub
${THIS_SH} ./histexp4.sub
${THIS_SH} ./histexp5.sub
${THIS_SH} ./histexp6.sub
${THIS_SH} ./histexp7.sub

--------------------------------------------------------------------------------
---
(command (word "LC_ALL=C"))
(command (word "LANG=C"))
(command (word "trap") (word "'rm $TMPDIR/newhistory'") (word "0"))
(command (word "file=bax"))
(command (word "histchars='!^#'"))
(command (word "unset") (word "HISTFILESIZE") (word "HISTTIMEFORMAT"))
(command (word "history") (word "-c"))
(command (word "HISTFILE=history.list"))
(command (word "HISTCONTROL=ignoreboth"))
(command (word "HISTIGNORE='&:#*:history*:fc*'"))
(command (word "HISTSIZE=32"))
(command (word "shopt") (word "-s") (word "cmdhist"))
(command (word "set") (word "-o") (word "history"))
(command (word "history") (word "-p") (word "'!!'"))
(command (word "history") (word "-p") (word "'!!:z'"))
(command (word "history"))
(command (word "HISTFILE=$TMPDIR/newhistory"))
(command (word "history") (word "-a"))
(command (word "history") (word "-w"))
(command (word "history") (word "-s") (word "\"echo line 2 for history\""))
(command (word "history"))
(command (word "history") (word "-p") (word "'!e'"))
(command (word "history") (word "-p") (word "'!!'"))
(command (word "set") (word "-H"))
(command (word "!!"))
(command (word "!e"))
(command (word "history"))
(command (word "echo") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "!?ch?"))
(command (word "!-2"))
(command (word "^2^8"))
(command (word "!2"))
(command (word "echo") (word "!-1:0:t"))
(command (word "echo") (word "!-2:0:h"))
(command (word "echo") (word "!?d?:5"))
(command (word "echo") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "echo") (word "!-1:2-$"))
(command (word "echo") (word "!-2:2-4"))
(command (word "echo") (word "!-2:3*"))
(command (word "echo") (word "!!:*"))
(command (word "echo") (word "!?a?:2-"))
(command (word "echo") (word "file.c"))
(command (word "echo") (word "!!:$:r"))
(command (word "echo") (word "!-2:$:e"))
(command (word "echo") (word "!-3:$:r:q"))
(command (word "echo") (word "$file.c"))
(command (word "echo") (word "!!:$:r"))
(command (word "echo") (word "!-2:^:e"))
(command (word "echo") (word "!-3:$:r:q"))
(command (word "echo") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "echo") (word "!!:1-$:x"))
(command (word "echo") (word "!-2:1-$:q"))
(command (word "echo") (word "foo.c") (word "foo.o") (word "foo.html") (word "foo.h"))
(command (word "!!:s/foo/bar/"))
(command (word "!-2:gs/foo/bar/"))
(background (command (word "!!:gs/bar/x")) (command (word "/")))
(background (command (word "!-2:g")))
(command (word "!!:gs+bar+whix+"))
(command (word "!!:p"))
(command (word "echo") (word "!?.o?:%:r:q"))
(command (word "!!:0") (word "!?.h?:%:q"))
(command (word "!!:-$"))
(command (word "!:-$"))
(command (word "history"))
(command (word "echo") (word "'!!'"))
(command (word "echo") (word "\\!\\!"))
(command (word "echo") (word "'!!'") (word "!!:*"))
(command (word "history") (word "-c"))
(command (word "unset") (word "HISTFILE"))
(case (word "p") (pattern ((word "[!A-Z]")) (command (word "echo") (word "ok") (word "1"))))
(command (word "var1='ok 2'"))
(command (word "var2=var1"))
(command (word "echo") (word "${!var2}"))
(command (word "echo") (word "ok") (word "3"))
(command (word "shopt") (word "a") (word "b") (word "c") (word "d") (redirect ">" "/dev/null"))
(command (word "echo") (word "!shopt-1"))
(command (word "echo") (word "!shopt*"))
(command (word "echo") (word "one") (word "two") (word "three") (word "four"))
(semi (command (word "echo") (word "!:2:p")) (command (word "echo") (word "!$")))
(command (word "echo") (word "one") (word "two") (word "three") (word "four"))
(semi (command (word "echo") (word "!$")) (command (word "echo") (word "!:2:p")))
(command (word "echo") (word "$((1+2))"))
(command (word "echo") (word "!!:1"))
(command (word "${THIS_SH}") (word "./histexp1.sub"))
(command (word "${THIS_SH}") (word "./histexp2.sub"))
(command (word "${THIS_SH}") (word "./histexp3.sub"))
(command (word "${THIS_SH}") (word "./histexp4.sub"))
(command (word "${THIS_SH}") (word "./histexp5.sub"))
(command (word "${THIS_SH}") (word "./histexp6.sub"))
(command (word "${THIS_SH}") (word "./histexp7.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== history
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
trap 'rm $TMPDIR/newhistory' 0

# bad options
history -x
# cannot use -r and -w at the same time
history -r -w /dev/null

# bad option
fc -v

unset HISTFILESIZE

# all of these should result in an empty history list
history -c
history -r /dev/null
history -n /dev/null
history -c

HISTFILE=history.list
HISTCONTROL=ignoreboth
HISTIGNORE='&:history*:fc*'
HISTSIZE=32
export HISTIGNORE

shopt -s cmdhist
set -o history

history

fc -l
fc -nl

fc -lr
fc -nlr

history -s "echo line for history"
history

history -p '!!'
history -p	# this succeeds silently

fc -nl

HISTFILE=$TMPDIR/newhistory
history -a
echo displaying \$HISTFILE after history -a
cat $HISTFILE

history
history -w
cat $HISTFILE

history -s "echo line 2 for history"
history
history -p '!e'
history -p '!!'

# this should show up as one history entry
for x in one two three
do
	:
done
history

# just a basic test.  a full test suite for history expansion should be
# created
set -H
!!
!e

unset HISTSIZE
unset HISTFILE

fc -l 4
fc -l 4 8

# now an out-of-range error because of the one=two not found in history
fc -l one=two three=four 502

history 4

shopt -so history
shopt -s expand_aliases

alias r="fc -s"

echo aa ab ac

r a=x
r x=4 b=8

# this had better fail with `no command found'
r cc

unalias -a
alias

# these two blocks had better both result in the same output
echo aa
echo bb
echo cc
fc -e cat

echo aa
echo bb
echo cc
fc -e cat -1

set +o history

shopt -q -o history
echo $?

${THIS_SH} ./history1.sub
rm -f $TMPDIR/foohist-*

${THIS_SH} ./history2.sub
${THIS_SH} ./history3.sub
${THIS_SH} ./history4.sub
${THIS_SH} ./history5.sub
${THIS_SH} ./history6.sub
${THIS_SH} ./history7.sub
${THIS_SH} ./history8.sub
${THIS_SH} ./history9.sub

--------------------------------------------------------------------------------
---
(command (word "trap") (word "'rm $TMPDIR/newhistory'") (word "0"))
(command (word "history") (word "-x"))
(command (word "history") (word "-r") (word "-w") (word "/dev/null"))
(command (word "fc") (word "-v"))
(command (word "unset") (word "HISTFILESIZE"))
(command (word "history") (word "-c"))
(command (word "history") (word "-r") (word "/dev/null"))
(command (word "history") (word "-n") (word "/dev/null"))
(command (word "history") (word "-c"))
(command (word "HISTFILE=history.list"))
(command (word "HISTCONTROL=ignoreboth"))
(command (word "HISTIGNORE='&:history*:fc*'"))
(command (word "HISTSIZE=32"))
(command (word "export") (word "HISTIGNORE"))
(command (word "shopt") (word "-s") (word "cmdhist"))
(command (word "set") (word "-o") (word "history"))
(command (word "history"))
(command (word "fc") (word "-l"))
(command (word "fc") (word "-nl"))
(command (word "fc") (word "-lr"))
(command (word "fc") (word "-nlr"))
(command (word "history") (word "-s") (word "\"echo line for history\""))
(command (word "history"))
(command (word "history") (word "-p") (word "'!!'"))
(command (word "history") (word "-p"))
(command (word "fc") (word "-nl"))
(command (word "HISTFILE=$TMPDIR/newhistory"))
(command (word "history") (word "-a"))
(command (word "echo") (word "displaying") (word "\\$HISTFILE") (word "after") (word "history") (word "-a"))
(command (word "cat") (word "$HISTFILE"))
(command (word "history"))
(command (word "history") (word "-w"))
(command (word "cat") (word "$HISTFILE"))
(command (word "history") (word "-s") (word "\"echo line 2 for history\""))
(command (word "history"))
(command (word "history") (word "-p") (word "'!e'"))
(command (word "history") (word "-p") (word "'!!'"))
(for (word "x") (in (word "one") (word "two") (word "three")) (command (word ":")))
(command (word "history"))
(command (word "set") (word "-H"))
(command (word "!!"))
(command (word "!e"))
(command (word "unset") (word "HISTSIZE"))
(command (word "unset") (word "HISTFILE"))
(command (word "fc") (word "-l") (word "4"))
(command (word "fc") (word "-l") (word "4") (word "8"))
(command (word "fc") (word "-l") (word "one=two") (word "three=four") (word "502"))
(command (word "history") (word "4"))
(command (word "shopt") (word "-so") (word "history"))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "r=\"fc -s\""))
(command (word "echo") (word "aa") (word "ab") (word "ac"))
(command (word "r") (word "a=x"))
(command (word "r") (word "x=4") (word "b=8"))
(command (word "r") (word "cc"))
(command (word "unalias") (word "-a"))
(command (word "alias"))
(command (word "echo") (word "aa"))
(command (word "echo") (word "bb"))
(command (word "echo") (word "cc"))
(command (word "fc") (word "-e") (word "cat"))
(command (word "echo") (word "aa"))
(command (word "echo") (word "bb"))
(command (word "echo") (word "cc"))
(command (word "fc") (word "-e") (word "cat") (word "-1"))
(command (word "set") (word "+o") (word "history"))
(command (word "shopt") (word "-q") (word "-o") (word "history"))
(command (word "echo") (word "$?"))
(command (word "${THIS_SH}") (word "./history1.sub"))
(command (word "rm") (word "-f") (word "$TMPDIR/foohist-*"))
(command (word "${THIS_SH}") (word "./history2.sub"))
(command (word "${THIS_SH}") (word "./history3.sub"))
(command (word "${THIS_SH}") (word "./history4.sub"))
(command (word "${THIS_SH}") (word "./history5.sub"))
(command (word "${THIS_SH}") (word "./history6.sub"))
(command (word "${THIS_SH}") (word "./history7.sub"))
(command (word "${THIS_SH}") (word "./history8.sub"))
(command (word "${THIS_SH}") (word "./history9.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== ifs-posix
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Usage: $SHELL ifs.sh
#
# This script generates 6856 tests for the set(1) and read(1)
# builtins w.r.t. IFS whitespace and non-whitespace characters.
# Each failed test produces one line on the standard output that
# contains the test along with the expected and actual results.
# The last output line contains the test result counts.  ordered>0
# are the number of tests where IFS=": " produced different results
# than IFS=" :".  If a test fails the same way for IFS=": " and
# IFS=" :" then the second output line is suppressed.

TESTS=6856

ksh_read=0
echo 1 | read ksh_read
ksh_arith=0
eval '((ksh_arith+=1))' 2>/dev/null

failed=0
ordered=0
passed=0

split()
{
	i=$1 s=$2 r=$3 S='' R=''
	for ifs in ': ' ' :'
	do	IFS=$ifs
		set x $i
		shift
		IFS=' '
		g="[$#]"
		while	:
		do	case $# in
			0)	break ;;
			esac
			g="$g($1)"
			shift
		done
		case $g in
		"$s")	case $ksh_arith in
			1)	((passed+=1)) ;;
			*)	passed=`expr $passed + 1` ;;
			esac
			case $S in
			'')	S=$g
				;;
			"$g")	;;
			*)	case $ksh_arith in
				1)	((ordered+=1)) ;;
				*)	ordered=`expr $ordered + 1` ;;
				esac
				;;
			esac
			;;
		"$S")	case $ksh_arith in
			1)	((failed+=1)) ;;
			*)	failed=`expr $failed + 1` ;;
			esac
			;;
		*)	case $ksh_arith in
			1)	((failed+=1)) ;;
			*)	failed=`expr $failed + 1` ;;
			esac
			case $s in
			"$S")	;;
			?0*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#]\" # expected \"$s\" got \"$g\"" ;;
			?1*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)\" # expected \"$s\" got \"$g\"" ;;
			?2*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)\" # expected \"$s\" got \"$g\"" ;;
			?3*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)(\$3)\" # expected \"$s\" got \"$g\"" ;;
			*)	echo TEST ERROR i="'$i'" s="'$s'" ;;
			esac
			case $S in
			'')	S=$g
				;;
			"$g")	;;
			*)	case $ksh_arith in
				1)	((ordered+=1)) ;;
				*)	ordered=`expr $ordered + 1` ;;
				esac
				;;
			esac
		esac
		case $ksh_read in
		1)	echo "$i" | IFS=$ifs read x y; g="($x)($y)" ;;
		*)	g=`export ifs; echo "$i" | ( IFS=$ifs; read x y; echo "($x)($y)" )` ;;
		esac
		case $g in
		"$r")	case $ksh_arith in
			1)	((passed+=1)) ;;
			*)	passed=`expr $passed + 1` ;;
			esac
			case $R in
			'')	R=$g
				;;
			"$g")	;;
			*)	case $ksh_arith in
				1)	((ordered+=1)) ;;
				*)	ordered=`expr $ordered + 1` ;;
				esac
				;;
			esac
			;;
		"$R")	case $ksh_arith in
			1)	((failed+=1)) ;;
			*)	failed=`expr $failed + 1` ;;
			esac
			;;
		*)	case $ksh_arith in
			1)	((failed+=1)) ;;
			*)	failed=`expr $failed + 1` ;;
			esac
			case $r in
			"$R")	;;
			*)	echo "echo \"$i\" | ( IFS=\"$ifs\" read x y; echo \"(\$x)(\$y)\" ) # expected \"$r\" got \"$g\"" ;;
			esac
			case $R in
			'')	R=$g
				;;
			"$g")	;;
			*)	case $ksh_arith in
				1)	((ordered+=1)) ;;
				*)	ordered=`expr $ordered + 1` ;;
				esac
				;;
			esac
			;;
		esac
	done
}

for str in 	\
	'-'	\
	'a'	\
	'- -'	\
	'- a'	\
	'a -'	\
	'a b'	\
	'- - -'	\
	'- - a'	\
	'- a -'	\
	'- a b'	\
	'a - -'	\
	'a - b'	\
	'a b -'	\
	'a b c'	\

do
	IFS=' '
	set x $str

	shift
	case $# in
	0)	continue ;;
	esac

	f1=$1
	case $f1 in
	'-')	f1='' ;;
	esac

	shift
	case $# in
	0)	for d0 in '' ' '
		do
			for d1 in '' ' ' ':' ' :' ': ' ' : '
			do
				case $f1$d1 in
				'')	split "$d0$f1$d1" "[0]" "()()" ;;
				' ')	;;
				*)	split "$d0$f1$d1" "[1]($f1)" "($f1)()" ;;
				esac
			done
		done
		continue
		;;
	esac
	f2=$1
	case $f2 in
	'-')	f2='' ;;
	esac

	shift
	case $# in
	0)	for d0 in '' ' '
		do
			for d1 in ' ' ':' ' :' ': ' ' : '
			do
				case ' ' in
				$f1$d1|$d1$f2)	continue ;;
				esac
				for d2 in '' ' ' ':' ' :' ': ' ' : '
				do
					case $f2$d2 in
					'')	split "$d0$f1$d1$f2$d2" "[1]($f1)" "($f1)()" ;;
					' ')	;;
					*)	split "$d0$f1$d1$f2$d2" "[2]($f1)($f2)" "($f1)($f2)" ;;
					esac
				done
			done
		done
		continue
		;;
	esac
	f3=$1
	case $f3 in
	'-')	f3='' ;;
	esac

	shift
	case $# in
	0)	for d0 in '' ' '
		do
			for d1 in ':' ' :' ': ' ' : '
			do
				case ' ' in
				$f1$d1|$d1$f2)	continue ;;
				esac
				for d2 in ' ' ':' ' :' ': ' ' : '
				do
					case $f2$d2 in
					' ')	continue ;;
					esac
					case ' ' in
					$f2$d2|$d2$f3)	continue ;;
					esac
					for d3 in '' ' ' ':' ' :' ': ' ' : '
					do
						case $f3$d3 in
						'')	split "$d0$f1$d1$f2$d2$f3$d3" "[2]($f1)($f2)" "($f1)($f2)" ;;
						' ')	;;
						*)	x=$f2$d2$f3$d3
							x=${x#' '}
							x=${x%' '}
							split "$d0$f1$d1$f2$d2$f3$d3" "[3]($f1)($f2)($f3)" "($f1)($x)"
							;;
						esac
					done
				done
			done
		done
		continue
		;;
	esac
done
case $ksh_arith in
1)	((tests=passed+failed)) ;;
*)	tests=`expr $passed + $failed` ;;
esac
case $ordered in
0)	ordered="" ;;
*)	ordered=" ordered $ordered" ;;
esac
case $tests in
$TESTS)	fatal="" ;;
*)	fatal=" -- fundamental IFS error -- $TESTS tests expected"
esac
echo "# tests $tests passed $passed failed $failed$ordered$fatal"

--------------------------------------------------------------------------------
---
(command (word "TESTS=6856"))
(command (word "ksh_read=0"))
(pipe (command (word "echo") (word "1")) (command (word "read") (word "ksh_read")))
(command (word "ksh_arith=0"))
(command (word "eval") (word "'((ksh_arith+=1))'") (redirect ">" "/dev/null"))
(command (word "failed=0"))
(command (word "ordered=0"))
(command (word "passed=0"))
(function "split" (brace-group (semi (command (word "i=$1") (word "s=$2") (word "r=$3") (word "S=''") (word "R=''")) (for (word "ifs") (in (word "': '") (word "' :'")) (semi (semi (semi (semi (semi (semi (semi (semi (command (word "IFS=$ifs")) (command (word "set") (word "x") (word "$i"))) (command (word "shift"))) (command (word "IFS=' '"))) (command (word "g=\"[$#]\""))) (while (command (word ":")) (semi (semi (case (word "$#") (pattern ((word "0")) (command (word "break")))) (command (word "g=\"$g($1)\""))) (command (word "shift"))))) (case (word "$g") (pattern ((word "\"$s\"")) (semi (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "passed+=1"))) (pattern ((word "*")) (command (word "passed=`expr $passed + 1`")))) (case (word "$S") (pattern ((word "''")) (command (word "S=$g"))) (pattern ((word "\"$g\"")) ()) (pattern ((word "*")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "ordered+=1"))) (pattern ((word "*")) (command (word "ordered=`expr $ordered + 1`")))))))) (pattern ((word "\"$S\"")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "failed+=1"))) (pattern ((word "*")) (command (word "failed=`expr $failed + 1`"))))) (pattern ((word "*")) (semi (semi (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "failed+=1"))) (pattern ((word "*")) (command (word "failed=`expr $failed + 1`")))) (case (word "$s") (pattern ((word "\"$S\"")) ()) (pattern ((word "?0*")) (command (word "echo") (word "\"IFS=\\\"$ifs\\\"; x=\\\"$i\\\"; set x \\$x; shift; echo \\\"[\\$#]\\\" # expected \\\"$s\\\" got \\\"$g\\\"\""))) (pattern ((word "?1*")) (command (word "echo") (word "\"IFS=\\\"$ifs\\\"; x=\\\"$i\\\"; set x \\$x; shift; echo \\\"[\\$#](\\$1)\\\" # expected \\\"$s\\\" got \\\"$g\\\"\""))) (pattern ((word "?2*")) (command (word "echo") (word "\"IFS=\\\"$ifs\\\"; x=\\\"$i\\\"; set x \\$x; shift; echo \\\"[\\$#](\\$1)(\\$2)\\\" # expected \\\"$s\\\" got \\\"$g\\\"\""))) (pattern ((word "?3*")) (command (word "echo") (word "\"IFS=\\\"$ifs\\\"; x=\\\"$i\\\"; set x \\$x; shift; echo \\\"[\\$#](\\$1)(\\$2)(\\$3)\\\" # expected \\\"$s\\\" got \\\"$g\\\"\""))) (pattern ((word "*")) (command (word "echo") (word "TEST") (word "ERROR") (word "i=\"'$i'\"") (word "s=\"'$s'\""))))) (case (word "$S") (pattern ((word "''")) (command (word "S=$g"))) (pattern ((word "\"$g\"")) ()) (pattern ((word "*")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "ordered+=1"))) (pattern ((word "*")) (command (word "ordered=`expr $ordered + 1`")))))))))) (case (word "$ksh_read") (pattern ((word "1")) (semi (pipe (command (word "echo") (word "\"$i\"")) (command (word "IFS=$ifs") (word "read") (word "x") (word "y"))) (command (word "g=\"($x)($y)\"")))) (pattern ((word "*")) (command (word "g=`export ifs; echo \"$i\" | ( IFS=$ifs; read x y; echo \"($x)($y)\" )`"))))) (case (word "$g") (pattern ((word "\"$r\"")) (semi (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "passed+=1"))) (pattern ((word "*")) (command (word "passed=`expr $passed + 1`")))) (case (word "$R") (pattern ((word "''")) (command (word "R=$g"))) (pattern ((word "\"$g\"")) ()) (pattern ((word "*")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "ordered+=1"))) (pattern ((word "*")) (command (word "ordered=`expr $ordered + 1`")))))))) (pattern ((word "\"$R\"")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "failed+=1"))) (pattern ((word "*")) (command (word "failed=`expr $failed + 1`"))))) (pattern ((word "*")) (semi (semi (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "failed+=1"))) (pattern ((word "*")) (command (word "failed=`expr $failed + 1`")))) (case (word "$r") (pattern ((word "\"$R\"")) ()) (pattern ((word "*")) (command (word "echo") (word "\"echo \\\"$i\\\" | ( IFS=\\\"$ifs\\\" read x y; echo \\\"(\\$x)(\\$y)\\\" ) # expected \\\"$r\\\" got \\\"$g\\\"\""))))) (case (word "$R") (pattern ((word "''")) (command (word "R=$g"))) (pattern ((word "\"$g\"")) ()) (pattern ((word "*")) (case (word "$ksh_arith") (pattern ((word "1")) (arith (word "ordered+=1"))) (pattern ((word "*")) (command (word "ordered=`expr $ordered + 1`"))))))))))))))
(for (word "str") (in (word "'-'") (word "'a'") (word "'- -'") (word "'- a'") (word "'a -'") (word "'a b'") (word "'- - -'") (word "'- - a'") (word "'- a -'") (word "'- a b'") (word "'a - -'") (word "'a - b'") (word "'a b -'") (word "'a b c'")) (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "IFS=' '")) (command (word "set") (word "x") (word "$str"))) (command (word "shift"))) (case (word "$#") (pattern ((word "0")) (command (word "continue"))))) (command (word "f1=$1"))) (case (word "$f1") (pattern ((word "'-'")) (command (word "f1=''"))))) (command (word "shift"))) (case (word "$#") (pattern ((word "0")) (semi (for (word "d0") (in (word "''") (word "' '")) (for (word "d1") (in (word "''") (word "' '") (word "':'") (word "' :'") (word "': '") (word "' : '")) (case (word "$f1$d1") (pattern ((word "''")) (command (word "split") (word "\"$d0$f1$d1\"") (word "\"[0]\"") (word "\"()()\""))) (pattern ((word "' '")) ()) (pattern ((word "*")) (command (word "split") (word "\"$d0$f1$d1\"") (word "\"[1]($f1)\"") (word "\"($f1)()\"")))))) (command (word "continue")))))) (command (word "f2=$1"))) (case (word "$f2") (pattern ((word "'-'")) (command (word "f2=''"))))) (command (word "shift"))) (case (word "$#") (pattern ((word "0")) (semi (for (word "d0") (in (word "''") (word "' '")) (for (word "d1") (in (word "' '") (word "':'") (word "' :'") (word "': '") (word "' : '")) (semi (case (word "' '") (pattern ((word "$f1$d1") (word "$d1$f2")) (command (word "continue")))) (for (word "d2") (in (word "''") (word "' '") (word "':'") (word "' :'") (word "': '") (word "' : '")) (case (word "$f2$d2") (pattern ((word "''")) (command (word "split") (word "\"$d0$f1$d1$f2$d2\"") (word "\"[1]($f1)\"") (word "\"($f1)()\""))) (pattern ((word "' '")) ()) (pattern ((word "*")) (command (word "split") (word "\"$d0$f1$d1$f2$d2\"") (word "\"[2]($f1)($f2)\"") (word "\"($f1)($f2)\"")))))))) (command (word "continue")))))) (command (word "f3=$1"))) (case (word "$f3") (pattern ((word "'-'")) (command (word "f3=''"))))) (command (word "shift"))) (case (word "$#") (pattern ((word "0")) (semi (for (word "d0") (in (word "''") (word "' '")) (for (word "d1") (in (word "':'") (word "' :'") (word "': '") (word "' : '")) (semi (case (word "' '") (pattern ((word "$f1$d1") (word "$d1$f2")) (command (word "continue")))) (for (word "d2") (in (word "' '") (word "':'") (word "' :'") (word "': '") (word "' : '")) (semi (semi (case (word "$f2$d2") (pattern ((word "' '")) (command (word "continue")))) (case (word "' '") (pattern ((word "$f2$d2") (word "$d2$f3")) (command (word "continue"))))) (for (word "d3") (in (word "''") (word "' '") (word "':'") (word "' :'") (word "': '") (word "' : '")) (case (word "$f3$d3") (pattern ((word "''")) (command (word "split") (word "\"$d0$f1$d1$f2$d2$f3$d3\"") (word "\"[2]($f1)($f2)\"") (word "\"($f1)($f2)\""))) (pattern ((word "' '")) ()) (pattern ((word "*")) (semi (semi (semi (command (word "x=$f2$d2$f3$d3")) (command (word "x=${x#' '}"))) (command (word "x=${x%' '}"))) (command (word "split") (word "\"$d0$f1$d1$f2$d2$f3$d3\"") (word "\"[3]($f1)($f2)($f3)\"") (word "\"($f1)($x)\""))))))))))) (command (word "continue")))))))
(case (word "$ksh_arith") (pattern ((word "1")) (arith (word "tests=passed+failed"))) (pattern ((word "*")) (command (word "tests=`expr $passed + $failed`"))))
(case (word "$ordered") (pattern ((word "0")) (command (word "ordered=\"\""))) (pattern ((word "*")) (command (word "ordered=\" ordered $ordered\""))))
(case (word "$tests") (pattern ((word "$TESTS")) (command (word "fatal=\"\""))) (pattern ((word "*")) (command (word "fatal=\" -- fundamental IFS error -- $TESTS tests expected\""))))
(command (word "echo") (word "\"# tests $tests passed $passed failed $failed$ordered$fatal\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== ifs
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
OIFS="$IFS"
IFS=":$IFS"
eval foo="a:b:c"
IFS="$OIFS"
echo $foo

OIFS=$IFS
IFS=":$IFS"
foo=$(echo a:b:c)
IFS=$OIFS

for i in $foo
do
	echo $i
done

OIFS=$IFS
IFS=":$IFS"
foo=`echo a:b:c`
IFS=$OIFS

for i in $foo
do
	echo $i
done

DEFIFS=$' \t\n'

# local copy of IFS that shadows global version
function f
{
	typeset IFS=:

	echo $1
}

function ff
{
	echo $1
}

f a:b:c:d:e
x=a:b:c:d:e
echo $x

IFS=: ff a:b:c:d:e
echo $x

# doesn't get word split
IFS=$DEFIFS
# variable assignment doesn't use new value for word splitting
IFS=: echo $x
# but does this time because of the eval
IFS=: eval echo \$x

# in posix mode, assignments preceding special builtins and functions are global
set -o posix
IFS=: export x
echo $x

IFS="$DEFIFS"

${THIS_SH} ./ifs1.sub

--------------------------------------------------------------------------------
---
(command (word "OIFS=\"$IFS\""))
(command (word "IFS=\":$IFS\""))
(command (word "eval") (word "foo=\"a:b:c\""))
(command (word "IFS=\"$OIFS\""))
(command (word "echo") (word "$foo"))
(command (word "OIFS=$IFS"))
(command (word "IFS=\":$IFS\""))
(command (word "foo=$(echo a:b:c)"))
(command (word "IFS=$OIFS"))
(for (word "i") (in (word "$foo")) (command (word "echo") (word "$i")))
(command (word "OIFS=$IFS"))
(command (word "IFS=\":$IFS\""))
(command (word "foo=`echo a:b:c`"))
(command (word "IFS=$OIFS"))
(for (word "i") (in (word "$foo")) (command (word "echo") (word "$i")))
(command (word "DEFIFS=' \t\n'"))
(function "f" (brace-group (semi (command (word "typeset") (word "IFS=:")) (command (word "echo") (word "$1")))))
(function "ff" (brace-group (command (word "echo") (word "$1"))))
(command (word "f") (word "a:b:c:d:e"))
(command (word "x=a:b:c:d:e"))
(command (word "echo") (word "$x"))
(command (word "IFS=:") (word "ff") (word "a:b:c:d:e"))
(command (word "echo") (word "$x"))
(command (word "IFS=$DEFIFS"))
(command (word "IFS=:") (word "echo") (word "$x"))
(command (word "IFS=:") (word "eval") (word "echo") (word "\\$x"))
(command (word "set") (word "-o") (word "posix"))
(command (word "IFS=:") (word "export") (word "x"))
(command (word "echo") (word "$x"))
(command (word "IFS=\"$DEFIFS\""))
(command (word "${THIS_SH}") (word "./ifs1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== intl
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
export LC_ALL=en_US.UTF-8

a=$'\303\251'

echo "$a"

echo ${#a}

b=$'A\303\251B'

echo "$b"

echo ${b: -1}

c=AeB

echo ${c: -1}

unset a
a=$(printf '%b' 'A\303\251B')
IFS=$(printf '%b' '\303\251')

case "$a" in
"A${IFS}B")	echo ok 1 ;;
*)		echo bad 1 ;;
esac

set $a

case $1 in
A)		echo ok 2 ;;
*)		echo bad 2 ;;
esac

set a b

printf '%s\n' "$*"

. ./test-glue-functions

printf '%s' "$*" | od -b | _intl_normalize_spaces

# display differences make this problematic
${THIS_SH} ./intl1.sub

# this tests both international handling in printf and temporary environments
${THIS_SH} ./intl2.sub

# test splitting on characters instead of bytes
${THIS_SH} ./intl3.sub

${THIS_SH} ./unicode1.sub # 2>/dev/null
${THIS_SH} ./unicode2.sub

${THIS_SH} ./unicode3.sub 2>&1

${THIS_SH} ./intl4.sub

--------------------------------------------------------------------------------
---
(command (word "export") (word "LC_ALL=en_US.UTF-8"))
(command (word "a=''"))
(command (word "echo") (word "\"$a\""))
(command (word "echo") (word "${#a}"))
(command (word "b='AB'"))
(command (word "echo") (word "\"$b\""))
(command (word "echo") (word "${b: -1}"))
(command (word "c=AeB"))
(command (word "echo") (word "${c: -1}"))
(command (word "unset") (word "a"))
(command (word "a=$(printf '%b' 'A\\303\\251B')"))
(command (word "IFS=$(printf '%b' '\\303\\251')"))
(case (word "\"$a\"") (pattern ((word "\"A${IFS}B\"")) (command (word "echo") (word "ok") (word "1"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "1"))))
(command (word "set") (word "$a"))
(case (word "$1") (pattern ((word "A")) (command (word "echo") (word "ok") (word "2"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "2"))))
(command (word "set") (word "a") (word "b"))
(command (word "printf") (word "'%s\\n'") (word "\"$*\""))
(command (word ".") (word "./test-glue-functions"))
(pipe (command (word "printf") (word "'%s'") (word "\"$*\"")) (pipe (command (word "od") (word "-b")) (command (word "_intl_normalize_spaces"))))
(command (word "${THIS_SH}") (word "./intl1.sub"))
(command (word "${THIS_SH}") (word "./intl2.sub"))
(command (word "${THIS_SH}") (word "./intl3.sub"))
(command (word "${THIS_SH}") (word "./unicode1.sub"))
(command (word "${THIS_SH}") (word "./unicode2.sub"))
(command (word "${THIS_SH}") (word "./unicode3.sub") (redirect ">&" 1))
(command (word "${THIS_SH}") (word "./intl4.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== invert
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# tests of return value inversion
# placeholder for future expansion

# user subshells (...) did this wrong in bash versions before 2.04

! ( echo hello | grep h >/dev/null 2>&1 ); echo $?
! echo hello | grep h >/dev/null 2>&1 ; echo $?

! true ; echo $?
! false; echo $?

! (false) ; echo $?
! (true); echo $?

! true | false ; echo $?
! false | true ; echo $?

! (true | false) ; echo $?
! (false | true) ; echo $?

--------------------------------------------------------------------------------
---
(semi (negation (subshell (pipe (command (word "echo") (word "hello")) (command (word "grep") (word "h") (redirect ">" "/dev/null") (redirect ">&" 1))))) (command (word "echo") (word "$?")))
(semi (negation (pipe (command (word "echo") (word "hello")) (command (word "grep") (word "h") (redirect ">" "/dev/null") (redirect ">&" 1)))) (command (word "echo") (word "$?")))
(semi (negation (command (word "true"))) (command (word "echo") (word "$?")))
(semi (negation (command (word "false"))) (command (word "echo") (word "$?")))
(semi (negation (subshell (command (word "false")))) (command (word "echo") (word "$?")))
(semi (negation (subshell (command (word "true")))) (command (word "echo") (word "$?")))
(semi (negation (pipe (command (word "true")) (command (word "false")))) (command (word "echo") (word "$?")))
(semi (negation (pipe (command (word "false")) (command (word "true")))) (command (word "echo") (word "$?")))
(semi (negation (subshell (pipe (command (word "true")) (command (word "false"))))) (command (word "echo") (word "$?")))
(semi (negation (subshell (pipe (command (word "false")) (command (word "true"))))) (command (word "echo") (word "$?")))
(command (word "--------------------------------------------------------------------------------"))
---

=== invocation
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

: ${THIS_SH:=./bash}

# invocation modes and errors

${THIS_SH} .

#${THIS_SH} --version -c 'exit 0' bash
#${THIS_SH} --help -c 'exit 0' bash

${THIS_SH} -c |& sed 's|^.*/bash|bash|'

${THIS_SH} --badopt |& sed 's|^.*/bash|bash|'
${THIS_SH} --initfile |& sed 's|^.*/bash|bash|'
${THIS_SH} -q |& sed 's|^.*/bash|bash|'

export BASH_ARGV0=this-bash
${THIS_SH} -c 'echo $0 $BASH_ARGV0'
unset BASH_ARGV0

{ ${THIS_SH} -c 'echo $-' bash | grep c >/dev/null; } && echo '$- for -c includes c'

# BASHOPTS
${THIS_SH} ./invocation1.sub
# SHELLOPTS
${THIS_SH} ./invocation2.sub

# rudimentary pretty-print tests
${THIS_SH} ./invocation3.sub

: ${TMPDIR:=/tmp}
TDIR=$TMPDIR/invocation-$$
mkdir $TDIR || exit 1
SAVEPWD=$PWD

echo 'echo this is bash_logout' > $TDIR/.bash_logout
HOME=$TDIR ${THIS_SH} --login -c 'logout'
rm -f $TDIR/.bash_logout

# script that ends with a comment and no newline
printf 'echo a # comment' > $TDIR/x23.in
${THIS_SH} $TDIR/x23.in
printf 'echo a' > $TDIR/x23.in
${THIS_SH} $TDIR/x23.in
rm -f $TDIR/x23.in

# script with invalid interpreter
cat > $TDIR/x23 <<EOF
#! nosuchfile
echo bad-interp
EOF
chmod +x $TDIR/x23

# this is fine
${THIS_SH} $TDIR/x23
command cd -L $TDIR
# but this results in a bad-interpreter error
./x23

# this should result in a cannot execute binary file error since ls is in $PATH
PATH=/bin:/usr/bin
${THIS_SH} ls |& sed 's|^.*: ||'

cd $SAVEPWD
rm -rf $TDIR

--------------------------------------------------------------------------------
---
(command (word ":") (word "${THIS_SH:=./bash}"))
(command (word "${THIS_SH}") (word "."))
(pipe (command (word "${THIS_SH}") (word "-c") (redirect ">&" 1)) (command (word "sed") (word "'s|^.*/bash|bash|'")))
(pipe (command (word "${THIS_SH}") (word "--badopt") (redirect ">&" 1)) (command (word "sed") (word "'s|^.*/bash|bash|'")))
(pipe (command (word "${THIS_SH}") (word "--initfile") (redirect ">&" 1)) (command (word "sed") (word "'s|^.*/bash|bash|'")))
(pipe (command (word "${THIS_SH}") (word "-q") (redirect ">&" 1)) (command (word "sed") (word "'s|^.*/bash|bash|'")))
(command (word "export") (word "BASH_ARGV0=this-bash"))
(command (word "${THIS_SH}") (word "-c") (word "'echo $0 $BASH_ARGV0'"))
(command (word "unset") (word "BASH_ARGV0"))
(and (brace-group (pipe (command (word "${THIS_SH}") (word "-c") (word "'echo $-'") (word "bash")) (command (word "grep") (word "c") (redirect ">" "/dev/null")))) (command (word "echo") (word "'$- for -c includes c'")))
(command (word "${THIS_SH}") (word "./invocation1.sub"))
(command (word "${THIS_SH}") (word "./invocation2.sub"))
(command (word "${THIS_SH}") (word "./invocation3.sub"))
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "TDIR=$TMPDIR/invocation-$$"))
(or (command (word "mkdir") (word "$TDIR")) (command (word "exit") (word "1")))
(command (word "SAVEPWD=$PWD"))
(command (word "echo") (word "'echo this is bash_logout'") (redirect ">" "$TDIR/.bash_logout"))
(command (word "HOME=$TDIR") (word "${THIS_SH}") (word "--login") (word "-c") (word "'logout'"))
(command (word "rm") (word "-f") (word "$TDIR/.bash_logout"))
(command (word "printf") (word "'echo a # comment'") (redirect ">" "$TDIR/x23.in"))
(command (word "${THIS_SH}") (word "$TDIR/x23.in"))
(command (word "printf") (word "'echo a'") (redirect ">" "$TDIR/x23.in"))
(command (word "${THIS_SH}") (word "$TDIR/x23.in"))
(command (word "rm") (word "-f") (word "$TDIR/x23.in"))
(command (word "cat") (redirect ">" "$TDIR/x23") (redirect "<<" "#! nosuchfile
echo bad-interp
"))
(command (word "chmod") (word "+x") (word "$TDIR/x23"))
(command (word "${THIS_SH}") (word "$TDIR/x23"))
(command (word "command") (word "cd") (word "-L") (word "$TDIR"))
(command (word "./x23"))
(command (word "PATH=/bin:/usr/bin"))
(pipe (command (word "${THIS_SH}") (word "ls") (redirect ">&" 1)) (command (word "sed") (word "'s|^.*: ||'")))
(command (word "cd") (word "$SAVEPWD"))
(command (word "rm") (word "-rf") (word "$TDIR"))
(command (word "--------------------------------------------------------------------------------"))
---

=== iquote
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# bug in bash up to and including bash-3.0 (including patches)
#
# problem is conflict between CTLNUL used internally to denote quoted null
# characters and its value (0x7f) appearing in the expansion of a variable
#
unset x
recho "xxx${x}yyy"

y=$'\177'
recho "xxx${y}yyy"

unset y

unset undef

set ""
recho ${undef-"x$*y"}

set $'\177'
recho ${undef-"x$*y"}

shift $#

f()
{
	recho "-${*-x}-"
}

f ''
f $'\177'

unset -f f

x=12345

recho "${x:6:1}"

x=
recho "${x:0:1}"

y=$'\177'
recho "${y:0:1}"

y=xxx$'\177'yyy
recho "${y:3:3}"

unset x y

eval tmp=`printf "$'\\\\\x%x'\n" 127`
printf "%#1x\n" "'$tmp"

x=$'\177'
printf "%#1x\n" "'$x"

a=127
eval c=\$\'\\$(printf '%o' $a)\'
printf "%#1x\n" "'$c"

recho "$c"
recho "$c"@
recho @"$c"@
recho @"$c"

recho "$c"
recho "$c@"
recho "@$c@"
recho "@$c"

unset tmp x a c

qtest()
{
	recho ${#q} "${q}" ${q}
}

q=$'\x7f'
qtest

q=${q}a
qtest

q=$'\x7fa'
qtest

q="${q}a"
qtest

unset -f qtest
unset q

set -- ''
recho "${*:1}"
recho  ${*:1}
recho  -${*:1}-
recho  -"${*:1}"-

set $'\177'
recho "${*:1}"
recho "-${*:1}-"

recho  ${*:1}
recho -${*:1}-

shift $#

DEL=`awk 'END{printf("%c", 0+127)}' </dev/null`
T1=a\ $DEL
T2="a $DEL"
set -- x $(echo $T1|wc -c) $(echo $T2|wc -c); shift
L1=$1; L2=$2
case "$L1/$L2" in
4/4) echo ok;;
*) echo CTLNUL bug: L1=$L1, L2=$L2;;
esac

x=$'\177'
recho "aaa${x}bbb"
recho ccc"${x}"ddd
recho eee"$x"fff
recho ggg"$(echo $x)"hhh

x=
recho "aaa${x}bbb"
recho ccc"${x}"ddd
recho eee"$x"fff
recho ggg"$(echo $x)"hhh

set -- $'\177'
recho "aaa${1}bbb"
recho ccc"${1}"ddd
recho eee"$1"fff
recho ggg"$(echo $1)"hhh

set -- ""
recho "aaa${1}bbb"
recho ccc"${1}"ddd
recho eee"$1"fff
recho ggg"$(echo $1)"hhh

recho aaa$'\177'bbb
recho ccc""ddd
recho "eeefff"
recho ggg"$(echo $'\177')"hhh

${THIS_SH} ./iquote1.sub

--------------------------------------------------------------------------------
---
(command (word "unset") (word "x"))
(command (word "recho") (word "\"xxx${x}yyy\""))
(command (word "y=''"))
(command (word "recho") (word "\"xxx${y}yyy\""))
(command (word "unset") (word "y"))
(command (word "unset") (word "undef"))
(command (word "set") (word "\"\""))
(command (word "recho") (word "${undef-\"x$*y\"}"))
(command (word "set") (word "''"))
(command (word "recho") (word "${undef-\"x$*y\"}"))
(command (word "shift") (word "$#"))
(function "f" (brace-group (command (word "recho") (word "\"-${*-x}-\""))))
(command (word "f") (word "''"))
(command (word "f") (word "''"))
(command (word "unset") (word "-f") (word "f"))
(command (word "x=12345"))
(command (word "recho") (word "\"${x:6:1}\""))
(command (word "x="))
(command (word "recho") (word "\"${x:0:1}\""))
(command (word "y=''"))
(command (word "recho") (word "\"${y:0:1}\""))
(command (word "y=xxx''yyy"))
(command (word "recho") (word "\"${y:3:3}\""))
(command (word "unset") (word "x") (word "y"))
(command (word "eval") (word "tmp=`printf \"$'\\\\\\\\\\x%x'\\n\" 127`"))
(command (word "printf") (word "\"%#1x\\n\"") (word "\"'$tmp\""))
(command (word "x=''"))
(command (word "printf") (word "\"%#1x\\n\"") (word "\"'$x\""))
(command (word "a=127"))
(command (word "eval") (word "c=\\$\\'\\\\$(printf '%o' $a)\\'"))
(command (word "printf") (word "\"%#1x\\n\"") (word "\"'$c\""))
(command (word "recho") (word "\"$c\""))
(command (word "recho") (word "\"$c\"@"))
(command (word "recho") (word "@\"$c\"@"))
(command (word "recho") (word "@\"$c\""))
(command (word "recho") (word "\"$c\""))
(command (word "recho") (word "\"$c@\""))
(command (word "recho") (word "\"@$c@\""))
(command (word "recho") (word "\"@$c\""))
(command (word "unset") (word "tmp") (word "x") (word "a") (word "c"))
(function "qtest" (brace-group (command (word "recho") (word "${#q}") (word "\"${q}\"") (word "${q}"))))
(command (word "q=''"))
(command (word "qtest"))
(command (word "q=${q}a"))
(command (word "qtest"))
(command (word "q='a'"))
(command (word "qtest"))
(command (word "q=\"${q}a\""))
(command (word "qtest"))
(command (word "unset") (word "-f") (word "qtest"))
(command (word "unset") (word "q"))
(command (word "set") (word "--") (word "''"))
(command (word "recho") (word "\"${*:1}\""))
(command (word "recho") (word "${*:1}"))
(command (word "recho") (word "-${*:1}-"))
(command (word "recho") (word "-\"${*:1}\"-"))
(command (word "set") (word "''"))
(command (word "recho") (word "\"${*:1}\""))
(command (word "recho") (word "\"-${*:1}-\""))
(command (word "recho") (word "${*:1}"))
(command (word "recho") (word "-${*:1}-"))
(command (word "shift") (word "$#"))
(command (word "DEL=`awk 'END{printf(\"%c\", 0+127)}' </dev/null`"))
(command (word "T1=a\\ $DEL"))
(command (word "T2=\"a $DEL\""))
(semi (command (word "set") (word "--") (word "x") (word "$(echo $T1 | wc -c)") (word "$(echo $T2 | wc -c)")) (command (word "shift")))
(semi (command (word "L1=$1")) (command (word "L2=$2")))
(case (word "\"$L1/$L2\"") (pattern ((word "4/4")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "CTLNUL") (word "bug:") (word "L1=$L1,") (word "L2=$L2"))))
(command (word "x=''"))
(command (word "recho") (word "\"aaa${x}bbb\""))
(command (word "recho") (word "ccc\"${x}\"ddd"))
(command (word "recho") (word "eee\"$x\"fff"))
(command (word "recho") (word "ggg\"$(echo $x)\"hhh"))
(command (word "x="))
(command (word "recho") (word "\"aaa${x}bbb\""))
(command (word "recho") (word "ccc\"${x}\"ddd"))
(command (word "recho") (word "eee\"$x\"fff"))
(command (word "recho") (word "ggg\"$(echo $x)\"hhh"))
(command (word "set") (word "--") (word "''"))
(command (word "recho") (word "\"aaa${1}bbb\""))
(command (word "recho") (word "ccc\"${1}\"ddd"))
(command (word "recho") (word "eee\"$1\"fff"))
(command (word "recho") (word "ggg\"$(echo $1)\"hhh"))
(command (word "set") (word "--") (word "\"\""))
(command (word "recho") (word "\"aaa${1}bbb\""))
(command (word "recho") (word "ccc\"${1}\"ddd"))
(command (word "recho") (word "eee\"$1\"fff"))
(command (word "recho") (word "ggg\"$(echo $1)\"hhh"))
(command (word "recho") (word "aaa''bbb"))
(command (word "recho") (word "ccc\"\"ddd"))
(command (word "recho") (word "\"eeefff\""))
(command (word "recho") (word "ggg\"$(echo '')\"hhh"))
(command (word "${THIS_SH}") (word "./iquote1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== jobs
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# test out %+, jobs -p, and $! agreement in a subshell first
${THIS_SH} ./jobs1.sub

# test out fg/bg failure in a subshell
${THIS_SH} ./jobs2.sub

# test out behavior of waiting for background pids -- bug in versions
# before 2.03
${THIS_SH} ./jobs3.sub

# test out behavior of using job control notation when job control is not
# active
${THIS_SH} ./jobs4.sub

# test out wait -n framework
${THIS_SH} ./jobs5.sub

# test out wait -f framework
${THIS_SH} ./jobs6.sub

${THIS_SH} ./jobs7.sub
# more disown -h tests
${THIS_SH} ./jobs8.sub

# wait interrupted by signal for which a trap has been set
${THIS_SH} ./jobs9.sub

jobs
echo $?

# a no-such-job error, since we can use job control notation without job control
wait %1

# make sure we can't fg a job started when job control was not active
sleep 20 &
pid=$!
fg %1
# make sure the killed processes don't cause a message
exec 5>&2
exec 2>/dev/null
kill -n9 $pid
wait $pid   # make sure we reap the processes while stderr is still redirected

sleep 30 &
pid2=$!
kill -sHUP $pid2
wait $pid2
exec 2>&5
unset -v pid pid2

# 
echo wait-for-pid
sleep 4 &
wait $!

echo wait-errors
wait 1-1
wait -- -4

echo wait-for-background-pids
sleep 2 &
sleep 4 &
wait

echo async list wait-for-background-pids
sleep 2 & sleep 4 &
wait

echo async list wait for child
sleep 2 & echo forked
wait

echo wait-when-no-children
wait

echo posix jobs output
${THIS_SH} -o posix -c 'sleep 1 & P=$! ; sleep 2; jobs; wait'

set -m

echo wait-for-job
sleep 3 &
wait %2		# this should be a no-such-job error
echo $?
wait %1

echo async list wait-for-job
sleep 2 & echo forked
wait %1

echo fg-bg 1
sleep 2 &
%1

echo fg-bg 2
sleep 2 &
fg %%

echo fg-bg 3
sleep 2 &
fg %s

echo fg-bg 4
sleep 2 &
fg %?ee

# these next two are error cases
echo fg-bg 5
sleep 2 &
fg %2		# this should be a no-such-job error
bg %1		# this should be a `bg background job?' error
wait

# these may someday mean to start the jobs, but not print the line
# describing the status, but for now they are errors
echo fg-bg 6
sleep 2 &
fg -s %1
bg -s %1
wait

# someday this may mean to disown all stopped jobs, but for now it is
# an error
disown -s

# this is an error -- the job with the pid that is the value of $! is
# retained only until a `wait' is performed
disown %1

# this, however, is an error
disown %2

# this is definitely an error
disown -h @12

echo wait-for-non-child
wait 1
echo $?

exit 1 | exit 2 | exit 3
echo $? -- ${PIPESTATUS[@]} -- ${PIPESTATUS[0]} - ${PIPESTATUS[1]} - ${PIPESTATUS[2]}

sleep 300 &
sleep300pid=$!
sleep 350 &
sleep 400 &

jobs

echo running jobs:
jobs -r

# should be an error
kill -n 1 %4
# should be an error
jobs %4
echo current job:
jobs %+
echo previous job:
jobs %-

kill -STOP %2
sleep 3	# give time for the shell to get the stop notification
echo after kill -STOP
echo running jobs:
jobs -r
echo stopped jobs:
jobs -s

disown %1

echo after disown
jobs
echo running jobs:
jobs -r
echo stopped jobs:
jobs -s

kill -s CONT %2
echo after kill -s CONT
echo running jobs:
jobs -r
echo stopped jobs:
jobs -s

kill -STOP %3
sleep 3	# give time for the shell to get the stop notification
echo after kill -STOP, backgrounding %3:
bg %3

disown -h %2

# make sure the killed processes don't cause a message
exec 5>&2
exec 2>/dev/null

echo killing...
kill -n 9 $sleep300pid
kill -n 9 %2 %3
wait	# make sure we reap the processes while stderr is still redirected
echo done

exec 2>&5

sleep 4 &
kill -STOP %1
sleep 2	# give time for the shell to get the stop notification
echo after KILL -STOP, foregrounding %1
fg %1
echo done

# these are all errors

set +m

jobs -q

suspend -z
suspend
suspend --

--------------------------------------------------------------------------------
---
(command (word "${THIS_SH}") (word "./jobs1.sub"))
(command (word "${THIS_SH}") (word "./jobs2.sub"))
(command (word "${THIS_SH}") (word "./jobs3.sub"))
(command (word "${THIS_SH}") (word "./jobs4.sub"))
(command (word "${THIS_SH}") (word "./jobs5.sub"))
(command (word "${THIS_SH}") (word "./jobs6.sub"))
(command (word "${THIS_SH}") (word "./jobs7.sub"))
(command (word "${THIS_SH}") (word "./jobs8.sub"))
(command (word "${THIS_SH}") (word "./jobs9.sub"))
(command (word "jobs"))
(command (word "echo") (word "$?"))
(command (word "wait") (word "%1"))
(background (command (word "sleep") (word "20")))
(command (word "pid=$!"))
(command (word "fg") (word "%1"))
(command (word "exec") (redirect ">&" 2))
(command (word "exec") (redirect ">" "/dev/null"))
(command (word "kill") (word "-n9") (word "$pid"))
(command (word "wait") (word "$pid"))
(background (command (word "sleep") (word "30")))
(command (word "pid2=$!"))
(command (word "kill") (word "-sHUP") (word "$pid2"))
(command (word "wait") (word "$pid2"))
(command (word "exec") (redirect ">&" 5))
(command (word "unset") (word "-v") (word "pid") (word "pid2"))
(command (word "echo") (word "wait-for-pid"))
(background (command (word "sleep") (word "4")))
(command (word "wait") (word "$!"))
(command (word "echo") (word "wait-errors"))
(command (word "wait") (word "1-1"))
(command (word "wait") (word "--") (word "-4"))
(command (word "echo") (word "wait-for-background-pids"))
(background (command (word "sleep") (word "2")))
(background (command (word "sleep") (word "4")))
(command (word "wait"))
(command (word "echo") (word "async") (word "list") (word "wait-for-background-pids"))
(background (background (command (word "sleep") (word "2")) (command (word "sleep") (word "4"))))
(command (word "wait"))
(command (word "echo") (word "async") (word "list") (word "wait") (word "for") (word "child"))
(background (command (word "sleep") (word "2")) (command (word "echo") (word "forked")))
(command (word "wait"))
(command (word "echo") (word "wait-when-no-children"))
(command (word "wait"))
(command (word "echo") (word "posix") (word "jobs") (word "output"))
(command (word "${THIS_SH}") (word "-o") (word "posix") (word "-c") (word "'sleep 1 & P=$! ; sleep 2; jobs; wait'"))
(command (word "set") (word "-m"))
(command (word "echo") (word "wait-for-job"))
(background (command (word "sleep") (word "3")))
(command (word "wait") (word "%2"))
(command (word "echo") (word "$?"))
(command (word "wait") (word "%1"))
(command (word "echo") (word "async") (word "list") (word "wait-for-job"))
(background (command (word "sleep") (word "2")) (command (word "echo") (word "forked")))
(command (word "wait") (word "%1"))
(command (word "echo") (word "fg-bg") (word "1"))
(background (command (word "sleep") (word "2")))
(command (word "%1"))
(command (word "echo") (word "fg-bg") (word "2"))
(background (command (word "sleep") (word "2")))
(command (word "fg") (word "%%"))
(command (word "echo") (word "fg-bg") (word "3"))
(background (command (word "sleep") (word "2")))
(command (word "fg") (word "%s"))
(command (word "echo") (word "fg-bg") (word "4"))
(background (command (word "sleep") (word "2")))
(command (word "fg") (word "%?ee"))
(command (word "echo") (word "fg-bg") (word "5"))
(background (command (word "sleep") (word "2")))
(command (word "fg") (word "%2"))
(command (word "bg") (word "%1"))
(command (word "wait"))
(command (word "echo") (word "fg-bg") (word "6"))
(background (command (word "sleep") (word "2")))
(command (word "fg") (word "-s") (word "%1"))
(command (word "bg") (word "-s") (word "%1"))
(command (word "wait"))
(command (word "disown") (word "-s"))
(command (word "disown") (word "%1"))
(command (word "disown") (word "%2"))
(command (word "disown") (word "-h") (word "@12"))
(command (word "echo") (word "wait-for-non-child"))
(command (word "wait") (word "1"))
(command (word "echo") (word "$?"))
(pipe (command (word "exit") (word "1")) (pipe (command (word "exit") (word "2")) (command (word "exit") (word "3"))))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}") (word "--") (word "${PIPESTATUS[0]}") (word "-") (word "${PIPESTATUS[1]}") (word "-") (word "${PIPESTATUS[2]}"))
(background (command (word "sleep") (word "300")))
(command (word "sleep300pid=$!"))
(background (command (word "sleep") (word "350")))
(background (command (word "sleep") (word "400")))
(command (word "jobs"))
(command (word "echo") (word "running") (word "jobs:"))
(command (word "jobs") (word "-r"))
(command (word "kill") (word "-n") (word "1") (word "%4"))
(command (word "jobs") (word "%4"))
(command (word "echo") (word "current") (word "job:"))
(command (word "jobs") (word "%+"))
(command (word "echo") (word "previous") (word "job:"))
(command (word "jobs") (word "%-"))
(command (word "kill") (word "-STOP") (word "%2"))
(command (word "sleep") (word "3"))
(command (word "echo") (word "after") (word "kill") (word "-STOP"))
(command (word "echo") (word "running") (word "jobs:"))
(command (word "jobs") (word "-r"))
(command (word "echo") (word "stopped") (word "jobs:"))
(command (word "jobs") (word "-s"))
(command (word "disown") (word "%1"))
(command (word "echo") (word "after") (word "disown"))
(command (word "jobs"))
(command (word "echo") (word "running") (word "jobs:"))
(command (word "jobs") (word "-r"))
(command (word "echo") (word "stopped") (word "jobs:"))
(command (word "jobs") (word "-s"))
(command (word "kill") (word "-s") (word "CONT") (word "%2"))
(command (word "echo") (word "after") (word "kill") (word "-s") (word "CONT"))
(command (word "echo") (word "running") (word "jobs:"))
(command (word "jobs") (word "-r"))
(command (word "echo") (word "stopped") (word "jobs:"))
(command (word "jobs") (word "-s"))
(command (word "kill") (word "-STOP") (word "%3"))
(command (word "sleep") (word "3"))
(command (word "echo") (word "after") (word "kill") (word "-STOP,") (word "backgrounding") (word "%3:"))
(command (word "bg") (word "%3"))
(command (word "disown") (word "-h") (word "%2"))
(command (word "exec") (redirect ">&" 2))
(command (word "exec") (redirect ">" "/dev/null"))
(command (word "echo") (word "killing..."))
(command (word "kill") (word "-n") (word "9") (word "$sleep300pid"))
(command (word "kill") (word "-n") (word "9") (word "%2") (word "%3"))
(command (word "wait"))
(command (word "echo") (word "done"))
(command (word "exec") (redirect ">&" 5))
(background (command (word "sleep") (word "4")))
(command (word "kill") (word "-STOP") (word "%1"))
(command (word "sleep") (word "2"))
(command (word "echo") (word "after") (word "KILL") (word "-STOP,") (word "foregrounding") (word "%1"))
(command (word "fg") (word "%1"))
(command (word "echo") (word "done"))
(command (word "set") (word "+m"))
(command (word "jobs") (word "-q"))
(command (word "suspend") (word "-z"))
(command (word "suspend"))
(command (word "suspend") (word "--"))
(command (word "--------------------------------------------------------------------------------"))
---

=== lastpipe
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
binfalse()
{
	$binfalse || return 1	# normalize return value
}

if [ -x /usr/bin/true ]; then
	bintrue=/usr/bin/true
elif [ -x /bin/true ]; then
	bintrue=/bin/true
else
	bintrue=true
fi
if [ -x /usr/bin/false ]; then
	binfalse=/usr/bin/false
elif [ -x /bin/false ]; then
	binfalse=/bin/false
else
	binfalse=false
fi

shopt -s lastpipe

unset foo bar
echo a b c | read foo
echo after 1: foo = $foo

unset tot
declare -i tot
printf "%d\n" 1 2 3 | while read foo; do tot+=$foo; done
echo after 2: tot = $tot

unset bar
echo g h i | bar=7
echo after: $bar

unset foo last
printf "%s\n" a b c | while read foo; do last=$foo; done
echo last = $last

exit 142 | false
echo $? -- ${PIPESTATUS[@]}

true | false | $bintrue
echo $? -- ${PIPESTATUS[@]}

true | $bintrue | false
echo $? -- ${PIPESTATUS[@]}

set -o pipefail
true | $bintrue | false
echo $? -- ${PIPESTATUS[@]}

true | binfalse | true
echo $? -- ${PIPESTATUS[@]}

binfalse | true | true | VAR=42
echo $? $VAR
set +o pipefail

${THIS_SH} ./lastpipe1.sub
echo lastpipe1.sub returns $?

${THIS_SH} ./lastpipe2.sub
${THIS_SH} ./lastpipe3.sub

--------------------------------------------------------------------------------
---
(function "binfalse" (brace-group (or (command (word "$binfalse")) (command (word "return") (word "1")))))
(if (command (word "[") (word "-x") (word "/usr/bin/true") (word "]")) (command (word "bintrue=/usr/bin/true")) (if (command (word "[") (word "-x") (word "/bin/true") (word "]")) (command (word "bintrue=/bin/true")) (command (word "bintrue=true"))))
(if (command (word "[") (word "-x") (word "/usr/bin/false") (word "]")) (command (word "binfalse=/usr/bin/false")) (if (command (word "[") (word "-x") (word "/bin/false") (word "]")) (command (word "binfalse=/bin/false")) (command (word "binfalse=false"))))
(command (word "shopt") (word "-s") (word "lastpipe"))
(command (word "unset") (word "foo") (word "bar"))
(pipe (command (word "echo") (word "a") (word "b") (word "c")) (command (word "read") (word "foo")))
(command (word "echo") (word "after") (word "1:") (word "foo") (word "=") (word "$foo"))
(command (word "unset") (word "tot"))
(command (word "declare") (word "-i") (word "tot"))
(pipe (command (word "printf") (word "\"%d\\n\"") (word "1") (word "2") (word "3")) (while (command (word "read") (word "foo")) (command (word "tot+=$foo"))))
(command (word "echo") (word "after") (word "2:") (word "tot") (word "=") (word "$tot"))
(command (word "unset") (word "bar"))
(pipe (command (word "echo") (word "g") (word "h") (word "i")) (command (word "bar=7")))
(command (word "echo") (word "after:") (word "$bar"))
(command (word "unset") (word "foo") (word "last"))
(pipe (command (word "printf") (word "\"%s\\n\"") (word "a") (word "b") (word "c")) (while (command (word "read") (word "foo")) (command (word "last=$foo"))))
(command (word "echo") (word "last") (word "=") (word "$last"))
(pipe (command (word "exit") (word "142")) (command (word "false")))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(pipe (command (word "true")) (pipe (command (word "false")) (command (word "$bintrue"))))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(pipe (command (word "true")) (pipe (command (word "$bintrue")) (command (word "false"))))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(command (word "set") (word "-o") (word "pipefail"))
(pipe (command (word "true")) (pipe (command (word "$bintrue")) (command (word "false"))))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(pipe (command (word "true")) (pipe (command (word "binfalse")) (command (word "true"))))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(pipe (command (word "binfalse")) (pipe (command (word "true")) (pipe (command (word "true")) (command (word "VAR=42")))))
(command (word "echo") (word "$?") (word "$VAR"))
(command (word "set") (word "+o") (word "pipefail"))
(command (word "${THIS_SH}") (word "./lastpipe1.sub"))
(command (word "echo") (word "lastpipe1.sub") (word "returns") (word "$?"))
(command (word "${THIS_SH}") (word "./lastpipe2.sub"))
(command (word "${THIS_SH}") (word "./lastpipe3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== mapfile
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
declare -a A
mapfile A < mapfile.data
for (( i = 0 ; i < ${#A[@]} ; i++ )); do
    echo -n "${A[${i}]}"
done

declare -a B
mapfile -t B < mapfile.data
for (( i = 0 ; i < ${#B[@]} ; i++ )); do
    echo "${B[${i}]}"
done

mapfile -C "echo" -c 1 A < mapfile.data
mapfile -C "echo" -c 3 A < mapfile.data
mapfile -C "echo" -c 19 A < mapfile.data

declare -a C
mapfile -t -u 3 C 3< mapfile.data < mapfile.tests
for (( i = 0 ; i < ${#C[@]} ; i++ )); do
    echo "${C[${i}]}"
done


declare -a D
for (( i = 0 ; i < 30; i++ )); do
    D[${i}]="[$i] aaa"
done
mapfile -O 10 -t D < mapfile.data
for (( i = 0 ; i < ${#D[@]} ; i++ )); do
    echo "${D[${i}]}"
done

declare -a E
for (( i = 0 ; i < 30; i++ )); do
    E[${i}]="[$i] aaa"
done
mapfile -O 10 -n 5 -t E < mapfile.data
for (( i = 0 ; i < ${#E[@]} ; i++ )); do
    echo "${E[${i}]}"
done

unset -v s array
s=$'a\xffb\xffc\xff'
mapfile -t -d $'\xff' array <<<"$s"
declare -p array
unset -v s array

${THIS_SH} ./mapfile1.sub
${THIS_SH} ./mapfile2.sub

--------------------------------------------------------------------------------
---
(command (word "declare") (word "-a") (word "A"))
(command (word "mapfile") (word "A") (redirect "<" "mapfile.data"))
(arith-for (init (word "i = 0 ")) (test (word "i < ${#A[@]} ")) (step (word "i++ ")) (command (word "echo") (word "-n") (word "\"${A[${i}]}\"")))
(command (word "declare") (word "-a") (word "B"))
(command (word "mapfile") (word "-t") (word "B") (redirect "<" "mapfile.data"))
(arith-for (init (word "i = 0 ")) (test (word "i < ${#B[@]} ")) (step (word "i++ ")) (command (word "echo") (word "\"${B[${i}]}\"")))
(command (word "mapfile") (word "-C") (word "\"echo\"") (word "-c") (word "1") (word "A") (redirect "<" "mapfile.data"))
(command (word "mapfile") (word "-C") (word "\"echo\"") (word "-c") (word "3") (word "A") (redirect "<" "mapfile.data"))
(command (word "mapfile") (word "-C") (word "\"echo\"") (word "-c") (word "19") (word "A") (redirect "<" "mapfile.data"))
(command (word "declare") (word "-a") (word "C"))
(command (word "mapfile") (word "-t") (word "-u") (word "3") (word "C") (redirect "<" "mapfile.data") (redirect "<" "mapfile.tests"))
(arith-for (init (word "i = 0 ")) (test (word "i < ${#C[@]} ")) (step (word "i++ ")) (command (word "echo") (word "\"${C[${i}]}\"")))
(command (word "declare") (word "-a") (word "D"))
(arith-for (init (word "i = 0 ")) (test (word "i < 30")) (step (word "i++ ")) (command (word "D[${i}]=\"[$i] aaa\"")))
(command (word "mapfile") (word "-O") (word "10") (word "-t") (word "D") (redirect "<" "mapfile.data"))
(arith-for (init (word "i = 0 ")) (test (word "i < ${#D[@]} ")) (step (word "i++ ")) (command (word "echo") (word "\"${D[${i}]}\"")))
(command (word "declare") (word "-a") (word "E"))
(arith-for (init (word "i = 0 ")) (test (word "i < 30")) (step (word "i++ ")) (command (word "E[${i}]=\"[$i] aaa\"")))
(command (word "mapfile") (word "-O") (word "10") (word "-n") (word "5") (word "-t") (word "E") (redirect "<" "mapfile.data"))
(arith-for (init (word "i = 0 ")) (test (word "i < ${#E[@]} ")) (step (word "i++ ")) (command (word "echo") (word "\"${E[${i}]}\"")))
(command (word "unset") (word "-v") (word "s") (word "array"))
(command (word "s='abc'"))
(command (word "mapfile") (word "-t") (word "-d") (word "''") (word "array") (redirect "<<<" ""$s""))
(command (word "declare") (word "-p") (word "array"))
(command (word "unset") (word "-v") (word "s") (word "array"))
(command (word "${THIS_SH}") (word "./mapfile1.sub"))
(command (word "${THIS_SH}") (word "./mapfile2.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== more-exp
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
expect()
{
	echo expect "$@"
}

tool_var() {
        eval $1=\"\${$1:-$2}\"
        export $1
}

A="aaa bbb ccc"

unset B

tool_var        B       ${B:-"$A"}

expect '<aaa bbb ccc>'
recho "$A"
expect '<aaa bbb ccc>'
recho "$B"

eto_prepend() {
        eval $1=\'$2\''${'$1':+":"${'$1'}}'; export $1
}

foo=bar; export foo
eto_prepend foo baz
expect '<baz:bar>'
recho $foo
expect '<baz:bar>'
recho ${foo-"bar"}

aa='aaa bbb ccc'

expect '<aaa bbb ccc>'
recho ${zzz-"$aa"}
expect '<bar>'
recho ${zzz:-"bar"}
expect '<bar>'
recho "${zzz:-bar}"
expect '<bar>'
recho "${zzz:-"bar"}"

var=abcde
expect '<abcde>'
recho "${var:-xyz}"
expect '<abcde>'
recho "${var:=xyz}"
expect '<xyz>'
recho "${var:+xyz}"

set 'a b' c d e f
expect '<a b> <c> <d> <e> <f>'
recho ${1+"$@"}
expect '<a b>'
recho "${1-"$@"}"
expect '<a> <b>'
recho ${1-"$@"}
expect '<a b> <c> <d> <e> <f>'
recho "${1+$@}"
expect '<a b> <c> <d> <e> <f>'
recho "${1+"$@"}"

HOME=/usr/homes/chet
somevar=
expect "<$HOME>"
recho ${somevar:-~}
# This changed after bash-3.0, when the tilde implementation was redone.  It's
# not backward compatible, but it's very hard to be backward-compatible here,
# and I think the old behavior was a bug
expect '<~>'
recho "${somevar:-~}"
expect '<~>'
recho "${somevar:-"~"}"
expect '<\~>'
recho "${somevar:-\~}"
expect '<\ \~>'
recho "${somevar:-\ \~}"
expect '<\ \ \~>'
recho "${somevar:-\ \ \~}"

expect "<$HOME>"
recho ${somevar:-$HOME}
expect "<$HOME>"
recho "${somevar:-$HOME}"
expect "<$HOME>"
recho "${somevar:-"$HOME"}"
expect '<$HOME>'
recho "${somevar:-\$HOME}"
expect '<\ $HOME>'
recho "${somevar:-\ \$HOME}"
expect '<\ \ $HOME>'
recho "${somevar:-\ \ \$HOME}"

foo=bar
expect "<'bar'>"
recho "${foo+'$foo'}"
expect "<'bar'>"
recho "${fox='$foo'}"

P='*@*'
expect '<*@>'
recho "${P%"*"}"
expect '<*@>'
recho "${P%'*'}"

expect '<*@>'
recho ${P%"*"}
expect '<*@>'
recho ${P%'*'}

expect '<*@*>'
recho ${P%""}
expect '<*@*>'
recho ${P#""}

expect '<*@*>'
recho ${P#"$foobar"}
expect '<*@*>'
recho ${P%"$foobar"}

s1=abcdefghijkl
s2=efgh

first=${s1/$s2*/}
expect '<abcd>'
recho $first

last=${s1##$first}
expect '<efghijkl>'
recho $last

shift $#
UNAME_RELEASE=${1:-4.2MP}

RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
case "$RELEASE" in
"")     RELEASE=0 ;;
*)      RELEASE=`expr "$RELEASE" + 0` ;;
esac            
REL_LEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.\([0-9]*\)'`    # 1
REL_SUBLEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.[0-9]*.\([0-9]*\)'` # 2

expect '<4> <2>'
recho $RELEASE $REL_LEVEL $REL_SUBLEVEL

b1()
{
	b2 ${1+"$@"}
}

b2()
{	
	recho $*
	recho ${#}
}

expect '<1>'
b1 ''

expect '<bar> <2>'
b1 bar ''

expect '<bar> <2>'
b1 '' bar

expect '<4>'
b1 '' '' '' ''

NL="\\
"

NNL="+$NL+"

expect '<--\> <-->'
recho --$NL--
expect '<--\^J-->'
recho "--$NL--"

expect '<--+\> <+-->'
recho --$NNL--
expect '<--+\^J+-->'
recho "--$NNL--"

expect '<-+\> <+-\> <->'
recho -$NNL-$NL-

set ''
expect '<xy>'
recho "$*xy"
expect '<xy>'
recho "x$*y"
expect '<xy>'
recho "xy$*"
expect '<xy>'
recho x"$*"y
expect '<xy>'
recho xy"$*"
expect '<xy>'
recho "$*"xy
expect '<>'
recho "$*"
expect nothing
recho $*

unset undef ; set ""

expect '<>'
recho ${undef-"$*"}
expect '<xy>'
recho ${undef-"x$*y"}
expect '<xy>'
recho ${undef-"$*xy"}
expect '<xy>'
recho ${undef-"xy$*"}
expect '<xy>'
recho ${undef-x"$*"y}
expect '<xy>'
recho ${undef-xy"$*"}
expect '<xy>'
recho ${undef-"$*"xy}
expect '<>'
recho "${undef-$*}"
expect nothing
recho ${undef-$*}

expect '<>'
recho ${undef-"$zzz"}
expect '<x>'
recho x${undef-"$zzz"}
expect '<x>'
recho x${undef-"$@"}
expect nothing
recho ${undef-"$@"}
expect '<x>'
recho ${undef-"$zzz"}x
expect '<x>'
recho ${undef-"$@"}x
expect '<x>'
recho "$@"x
expect '<x>'
recho "$zzz"x
expect '<^?>'
recho ${undef-}
expect '<^?>'
recho ${undef-""}

yyy=""
recho "$xxx"x
recho "$yyy"x

set "" "abd" ""
recho "$@"x
recho "$@"$xxx

OIFS="$IFS"

arg=a,b,c,d,e,f

IFS=,

export z=$arg

eval z1=\"$arg\"

IFS="$OIFS"

recho $z
recho $z1

# should give an error
abc\=def

zz="a b c d e"
declare a=$zz

recho "$a"
recho $a

recho $(echo "foo$(echo ")")")

# test backslash escapes

recho \a
recho \\a

recho "\a"
recho "\\a"

recho '\a'
recho '\\a'

recho $(zecho \a)
recho $(zecho \\a)

recho $(zecho "\a")
recho $(zecho "\\a")

recho $(zecho '\a')
recho $(zecho '\\a')

recho `zecho \a`
recho `zecho \\a`

recho `zecho "\a"`
recho `zecho "\\a"`

recho `zecho '\a'`
recho `zecho '\\a'`

a=foo

recho \$a
recho \\$a

recho "\$a"
recho "\\$a"

recho '\$a'
recho '\\$a'

recho $(zecho `zecho \a`)
recho $(zecho `zecho \\a`)

recho $(zecho `zecho "\a"`)
recho $(zecho `zecho "\\a"`)

recho $(zecho `zecho '\a'`)
recho $(zecho `zecho '\\a'`)

# should echo G { I K }
recho ${abc:-G { I } K }

abc=hi

# should echo hi K }
recho ${abc:-G { I } K }

# should echo a*
unset foo
recho "${foo:-"a"}*"

f ()
{
	echo "Number of args: $#"
	echo "<\${*-x}>: <${*-x}>"
	echo "<\${@-x}>: <${@-x}>"
}

f
f ''
f '' ''

set 1 2 3 4 5

expect '<5>'
recho ${#}
expect '<5>'
recho ${#:foo}
expect '<5>'
recho ${#:-foo}
expect '<5>'
recho ${#-posparams}
expect '<5>'
recho ${#:-posparams}

expect '<0>'
recho ${#!}

expect nothing
recho $!
expect nothing
recho ${!}

expect nothing
recho $8
expect nothing
recho ${8}

shift $#

expect '<0>'
recho ${#}
expect '<0>'
recho ${#:foo}
expect '<0>'
recho ${#:-foo}
expect '<0>'
recho ${#-posparams}
expect '<0>'
recho ${#:-posparams}

expect '<posparams>'
recho ${!-posparams}
expect '<posparams>'
recho ${!:-posparams}

expect '<2>'
recho ${#-}

expect '<0>'
recho ${#-posparams}

expect '<0>'
recho ${#?:-xyz}

expect '<1>'
recho ${#?}

set a b c d e

expect '<5>'
recho ${#}
expect '<5>'
recho ${#?:-xyz}

shift ${#}

expect '<0>'
recho ${#:-foo}

expect a bad substitution error
recho ${#:}
expect a bad substitution error
recho ${#/}
expect a bad substitution error
recho ${#%}
expect a bad substitution error
recho ${#=}
expect a bad substitution error
recho ${#+}
expect a bad substitution error
recho ${#1xyz}

expect a math syntax error
recho ${#:%}

expect '<0>'
recho ${#:-}

set --
unset a b

x=a
y=b

IFS=+

expect '<a+b>'
recho $x+$y
expect '<+>'
recho $a+$b

expect '<+>'
recho + "$@"
expect '<+>'
recho +"$@"

# variants of nested curly braces inside ${...} expressions

# IFS is not the standard one

expect '<G { I>' '<K>' '<}>'
recho ${gik:-G { I } K }

abc=hi

expect '<hi>' '<K>' '<}>'
recho ${abc:-G { I } K }

# reset IFS to the default
IFS=' 	
'

# nested ${...} inside ${...} are handled specially
unset XXX FOO BAR
expect '<xxx>' '<yyy>'
XXX=xxx
FOO=${BAR:-${XXX} yyy}
recho $FOO

# this was a bug in versions of bash prior to bash-2.04-release
set -- ''
expect 1
echo $#
expect '<>'
recho "${@}"
expect '<>'
recho "${@-}"
expect '<>'
recho "${@:-}"

# this was a bug in bash-2.04, fixed in 2.05
set -- a b
expect '<:a:>' '<:b:>'
for i in "${@-}"; do recho :$i:; done

# I believe that ksh93 does these wrong -- we're using the rhs, so shouldn't
# it behave the same as ""?
set --
expect '<>'
recho "${@-}"
expect '<>'
recho "${@:-}"

--------------------------------------------------------------------------------
---
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(function "tool_var" (brace-group (semi (command (word "eval") (word "$1=\\\"\\${$1:-$2}\\\"")) (command (word "export") (word "$1")))))
(command (word "A=\"aaa bbb ccc\""))
(command (word "unset") (word "B"))
(command (word "tool_var") (word "B") (word "${B:-\"$A\"}"))
(command (word "expect") (word "'<aaa bbb ccc>'"))
(command (word "recho") (word "\"$A\""))
(command (word "expect") (word "'<aaa bbb ccc>'"))
(command (word "recho") (word "\"$B\""))
(function "eto_prepend" (brace-group (semi (command (word "eval") (word "$1=\\'$2\\''${'$1':+\":\"${'$1'}}'")) (command (word "export") (word "$1")))))
(semi (command (word "foo=bar")) (command (word "export") (word "foo")))
(command (word "eto_prepend") (word "foo") (word "baz"))
(command (word "expect") (word "'<baz:bar>'"))
(command (word "recho") (word "$foo"))
(command (word "expect") (word "'<baz:bar>'"))
(command (word "recho") (word "${foo-\"bar\"}"))
(command (word "aa='aaa bbb ccc'"))
(command (word "expect") (word "'<aaa bbb ccc>'"))
(command (word "recho") (word "${zzz-\"$aa\"}"))
(command (word "expect") (word "'<bar>'"))
(command (word "recho") (word "${zzz:-\"bar\"}"))
(command (word "expect") (word "'<bar>'"))
(command (word "recho") (word "\"${zzz:-bar}\""))
(command (word "expect") (word "'<bar>'"))
(command (word "recho") (word "\"${zzz:-\"bar\"}\""))
(command (word "var=abcde"))
(command (word "expect") (word "'<abcde>'"))
(command (word "recho") (word "\"${var:-xyz}\""))
(command (word "expect") (word "'<abcde>'"))
(command (word "recho") (word "\"${var:=xyz}\""))
(command (word "expect") (word "'<xyz>'"))
(command (word "recho") (word "\"${var:+xyz}\""))
(command (word "set") (word "'a b'") (word "c") (word "d") (word "e") (word "f"))
(command (word "expect") (word "'<a b> <c> <d> <e> <f>'"))
(command (word "recho") (word "${1+\"$@\"}"))
(command (word "expect") (word "'<a b>'"))
(command (word "recho") (word "\"${1-\"$@\"}\""))
(command (word "expect") (word "'<a> <b>'"))
(command (word "recho") (word "${1-\"$@\"}"))
(command (word "expect") (word "'<a b> <c> <d> <e> <f>'"))
(command (word "recho") (word "\"${1+$@}\""))
(command (word "expect") (word "'<a b> <c> <d> <e> <f>'"))
(command (word "recho") (word "\"${1+\"$@\"}\""))
(command (word "HOME=/usr/homes/chet"))
(command (word "somevar="))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${somevar:-~}"))
(command (word "expect") (word "'<~>'"))
(command (word "recho") (word "\"${somevar:-~}\""))
(command (word "expect") (word "'<~>'"))
(command (word "recho") (word "\"${somevar:-\"~\"}\""))
(command (word "expect") (word "'<\\~>'"))
(command (word "recho") (word "\"${somevar:-\\~}\""))
(command (word "expect") (word "'<\\ \\~>'"))
(command (word "recho") (word "\"${somevar:-\\ \\~}\""))
(command (word "expect") (word "'<\\ \\ \\~>'"))
(command (word "recho") (word "\"${somevar:-\\ \\ \\~}\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${somevar:-$HOME}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"${somevar:-$HOME}\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"${somevar:-\"$HOME\"}\""))
(command (word "expect") (word "'<$HOME>'"))
(command (word "recho") (word "\"${somevar:-\\$HOME}\""))
(command (word "expect") (word "'<\\ $HOME>'"))
(command (word "recho") (word "\"${somevar:-\\ \\$HOME}\""))
(command (word "expect") (word "'<\\ \\ $HOME>'"))
(command (word "recho") (word "\"${somevar:-\\ \\ \\$HOME}\""))
(command (word "foo=bar"))
(command (word "expect") (word "\"<'bar'>\""))
(command (word "recho") (word "\"${foo+'$foo'}\""))
(command (word "expect") (word "\"<'bar'>\""))
(command (word "recho") (word "\"${fox='$foo'}\""))
(command (word "P='*@*'"))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "\"${P%\"*\"}\""))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "\"${P%'*'}\""))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "${P%\"*\"}"))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "${P%'*'}"))
(command (word "expect") (word "'<*@*>'"))
(command (word "recho") (word "${P%\"\"}"))
(command (word "expect") (word "'<*@*>'"))
(command (word "recho") (word "${P#\"\"}"))
(command (word "expect") (word "'<*@*>'"))
(command (word "recho") (word "${P#\"$foobar\"}"))
(command (word "expect") (word "'<*@*>'"))
(command (word "recho") (word "${P%\"$foobar\"}"))
(command (word "s1=abcdefghijkl"))
(command (word "s2=efgh"))
(command (word "first=${s1/$s2*/}"))
(command (word "expect") (word "'<abcd>'"))
(command (word "recho") (word "$first"))
(command (word "last=${s1##$first}"))
(command (word "expect") (word "'<efghijkl>'"))
(command (word "recho") (word "$last"))
(command (word "shift") (word "$#"))
(command (word "UNAME_RELEASE=${1:-4.2MP}"))
(command (word "RELEASE=`expr \"$UNAME_RELEASE\" : '[^0-9]*\\([0-9]*\\)'`"))
(case (word "\"$RELEASE\"") (pattern ((word "\"\"")) (command (word "RELEASE=0"))) (pattern ((word "*")) (command (word "RELEASE=`expr \"$RELEASE\" + 0`"))))
(command (word "REL_LEVEL=`expr \"$UNAME_RELEASE\" : '[^0-9]*[0-9]*.\\([0-9]*\\)'`"))
(command (word "REL_SUBLEVEL=`expr \"$UNAME_RELEASE\" : '[^0-9]*[0-9]*.[0-9]*.\\([0-9]*\\)'`"))
(command (word "expect") (word "'<4> <2>'"))
(command (word "recho") (word "$RELEASE") (word "$REL_LEVEL") (word "$REL_SUBLEVEL"))
(function "b1" (brace-group (command (word "b2") (word "${1+\"$@\"}"))))
(function "b2" (brace-group (semi (command (word "recho") (word "$*")) (command (word "recho") (word "${#}")))))
(command (word "expect") (word "'<1>'"))
(command (word "b1") (word "''"))
(command (word "expect") (word "'<bar> <2>'"))
(command (word "b1") (word "bar") (word "''"))
(command (word "expect") (word "'<bar> <2>'"))
(command (word "b1") (word "''") (word "bar"))
(command (word "expect") (word "'<4>'"))
(command (word "b1") (word "''") (word "''") (word "''") (word "''"))
(command (word "NL=\"\\\\\n\""))
(command (word "NNL=\"+$NL+\""))
(command (word "expect") (word "'<--\\> <-->'"))
(command (word "recho") (word "--$NL--"))
(command (word "expect") (word "'<--\\^J-->'"))
(command (word "recho") (word "\"--$NL--\""))
(command (word "expect") (word "'<--+\\> <+-->'"))
(command (word "recho") (word "--$NNL--"))
(command (word "expect") (word "'<--+\\^J+-->'"))
(command (word "recho") (word "\"--$NNL--\""))
(command (word "expect") (word "'<-+\\> <+-\\> <->'"))
(command (word "recho") (word "-$NNL-$NL-"))
(command (word "set") (word "''"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "\"$*xy\""))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "\"x$*y\""))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "\"xy$*\""))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "x\"$*\"y"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "xy\"$*\""))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "\"$*\"xy"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"$*\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$*"))
(semi (command (word "unset") (word "undef")) (command (word "set") (word "\"\"")))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "${undef-\"$*\"}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-\"x$*y\"}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-\"$*xy\"}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-\"xy$*\"}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-x\"$*\"y}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-xy\"$*\"}"))
(command (word "expect") (word "'<xy>'"))
(command (word "recho") (word "${undef-\"$*\"xy}"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${undef-$*}\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${undef-$*}"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "${undef-\"$zzz\"}"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "x${undef-\"$zzz\"}"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "x${undef-\"$@\"}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${undef-\"$@\"}"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "${undef-\"$zzz\"}x"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "${undef-\"$@\"}x"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "\"$@\"x"))
(command (word "expect") (word "'<x>'"))
(command (word "recho") (word "\"$zzz\"x"))
(command (word "expect") (word "'<^?>'"))
(command (word "recho") (word "${undef-}"))
(command (word "expect") (word "'<^?>'"))
(command (word "recho") (word "${undef-\"\"}"))
(command (word "yyy=\"\""))
(command (word "recho") (word "\"$xxx\"x"))
(command (word "recho") (word "\"$yyy\"x"))
(command (word "set") (word "\"\"") (word "\"abd\"") (word "\"\""))
(command (word "recho") (word "\"$@\"x"))
(command (word "recho") (word "\"$@\"$xxx"))
(command (word "OIFS=\"$IFS\""))
(command (word "arg=a,b,c,d,e,f"))
(command (word "IFS=,"))
(command (word "export") (word "z=$arg"))
(command (word "eval") (word "z1=\\\"$arg\\\""))
(command (word "IFS=\"$OIFS\""))
(command (word "recho") (word "$z"))
(command (word "recho") (word "$z1"))
(command (word "abc\\=def"))
(command (word "zz=\"a b c d e\""))
(command (word "declare") (word "a=$zz"))
(command (word "recho") (word "\"$a\""))
(command (word "recho") (word "$a"))
(command (word "recho") (word "$(echo \"foo$(echo \")\")\")"))
(command (word "recho") (word "\\a"))
(command (word "recho") (word "\\\\a"))
(command (word "recho") (word "\"\\a\""))
(command (word "recho") (word "\"\\\\a\""))
(command (word "recho") (word "'\\a'"))
(command (word "recho") (word "'\\\\a'"))
(command (word "recho") (word "$(zecho \\a)"))
(command (word "recho") (word "$(zecho \\\\a)"))
(command (word "recho") (word "$(zecho \"\\a\")"))
(command (word "recho") (word "$(zecho \"\\\\a\")"))
(command (word "recho") (word "$(zecho '\\a')"))
(command (word "recho") (word "$(zecho '\\\\a')"))
(command (word "recho") (word "`zecho \\a`"))
(command (word "recho") (word "`zecho \\\\a`"))
(command (word "recho") (word "`zecho \"\\a\"`"))
(command (word "recho") (word "`zecho \"\\\\a\"`"))
(command (word "recho") (word "`zecho '\\a'`"))
(command (word "recho") (word "`zecho '\\\\a'`"))
(command (word "a=foo"))
(command (word "recho") (word "\\$a"))
(command (word "recho") (word "\\\\$a"))
(command (word "recho") (word "\"\\$a\""))
(command (word "recho") (word "\"\\\\$a\""))
(command (word "recho") (word "'\\$a'"))
(command (word "recho") (word "'\\\\$a'"))
(command (word "recho") (word "$(zecho `zecho \\a`)"))
(command (word "recho") (word "$(zecho `zecho \\\\a`)"))
(command (word "recho") (word "$(zecho `zecho \"\\a\"`)"))
(command (word "recho") (word "$(zecho `zecho \"\\\\a\"`)"))
(command (word "recho") (word "$(zecho `zecho '\\a'`)"))
(command (word "recho") (word "$(zecho `zecho '\\\\a'`)"))
(command (word "recho") (word "${abc:-G { I }") (word "K") (word "}"))
(command (word "abc=hi"))
(command (word "recho") (word "${abc:-G { I }") (word "K") (word "}"))
(command (word "unset") (word "foo"))
(command (word "recho") (word "\"${foo:-\"a\"}*\""))
(function "f" (brace-group (semi (semi (command (word "echo") (word "\"Number of args: $#\"")) (command (word "echo") (word "\"<\\${*-x}>: <${*-x}>\""))) (command (word "echo") (word "\"<\\${@-x}>: <${@-x}>\"")))))
(command (word "f"))
(command (word "f") (word "''"))
(command (word "f") (word "''") (word "''"))
(command (word "set") (word "1") (word "2") (word "3") (word "4") (word "5"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#:foo}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#:-foo}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#-posparams}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#:-posparams}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#!}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$!"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${!}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$8"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${8}"))
(command (word "shift") (word "$#"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#:foo}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#:-foo}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#-posparams}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#:-posparams}"))
(command (word "expect") (word "'<posparams>'"))
(command (word "recho") (word "${!-posparams}"))
(command (word "expect") (word "'<posparams>'"))
(command (word "recho") (word "${!:-posparams}"))
(command (word "expect") (word "'<2>'"))
(command (word "recho") (word "${#-}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#-posparams}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#?:-xyz}"))
(command (word "expect") (word "'<1>'"))
(command (word "recho") (word "${#?}"))
(command (word "set") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#}"))
(command (word "expect") (word "'<5>'"))
(command (word "recho") (word "${#?:-xyz}"))
(command (word "shift") (word "${#}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#:-foo}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#:}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#/}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#%}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#=}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#+}"))
(command (word "expect") (word "a") (word "bad") (word "substitution") (word "error"))
(command (word "recho") (word "${#1xyz}"))
(command (word "expect") (word "a") (word "math") (word "syntax") (word "error"))
(command (word "recho") (word "${#:%}"))
(command (word "expect") (word "'<0>'"))
(command (word "recho") (word "${#:-}"))
(command (word "set") (word "--"))
(command (word "unset") (word "a") (word "b"))
(command (word "x=a"))
(command (word "y=b"))
(command (word "IFS=+"))
(command (word "expect") (word "'<a+b>'"))
(command (word "recho") (word "$x+$y"))
(command (word "expect") (word "'<+>'"))
(command (word "recho") (word "$a+$b"))
(command (word "expect") (word "'<+>'"))
(command (word "recho") (word "+") (word "\"$@\""))
(command (word "expect") (word "'<+>'"))
(command (word "recho") (word "+\"$@\""))
(command (word "expect") (word "'<G { I>'") (word "'<K>'") (word "'<}>'"))
(command (word "recho") (word "${gik:-G { I }") (word "K") (word "}"))
(command (word "abc=hi"))
(command (word "expect") (word "'<hi>'") (word "'<K>'") (word "'<}>'"))
(command (word "recho") (word "${abc:-G { I }") (word "K") (word "}"))
(command (word "IFS=' \t\n'"))
(command (word "unset") (word "XXX") (word "FOO") (word "BAR"))
(command (word "expect") (word "'<xxx>'") (word "'<yyy>'"))
(command (word "XXX=xxx"))
(command (word "FOO=${BAR:-${XXX} yyy}"))
(command (word "recho") (word "$FOO"))
(command (word "set") (word "--") (word "''"))
(command (word "expect") (word "1"))
(command (word "echo") (word "$#"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${@}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${@-}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${@:-}\""))
(command (word "set") (word "--") (word "a") (word "b"))
(command (word "expect") (word "'<:a:>'") (word "'<:b:>'"))
(for (word "i") (in (word "\"${@-}\"")) (command (word "recho") (word ":$i:")))
(command (word "set") (word "--"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${@-}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${@:-}\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== nameref
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# basic nameref tests
bar=one
flow=two
flip=three

foo=bar
typeset -n foo

typeset -n fee=flow

echo ${foo}
echo ${fee}

typeset -n fee=flip
echo ${fee}

typeset -n

echo turning off nameref attribute on foo
typeset +n foo=other
echo ${foo}
echo after +n foo bar = $bar

unset foo bar fee

bar=one

foo=bar
typeset -n foo

foo=two printf "%s\n" $foo
foo=two eval 'printf "%s\n" $foo'

foo=two echo $foo

unset foo bar
# other basic assignment tests
bar=one

echo "expect <one>"
recho ${bar}
typeset -n foo=bar
foo=two

echo "expect <two>"
recho ${bar}

# this appears to be a ksh93 bug; it doesn't unset foo here and messes up
# later
unset foo bar

# initial tests of working inside shell functions
echoval()
{
	typeset -n ref=$1
	printf "%s\n" $ref
}

foo=bar
bar=one
echo "expect <$foo>"
echoval foo
echo "expect <$bar>"
echoval bar

unset foo bar
changevar()
{
	typeset -n v=$1

	shift
	v="$@"
	echo "changevar: expect <$@>"
	recho "$v"
}

bar=one

echo "expect <one>"
recho ${bar}
changevar bar two
echo "expect <two>"
recho $bar

changevar bar three four five
echo "expect <three four five>"
recho "$bar"

unset foo bar
unset -n foo bar
readonly foo=one
typeset -n bar=foo
bar=4
foo=4

echo $foo
echo $bar

assignvar()
{
	typeset -n ref=$1
	shift
	ref="$@"
}

readonly foo=one

assignvar foo two three four
echo $foo

var=abcde
x=var
declare -n v=var
# these two should display the same
echo ${!x//c/x}
echo ${v//c/x}

for testfile in ./nameref[0-9].sub ./nameref[1-9][0-9].sub ; do
	${THIS_SH} "$testfile"
done

--------------------------------------------------------------------------------
---
(command (word "bar=one"))
(command (word "flow=two"))
(command (word "flip=three"))
(command (word "foo=bar"))
(command (word "typeset") (word "-n") (word "foo"))
(command (word "typeset") (word "-n") (word "fee=flow"))
(command (word "echo") (word "${foo}"))
(command (word "echo") (word "${fee}"))
(command (word "typeset") (word "-n") (word "fee=flip"))
(command (word "echo") (word "${fee}"))
(command (word "typeset") (word "-n"))
(command (word "echo") (word "turning") (word "off") (word "nameref") (word "attribute") (word "on") (word "foo"))
(command (word "typeset") (word "+n") (word "foo=other"))
(command (word "echo") (word "${foo}"))
(command (word "echo") (word "after") (word "+n") (word "foo") (word "bar") (word "=") (word "$bar"))
(command (word "unset") (word "foo") (word "bar") (word "fee"))
(command (word "bar=one"))
(command (word "foo=bar"))
(command (word "typeset") (word "-n") (word "foo"))
(command (word "foo=two") (word "printf") (word "\"%s\\n\"") (word "$foo"))
(command (word "foo=two") (word "eval") (word "'printf \"%s\\n\" $foo'"))
(command (word "foo=two") (word "echo") (word "$foo"))
(command (word "unset") (word "foo") (word "bar"))
(command (word "bar=one"))
(command (word "echo") (word "\"expect <one>\""))
(command (word "recho") (word "${bar}"))
(command (word "typeset") (word "-n") (word "foo=bar"))
(command (word "foo=two"))
(command (word "echo") (word "\"expect <two>\""))
(command (word "recho") (word "${bar}"))
(command (word "unset") (word "foo") (word "bar"))
(function "echoval" (brace-group (semi (command (word "typeset") (word "-n") (word "ref=$1")) (command (word "printf") (word "\"%s\\n\"") (word "$ref")))))
(command (word "foo=bar"))
(command (word "bar=one"))
(command (word "echo") (word "\"expect <$foo>\""))
(command (word "echoval") (word "foo"))
(command (word "echo") (word "\"expect <$bar>\""))
(command (word "echoval") (word "bar"))
(command (word "unset") (word "foo") (word "bar"))
(function "changevar" (brace-group (semi (semi (semi (semi (command (word "typeset") (word "-n") (word "v=$1")) (command (word "shift"))) (command (word "v=\"$@\""))) (command (word "echo") (word "\"changevar: expect <$@>\""))) (command (word "recho") (word "\"$v\"")))))
(command (word "bar=one"))
(command (word "echo") (word "\"expect <one>\""))
(command (word "recho") (word "${bar}"))
(command (word "changevar") (word "bar") (word "two"))
(command (word "echo") (word "\"expect <two>\""))
(command (word "recho") (word "$bar"))
(command (word "changevar") (word "bar") (word "three") (word "four") (word "five"))
(command (word "echo") (word "\"expect <three four five>\""))
(command (word "recho") (word "\"$bar\""))
(command (word "unset") (word "foo") (word "bar"))
(command (word "unset") (word "-n") (word "foo") (word "bar"))
(command (word "readonly") (word "foo=one"))
(command (word "typeset") (word "-n") (word "bar=foo"))
(command (word "bar=4"))
(command (word "foo=4"))
(command (word "echo") (word "$foo"))
(command (word "echo") (word "$bar"))
(function "assignvar" (brace-group (semi (semi (command (word "typeset") (word "-n") (word "ref=$1")) (command (word "shift"))) (command (word "ref=\"$@\"")))))
(command (word "readonly") (word "foo=one"))
(command (word "assignvar") (word "foo") (word "two") (word "three") (word "four"))
(command (word "echo") (word "$foo"))
(command (word "var=abcde"))
(command (word "x=var"))
(command (word "declare") (word "-n") (word "v=var"))
(command (word "echo") (word "${!x//c/x}"))
(command (word "echo") (word "${v//c/x}"))
(for (word "testfile") (in (word "./nameref[0-9].sub") (word "./nameref[1-9][0-9].sub")) (command (word "${THIS_SH}") (word "\"$testfile\"")))
(command (word "--------------------------------------------------------------------------------"))
---

=== new-exp
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
if (( $UID == 0 )); then
	echo "new-exp.tests: the test suite should not be run as root" >&2
fi

# must do this because posix mode causes process substitution to be disabled
# and flagged as a syntax error, which causes the shell to exit
set +o posix

expect()
{
        echo expect "$@"
}

HOME=/usr/homes/chet	# to make the check against new-exp.right work
expect '<foo bar>'
recho "${undef-"foo bar"}"	# should be foo bar
expect '<foo>'
recho "${und="foo"}"		# should be foo

expect "<$HOME>"
recho ${HOME-"}"}
expect "<$HOME>"
recho "${HOME-'}'}"
expect "<$HOME>"
recho "${HOME-"}"}"

expect $0: 'HOME: }: syntax error: operand expected (error token is "}")'
recho "${HOME:`echo }`}"	# should be a math error -- bad substring substitution

expect unset
_ENV=oops
x=${_ENV[(_$-=0)+(_=1)-_${-%%*i*}]}
echo ${x:-unset}

expect "<$HOME>"
recho ${HOME}
expect "<$HOME>"
recho ${HOME:-`echo }`}
expect "<$HOME>"
recho ${HOME:-`echo "}"`}
expect "<$HOME>"
recho "${HOME:-`echo "}"`}"
expect "<$HOME>"
recho "$(echo "${HOME}")"
expect "<$HOME>"
recho "$(echo "$(echo ${HOME})")"
expect "<$HOME>"
recho "$(echo "$(echo "${HOME}")")"

P=*@*
expect '<*@>'
recho "${P%"*"}"	# 
expect '<*@>'
recho "${P%'*'}"	# 
expect '<@*>'
recho "${P#\*}"		# should be @*

expect '<)>'
recho "$(echo ")")"	# should be )
expect '<")">'
recho "$(echo "\")\"")"	# should be ")"

foo='abcd   '
expect '<-abcd> <->'
recho -${foo}-		# should be -abcd -
expect '<-abcd> <->'
recho -${foo% *}-	# should be -abcd -
expect '<-abcd->'
recho -${foo%% *}-	# should be -abcd-

foo=bar
expect '<bar foo>'
echo -n $foo' ' ; echo foo

expect '<bar foo>'
echo -n $foo" " ; echo foo

expect '<bar foo>'
echo -n "$foo " ; echo foo

expect '<barfoo>'
echo -e "$foo\c " ; echo foo

expect '<barfoo>'
echo -e $foo"\c " ; echo foo

# make sure backslashes are preserved in front of characters that are not
# valid backslash escapes
expect '<\x>'
echo -e '\x'

# substring tests
z=abcdefghijklmnop
expect '<abcd>'
recho ${z:0:4}

expect '<efg> <nop>'
recho ${z:4:3} ${z:${#z}-3:3}

expect '<efg> <nop>'
recho ${z:4:3} ${z: -3:3}

expect '<hijklmnop>'
recho ${z:7:30}

expect '<abcdefghijklmnop>'
recho ${z:0:100}

expect '<abcdefghijklmnop>'
recho ${z:0:${#z}}

set 'ab cd' 'ef' 'gh ij' 'kl mn' 'op'
expect '<ab cd> <ef>'
recho "${@:1:2}"

expect '<gh ij> <kl mn>'
recho "${@:3:2}"

expect '<gh ij> <kl mn> <op>'
recho "${@:3:4}"

expect '<ab cd> <ef> <gh ij> <kl mn> <op>'
recho "${@:1:$#}"

# code to ad-hoc parse arithmetic expressions in substring expansions was
# broken until post-2.04
base=/home/chet/foo//bar
string1=$base/abcabcabc
x=1 j=4

expect '</home/chet/foo//bar/abcabcabc>'
recho ${string1:0}

expect '<home/chet/foo//bar/abcabcabc>'
recho ${string1:1}

expect '<home>'
recho ${string1:(j?1:0):j}

expect '<home>'
recho ${string1:j?1:0:j}

expect '<home>'
recho ${string1:(j?(x?1:0):0):j}

expect '<home>'
recho ${string1:j?(x?1:0):0:j}

unset base string1 x j

# indirect variable references
expect '<abcdefghijklmnop>'
recho ${!9:-$z}

ef=4
expect '<4>'
recho ${!2}

expect '<op>'
recho ${!#}

set a b c d e
a=
expect '<abcdefghijklmnop>'
recho ${a:-$z}
expect '<abcdefghijklmnop>'
recho ${!1:-$z}

expect nothing
recho ${a-$z}
expect nothing
recho ${!1-$z}

expect an error
v=bad-var
echo ${!v}
unset -v v

set -- a 'b c' d
unset foo
foo=@
expect '<a> <b> <c> <d>'
recho ${!foo}
expect '<a> <b c> <d>'
recho "${!foo}"

set -u
expect $0: ABX: unbound variable
( recho ${ABX} )
set +u

expect $0: '$6: cannot assign in this way'
recho ${6="arg6"}

v=abcde

# sed-like variable substitution
expect '<xxcde>'
recho ${v/a[a-z]/xx}
expect '<axxde>'
recho ${v/a??/axx}
expect '<abxyz>'
recho ${v/c??/xyz}
expect '<abbcde>'
recho ${v/#a/ab}
expect '<abcde>'
recho ${v/#d/ab}
expect '<abcabe>'
recho ${v/d/ab}
expect '<abcdlast>'
recho ${v/%?/last}
expect '<abcde>'
recho ${v/%x/last}

av=(abcd efgh ijkl mnop qrst uvwx)

expect '<xxcd>'
recho ${av/??/xx}
expect '<abxx>'
recho ${av/%??/xx}
expect '<xxgh>'
recho ${av[1]/??/xx}
expect '<efgh>'
recho ${av[1]/%ab/xx}
expect '<xxfgh>'
recho ${av[1]/#?/xx}
expect '<zagh>'
recho ${av[1]/??/za}
expect '<zaza>'
recho ${av[1]//??/za}
expect '<zagh>'
recho ${av[1]/#??/za}
expect '<efza>'
recho ${av[1]/%??/za}

expect '<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'
recho ${av[@]/*/yyy}
expect '<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'
recho ${av[@]/#*/yyy}
expect '<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'
recho ${av[@]/%*/yyy}
expect '<yyy> <efgh> <ijkl> <mnop> <qrst> <uvwx>'
recho ${av[@]/a*/yyy}
expect '<abxx> <efxx> <ijxx> <mnxx> <qrxx> <uvxx>'
recho ${av[@]/%??/xx}

set abcd efgh ijkl mnop qrst uvwx

expect '<xxcd>'
recho ${1/??/xx}
expect '<xxcd> <xxgh> <xxkl> <xxop> <xxst> <xxwx>'
recho ${@/??/xx}
expect '<xxcd> <xxgh> <xxkl> <xxop> <xxst> <xxwx>'
recho ${@/%??/xx}
expect '<zaza>'
recho ${3//??/za}
expect '<efza>'
recho ${3/%??/za}
expect '<zaza> <zaza> <zaza> <zaza> <zaza> <zaza>'
recho ${@//??/za}
expect '<zacd> <zagh> <zakl> <zaop> <zast> <zawx>'
recho ${@/#??/za}
expect '<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'
recho ${@//*/yyy}
expect '<yyy> <efgh> <ijkl> <mnop> <qrst> <uvwx>'
recho ${@//a*/yyy}
expect '<abcd> <efgh> <ijkl> <mnop> <qrst> <uvwyyy>'
recho ${@/%x*/yyy}

expect a newline
echo $abmcde

# sneaky way to replace a newline in a variable value with something else
AVAR=$'This\nstring\nhas\nmultiple\nlines.'
echo "${AVAR}"

eval BVAR=\"\${AVAR//$'\n'/-}\"
echo "$BVAR"

unset AVAR BVAR

# run process substitution tests in a subshell so that syntax errors
# caused by a shell not implementing process substitution (e.g., one
# built on a NeXT) will not cause the whole test to exit prematurely
${THIS_SH} ./new-exp1.sub

# run the tests of $(<filename) in a subshell to avoid cluttering up
# this script
${THIS_SH} ./new-exp2.sub

expect '<6>'
recho ${#:-foo}
expect $0: '${#:}: bad substitution'
echo ${#:}

expect "<'>"
recho "'"
expect '<">'
recho '"'
expect '<"hello">'
recho "\"hello\""

shift $#
unset foo
z=abcdef
z1='abc def'

expect '<>'
recho ${foo:-""}
expect nothing
recho ${foo:-"$@"}
expect '<>'
recho "${foo:-$@}"

# unset var
expect '<>'
recho ${foo:-"$zbcd"}
expect nothing
recho ${foo:-$zbcd}

# set var
expect '<abcdef>'
recho ${foo:-"$z"}
expect '<abc def>'
recho ${foo:-"$z1"}

expect '<abcdef>'
recho ${foo:-$z}
expect '<abc> <def>'
recho ${foo:-$z1}

expect '<abcdef>'
recho "${foo:-$z}"
expect '<abc def>'
recho "${foo:-$z1}"

expect '<abcdef>'
recho "${foo:-"$z"}"
# this disagrees with sh and ksh, but I think it is right according
# to posix.2.
expect '<abc def>'
recho "${foo:-"$z1"}"

set ab cd ef gh
expect '<ab> <cd> <ef> <gh>'
recho ${foo:-"$@"}
expect '<ab> <cd> <ef> <gh>'
recho "${foo:-$@}"
expect '<ab> <cd> <ef> <gh>'
recho "${foo:-"$@"}"

shift ${#}
expect nothing
recho $xxx"$@"
expect nothing
recho ${foo:-$xxx"$@"}
expect '<>'
recho "${foo:-$xxx$@}"
expect '<>'
recho "${foo:-$xxx"$@"}"

expect nothing
recho $xxx"$@"
expect nothing
recho "$xxx$@"
expect nothing
recho "$@"$xxx

expect '<>'
recho $xxx""
expect '<>'
recho $xxx''
expect '<>'
recho ''$xxx
expect '<>'
recho ""$xxx

AB='abcdefghijklmnopqrstuvwxyz'

recho ${AB:7:15}
recho ${AB:15:7}

recho ${AB:20}

recho ${AB:0}
recho ${AB:0:20}

recho ${AB:10:7}
recho ${AB:10:3+4}
recho ${AB:20/2:3+4}

set 1 2 3 4 5 6
recho \""${*:2:2}"\"

IFS=:
recho \""${*:2:2}"\"

IFS=$' \t\n'

z=123456

recho \""${z:2:2}"\"
recho \""${z:2}"\"
recho \""${z:2:4}"\"
recho \""${z:2:6}"\"

set $'\1' $'\2' $'\177'

recho $*
recho $@

recho ${*}
recho ${@}

xx=one/two/two
recho ${xx%/*}
recho ${xx/\/two}

yy=oneonetwo
recho ${yy//one}
recho ${yy/\/one}

xx=oneonetwo

recho ${xx/one}
recho ${xx//one}
recho ${xx/\/one}

# out-of-range substrings
var=abc
c=${var:3}
expect nothing
recho $c
c=${var:4}
expect nothing
recho $c
# as of bash-4.2, negative LENGTH means offset from the end
c=${var:0:-2}
expect '<a>'
recho $c

var=abcdefghi
c=${var:3:12}
recho $c
c=${var:4:20}
recho $c

# make sure null patterns work
xxx=endocrine
yyy=n
unset zzz

recho ${xxx/$yyy/*}
recho ${xxx//$yyy/*}

recho ${xxx/$zzz/*}
recho ${xxx//$zzz/*}

recho ${xxx//%${zzz}/}
recho ${xxx//%${zzz}}
recho ${xxx//#${zzz}/}
recho ${xxx//#${zzz}}

# make sure null strings are replaced appropriately
unset var
var=
echo "${var/#/x}"
echo "${var/*/x}"
echo "${var//*/x}"

var=abc
echo "${var/#/x}"
echo "${var/*/x}"
echo "${var//*/x}"
unset var

# another case that caused a core dump in bash-2.0
XPATH=/usr/bin:/bin:/usr/local/bin:/usr/gnu/bin::/usr/bin/X11:/sbin:/usr/sbin

recho ${XPATH//:/ }

xx=(ar as at au av aw ax ay az)

recho ${xx[@]/a/}
recho ${xx[@]//a/}

recho ${xx[*]/a/}
recho ${xx[*]//a/}

recho ${xx[@]%?}
recho ${xx[*]%?}

recho ${xx[@]#?}
recho ${xx[*]#?}

set -- ar as at au av aw ax ay az

recho ${@/a/}
recho ${@//a/}

recho ${*/a/}
recho ${*//a/}

recho ${@%?}
recho ${*%?}

recho ${@#?}
recho ${*#?}

shift ${#}
set -u
( recho $9 ; echo after 1)
( recho ${9} ; echo after 2)
( recho $UNSET ; echo after 3)
( recho ${UNSET} ; echo after 4)
( recho "$UNSET" ; echo after 5)
( recho "${UNSET}" ; echo after 6)
( recho "${#UNSET}" ; echo after 7)
set +u

RECEIVED="12345"
recho "${RECEIVED:$((${#RECEIVED}-1)):1}"
RECEIVED="12345#"
recho "${RECEIVED:$((${#RECEIVED}-1)):1}"
RECEIVED="#"
recho "${RECEIVED:$((${#RECEIVED}-1)):1}"
RECEIVED=""
recho "${RECEIVED:$((${#RECEIVED}-1)):1}"

# tests of new prefix expansion ${!prefix*}
${THIS_SH} ./new-exp3.sub

# bug with indirect expansion through bash-2.05b
${THIS_SH} ./new-exp4.sub

# these caused errors and core dumps in versions before bash-2.04
c=""
echo ${c//${$(($#-1))}/x/}

set a b c d e f g
recho "$@"

set -- ${@:1:$(($# - 2))}
recho "$@"

set a b
recho ${@:1:$(($# - 2))}

recho ${@:1:0}
recho ${@:1:1}
recho ${@:1:2}

recho "${*:1:0}"

# this is an error -- negative expression
set a
recho ${@:1:$(($# - 2))}
set a b c d e
recho ${@: -3:-2}

XPATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:.:/sbin:/usr/sbin
set $( IFS=: ; echo $XPATH ) 

recho ${@##*/}
recho ${@%%[!/]*}

recho ${@#/*}
recho ${@%*/}

set /full/path/to/x16 /another/full/path

recho ${1%/*}
recho ${1%%[!/]*}
recho ${1#*/}
recho ${1##*/}

${THIS_SH} ./new-exp5.sub

unset var
var=blah

# these had better agree
echo ${var[@]:3}
echo ${var:3}
echo ${var[@]/#/--}
echo ${var/#/--}
echo ${var[@]##?}
echo ${var##?}

unset var
var=(abcde abcfg abchi)

# problems with anchoring pattern replacements
echo ${var[*]//#abc/foo}
echo ${var[*]/#abc/foo}
unset var

${THIS_SH} ./new-exp6.sub

${THIS_SH} ./new-exp7.sub

${THIS_SH} ./new-exp8.sub

# tests to check whether things like indirect expansion of a variable whose
# value is 'anothervar[@]' stop working
${THIS_SH} ./new-exp9.sub

# new parameter transformation `@' expansion operator
${THIS_SH} ./new-exp10.sub

# parameter substring replacement and removal operators with multibyte chars
${THIS_SH} ./new-exp11.sub

# indirect expansion with arrays and local variables
${THIS_SH} ./new-exp12.sub

# more indirect expansion and parameter transformation issues
${THIS_SH} ./new-exp13.sub

# new K parameter transformation operator
${THIS_SH} ./new-exp14.sub

# ongoing work with a/A parameter transformations and `nounset'
${THIS_SH} ./new-exp15.sub

# pattern substitution with `&' (quoted and unquoted) in the replacement string
${THIS_SH} ./new-exp16.sub


# problems with stray CTLNUL in bash-4.0-alpha
unset a
a=/a
recho "/${a%/*}"
recho "/${a///a/}"

patfunc()
{
	echo ${1##*"${1##*}"}
}
patfunc foo

# caused core dumps because of bad bracket expression parsing in bash-5.0
eval : $'${x/#[0\xef\xbf\xbd\\Z[:]]}'

a=1/%2/%3
echo "${a/\%/##}"
echo "${a//\%/##}"
echo "${a/\/%/##}"

b=1/#2/#3
echo "${b/\#/%%}"
echo "${b//\#/%%}"
echo "${b/\/#/%%}"

unset a b

expect $0: 'ABXD: parameter unset'
${THIS_SH} -c 'recho ${ABXD:?"parameter unset"}' $0

--------------------------------------------------------------------------------
---
(if (arith (word " $UID == 0 ")) (command (word "echo") (word "\"new-exp.tests: the test suite should not be run as root\"") (redirect ">&" 2)))
(command (word "set") (word "+o") (word "posix"))
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(command (word "HOME=/usr/homes/chet"))
(command (word "expect") (word "'<foo bar>'"))
(command (word "recho") (word "\"${undef-\"foo bar\"}\""))
(command (word "expect") (word "'<foo>'"))
(command (word "recho") (word "\"${und=\"foo\"}\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${HOME-\"}\"}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"${HOME-'}'}\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"${HOME-\"}\"}\""))
(command (word "expect") (word "$0:") (word "'HOME: }: syntax error: operand expected (error token is \"}\")'"))
(command (word "recho") (word "\"${HOME:`echo }`}\""))
(command (word "expect") (word "unset"))
(command (word "_ENV=oops"))
(command (word "x=${_ENV[(_$-=0)+(_=1)-_${-%%*i*}]}"))
(command (word "echo") (word "${x:-unset}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${HOME}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${HOME:-`echo }`}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "${HOME:-`echo \"}\"`}"))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"${HOME:-`echo \"}\"`}\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"$(echo \"${HOME}\")\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"$(echo \"$(echo ${HOME})\")\""))
(command (word "expect") (word "\"<$HOME>\""))
(command (word "recho") (word "\"$(echo \"$(echo \"${HOME}\")\")\""))
(command (word "P=*@*"))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "\"${P%\"*\"}\""))
(command (word "expect") (word "'<*@>'"))
(command (word "recho") (word "\"${P%'*'}\""))
(command (word "expect") (word "'<@*>'"))
(command (word "recho") (word "\"${P#\\*}\""))
(command (word "expect") (word "'<)>'"))
(command (word "recho") (word "\"$(echo \")\")\""))
(command (word "expect") (word "'<\")\">'"))
(command (word "recho") (word "\"$(echo \"\\\")\\\"\")\""))
(command (word "foo='abcd   '"))
(command (word "expect") (word "'<-abcd> <->'"))
(command (word "recho") (word "-${foo}-"))
(command (word "expect") (word "'<-abcd> <->'"))
(command (word "recho") (word "-${foo% *}-"))
(command (word "expect") (word "'<-abcd->'"))
(command (word "recho") (word "-${foo%% *}-"))
(command (word "foo=bar"))
(command (word "expect") (word "'<bar foo>'"))
(semi (command (word "echo") (word "-n") (word "$foo' '")) (command (word "echo") (word "foo")))
(command (word "expect") (word "'<bar foo>'"))
(semi (command (word "echo") (word "-n") (word "$foo\" \"")) (command (word "echo") (word "foo")))
(command (word "expect") (word "'<bar foo>'"))
(semi (command (word "echo") (word "-n") (word "\"$foo \"")) (command (word "echo") (word "foo")))
(command (word "expect") (word "'<barfoo>'"))
(semi (command (word "echo") (word "-e") (word "\"$foo\\c \"")) (command (word "echo") (word "foo")))
(command (word "expect") (word "'<barfoo>'"))
(semi (command (word "echo") (word "-e") (word "$foo\"\\c \"")) (command (word "echo") (word "foo")))
(command (word "expect") (word "'<\\x>'"))
(command (word "echo") (word "-e") (word "'\\x'"))
(command (word "z=abcdefghijklmnop"))
(command (word "expect") (word "'<abcd>'"))
(command (word "recho") (word "${z:0:4}"))
(command (word "expect") (word "'<efg> <nop>'"))
(command (word "recho") (word "${z:4:3}") (word "${z:${#z}-3:3}"))
(command (word "expect") (word "'<efg> <nop>'"))
(command (word "recho") (word "${z:4:3}") (word "${z: -3:3}"))
(command (word "expect") (word "'<hijklmnop>'"))
(command (word "recho") (word "${z:7:30}"))
(command (word "expect") (word "'<abcdefghijklmnop>'"))
(command (word "recho") (word "${z:0:100}"))
(command (word "expect") (word "'<abcdefghijklmnop>'"))
(command (word "recho") (word "${z:0:${#z}}"))
(command (word "set") (word "'ab cd'") (word "'ef'") (word "'gh ij'") (word "'kl mn'") (word "'op'"))
(command (word "expect") (word "'<ab cd> <ef>'"))
(command (word "recho") (word "\"${@:1:2}\""))
(command (word "expect") (word "'<gh ij> <kl mn>'"))
(command (word "recho") (word "\"${@:3:2}\""))
(command (word "expect") (word "'<gh ij> <kl mn> <op>'"))
(command (word "recho") (word "\"${@:3:4}\""))
(command (word "expect") (word "'<ab cd> <ef> <gh ij> <kl mn> <op>'"))
(command (word "recho") (word "\"${@:1:$#}\""))
(command (word "base=/home/chet/foo//bar"))
(command (word "string1=$base/abcabcabc"))
(command (word "x=1") (word "j=4"))
(command (word "expect") (word "'</home/chet/foo//bar/abcabcabc>'"))
(command (word "recho") (word "${string1:0}"))
(command (word "expect") (word "'<home/chet/foo//bar/abcabcabc>'"))
(command (word "recho") (word "${string1:1}"))
(command (word "expect") (word "'<home>'"))
(command (word "recho") (word "${string1:(j?1:0):j}"))
(command (word "expect") (word "'<home>'"))
(command (word "recho") (word "${string1:j?1:0:j}"))
(command (word "expect") (word "'<home>'"))
(command (word "recho") (word "${string1:(j?(x?1:0):0):j}"))
(command (word "expect") (word "'<home>'"))
(command (word "recho") (word "${string1:j?(x?1:0):0:j}"))
(command (word "unset") (word "base") (word "string1") (word "x") (word "j"))
(command (word "expect") (word "'<abcdefghijklmnop>'"))
(command (word "recho") (word "${!9:-$z}"))
(command (word "ef=4"))
(command (word "expect") (word "'<4>'"))
(command (word "recho") (word "${!2}"))
(command (word "expect") (word "'<op>'"))
(command (word "recho") (word "${!#}"))
(command (word "set") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "a="))
(command (word "expect") (word "'<abcdefghijklmnop>'"))
(command (word "recho") (word "${a:-$z}"))
(command (word "expect") (word "'<abcdefghijklmnop>'"))
(command (word "recho") (word "${!1:-$z}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${a-$z}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${!1-$z}"))
(command (word "expect") (word "an") (word "error"))
(command (word "v=bad-var"))
(command (word "echo") (word "${!v}"))
(command (word "unset") (word "-v") (word "v"))
(command (word "set") (word "--") (word "a") (word "'b c'") (word "d"))
(command (word "unset") (word "foo"))
(command (word "foo=@"))
(command (word "expect") (word "'<a> <b> <c> <d>'"))
(command (word "recho") (word "${!foo}"))
(command (word "expect") (word "'<a> <b c> <d>'"))
(command (word "recho") (word "\"${!foo}\""))
(command (word "set") (word "-u"))
(command (word "expect") (word "$0:") (word "ABX:") (word "unbound") (word "variable"))
(subshell (command (word "recho") (word "${ABX}")))
(command (word "set") (word "+u"))
(command (word "expect") (word "$0:") (word "'$6: cannot assign in this way'"))
(command (word "recho") (word "${6=\"arg6\"}"))
(command (word "v=abcde"))
(command (word "expect") (word "'<xxcde>'"))
(command (word "recho") (word "${v/a[a-z]/xx}"))
(command (word "expect") (word "'<axxde>'"))
(command (word "recho") (word "${v/a??/axx}"))
(command (word "expect") (word "'<abxyz>'"))
(command (word "recho") (word "${v/c??/xyz}"))
(command (word "expect") (word "'<abbcde>'"))
(command (word "recho") (word "${v/#a/ab}"))
(command (word "expect") (word "'<abcde>'"))
(command (word "recho") (word "${v/#d/ab}"))
(command (word "expect") (word "'<abcabe>'"))
(command (word "recho") (word "${v/d/ab}"))
(command (word "expect") (word "'<abcdlast>'"))
(command (word "recho") (word "${v/%?/last}"))
(command (word "expect") (word "'<abcde>'"))
(command (word "recho") (word "${v/%x/last}"))
(command (word "av=(abcd efgh ijkl mnop qrst uvwx)"))
(command (word "expect") (word "'<xxcd>'"))
(command (word "recho") (word "${av/??/xx}"))
(command (word "expect") (word "'<abxx>'"))
(command (word "recho") (word "${av/%??/xx}"))
(command (word "expect") (word "'<xxgh>'"))
(command (word "recho") (word "${av[1]/??/xx}"))
(command (word "expect") (word "'<efgh>'"))
(command (word "recho") (word "${av[1]/%ab/xx}"))
(command (word "expect") (word "'<xxfgh>'"))
(command (word "recho") (word "${av[1]/#?/xx}"))
(command (word "expect") (word "'<zagh>'"))
(command (word "recho") (word "${av[1]/??/za}"))
(command (word "expect") (word "'<zaza>'"))
(command (word "recho") (word "${av[1]//??/za}"))
(command (word "expect") (word "'<zagh>'"))
(command (word "recho") (word "${av[1]/#??/za}"))
(command (word "expect") (word "'<efza>'"))
(command (word "recho") (word "${av[1]/%??/za}"))
(command (word "expect") (word "'<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'"))
(command (word "recho") (word "${av[@]/*/yyy}"))
(command (word "expect") (word "'<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'"))
(command (word "recho") (word "${av[@]/#*/yyy}"))
(command (word "expect") (word "'<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'"))
(command (word "recho") (word "${av[@]/%*/yyy}"))
(command (word "expect") (word "'<yyy> <efgh> <ijkl> <mnop> <qrst> <uvwx>'"))
(command (word "recho") (word "${av[@]/a*/yyy}"))
(command (word "expect") (word "'<abxx> <efxx> <ijxx> <mnxx> <qrxx> <uvxx>'"))
(command (word "recho") (word "${av[@]/%??/xx}"))
(command (word "set") (word "abcd") (word "efgh") (word "ijkl") (word "mnop") (word "qrst") (word "uvwx"))
(command (word "expect") (word "'<xxcd>'"))
(command (word "recho") (word "${1/??/xx}"))
(command (word "expect") (word "'<xxcd> <xxgh> <xxkl> <xxop> <xxst> <xxwx>'"))
(command (word "recho") (word "${@/??/xx}"))
(command (word "expect") (word "'<xxcd> <xxgh> <xxkl> <xxop> <xxst> <xxwx>'"))
(command (word "recho") (word "${@/%??/xx}"))
(command (word "expect") (word "'<zaza>'"))
(command (word "recho") (word "${3//??/za}"))
(command (word "expect") (word "'<efza>'"))
(command (word "recho") (word "${3/%??/za}"))
(command (word "expect") (word "'<zaza> <zaza> <zaza> <zaza> <zaza> <zaza>'"))
(command (word "recho") (word "${@//??/za}"))
(command (word "expect") (word "'<zacd> <zagh> <zakl> <zaop> <zast> <zawx>'"))
(command (word "recho") (word "${@/#??/za}"))
(command (word "expect") (word "'<yyy> <yyy> <yyy> <yyy> <yyy> <yyy>'"))
(command (word "recho") (word "${@//*/yyy}"))
(command (word "expect") (word "'<yyy> <efgh> <ijkl> <mnop> <qrst> <uvwx>'"))
(command (word "recho") (word "${@//a*/yyy}"))
(command (word "expect") (word "'<abcd> <efgh> <ijkl> <mnop> <qrst> <uvwyyy>'"))
(command (word "recho") (word "${@/%x*/yyy}"))
(command (word "expect") (word "a") (word "newline"))
(command (word "echo") (word "$abmcde"))
(command (word "AVAR='This\nstring\nhas\nmultiple\nlines.'"))
(command (word "echo") (word "\"${AVAR}\""))
(command (word "eval") (word "BVAR=\\\"\\${AVAR//'\n'/-}\\\""))
(command (word "echo") (word "\"$BVAR\""))
(command (word "unset") (word "AVAR") (word "BVAR"))
(command (word "${THIS_SH}") (word "./new-exp1.sub"))
(command (word "${THIS_SH}") (word "./new-exp2.sub"))
(command (word "expect") (word "'<6>'"))
(command (word "recho") (word "${#:-foo}"))
(command (word "expect") (word "$0:") (word "'${#:}: bad substitution'"))
(command (word "echo") (word "${#:}"))
(command (word "expect") (word "\"<'>\""))
(command (word "recho") (word "\"'\""))
(command (word "expect") (word "'<\">'"))
(command (word "recho") (word "'\"'"))
(command (word "expect") (word "'<\"hello\">'"))
(command (word "recho") (word "\"\\\"hello\\\"\""))
(command (word "shift") (word "$#"))
(command (word "unset") (word "foo"))
(command (word "z=abcdef"))
(command (word "z1='abc def'"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "${foo:-\"\"}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${foo:-\"$@\"}"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${foo:-$@}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "${foo:-\"$zbcd\"}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${foo:-$zbcd}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${foo:-\"$z\"}"))
(command (word "expect") (word "'<abc def>'"))
(command (word "recho") (word "${foo:-\"$z1\"}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "${foo:-$z}"))
(command (word "expect") (word "'<abc> <def>'"))
(command (word "recho") (word "${foo:-$z1}"))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "\"${foo:-$z}\""))
(command (word "expect") (word "'<abc def>'"))
(command (word "recho") (word "\"${foo:-$z1}\""))
(command (word "expect") (word "'<abcdef>'"))
(command (word "recho") (word "\"${foo:-\"$z\"}\""))
(command (word "expect") (word "'<abc def>'"))
(command (word "recho") (word "\"${foo:-\"$z1\"}\""))
(command (word "set") (word "ab") (word "cd") (word "ef") (word "gh"))
(command (word "expect") (word "'<ab> <cd> <ef> <gh>'"))
(command (word "recho") (word "${foo:-\"$@\"}"))
(command (word "expect") (word "'<ab> <cd> <ef> <gh>'"))
(command (word "recho") (word "\"${foo:-$@}\""))
(command (word "expect") (word "'<ab> <cd> <ef> <gh>'"))
(command (word "recho") (word "\"${foo:-\"$@\"}\""))
(command (word "shift") (word "${#}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$xxx\"$@\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "${foo:-$xxx\"$@\"}"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${foo:-$xxx$@}\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"${foo:-$xxx\"$@\"}\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$xxx\"$@\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "\"$xxx$@\""))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "\"$@\"$xxx"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx\"\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "$xxx''"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "''$xxx"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"\"$xxx"))
(command (word "AB='abcdefghijklmnopqrstuvwxyz'"))
(command (word "recho") (word "${AB:7:15}"))
(command (word "recho") (word "${AB:15:7}"))
(command (word "recho") (word "${AB:20}"))
(command (word "recho") (word "${AB:0}"))
(command (word "recho") (word "${AB:0:20}"))
(command (word "recho") (word "${AB:10:7}"))
(command (word "recho") (word "${AB:10:3+4}"))
(command (word "recho") (word "${AB:20/2:3+4}"))
(command (word "set") (word "1") (word "2") (word "3") (word "4") (word "5") (word "6"))
(command (word "recho") (word "\\\"\"${*:2:2}\"\\\""))
(command (word "IFS=:"))
(command (word "recho") (word "\\\"\"${*:2:2}\"\\\""))
(command (word "IFS=' \t\n'"))
(command (word "z=123456"))
(command (word "recho") (word "\\\"\"${z:2:2}\"\\\""))
(command (word "recho") (word "\\\"\"${z:2}\"\\\""))
(command (word "recho") (word "\\\"\"${z:2:4}\"\\\""))
(command (word "recho") (word "\\\"\"${z:2:6}\"\\\""))
(command (word "set") (word "''") (word "''") (word "''"))
(command (word "recho") (word "$*"))
(command (word "recho") (word "$@"))
(command (word "recho") (word "${*}"))
(command (word "recho") (word "${@}"))
(command (word "xx=one/two/two"))
(command (word "recho") (word "${xx%/*}"))
(command (word "recho") (word "${xx/\\/two}"))
(command (word "yy=oneonetwo"))
(command (word "recho") (word "${yy//one}"))
(command (word "recho") (word "${yy/\\/one}"))
(command (word "xx=oneonetwo"))
(command (word "recho") (word "${xx/one}"))
(command (word "recho") (word "${xx//one}"))
(command (word "recho") (word "${xx/\\/one}"))
(command (word "var=abc"))
(command (word "c=${var:3}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$c"))
(command (word "c=${var:4}"))
(command (word "expect") (word "nothing"))
(command (word "recho") (word "$c"))
(command (word "c=${var:0:-2}"))
(command (word "expect") (word "'<a>'"))
(command (word "recho") (word "$c"))
(command (word "var=abcdefghi"))
(command (word "c=${var:3:12}"))
(command (word "recho") (word "$c"))
(command (word "c=${var:4:20}"))
(command (word "recho") (word "$c"))
(command (word "xxx=endocrine"))
(command (word "yyy=n"))
(command (word "unset") (word "zzz"))
(command (word "recho") (word "${xxx/$yyy/*}"))
(command (word "recho") (word "${xxx//$yyy/*}"))
(command (word "recho") (word "${xxx/$zzz/*}"))
(command (word "recho") (word "${xxx//$zzz/*}"))
(command (word "recho") (word "${xxx//%${zzz}/}"))
(command (word "recho") (word "${xxx//%${zzz}}"))
(command (word "recho") (word "${xxx//#${zzz}/}"))
(command (word "recho") (word "${xxx//#${zzz}}"))
(command (word "unset") (word "var"))
(command (word "var="))
(command (word "echo") (word "\"${var/#/x}\""))
(command (word "echo") (word "\"${var/*/x}\""))
(command (word "echo") (word "\"${var//*/x}\""))
(command (word "var=abc"))
(command (word "echo") (word "\"${var/#/x}\""))
(command (word "echo") (word "\"${var/*/x}\""))
(command (word "echo") (word "\"${var//*/x}\""))
(command (word "unset") (word "var"))
(command (word "XPATH=/usr/bin:/bin:/usr/local/bin:/usr/gnu/bin::/usr/bin/X11:/sbin:/usr/sbin"))
(command (word "recho") (word "${XPATH//:/ }"))
(command (word "xx=(ar as at au av aw ax ay az)"))
(command (word "recho") (word "${xx[@]/a/}"))
(command (word "recho") (word "${xx[@]//a/}"))
(command (word "recho") (word "${xx[*]/a/}"))
(command (word "recho") (word "${xx[*]//a/}"))
(command (word "recho") (word "${xx[@]%?}"))
(command (word "recho") (word "${xx[*]%?}"))
(command (word "recho") (word "${xx[@]#?}"))
(command (word "recho") (word "${xx[*]#?}"))
(command (word "set") (word "--") (word "ar") (word "as") (word "at") (word "au") (word "av") (word "aw") (word "ax") (word "ay") (word "az"))
(command (word "recho") (word "${@/a/}"))
(command (word "recho") (word "${@//a/}"))
(command (word "recho") (word "${*/a/}"))
(command (word "recho") (word "${*//a/}"))
(command (word "recho") (word "${@%?}"))
(command (word "recho") (word "${*%?}"))
(command (word "recho") (word "${@#?}"))
(command (word "recho") (word "${*#?}"))
(command (word "shift") (word "${#}"))
(command (word "set") (word "-u"))
(subshell (semi (command (word "recho") (word "$9")) (command (word "echo") (word "after") (word "1"))))
(subshell (semi (command (word "recho") (word "${9}")) (command (word "echo") (word "after") (word "2"))))
(subshell (semi (command (word "recho") (word "$UNSET")) (command (word "echo") (word "after") (word "3"))))
(subshell (semi (command (word "recho") (word "${UNSET}")) (command (word "echo") (word "after") (word "4"))))
(subshell (semi (command (word "recho") (word "\"$UNSET\"")) (command (word "echo") (word "after") (word "5"))))
(subshell (semi (command (word "recho") (word "\"${UNSET}\"")) (command (word "echo") (word "after") (word "6"))))
(subshell (semi (command (word "recho") (word "\"${#UNSET}\"")) (command (word "echo") (word "after") (word "7"))))
(command (word "set") (word "+u"))
(command (word "RECEIVED=\"12345\""))
(command (word "recho") (word "\"${RECEIVED:$((${#RECEIVED}-1)):1}\""))
(command (word "RECEIVED=\"12345#\""))
(command (word "recho") (word "\"${RECEIVED:$((${#RECEIVED}-1)):1}\""))
(command (word "RECEIVED=\"#\""))
(command (word "recho") (word "\"${RECEIVED:$((${#RECEIVED}-1)):1}\""))
(command (word "RECEIVED=\"\""))
(command (word "recho") (word "\"${RECEIVED:$((${#RECEIVED}-1)):1}\""))
(command (word "${THIS_SH}") (word "./new-exp3.sub"))
(command (word "${THIS_SH}") (word "./new-exp4.sub"))
(command (word "c=\"\""))
(command (word "echo") (word "${c//${$(($#-1))}/x/}"))
(command (word "set") (word "a") (word "b") (word "c") (word "d") (word "e") (word "f") (word "g"))
(command (word "recho") (word "\"$@\""))
(command (word "set") (word "--") (word "${@:1:$(($# - 2))}"))
(command (word "recho") (word "\"$@\""))
(command (word "set") (word "a") (word "b"))
(command (word "recho") (word "${@:1:$(($# - 2))}"))
(command (word "recho") (word "${@:1:0}"))
(command (word "recho") (word "${@:1:1}"))
(command (word "recho") (word "${@:1:2}"))
(command (word "recho") (word "\"${*:1:0}\""))
(command (word "set") (word "a"))
(command (word "recho") (word "${@:1:$(($# - 2))}"))
(command (word "set") (word "a") (word "b") (word "c") (word "d") (word "e"))
(command (word "recho") (word "${@: -3:-2}"))
(command (word "XPATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:.:/sbin:/usr/sbin"))
(command (word "set") (word "$(IFS=:; echo $XPATH)"))
(command (word "recho") (word "${@##*/}"))
(command (word "recho") (word "${@%%[!/]*}"))
(command (word "recho") (word "${@#/*}"))
(command (word "recho") (word "${@%*/}"))
(command (word "set") (word "/full/path/to/x16") (word "/another/full/path"))
(command (word "recho") (word "${1%/*}"))
(command (word "recho") (word "${1%%[!/]*}"))
(command (word "recho") (word "${1#*/}"))
(command (word "recho") (word "${1##*/}"))
(command (word "${THIS_SH}") (word "./new-exp5.sub"))
(command (word "unset") (word "var"))
(command (word "var=blah"))
(command (word "echo") (word "${var[@]:3}"))
(command (word "echo") (word "${var:3}"))
(command (word "echo") (word "${var[@]/#/--}"))
(command (word "echo") (word "${var/#/--}"))
(command (word "echo") (word "${var[@]##?}"))
(command (word "echo") (word "${var##?}"))
(command (word "unset") (word "var"))
(command (word "var=(abcde abcfg abchi)"))
(command (word "echo") (word "${var[*]//#abc/foo}"))
(command (word "echo") (word "${var[*]/#abc/foo}"))
(command (word "unset") (word "var"))
(command (word "${THIS_SH}") (word "./new-exp6.sub"))
(command (word "${THIS_SH}") (word "./new-exp7.sub"))
(command (word "${THIS_SH}") (word "./new-exp8.sub"))
(command (word "${THIS_SH}") (word "./new-exp9.sub"))
(command (word "${THIS_SH}") (word "./new-exp10.sub"))
(command (word "${THIS_SH}") (word "./new-exp11.sub"))
(command (word "${THIS_SH}") (word "./new-exp12.sub"))
(command (word "${THIS_SH}") (word "./new-exp13.sub"))
(command (word "${THIS_SH}") (word "./new-exp14.sub"))
(command (word "${THIS_SH}") (word "./new-exp15.sub"))
(command (word "${THIS_SH}") (word "./new-exp16.sub"))
(command (word "unset") (word "a"))
(command (word "a=/a"))
(command (word "recho") (word "\"/${a%/*}\""))
(command (word "recho") (word "\"/${a///a/}\""))
(function "patfunc" (brace-group (command (word "echo") (word "${1##*\"${1##*}\"}"))))
(command (word "patfunc") (word "foo"))
(command (word "eval") (word ":") (word "'${x/#[0\\Z[:]]}'"))
(command (word "a=1/%2/%3"))
(command (word "echo") (word "\"${a/\\%/##}\""))
(command (word "echo") (word "\"${a//\\%/##}\""))
(command (word "echo") (word "\"${a/\\/%/##}\""))
(command (word "b=1/#2/#3"))
(command (word "echo") (word "\"${b/\\#/%%}\""))
(command (word "echo") (word "\"${b//\\#/%%}\""))
(command (word "echo") (word "\"${b/\\/#/%%}\""))
(command (word "unset") (word "a") (word "b"))
(command (word "expect") (word "$0:") (word "'ABXD: parameter unset'"))
(command (word "${THIS_SH}") (word "-c") (word "'recho ${ABXD:?\"parameter unset\"}'") (word "$0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
expect()
{
        echo expect "$@"
}

expect '<^J^J^J>'
recho $'\n\n\n'

expect '<++^J++>'
f=$'\n'
recho "++$f++"
unset f

z1=$''
expect '<>'
recho "$z1"

ZIFS=$'\n'$'\t'$' '

expect '<^J^I >'
recho "$ZIFS"

expect '<abc>'
recho $'abc'

expect '<^M^[^Gabc>'
recho $'\r\e\aabc'

D=$"hello"," "$"world"

expect '<hello,> <world>'
recho $D

expect '<hello, world>'
recho "$D"

D=$""
expect '<>'
recho "$D"

world=chet

expect '<$hello, world>'
recho \$"hello, world"

expect '<hello, $world>'
recho $"hello, \$world"

expect '<hello, "world">'
recho $"hello, \"world\""

expect '<hello, $"world">'
recho $"hello"', $"world"'

expect '<hello, $"world">'
recho $'hello, $"world"'

expect '<$hello, chet>'
recho \$"hello, $world"

expect '<hello, chet>'
recho $"hello, $world"

z=$'\v\f\a\b'
case "$z" in
$'\v\f\a\b')	echo ok;;
*)		echo bad;;
esac

# Dave Korn says this should be allowed and echo 'abcd'
echo $'\'abcd\''

# printf translates \' to ' ...
printf "\'abcd\'\n"

# but echo -e doesn't
echo -e "\'abcd\'"
echo -e "\\'abcd\\'"

# and what do we do about unrecognized escape sequences?

shopt -s xpg_echo

recho $'A\CB'

recho "A\CB"

cde=c
recho $'ab$cde'

printf "%b\n" 'A\CB'
printf 'A\CB\n'

echo 'A\CB'

world=chet

recho $'hello, $"world"'
recho $'hello, \$"world"'
recho $'hello, $\"world"'

recho "hello, $"world""

# ansi quoting inside double-quoted command subst - bash-3.1 bug
echo $(set -- $'a b'; echo $#)
echo "$(set -- $'a b'; echo $#)"

echo "$(echo $';foo')"

args ()
{
 for a in "$@";do echo "'$a'";done
}
unset mytab
recho "${mytab:-$'\t'}"
recho "$( args $'A\tB' )"

# tests for $'...' not being expanded when inside double quotes
recho $'a\tb\tc'
recho "$'a\tb\tc'"

# tests for $'...' being expanded in command substitution, and when
echo "$(echo $'\t\t\101\104\n\105')"

${THIS_SH} ./nquote1.sub
${THIS_SH} ./nquote2.sub
${THIS_SH} ./nquote3.sub
${THIS_SH} ./nquote4.sub
${THIS_SH} ./nquote5.sub

--------------------------------------------------------------------------------
---
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(command (word "expect") (word "'<^J^J^J>'"))
(command (word "recho") (word "'\n\n\n'"))
(command (word "expect") (word "'<++^J++>'"))
(command (word "f='\n'"))
(command (word "recho") (word "\"++$f++\""))
(command (word "unset") (word "f"))
(command (word "z1=''"))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"$z1\""))
(command (word "ZIFS='\n''\t'' '"))
(command (word "expect") (word "'<^J^I >'"))
(command (word "recho") (word "\"$ZIFS\""))
(command (word "expect") (word "'<abc>'"))
(command (word "recho") (word "'abc'"))
(command (word "expect") (word "'<^M^[^Gabc>'"))
(command (word "recho") (word "'abc'"))
(command (word "D=\"hello\",\" \"\"world\""))
(command (word "expect") (word "'<hello,> <world>'"))
(command (word "recho") (word "$D"))
(command (word "expect") (word "'<hello, world>'"))
(command (word "recho") (word "\"$D\""))
(command (word "D=\"\""))
(command (word "expect") (word "'<>'"))
(command (word "recho") (word "\"$D\""))
(command (word "world=chet"))
(command (word "expect") (word "'<$hello, world>'"))
(command (word "recho") (word "\\$\"hello, world\""))
(command (word "expect") (word "'<hello, $world>'"))
(command (word "recho") (word "\"hello, \\$world\""))
(command (word "expect") (word "'<hello, \"world\">'"))
(command (word "recho") (word "\"hello, \\\"world\\\"\""))
(command (word "expect") (word "'<hello, $\"world\">'"))
(command (word "recho") (word "\"hello\"', $\"world\"'"))
(command (word "expect") (word "'<hello, $\"world\">'"))
(command (word "recho") (word "'hello, $\"world\"'"))
(command (word "expect") (word "'<$hello, chet>'"))
(command (word "recho") (word "\\$\"hello, $world\""))
(command (word "expect") (word "'<hello, chet>'"))
(command (word "recho") (word "\"hello, $world\""))
(command (word "z=''"))
(case (word "\"$z\"") (pattern ((word "''")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "bad"))))
(command (word "echo") (word "''\\''abcd'\\'''"))
(command (word "printf") (word "\"\\'abcd\\'\\n\""))
(command (word "echo") (word "-e") (word "\"\\'abcd\\'\""))
(command (word "echo") (word "-e") (word "\"\\\\'abcd\\\\'\""))
(command (word "shopt") (word "-s") (word "xpg_echo"))
(command (word "recho") (word "'A\\CB'"))
(command (word "recho") (word "\"A\\CB\""))
(command (word "cde=c"))
(command (word "recho") (word "'ab$cde'"))
(command (word "printf") (word "\"%b\\n\"") (word "'A\\CB'"))
(command (word "printf") (word "'A\\CB\\n'"))
(command (word "echo") (word "'A\\CB'"))
(command (word "world=chet"))
(command (word "recho") (word "'hello, $\"world\"'"))
(command (word "recho") (word "'hello, \\$\"world\"'"))
(command (word "recho") (word "'hello, $\"world\"'"))
(command (word "recho") (word "\"hello, $\"world\"\""))
(command (word "echo") (word "$(set -- 'a b'; echo $#)"))
(command (word "echo") (word "\"$(set -- 'a b'; echo $#)\""))
(command (word "echo") (word "\"$(echo ';foo')\""))
(function "args" (brace-group (for (word "a") (in (word "\"$@\"")) (command (word "echo") (word "\"'$a'\"")))))
(command (word "unset") (word "mytab"))
(command (word "recho") (word "\"${mytab:-\t}\""))
(command (word "recho") (word "\"$(args 'A\tB')\""))
(command (word "recho") (word "'a\tb\tc'"))
(command (word "recho") (word "\"$'a\\tb\\tc'\""))
(command (word "echo") (word "\"$(echo '\t\tAD\nE')\""))
(command (word "${THIS_SH}") (word "./nquote1.sub"))
(command (word "${THIS_SH}") (word "./nquote2.sub"))
(command (word "${THIS_SH}") (word "./nquote3.sub"))
(command (word "${THIS_SH}") (word "./nquote4.sub"))
(command (word "${THIS_SH}") (word "./nquote5.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote1
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
a=$'a\001b'

set $a

b=$a
c=$1
d="$1"

e=$'uv\001\001wx'

recho a $a ${#a}
recho 1 $1 ${#1}
recho b $b ${#b}
recho c $c ${#c}
recho d $d ${#d}

recho a ${a} ${#a}
recho 1 ${1} ${#1}
recho b ${b} ${#b}
recho c ${c} ${#c}
recho d ${d} ${#d}

recho a "$a" ${#a}
recho 1 "$1" ${#1}
recho b "$b" ${#b}
recho c "$c" ${#c}
recho d "$d" ${#d}

recho a "${a}" ${#a}
recho 1 "${1}" ${#1}
recho b "${b}" ${#b}
recho c "${c}" ${#c}
recho d "${d}" ${#d}

set $e

recho e1 ${e:1:3}
recho e2 "${e:1:3}"
recho e3 ${1:1:3}
recho e4 "${1:1:3}"

arr[0]=$e
arr[1]=$e

recho a1 ${arr:0:4}
recho a2 "${arr:0:4}"

recho a3 ${arr[@]:0:2}
recho a4 "${arr[@]:0:2}"

set $e $e

recho p1 ${@:1:2}
recho p2 "${@:1:2}"

recho p1 ${*:1:2}
recho p2 "${*:1:2}"

recho $e

recho 'uvwx'

f='uvwx'

recho $f

echo -en "\01" | cat -v
echo

huhu() { echo "$1"; };

huhu $(echo -en "\01") | cat -v
huhu $(echo -en "\02") | cat -v

f=$'uv\001w\001xy'

set $f $f

recho f1 ${f:1:3}
recho f2 "${f:1:3}"

arr[0]=$f
arr[1]=$f

recho a1 ${arr:0:4}
recho a2 "${arr:0:4}"
recho a3 ${arr[0]:0:4}
recho a4 "${arr[0]:0:4}"

recho e1 ${f:0:4}
recho e2 "${f:0:4}"

recho d1 ${1:2:2}
recho d2 "${1:2:2}"

recho @1 ${@:1:2}
recho @2 "${@:1:2}"

declare -A assoc
assoc=( [0]=$e [1]=$e )

recho aa1 ${assoc:0:4}
recho aa2 "${assoc:0:4}"

recho aa3 ${assoc[@]:0:2}
recho aa4 "${assoc[@]:0:2}"

--------------------------------------------------------------------------------
---
(command (word "a='ab'"))
(command (word "set") (word "$a"))
(command (word "b=$a"))
(command (word "c=$1"))
(command (word "d=\"$1\""))
(command (word "e='uvwx'"))
(command (word "recho") (word "a") (word "$a") (word "${#a}"))
(command (word "recho") (word "1") (word "$1") (word "${#1}"))
(command (word "recho") (word "b") (word "$b") (word "${#b}"))
(command (word "recho") (word "c") (word "$c") (word "${#c}"))
(command (word "recho") (word "d") (word "$d") (word "${#d}"))
(command (word "recho") (word "a") (word "${a}") (word "${#a}"))
(command (word "recho") (word "1") (word "${1}") (word "${#1}"))
(command (word "recho") (word "b") (word "${b}") (word "${#b}"))
(command (word "recho") (word "c") (word "${c}") (word "${#c}"))
(command (word "recho") (word "d") (word "${d}") (word "${#d}"))
(command (word "recho") (word "a") (word "\"$a\"") (word "${#a}"))
(command (word "recho") (word "1") (word "\"$1\"") (word "${#1}"))
(command (word "recho") (word "b") (word "\"$b\"") (word "${#b}"))
(command (word "recho") (word "c") (word "\"$c\"") (word "${#c}"))
(command (word "recho") (word "d") (word "\"$d\"") (word "${#d}"))
(command (word "recho") (word "a") (word "\"${a}\"") (word "${#a}"))
(command (word "recho") (word "1") (word "\"${1}\"") (word "${#1}"))
(command (word "recho") (word "b") (word "\"${b}\"") (word "${#b}"))
(command (word "recho") (word "c") (word "\"${c}\"") (word "${#c}"))
(command (word "recho") (word "d") (word "\"${d}\"") (word "${#d}"))
(command (word "set") (word "$e"))
(command (word "recho") (word "e1") (word "${e:1:3}"))
(command (word "recho") (word "e2") (word "\"${e:1:3}\""))
(command (word "recho") (word "e3") (word "${1:1:3}"))
(command (word "recho") (word "e4") (word "\"${1:1:3}\""))
(command (word "arr[0]=$e"))
(command (word "arr[1]=$e"))
(command (word "recho") (word "a1") (word "${arr:0:4}"))
(command (word "recho") (word "a2") (word "\"${arr:0:4}\""))
(command (word "recho") (word "a3") (word "${arr[@]:0:2}"))
(command (word "recho") (word "a4") (word "\"${arr[@]:0:2}\""))
(command (word "set") (word "$e") (word "$e"))
(command (word "recho") (word "p1") (word "${@:1:2}"))
(command (word "recho") (word "p2") (word "\"${@:1:2}\""))
(command (word "recho") (word "p1") (word "${*:1:2}"))
(command (word "recho") (word "p2") (word "\"${*:1:2}\""))
(command (word "recho") (word "$e"))
(command (word "recho") (word "'uvwx'"))
(command (word "f='uvwx'"))
(command (word "recho") (word "$f"))
(pipe (command (word "echo") (word "-en") (word "\"\\01\"")) (command (word "cat") (word "-v")))
(command (word "echo"))
(function "huhu" (brace-group (command (word "echo") (word "\"$1\""))))
(pipe (command (word "huhu") (word "$(echo -en \"\\01\")")) (command (word "cat") (word "-v")))
(pipe (command (word "huhu") (word "$(echo -en \"\\02\")")) (command (word "cat") (word "-v")))
(command (word "f='uvwxy'"))
(command (word "set") (word "$f") (word "$f"))
(command (word "recho") (word "f1") (word "${f:1:3}"))
(command (word "recho") (word "f2") (word "\"${f:1:3}\""))
(command (word "arr[0]=$f"))
(command (word "arr[1]=$f"))
(command (word "recho") (word "a1") (word "${arr:0:4}"))
(command (word "recho") (word "a2") (word "\"${arr:0:4}\""))
(command (word "recho") (word "a3") (word "${arr[0]:0:4}"))
(command (word "recho") (word "a4") (word "\"${arr[0]:0:4}\""))
(command (word "recho") (word "e1") (word "${f:0:4}"))
(command (word "recho") (word "e2") (word "\"${f:0:4}\""))
(command (word "recho") (word "d1") (word "${1:2:2}"))
(command (word "recho") (word "d2") (word "\"${1:2:2}\""))
(command (word "recho") (word "@1") (word "${@:1:2}"))
(command (word "recho") (word "@2") (word "\"${@:1:2}\""))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc=([0]=$e [1]=$e)"))
(command (word "recho") (word "aa1") (word "${assoc:0:4}"))
(command (word "recho") (word "aa2") (word "\"${assoc:0:4}\""))
(command (word "recho") (word "aa3") (word "${assoc[@]:0:2}"))
(command (word "recho") (word "aa4") (word "\"${assoc[@]:0:2}\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
a=$'a\001b'

e=$'uv\001\001wx'

recho $a
recho $e

recho ${a/$'\001'/A}
recho "${a/$'\001'/A}"
recho ${e/$'\001'/A}
recho "${e/$'\001'/A}"

recho ${a/b/B}
recho "${a/b/B}"
recho ${e/w/W}
recho "${e/w/W}"

recho ${a//$'\001'/A}
recho "${a//$'\001'/A}"
recho ${e//$'\001'/A}
recho "${e//$'\001'/A}"

recho ${a//b/B}
recho "${a//b/B}"
recho ${e//w/W}
recho "${e//w/W}"

# pos params pat subst

set $e $e

recho ${@/$'\001'/A}
recho "${@/$'\001'/A}"
recho ${@/w/W}
recho "${@/w/W}"

recho ${@//$'\001'/A}
recho "${@//$'\001'/A}"
recho ${@//w/W}
recho "${@//w/W}"

arr[0]=$a
arr[1]=$e

recho ${arr[0]}
recho ${arr[1]}

recho ${arr[0]/$'\001'/A}
recho "${arr[0]/$'\001'/A}"
recho ${arr[1]/$'\001'/A}
recho "${arr[1]/$'\001'/A}"

recho ${arr[0]/b/B}
recho "${arr[0]/b/B}"
recho ${arr[1]/w/W}
recho "${arr[1]/w/W}"

recho ${arr[0]//$'\001'/A}
recho "${arr[0]//$'\001'/A}"
recho ${arr[1]//$'\001'/A}
recho "${arr[1]//$'\001'/A}"

recho ${arr[0]//b/B}
recho "${arr[0]//b/B}"
recho ${arr[1]//w/W}
recho "${arr[1]//w/W}"

recho ${arr[@]/$'\001'/A}
recho "${arr[@]/$'\001'/A}"

recho ${arr[@]/b/B}
recho "${arr[@]/b/B}"
recho ${arr[@]/w/W}
recho "${arr[@]/w/W}"

recho ${arr[@]//$'\001'/A}
recho "${arr[@]//$'\001'/A}"

recho ${arr[@]//b/B}
recho "${arr[@]//b/B}"
recho ${arr[@]//w/W}
recho "${arr[@]//w/W}"

--------------------------------------------------------------------------------
---
(command (word "a='ab'"))
(command (word "e='uvwx'"))
(command (word "recho") (word "$a"))
(command (word "recho") (word "$e"))
(command (word "recho") (word "${a/''/A}"))
(command (word "recho") (word "\"${a/''/A}\""))
(command (word "recho") (word "${e/''/A}"))
(command (word "recho") (word "\"${e/''/A}\""))
(command (word "recho") (word "${a/b/B}"))
(command (word "recho") (word "\"${a/b/B}\""))
(command (word "recho") (word "${e/w/W}"))
(command (word "recho") (word "\"${e/w/W}\""))
(command (word "recho") (word "${a//''/A}"))
(command (word "recho") (word "\"${a//''/A}\""))
(command (word "recho") (word "${e//''/A}"))
(command (word "recho") (word "\"${e//''/A}\""))
(command (word "recho") (word "${a//b/B}"))
(command (word "recho") (word "\"${a//b/B}\""))
(command (word "recho") (word "${e//w/W}"))
(command (word "recho") (word "\"${e//w/W}\""))
(command (word "set") (word "$e") (word "$e"))
(command (word "recho") (word "${@/''/A}"))
(command (word "recho") (word "\"${@/''/A}\""))
(command (word "recho") (word "${@/w/W}"))
(command (word "recho") (word "\"${@/w/W}\""))
(command (word "recho") (word "${@//''/A}"))
(command (word "recho") (word "\"${@//''/A}\""))
(command (word "recho") (word "${@//w/W}"))
(command (word "recho") (word "\"${@//w/W}\""))
(command (word "arr[0]=$a"))
(command (word "arr[1]=$e"))
(command (word "recho") (word "${arr[0]}"))
(command (word "recho") (word "${arr[1]}"))
(command (word "recho") (word "${arr[0]/''/A}"))
(command (word "recho") (word "\"${arr[0]/''/A}\""))
(command (word "recho") (word "${arr[1]/''/A}"))
(command (word "recho") (word "\"${arr[1]/''/A}\""))
(command (word "recho") (word "${arr[0]/b/B}"))
(command (word "recho") (word "\"${arr[0]/b/B}\""))
(command (word "recho") (word "${arr[1]/w/W}"))
(command (word "recho") (word "\"${arr[1]/w/W}\""))
(command (word "recho") (word "${arr[0]//''/A}"))
(command (word "recho") (word "\"${arr[0]//''/A}\""))
(command (word "recho") (word "${arr[1]//''/A}"))
(command (word "recho") (word "\"${arr[1]//''/A}\""))
(command (word "recho") (word "${arr[0]//b/B}"))
(command (word "recho") (word "\"${arr[0]//b/B}\""))
(command (word "recho") (word "${arr[1]//w/W}"))
(command (word "recho") (word "\"${arr[1]//w/W}\""))
(command (word "recho") (word "${arr[@]/''/A}"))
(command (word "recho") (word "\"${arr[@]/''/A}\""))
(command (word "recho") (word "${arr[@]/b/B}"))
(command (word "recho") (word "\"${arr[@]/b/B}\""))
(command (word "recho") (word "${arr[@]/w/W}"))
(command (word "recho") (word "\"${arr[@]/w/W}\""))
(command (word "recho") (word "${arr[@]//''/A}"))
(command (word "recho") (word "\"${arr[@]//''/A}\""))
(command (word "recho") (word "${arr[@]//b/B}"))
(command (word "recho") (word "\"${arr[@]//b/B}\""))
(command (word "recho") (word "${arr[@]//w/W}"))
(command (word "recho") (word "\"${arr[@]//w/W}\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote3
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
a=$'a\001b'

set $a

b=$a
c=$1
d="$1"

e=$'uv\001\001wx'
f=$'uv\001w\001xy'

set $e $e

recho ${e%%??}
recho "${e%%??}"

recho ${e%%???}
recho "${e%%???}"

recho ${a#?}
recho "${a#?}"

# simple variables

recho ${f##*$'\001'}
recho "${f##*$'\001'}"
recho ${f##*''}		# literal ^A
recho "${f##*'^A'}"		# two characters, `^' and `A'

recho ${e%$'\001'*}
recho "${e%$'\001'*}"
recho ${e#*$'\001'}
recho "${e#*$'\001'}"

# array members

arr[0]=$e
arr[1]=$f

recho ${arr[1]##*$'\001'}
recho "${arr[1]##*$'\001'}"
recho ${arr[1]##*''}		# literal ^A
recho "${arr[1]##*'^A'}"	# two characters, `^' and `A'

recho ${arr[0]%$'\001'*}
recho "${arr[0]%$'\001'*}"
recho ${arr[0]#*$'\001'}
recho "${arr[0]#*$'\001'}"

recho ${arr%$'\001'*}
recho "${arr%$'\001'*}"
recho ${arr#*$'\001'}
recho "${arr#*$'\001'}"

# positional parameters

set $e $f

recho ${2##*$'\001'}
recho "${2##*$'\001'}"
recho ${2##*''}		# literal ^A
recho "${2##*''}"		# literal ^A
recho ${2##*'^A'}		# two characters, `^' and `A'
recho "${2##*'^A'}"		# two characters, `^' and `A'

recho ${1%$'\001'*}
recho "${1%$'\001'*}"
recho ${1#*$'\001'}
recho "${1#*$'\001'}"

recho ${@%$'\001'*}
recho "${@%$'\001'*}"
recho ${@#*$'\001'}
recho "${@#*$'\001'}"
recho ${@##*''}		# literal ^A
recho "${@##*'^A'}"		# two characters, `^' and `A'

# arrays treated as a whole

recho ${arr[@]%$'\001'*}
recho "${arr[@]%$'\001'*}"
recho ${arr[@]#*$'\001'}
recho "${arr[@]#*$'\001'}"
recho ${arr[@]##*''}		# literal ^A
recho "${arr[@]##*'^A'}"		# two characters, `^' and `A'

--------------------------------------------------------------------------------
---
(command (word "a='ab'"))
(command (word "set") (word "$a"))
(command (word "b=$a"))
(command (word "c=$1"))
(command (word "d=\"$1\""))
(command (word "e='uvwx'"))
(command (word "f='uvwxy'"))
(command (word "set") (word "$e") (word "$e"))
(command (word "recho") (word "${e%%??}"))
(command (word "recho") (word "\"${e%%??}\""))
(command (word "recho") (word "${e%%???}"))
(command (word "recho") (word "\"${e%%???}\""))
(command (word "recho") (word "${a#?}"))
(command (word "recho") (word "\"${a#?}\""))
(command (word "recho") (word "${f##*''}"))
(command (word "recho") (word "\"${f##*''}\""))
(command (word "recho") (word "${f##*''}"))
(command (word "recho") (word "\"${f##*'^A'}\""))
(command (word "recho") (word "${e%''*}"))
(command (word "recho") (word "\"${e%''*}\""))
(command (word "recho") (word "${e#*''}"))
(command (word "recho") (word "\"${e#*''}\""))
(command (word "arr[0]=$e"))
(command (word "arr[1]=$f"))
(command (word "recho") (word "${arr[1]##*''}"))
(command (word "recho") (word "\"${arr[1]##*''}\""))
(command (word "recho") (word "${arr[1]##*''}"))
(command (word "recho") (word "\"${arr[1]##*'^A'}\""))
(command (word "recho") (word "${arr[0]%''*}"))
(command (word "recho") (word "\"${arr[0]%''*}\""))
(command (word "recho") (word "${arr[0]#*''}"))
(command (word "recho") (word "\"${arr[0]#*''}\""))
(command (word "recho") (word "${arr%''*}"))
(command (word "recho") (word "\"${arr%''*}\""))
(command (word "recho") (word "${arr#*''}"))
(command (word "recho") (word "\"${arr#*''}\""))
(command (word "set") (word "$e") (word "$f"))
(command (word "recho") (word "${2##*''}"))
(command (word "recho") (word "\"${2##*''}\""))
(command (word "recho") (word "${2##*''}"))
(command (word "recho") (word "\"${2##*''}\""))
(command (word "recho") (word "${2##*'^A'}"))
(command (word "recho") (word "\"${2##*'^A'}\""))
(command (word "recho") (word "${1%''*}"))
(command (word "recho") (word "\"${1%''*}\""))
(command (word "recho") (word "${1#*''}"))
(command (word "recho") (word "\"${1#*''}\""))
(command (word "recho") (word "${@%''*}"))
(command (word "recho") (word "\"${@%''*}\""))
(command (word "recho") (word "${@#*''}"))
(command (word "recho") (word "\"${@#*''}\""))
(command (word "recho") (word "${@##*''}"))
(command (word "recho") (word "\"${@##*'^A'}\""))
(command (word "recho") (word "${arr[@]%''*}"))
(command (word "recho") (word "\"${arr[@]%''*}\""))
(command (word "recho") (word "${arr[@]#*''}"))
(command (word "recho") (word "\"${arr[@]#*''}\""))
(command (word "recho") (word "${arr[@]##*''}"))
(command (word "recho") (word "\"${arr[@]##*'^A'}\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote4
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
recho $'ab\x{}cd'
recho $'ab\x{41}cd'
recho $'ab\x41cd'

recho $'ab\x{4}cd'
recho $'ab\x4cd'

recho $'ab\x{cde'

recho $'ab\x{cde'
recho $'ab\x{cd}e'
recho $'ab\x{c}de'

recho $'\x{abcX'
recho $'\x{ab}cX'
recho $'\x{}X'
recho $'\x{X'
recho $'\x{01234567X'

recho $'\x{41}b'
recho $'\x{}bc'
recho $'\x{1}bcd'

recho $'\x{bde'

--------------------------------------------------------------------------------
---
(command (word "recho") (word "'ab'"))
(command (word "recho") (word "'abAcd'"))
(command (word "recho") (word "'abAcd'"))
(command (word "recho") (word "'abcd'"))
(command (word "recho") (word "'abLd'"))
(command (word "recho") (word "'ab'"))
(command (word "recho") (word "'ab'"))
(command (word "recho") (word "'abe'"))
(command (word "recho") (word "'abde'"))
(command (word "recho") (word "'X'"))
(command (word "recho") (word "'cX'"))
(command (word "recho") (word "''"))
(command (word "recho") (word "''"))
(command (word "recho") (word "'gX'"))
(command (word "recho") (word "'Ab'"))
(command (word "recho") (word "''"))
(command (word "recho") (word "'bcd'"))
(command (word "recho") (word "''"))
(command (word "--------------------------------------------------------------------------------"))
---

=== nquote5
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
a=$'ab\001cd\001ef'
IFS=$'\001'

recho $a
recho ${a}
recho xx${a}yy
recho "$a"

recho $(echo $a)
recho $(echo "$a")

recho ${a%%??}
recho "${a%%??}"

recho ${a/f/}
recho "${a/f/}"

a1=("$a")
recho ${a1[0]}
recho ${a1}

recho ${a:2:2}

set -- $a
recho $1 -- $2 -- $3

set -- "$a"
recho $1
recho ${1}

echo "$a" | { IFS=$'\001' read x y z; recho $x -- $y -- $z ; }
unset x y z
b=$'uv\177wx\177yz'

recho $b

recho "ab${x}y${a}z"
recho ab${x}y${a}z

recho "ab${b}y${a}z"
recho ab${b}y${a}z

echo "ab${b}y${a}z" | { IFS=$'\001' read l m n o  ; recho $l -- $m -- $n -- $o; }
unset l m n o

a=$'ab\001cd\001ef'
b=$'uv\177wx\177yz'

IFS=$'\177'

recho $a
recho $b

recho "ab${x}y${b}z"
recho ab${x}y${b}z

recho "ab${b}y${a}z"
recho ab${b}y${a}z

echo "ab${b}y${a}z" | { IFS=$'\001' read l m n o  ; recho "$l" -- "$m" -- "$n" -- "$o"; }
unset l m n o
echo "ab${b}y${a}z" | { IFS=$'\177' read l m n o  ; recho "$l" -- "$m" -- "$n" -- "$o"; }
unset l m n o

--------------------------------------------------------------------------------
---
(command (word "a='abcdef'"))
(command (word "IFS=''"))
(command (word "recho") (word "$a"))
(command (word "recho") (word "${a}"))
(command (word "recho") (word "xx${a}yy"))
(command (word "recho") (word "\"$a\""))
(command (word "recho") (word "$(echo $a)"))
(command (word "recho") (word "$(echo \"$a\")"))
(command (word "recho") (word "${a%%??}"))
(command (word "recho") (word "\"${a%%??}\""))
(command (word "recho") (word "${a/f/}"))
(command (word "recho") (word "\"${a/f/}\""))
(command (word "a1=(\"$a\")"))
(command (word "recho") (word "${a1[0]}"))
(command (word "recho") (word "${a1}"))
(command (word "recho") (word "${a:2:2}"))
(command (word "set") (word "--") (word "$a"))
(command (word "recho") (word "$1") (word "--") (word "$2") (word "--") (word "$3"))
(command (word "set") (word "--") (word "\"$a\""))
(command (word "recho") (word "$1"))
(command (word "recho") (word "${1}"))
(pipe (command (word "echo") (word "\"$a\"")) (brace-group (semi (command (word "IFS=''") (word "read") (word "x") (word "y") (word "z")) (command (word "recho") (word "$x") (word "--") (word "$y") (word "--") (word "$z")))))
(command (word "unset") (word "x") (word "y") (word "z"))
(command (word "b='uvwxyz'"))
(command (word "recho") (word "$b"))
(command (word "recho") (word "\"ab${x}y${a}z\""))
(command (word "recho") (word "ab${x}y${a}z"))
(command (word "recho") (word "\"ab${b}y${a}z\""))
(command (word "recho") (word "ab${b}y${a}z"))
(pipe (command (word "echo") (word "\"ab${b}y${a}z\"")) (brace-group (semi (command (word "IFS=''") (word "read") (word "l") (word "m") (word "n") (word "o")) (command (word "recho") (word "$l") (word "--") (word "$m") (word "--") (word "$n") (word "--") (word "$o")))))
(command (word "unset") (word "l") (word "m") (word "n") (word "o"))
(command (word "a='abcdef'"))
(command (word "b='uvwxyz'"))
(command (word "IFS=''"))
(command (word "recho") (word "$a"))
(command (word "recho") (word "$b"))
(command (word "recho") (word "\"ab${x}y${b}z\""))
(command (word "recho") (word "ab${x}y${b}z"))
(command (word "recho") (word "\"ab${b}y${a}z\""))
(command (word "recho") (word "ab${b}y${a}z"))
(pipe (command (word "echo") (word "\"ab${b}y${a}z\"")) (brace-group (semi (command (word "IFS=''") (word "read") (word "l") (word "m") (word "n") (word "o")) (command (word "recho") (word "\"$l\"") (word "--") (word "\"$m\"") (word "--") (word "\"$n\"") (word "--") (word "\"$o\"")))))
(command (word "unset") (word "l") (word "m") (word "n") (word "o"))
(pipe (command (word "echo") (word "\"ab${b}y${a}z\"")) (brace-group (semi (command (word "IFS=''") (word "read") (word "l") (word "m") (word "n") (word "o")) (command (word "recho") (word "\"$l\"") (word "--") (word "\"$m\"") (word "--") (word "\"$n\"") (word "--") (word "\"$o\"")))))
(command (word "unset") (word "l") (word "m") (word "n") (word "o"))
(command (word "--------------------------------------------------------------------------------"))
---

=== parser
# catch-all for parsing problems that don't fit anywhere else

# word_top issues in bash-5.2
case x in x) if ((1)); then :; fi ;; esac
case x in x) if ((1)); then :; fi esac

case x in x) if ((true ) ); then :; fi ;; esac
case x in x) if ((true ) ); then :; fi esac

# problem with bash-5.2
${THIS_SH} -c '((X=([))]' bash

# this has to be in a separate file to get desired EOF behavior
${THIS_SH} ./parser1.sub

${THIS_SH} ./posix2syntax.sub

--------------------------------------------------------------------------------
---
(case (word "x") (pattern ((word "x")) (if (arith (word "1")) (command (word ":")))))
(case (word "x") (pattern ((word "x")) (if (arith (word "1")) (command (word ":")))))
(case (word "x") (pattern ((word "x")) (if (subshell (subshell (command (word "true")))) (command (word ":")))))
(case (word "x") (pattern ((word "x")) (if (subshell (subshell (command (word "true")))) (command (word ":")))))
(command (word "${THIS_SH}") (word "-c") (word "'((X=([))]'") (word "bash"))
(command (word "${THIS_SH}") (word "./parser1.sub"))
(command (word "${THIS_SH}") (word "./posix2syntax.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== posix2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# posix-2.sh - Simple identification tests for POSIX.2 features
# commonly missing or incorrectly implemented.
# Time-stamp: <96/04/10 16:43:48 gildea>
# By Stephen Gildea <gildea@x.org> March 1995
#
# Copyright (c) 1995  Stephen Gildea
# Permission is hereby granted to deal in this Software without restriction.
# THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
#
# MODIFIED BY chet@po.cwru.edu to make part of the bash test suite.
# last change: Wed Jun 19 12:24:24 EDT 1996
#
# some of the tests:
#
# shell functions (do we care?)
# var=${var:-val}
# unset
# set --
# IFS parsing
## not exiting with -e and failed "if", the way Ultrix does (Ultrix 4.2?)
# "$@" expands to zero arguments if passed zero arguments
# $SHELL -c 'echo $1' bad good
# test -x
# positional parameters greater than 9
# arithmetic expansion $(( ... ))
# getopts

# For some tests we must run a sub-shell; $TESTSHELL says what to use.
# If set, TESTSHELL must be an absolute pathname.
# For example, on HP-UX 9, /bin/posix/sh is the supposedly-compliant shell.
TESTSHELL=${THIS_SH:-$PWD/../bash}

# these tests create temp files with names $TMPDIR/conf*
: ${TMPDIR:=/tmp}

exitval=0
numtests=0

echo "Testing for POSIX.2 conformance"

newtest()
{
    numtests=$(($numtests + 1))
}

testfail()
{
    echo "$1 test failed"
    exitval=$(($exitval + 1))
}

newtest
empty=""
test "${empty:-ok}" = ok || testfail "empty var colon"
newtest
test "${empty-bad}" = "" || testfail "got \"${empty-bad}\": empty var nocolon"
newtest
test "${unsetvar-ok}" = ok || testfail "unset var"
newtest
unset empty
test "${empty-ok}" = ok || testfail "unset"

newtest
set -- -Z
test "x$1" = x-Z || testfail '\"set -- arg\"'
# this should empty the argument list
newtest
set --
test $# = 0 || testfail "still $# args: \"set --\""

# IFS parsing:
newtest
names=one/good/three
saved_ifs="$IFS"
IFS=/
set $names lose
test "$2" = good || testfail "got \"$2\": IFS parsing"
IFS="$saved_ifs"

# "$@" with 0 arguments should expand to 0 arguments
newtest
cat > $TMPDIR/conftest1 << EOF
$TMPDIR/conftest2 "\$@"
EOF
cat > $TMPDIR/conftest2 << "EOF"
#! /bin/sh
echo $#
EOF
chmod +x $TMPDIR/conftest1 $TMPDIR/conftest2
numargs=$($TESTSHELL $TMPDIR/conftest1)
if [ "$?" != 0 ]; then
    testfail 'running $@'
else
    test "$numargs" = 0 || testfail '"$@" got '"$numargs args: expansion w 0 args"
fi
rm -f $TMPDIR/conftest1 $TMPDIR/conftest2

newtest
val=$("$TESTSHELL" -c 'echo $1' csh good)
test "$val" = good || testfail "got \"$val\": sh -c"

newtest
# do these tests in a sub-shell because failure will exit
val=$("$TESTSHELL" -c 'echo ${10}' 0  1 2 3 4 5 6 7 8 9 ten 11 2> /dev/null)
test "$val" = ten || testfail "accessing more than 9 positional params"

a=abc_def_ghi
export a
newtest; val=`"$TESTSHELL" -c 'echo "${a%_*}"' 2> /dev/null`
test "$val" = abc_def || testfail "parameter % op"
newtest; val=`"$TESTSHELL" -c 'echo "${a%%_*}"' 2> /dev/null`
test "$val" = abc || testfail "parameter %% op"
newtest; val=`"$TESTSHELL" -c 'echo "${a#*_}"' 2> /dev/null`
test "$val" = def_ghi || testfail "parameter # op"
newtest; val=`"$TESTSHELL" -c 'echo "${a##*_}"' 2> /dev/null`
test "$val" = ghi || testfail "parameter ## op"

newtest
"$TESTSHELL" -c 'export a=value' 2> /dev/null || testfail "export with value"

newtest
a=5; test "$(( ($a+1)/2 ))" = 3 || testfail "arithmetic expansion"

# does "test" support the -x switch?
newtest
touch $TMPDIR/conftest
chmod -x $TMPDIR/conftest
test -x $TMPDIR/conftest && testfail "negative test -x"
chmod +x $TMPDIR/conftest
test -x $TMPDIR/conftest || testfail "positive test -x"
rm -f $TMPDIR/conftest

newtest
test "$OPTIND" = 1 || testfail "OPTIND initial value"

newtest
getopts a: store -a aoptval
if [ "$OPTIND" != 3 ] || [ "$store" != a ] || [ "$OPTARG" != aoptval ]; then
    testfail "getopts"
fi

# if I change the default quoting style for variable values, these
# next four must change

newtest
SQUOTE="'"
val1=$(set | sed -n 's:^SQUOTE=::p')
if [ "$val1" != "\'" ]; then
        testfail "variable quoting 1"
fi

newtest
VTILDE='~'
val1=$(set | sed -n 's:^VTILDE=::p')
if [ "$val1" != "'~'" ]; then
	testfail "variable quoting 2"
fi

newtest
VHASH=ab#cd
val1=$(set | sed -n 's:^VHASH=::p')
if [ "$val1" != "ab#cd" ]; then
	testfail "variable quoting 3"
fi

newtest
VHASH2=#abcd
val1=$(set | sed -n 's:^VHASH2=::p')
if [ "$val1" != "'#abcd'" ]; then
	testfail "variable quoting 4"
fi

# these are Posix.2 shell grammar rule 4, problems through bash-4.3
newtest
case esac in (foo|esac) ;; *) testfail "case esac test 1" ;; esac
newtest
case esac in foo|esac) ;; *) testfail "case esac test 2" ;; esac

# POSIX.2 grammar rule 4 problem through bash-5.1
newtest
eval 'case esac in (esac) ;; *) testfail "case esac test 3" ;; esac'

# these are supposed to be syntax errors
newtest
eval 'case esac in esac) ;; *) echo "case esac test 4";; esac' && testfail 'case esac test 4'

if [ $exitval = 0 ]; then
    echo "All tests passed"
else
    echo "$exitval of $numtests tests failed"
fi
exit $exitval

--------------------------------------------------------------------------------
---
(command (word "TESTSHELL=${THIS_SH:-$PWD/../bash}"))
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "exitval=0"))
(command (word "numtests=0"))
(command (word "echo") (word "\"Testing for POSIX.2 conformance\""))
(function "newtest" (brace-group (command (word "numtests=$(($numtests + 1))"))))
(function "testfail" (brace-group (semi (command (word "echo") (word "\"$1 test failed\"")) (command (word "exitval=$(($exitval + 1))")))))
(command (word "newtest"))
(command (word "empty=\"\""))
(or (command (word "test") (word "\"${empty:-ok}\"") (word "=") (word "ok")) (command (word "testfail") (word "\"empty var colon\"")))
(command (word "newtest"))
(or (command (word "test") (word "\"${empty-bad}\"") (word "=") (word "\"\"")) (command (word "testfail") (word "\"got \\\"${empty-bad}\\\": empty var nocolon\"")))
(command (word "newtest"))
(or (command (word "test") (word "\"${unsetvar-ok}\"") (word "=") (word "ok")) (command (word "testfail") (word "\"unset var\"")))
(command (word "newtest"))
(command (word "unset") (word "empty"))
(or (command (word "test") (word "\"${empty-ok}\"") (word "=") (word "ok")) (command (word "testfail") (word "\"unset\"")))
(command (word "newtest"))
(command (word "set") (word "--") (word "-Z"))
(or (command (word "test") (word "\"x$1\"") (word "=") (word "x-Z")) (command (word "testfail") (word "'\\\"set -- arg\\\"'")))
(command (word "newtest"))
(command (word "set") (word "--"))
(or (command (word "test") (word "$#") (word "=") (word "0")) (command (word "testfail") (word "\"still $# args: \\\"set --\\\"\"")))
(command (word "newtest"))
(command (word "names=one/good/three"))
(command (word "saved_ifs=\"$IFS\""))
(command (word "IFS=/"))
(command (word "set") (word "$names") (word "lose"))
(or (command (word "test") (word "\"$2\"") (word "=") (word "good")) (command (word "testfail") (word "\"got \\\"$2\\\": IFS parsing\"")))
(command (word "IFS=\"$saved_ifs\""))
(command (word "newtest"))
(command (word "cat") (redirect ">" "$TMPDIR/conftest1") (redirect "<<" "$TMPDIR/conftest2 "\$@"
"))
(command (word "cat") (redirect ">" "$TMPDIR/conftest2") (redirect "<<" "#! /bin/sh
echo $#
"))
(command (word "chmod") (word "+x") (word "$TMPDIR/conftest1") (word "$TMPDIR/conftest2"))
(command (word "numargs=$($TESTSHELL $TMPDIR/conftest1)"))
(if (command (word "[") (word "\"$?\"") (word "!=") (word "0") (word "]")) (command (word "testfail") (word "'running $@'")) (or (command (word "test") (word "\"$numargs\"") (word "=") (word "0")) (command (word "testfail") (word "'\"$@\" got '\"$numargs args: expansion w 0 args\""))))
(command (word "rm") (word "-f") (word "$TMPDIR/conftest1") (word "$TMPDIR/conftest2"))
(command (word "newtest"))
(command (word "val=$(\"$TESTSHELL\" -c 'echo $1' csh good)"))
(or (command (word "test") (word "\"$val\"") (word "=") (word "good")) (command (word "testfail") (word "\"got \\\"$val\\\": sh -c\"")))
(command (word "newtest"))
(command (word "val=$(\"$TESTSHELL\" -c 'echo ${10}' 0 1 2 3 4 5 6 7 8 9 ten 11 2> /dev/null)"))
(or (command (word "test") (word "\"$val\"") (word "=") (word "ten")) (command (word "testfail") (word "\"accessing more than 9 positional params\"")))
(command (word "a=abc_def_ghi"))
(command (word "export") (word "a"))
(semi (command (word "newtest")) (command (word "val=`\"$TESTSHELL\" -c 'echo \"${a%_*}\"' 2> /dev/null`")))
(or (command (word "test") (word "\"$val\"") (word "=") (word "abc_def")) (command (word "testfail") (word "\"parameter % op\"")))
(semi (command (word "newtest")) (command (word "val=`\"$TESTSHELL\" -c 'echo \"${a%%_*}\"' 2> /dev/null`")))
(or (command (word "test") (word "\"$val\"") (word "=") (word "abc")) (command (word "testfail") (word "\"parameter %% op\"")))
(semi (command (word "newtest")) (command (word "val=`\"$TESTSHELL\" -c 'echo \"${a#*_}\"' 2> /dev/null`")))
(or (command (word "test") (word "\"$val\"") (word "=") (word "def_ghi")) (command (word "testfail") (word "\"parameter # op\"")))
(semi (command (word "newtest")) (command (word "val=`\"$TESTSHELL\" -c 'echo \"${a##*_}\"' 2> /dev/null`")))
(or (command (word "test") (word "\"$val\"") (word "=") (word "ghi")) (command (word "testfail") (word "\"parameter ## op\"")))
(command (word "newtest"))
(or (command (word "\"$TESTSHELL\"") (word "-c") (word "'export a=value'") (redirect ">" "/dev/null")) (command (word "testfail") (word "\"export with value\"")))
(command (word "newtest"))
(semi (command (word "a=5")) (or (command (word "test") (word "\"$(( ($a+1)/2 ))\"") (word "=") (word "3")) (command (word "testfail") (word "\"arithmetic expansion\""))))
(command (word "newtest"))
(command (word "touch") (word "$TMPDIR/conftest"))
(command (word "chmod") (word "-x") (word "$TMPDIR/conftest"))
(and (command (word "test") (word "-x") (word "$TMPDIR/conftest")) (command (word "testfail") (word "\"negative test -x\"")))
(command (word "chmod") (word "+x") (word "$TMPDIR/conftest"))
(or (command (word "test") (word "-x") (word "$TMPDIR/conftest")) (command (word "testfail") (word "\"positive test -x\"")))
(command (word "rm") (word "-f") (word "$TMPDIR/conftest"))
(command (word "newtest"))
(or (command (word "test") (word "\"$OPTIND\"") (word "=") (word "1")) (command (word "testfail") (word "\"OPTIND initial value\"")))
(command (word "newtest"))
(command (word "getopts") (word "a:") (word "store") (word "-a") (word "aoptval"))
(if (or (or (command (word "[") (word "\"$OPTIND\"") (word "!=") (word "3") (word "]")) (command (word "[") (word "\"$store\"") (word "!=") (word "a") (word "]"))) (command (word "[") (word "\"$OPTARG\"") (word "!=") (word "aoptval") (word "]"))) (command (word "testfail") (word "\"getopts\"")))
(command (word "newtest"))
(command (word "SQUOTE=\"'\""))
(command (word "val1=$(set | sed -n 's:^SQUOTE=::p')"))
(if (command (word "[") (word "\"$val1\"") (word "!=") (word "\"\\'\"") (word "]")) (command (word "testfail") (word "\"variable quoting 1\"")))
(command (word "newtest"))
(command (word "VTILDE='~'"))
(command (word "val1=$(set | sed -n 's:^VTILDE=::p')"))
(if (command (word "[") (word "\"$val1\"") (word "!=") (word "\"'~'\"") (word "]")) (command (word "testfail") (word "\"variable quoting 2\"")))
(command (word "newtest"))
(command (word "VHASH=ab#cd"))
(command (word "val1=$(set | sed -n 's:^VHASH=::p')"))
(if (command (word "[") (word "\"$val1\"") (word "!=") (word "\"ab#cd\"") (word "]")) (command (word "testfail") (word "\"variable quoting 3\"")))
(command (word "newtest"))
(command (word "VHASH2=#abcd"))
(command (word "val1=$(set | sed -n 's:^VHASH2=::p')"))
(if (command (word "[") (word "\"$val1\"") (word "!=") (word "\"'#abcd'\"") (word "]")) (command (word "testfail") (word "\"variable quoting 4\"")))
(command (word "newtest"))
(case (word "esac") (pattern ((word "foo") (word "esac")) ()) (pattern ((word "*")) (command (word "testfail") (word "\"case esac test 1\""))))
(command (word "newtest"))
(case (word "esac") (pattern ((word "foo") (word "esac")) ()) (pattern ((word "*")) (command (word "testfail") (word "\"case esac test 2\""))))
(command (word "newtest"))
(command (word "eval") (word "'case esac in (esac) ;; *) testfail \"case esac test 3\" ;; esac'"))
(command (word "newtest"))
(and (command (word "eval") (word "'case esac in esac) ;; *) echo \"case esac test 4\";; esac'")) (command (word "testfail") (word "'case esac test 4'")))
(if (command (word "[") (word "$exitval") (word "=") (word "0") (word "]")) (command (word "echo") (word "\"All tests passed\"")) (command (word "echo") (word "\"$exitval of $numtests tests failed\"")))
(command (word "exit") (word "$exitval"))
(command (word "--------------------------------------------------------------------------------"))
---

=== posixpat
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# A test suite for the POSIX.2 (BRE) pattern matching code
LC_ALL=C
LANG=C

# First, test POSIX.2 character classes

case e in
[[:xdigit:]])	echo ok 1;;
esac

case a in
[[:alpha:]123])	echo ok 2;;
esac

case 1 in
[[:alpha:]123])	echo ok 3;;
esac

case 9 in
[![:alpha:]])	echo ok 4;;
esac

case a in
[:al:])		echo ok 5;;
esac

# invalid character class expressions are no longer just characters to be
# matched
case a in
[[:al:])	echo bad 6;;
*)		echo ok 6;;
esac

case '!' in
[abc[:punct:][0-9])	echo ok 7;;
esac

# let's try to match the start of a valid sh identifier
case 'PATH' in
[_[:alpha:]]*)	echo ok 8;;
esac

# let's try to match the first two characters of a valid sh identifier
case PATH in
[_[:alpha:]][_[:alnum:]]*)	echo ok 9;;
esac

# is ^C a cntrl character?
case $'\003' in
[[:cntrl:]])	echo ok 10;;
esac

# how about A?
case A in
[[:cntrl:]])	echo oops -- cntrl ;;
*)		echo ok 11;;
esac

case 9 in
[[:digit:]])	echo ok 12;;
esac

case X in
[[:digit:]])	echo oops -- digit;;
*)		echo ok 13;;
esac

case $'\033' in
[[:graph:]])	echo oops -- graph;;
*)		echo ok 14;;
esac

case $'\040' in
[[:graph:]])	echo oops -- graph 2;;
*)		echo ok 15;;
esac

case ' ' in
[[:graph:]])	echo oops -- graph 3;;
*)		echo ok 16;;
esac

case 'aB' in
[[:lower:]][[:upper:]])	echo ok 17;;
esac

case $'\040' in
[[:print:]])	echo ok 18;;
*)		echo oops -- print;;
esac

case PS3 in
[_[:alpha:]][_[:alnum:]][_[:alnum:]]*)	echo ok 19;;
esac

case a in
[[:alpha:][:digit:]])	echo ok 20;;
*)			echo oops - skip brackpat ;;
esac

case a in
[[:alpha:]\])	echo oops -- dangling backslash in brackpat ;;
*)		echo ok 21 ;;
esac

# what's a newline?  is it a blank? a space?
case $'\n' in
[[:blank:]])	echo ok -- blank ;;
[[:space:]])	echo ok -- space ;;
*)		echo oops newline ;;
esac

# OK, what's a tab?  is it a blank? a space?
case $'\t' in
[[:blank:]])	echo ok -- blank ;;
[[:space:]])	echo ok -- space ;;
*)		echo oops newline ;;
esac

# let's check out characters in the ASCII range
case $'\377' in
[[:ascii:]])	echo oops -- ascii\?;;
esac

case 9 in
[1[:alpha:]123]) echo oops 1;;
esac

# however, an unterminated brace expression containing a valid char class
# that matches had better fail
case a in
[[:alpha:])	echo oops 2;;
esac

case $'\b' in
[[:graph:]])	echo oops 3;;
esac

case $'\b' in
[[:print:]])	echo oops 4;;
esac

case $' ' in
[[:punct:]])	echo oops 5;;
esac

# Next, test POSIX.2 collating symbols

case 'a' in
[[.a.]])	echo ok 1;;
esac

case '-' in
[[.hyphen.]-9])	echo ok 2;;
esac

case 'p' in
[[.a.]-[.z.]])	echo ok 3;;
esac

case '-' in
[[.-.]])	echo ok 4;;
esac

case ' ' in
[[.space.]])	echo ok 5;;
esac

case ' ' in
[[.grave-accent.]])	echo oops - grave;;
*)		echo ok 6;;
esac

case '4' in
[[.-.]-9])	echo ok 7;;
esac

# an invalid collating symbol cannot be the first part of a range
case 'c' in
[[.yyz.]-[.z.]])	echo oops - yyz;;
*)		echo ok 8;;
esac

case 'c' in
[[.yyz.][.a.]-z])   echo ok 9;;
esac

# but when not part of a range is not an error
case 'c' in
[[.yyz.][.a.]-[.z.]])   echo ok 10 ;;
esac

case 'p' in
[[.a.]-[.Z.]])		echo oops -- bad range ;; 
*)			echo ok 11;;
esac

case p in
[[.a.]-[.zz.]p])	echo ok 12;;
*)			echo oops -- bad range 2;;
esac

case p in
[[.aa.]-[.z.]p])	echo ok 13;;
*)			echo oops -- bad range 3;;
esac

case c in
[[.yyz.]cde])		echo ok 14;;
esac

case abc in
[[.cb.]a-Za]*)		echo ok 15;;
esac

case $'\t' in
[[.space.][.tab.][.newline.]])	echo ok 16;;
esac

# and finally, test POSIX.2 equivalence classes

case "abc" in
[[:alpha:]][[=b=]][[:ascii:]])	echo ok 1;;
esac

case "abc" in
[[:alpha:]][[=B=]][[:ascii:]])	echo oops -- =B=;;
*)	echo ok 2 ;;
esac

case a in
[[=b=])		echo oops;;	# an incomplete equiv class is just a string
*)		echo ok 3;;
esac

--------------------------------------------------------------------------------
---
(command (word "LC_ALL=C"))
(command (word "LANG=C"))
(case (word "e") (pattern ((word "[[:xdigit:]]")) (command (word "echo") (word "ok") (word "1"))))
(case (word "a") (pattern ((word "[[:alpha:]123]")) (command (word "echo") (word "ok") (word "2"))))
(case (word "1") (pattern ((word "[[:alpha:]123]")) (command (word "echo") (word "ok") (word "3"))))
(case (word "9") (pattern ((word "[![:alpha:]]")) (command (word "echo") (word "ok") (word "4"))))
(case (word "a") (pattern ((word "[:al:]")) (command (word "echo") (word "ok") (word "5"))))
(case (word "a") (pattern ((word "[[:al:]")) (command (word "echo") (word "bad") (word "6"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "6"))))
(case (word "'!'") (pattern ((word "[abc[:punct:][0-9]")) (command (word "echo") (word "ok") (word "7"))))
(case (word "'PATH'") (pattern ((word "[_[:alpha:]]*")) (command (word "echo") (word "ok") (word "8"))))
(case (word "PATH") (pattern ((word "[_[:alpha:]][_[:alnum:]]*")) (command (word "echo") (word "ok") (word "9"))))
(case (word "''") (pattern ((word "[[:cntrl:]]")) (command (word "echo") (word "ok") (word "10"))))
(case (word "A") (pattern ((word "[[:cntrl:]]")) (command (word "echo") (word "oops") (word "--") (word "cntrl"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "11"))))
(case (word "9") (pattern ((word "[[:digit:]]")) (command (word "echo") (word "ok") (word "12"))))
(case (word "X") (pattern ((word "[[:digit:]]")) (command (word "echo") (word "oops") (word "--") (word "digit"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "13"))))
(case (word "''") (pattern ((word "[[:graph:]]")) (command (word "echo") (word "oops") (word "--") (word "graph"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "14"))))
(case (word "' '") (pattern ((word "[[:graph:]]")) (command (word "echo") (word "oops") (word "--") (word "graph") (word "2"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "15"))))
(case (word "' '") (pattern ((word "[[:graph:]]")) (command (word "echo") (word "oops") (word "--") (word "graph") (word "3"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "16"))))
(case (word "'aB'") (pattern ((word "[[:lower:]][[:upper:]]")) (command (word "echo") (word "ok") (word "17"))))
(case (word "' '") (pattern ((word "[[:print:]]")) (command (word "echo") (word "ok") (word "18"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "print"))))
(case (word "PS3") (pattern ((word "[_[:alpha:]][_[:alnum:]][_[:alnum:]]*")) (command (word "echo") (word "ok") (word "19"))))
(case (word "a") (pattern ((word "[[:alpha:][:digit:]]")) (command (word "echo") (word "ok") (word "20"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "-") (word "skip") (word "brackpat"))))
(case (word "a") (pattern ((word "[[:alpha:]\\]")) (command (word "echo") (word "oops") (word "--") (word "dangling") (word "backslash") (word "in") (word "brackpat"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "21"))))
(case (word "'\n'") (pattern ((word "[[:blank:]]")) (command (word "echo") (word "ok") (word "--") (word "blank"))) (pattern ((word "[[:space:]]")) (command (word "echo") (word "ok") (word "--") (word "space"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "newline"))))
(case (word "'\t'") (pattern ((word "[[:blank:]]")) (command (word "echo") (word "ok") (word "--") (word "blank"))) (pattern ((word "[[:space:]]")) (command (word "echo") (word "ok") (word "--") (word "space"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "newline"))))
(case (word "''") (pattern ((word "[[:ascii:]]")) (command (word "echo") (word "oops") (word "--") (word "ascii\\?"))))
(case (word "9") (pattern ((word "[1[:alpha:]123]")) (command (word "echo") (word "oops") (word "1"))))
(case (word "a") (pattern ((word "[[:alpha:]")) (command (word "echo") (word "oops") (word "2"))))
(case (word "''") (pattern ((word "[[:graph:]]")) (command (word "echo") (word "oops") (word "3"))))
(case (word "''") (pattern ((word "[[:print:]]")) (command (word "echo") (word "oops") (word "4"))))
(case (word "' '") (pattern ((word "[[:punct:]]")) (command (word "echo") (word "oops") (word "5"))))
(case (word "'a'") (pattern ((word "[[.a.]]")) (command (word "echo") (word "ok") (word "1"))))
(case (word "'-'") (pattern ((word "[[.hyphen.]-9]")) (command (word "echo") (word "ok") (word "2"))))
(case (word "'p'") (pattern ((word "[[.a.]-[.z.]]")) (command (word "echo") (word "ok") (word "3"))))
(case (word "'-'") (pattern ((word "[[.-.]]")) (command (word "echo") (word "ok") (word "4"))))
(case (word "' '") (pattern ((word "[[.space.]]")) (command (word "echo") (word "ok") (word "5"))))
(case (word "' '") (pattern ((word "[[.grave-accent.]]")) (command (word "echo") (word "oops") (word "-") (word "grave"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "6"))))
(case (word "'4'") (pattern ((word "[[.-.]-9]")) (command (word "echo") (word "ok") (word "7"))))
(case (word "'c'") (pattern ((word "[[.yyz.]-[.z.]]")) (command (word "echo") (word "oops") (word "-") (word "yyz"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "8"))))
(case (word "'c'") (pattern ((word "[[.yyz.][.a.]-z]")) (command (word "echo") (word "ok") (word "9"))))
(case (word "'c'") (pattern ((word "[[.yyz.][.a.]-[.z.]]")) (command (word "echo") (word "ok") (word "10"))))
(case (word "'p'") (pattern ((word "[[.a.]-[.Z.]]")) (command (word "echo") (word "oops") (word "--") (word "bad") (word "range"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "11"))))
(case (word "p") (pattern ((word "[[.a.]-[.zz.]p]")) (command (word "echo") (word "ok") (word "12"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "bad") (word "range") (word "2"))))
(case (word "p") (pattern ((word "[[.aa.]-[.z.]p]")) (command (word "echo") (word "ok") (word "13"))) (pattern ((word "*")) (command (word "echo") (word "oops") (word "--") (word "bad") (word "range") (word "3"))))
(case (word "c") (pattern ((word "[[.yyz.]cde]")) (command (word "echo") (word "ok") (word "14"))))
(case (word "abc") (pattern ((word "[[.cb.]a-Za]*")) (command (word "echo") (word "ok") (word "15"))))
(case (word "'\t'") (pattern ((word "[[.space.][.tab.][.newline.]]")) (command (word "echo") (word "ok") (word "16"))))
(case (word "\"abc\"") (pattern ((word "[[:alpha:]][[=b=]][[:ascii:]]")) (command (word "echo") (word "ok") (word "1"))))
(case (word "\"abc\"") (pattern ((word "[[:alpha:]][[=B=]][[:ascii:]]")) (command (word "echo") (word "oops") (word "--") (word "=B="))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "2"))))
(case (word "a") (pattern ((word "[[=b=]")) (command (word "echo") (word "oops"))) (pattern ((word "*")) (command (word "echo") (word "ok") (word "3"))))
(command (word "--------------------------------------------------------------------------------"))
---

=== posixpipe
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Test timed and negated pipelines in bash-4.2 and later
export TIMEFORMAT=$'real %2R\nuser %2U\nsys %2S'

!
echo $?

! !
echo $?

time ! echo a
echo $?

! time echo a
echo $?

tfunc()
{
	time
}

type tfunc

! true
echo $?
! ! true
echo $?
! ! ! true
echo $?

time time echo a
echo $?

time time -p echo a
echo $?
time -p time echo a
echo $?

!
echo $?
! !
echo $?

time -p -- echo a

time -- :

# this should print timing information
. ./test-glue-functions

${THIS_SH} -c '{ time; echo after; }' |& wc -l | _cut_leading_spaces

--------------------------------------------------------------------------------
---
(command (word "export") (word "TIMEFORMAT='real %2R\nuser %2U\nsys %2S'"))
(negation (command))
(command (word "echo") (word "$?"))
(command)
(command (word "echo") (word "$?"))
(negation (time (command (word "echo") (word "a"))))
(command (word "echo") (word "$?"))
(negation (time (command (word "echo") (word "a"))))
(command (word "echo") (word "$?"))
(function "tfunc" (brace-group (time (command))))
(command (word "type") (word "tfunc"))
(negation (command (word "true")))
(command (word "echo") (word "$?"))
(command (word "true"))
(command (word "echo") (word "$?"))
(negation (command (word "true")))
(command (word "echo") (word "$?"))
(time (command (word "echo") (word "a")))
(command (word "echo") (word "$?"))
(time -p (command (word "echo") (word "a")))
(command (word "echo") (word "$?"))
(time -p (command (word "echo") (word "a")))
(command (word "echo") (word "$?"))
(negation (command))
(command (word "echo") (word "$?"))
(command)
(command (word "echo") (word "$?"))
(time -p (command (word "echo") (word "a")))
(time -p (command (word ":")))
(command (word ".") (word "./test-glue-functions"))
(pipe (command (word "${THIS_SH}") (word "-c") (word "'{ time; echo after; }'") (redirect ">&" 1)) (pipe (command (word "wc") (word "-l")) (command (word "_cut_leading_spaces"))))
(command (word "--------------------------------------------------------------------------------"))
---

=== precedence
# @(#)precedence_test 1.0 91/07/24 Maarten Litmaath

#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# test of relative precedences for `&&' and `||' operators

echo "\`Say' echos its argument. Its return value is of no interest."
case `echo -n` in
  '') Say () { echo -n "$*" ; } ;;
   *) Say () { echo "$*\c" ; } ;;
esac

echo "\`Truth' echos its argument and returns a TRUE result."
Truth () {
  Say $1;
  return 0;
}

echo "\`False' echos its argument and returns a FALSE result."
False () {
  Say $1;
  return 1;
}

echo ""

cmd1='$open $test1 && $test2 $close || $test3'
cmd2='$test1 || $open $test2 && $test3 $close'

grouping_sh=
grouping_C='( )'

test3='Say 3'

for i in 1 2
do
   eval proto=\$cmd$i

   for test1 in 'Truth 1' 'False 1'
   do
      for test2 in 'Truth 2' 'False 2'
      do
	 for precedence in sh C
	 do
	    eval set x \$grouping_$precedence
	    shift
	    open=${1-' '}
	    close=${2-' '}
	    eval cmd=\""$proto"\"
	    Say "$cmd   output="
	    output=`eval "$cmd"`
	    Say "$output"
	    read correct || { echo 'Input fubar.  Abort.' >&2; exit 1; }
	    test "X$output" = "X$correct" || echo "   correct=$correct"
	    echo ''
	 done

	 echo ''
      done
   done
done << EOF
12
12
123
123
13
13
13
13
13
1
13
1
123
123
12
12
EOF

--------------------------------------------------------------------------------
---
(command (word "echo") (word "\"\\`Say' echos its argument. Its return value is of no interest.\""))
(case (word "`echo -n`") (pattern ((word "''")) (function "Say" (brace-group (command (word "echo") (word "-n") (word "\"$*\""))))) (pattern ((word "*")) (function "Say" (brace-group (command (word "echo") (word "\"$*\\c\""))))))
(command (word "echo") (word "\"\\`Truth' echos its argument and returns a TRUE result.\""))
(function "Truth" (brace-group (semi (command (word "Say") (word "$1")) (command (word "return") (word "0")))))
(command (word "echo") (word "\"\\`False' echos its argument and returns a FALSE result.\""))
(function "False" (brace-group (semi (command (word "Say") (word "$1")) (command (word "return") (word "1")))))
(command (word "echo") (word "\"\""))
(command (word "cmd1='$open $test1 && $test2 $close || $test3'"))
(command (word "cmd2='$test1 || $open $test2 && $test3 $close'"))
(command (word "grouping_sh="))
(command (word "grouping_C='( )'"))
(command (word "test3='Say 3'"))
(for (word "i") (in (word "1") (word "2")) (semi (command (word "eval") (word "proto=\\$cmd$i")) (for (word "test1") (in (word "'Truth 1'") (word "'False 1'")) (for (word "test2") (in (word "'Truth 2'") (word "'False 2'")) (semi (for (word "precedence") (in (word "sh") (word "C")) (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "eval") (word "set") (word "x") (word "\\$grouping_$precedence")) (command (word "shift"))) (command (word "open=${1-' '}"))) (command (word "close=${2-' '}"))) (command (word "eval") (word "cmd=\\\"\"$proto\"\\\""))) (command (word "Say") (word "\"$cmd   output=\""))) (command (word "output=`eval \"$cmd\"`"))) (command (word "Say") (word "\"$output\""))) (or (command (word "read") (word "correct")) (brace-group (semi (command (word "echo") (word "'Input fubar.  Abort.'") (redirect ">&" 2)) (command (word "exit") (word "1")))))) (or (command (word "test") (word "\"X$output\"") (word "=") (word "\"X$correct\"")) (command (word "echo") (word "\"   correct=$correct\"")))) (command (word "echo") (word "''")))) (command (word "echo") (word "''"))))))) (redirect "<<" "12
12
123
123
13
13
13
13
13
1
13
1
123
123
12
12
")
(command (word "--------------------------------------------------------------------------------"))
---

=== printf
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
LC_ALL=C
LC_NUMERIC=C

: ${TMPDIR:=/tmp}
TMPF=$TMPDIR/printf-oflow-$RANDOM

printf_overflow ()
{
        local r;

        line=$1 ; shift
        rm -f "$TMPF"
        printf "$@"  2>$TMPF
        r=$?
        if [ ! -s "$TMPF" ]; then
                echo "printf.tests: $line: expected overflow error output to stderr" >&2
        fi
        rm -f "$TMPF"
        return $r
}

# these should output error messages -- the format is required
printf
printf --

# these should output nothing
printf ""
printf -- ""

# this is an error
printf -x

# these are errors
printf -v invalid-var 'abc\n'
printf '%s\n%n' abc invalid-var

# in the future this may mean to put the output into VAR, but for
# now it is an error
# 2005-03-15 no longer an error
unset var
printf -v var "%10d" $RANDOM
echo ${#var}

# this should expand escape sequences in the format string, nothing else
printf "\tone\n"

# this should not cut off output after the \c
printf "one\ctwo\n"

# and unrecognized backslash escapes should have the backslash preserverd
printf "4\.2\n"

printf "no newline " ; printf "now newline\n"

# %% -> %
printf "%%\n"

# this was a bug caused by pre-processing the string for backslash escapes
# before doing the `%' format processing -- all versions before bash-2.04
printf "\045" ; echo
printf "\045d\n"

# simple character output
printf "%c\n" ABCD

# test simple string output
printf "%s\n" unquoted

# test quoted string output
printf "%s %q\n" unquoted quoted
printf "%s%10q\n" unquoted quoted

printf "%q\n" 'this&that'

# %Q is like %q but treats the precision differently
S="a'b"
S1="${S@Q}"
T=';ls'

printf 'echo %.2q%q\n' "$S" "$T"
printf 'echo %.2Q%Q\n' "$S" "$T"	# note the difference
# a different way to do it
printf 'echo %.*s%q\n' ${#S1} "$S1" "$T"

printf '%.1Q\n' '**'
printf '%.*Q\n' 1 '**'

# make sure the format string is reused to use up arguments
printf "%d " 1 2 3 4 5; printf "\n"

# make sure that extra format characters get null arguments
printf "%s %d %d %d\n" onestring

printf "%s %d %u %4.2f\n" onestring

printf -- "--%s %s--\n" 4.2 ''
printf -- "--%s %s--\n" 4.2

# test %b escapes

# 8 is a non-octal digit, so the `81' should be output
printf -- "--%b--\n" '\n\081'

printf -- "--%b--\n" '\t\0101'
printf -- "--%b--\n" '\t\101'

# these should all display `A7'
echo -e "\01017"
echo -e "\x417"

printf "%b\n" '\01017'
printf "%b\n" '\1017'
printf "%b\n" '\x417'

printf -- "--%b--\n" '\"abcd\"'
printf -- "--%b--\n" "\'abcd\'"

printf -- "--%b--\n" 'a\\x'

printf -- "--%b--\n" '\x'

Z1=$(printf -- "%b\n" '\a\b\e\f\r\v')
Z2=$'\a\b\e\f\r\v'

if [ "$Z1" != "$Z2" ]; then
	echo "whoops: printf %b and $'' differ" >&2
fi
unset Z1 Z2

printf -- "--%b--\n" ''
printf -- "--%b--\n"

# the stuff following the \c should be ignored, as well as the rest
# of the format string
printf -- "--%b--\n" '4.2\c5.4\n'; printf "\n"

# unrecognized escape sequences should by displayed unchanged
printf -- "--%b--\n" '4\.2'

# a bare \ should not be processed as an escape sequence
printf -- "--%b--\n" '\'

# make sure extra arguments are ignored if the format string doesn't
# actually use them
printf "\n" 4.4 BSD
printf " " 4.4 BSD ; printf "\n"

# make sure that a fieldwidth and precision of `*' are handled right
printf "%10.8s\n" 4.4BSD
printf "%*.*s\n" 10 8 4.4BSD

printf "%10.8q\n" 4.4BSD
printf "%*.*q\n" 10 8 4.4BSD

printf "%6b\n" 4.4BSD
printf "%*b\n" 6 4.4BSD

# we handle this crap with homemade code in printf.def
printf "%10b\n" 4.4BSD
printf -- "--%-10b--\n" 4.4BSD
printf "%4.2b\n" 4.4BSD
printf "%.3b\n" 4.4BSD
printf -- "--%-8b--\n" 4.4BSD

# test numeric conversions -- these four lines should echo identically
printf "%d %u %i 0%o 0x%x 0x%X\n" 255 255 255 255 255 255
printf "%d %u %i %#o %#x %#X\n" 255 255 255 255 255 255

printf "%ld %lu %li 0%o 0x%x 0x%X\n" 255 255 255 255 255 255
printf "%ld %lu %li %#o %#x %#X\n" 255 255 255 255 255 255

printf "%10d\n" 42
printf "%10d\n" -42

printf "%*d\n" 10 42
printf "%*d\n" 10 -42

# test some simple floating point formats
printf "%4.2f\n" 4.2
printf "%#4.2f\n" 4.2
printf "%#4.1f\n" 4.2

printf "%*.*f\n" 4 2 4.2
printf "%#*.*f\n" 4 2 4.2
printf "%#*.*f\n" 4 1 4.2

printf "%E\n" 4.2
printf "%e\n" 4.2
printf "%6.1E\n" 4.2
printf "%6.1e\n" 4.2

printf "%G\n" 4.2
printf "%g\n" 4.2
printf "%6.2G\n" 4.2
printf "%6.2g\n" 4.2

# test some of the more esoteric features of POSIX.1 printf
printf "%d\n" "'string'"
printf "%d\n" '"string"'

printf "%#o\n" "'string'"
printf "%#o\n" '"string"'

printf "%#x\n" "'string'"
printf "%#X\n" '"string"'

printf "%6.2f\n" "'string'"
printf "%6.2f\n" '"string"'

# output from these two lines had better be the same
printf -- "--%6.4s--\n" abcdefghijklmnopqrstuvwxyz
printf -- "--%6.4b--\n" abcdefghijklmnopqrstuvwxyz

# and these two also
printf -- "--%12.10s--\n" abcdefghijklmnopqrstuvwxyz
printf -- "--%12.10b--\n" abcdefghijklmnopqrstuvwxyz

# tests for translating \' to ' and \\ to \
# printf translates \' to ' in the format string...
printf "\'abcd\'\n"

# but not when the %b format specification is used
printf "%b\n" \\\'abcd\\\'

# but both translate \\ to \
printf '\\abcd\\\n'
printf "%b\n" '\\abcd\\'

# this was reported as a bug in bash-2.03
# these three lines should all echo `26'
printf "%d\n" 0x1a
printf "%d\n" 032
printf "%d\n" 26

# error messages

# this should be an overflow, but error messages vary between systems
# printf "%lu\n" 4294967296

# ...but we cannot use this because some systems (SunOS4, for example),
# happily ignore overflow conditions in strtol(3)
#printf "%ld\n" 4294967296

printf "%10"
printf "ab%Mcd\n"

# this caused an infinite loop in older versions of printf
printf "%y" 0

# these should print a warning and `0', according to POSIX.2
printf "%d\n" GNU
printf "%o\n" GNU

# failures in all bash versions through bash-2.05
printf "%.0s" foo
printf "%.*s" 0 foo

printf '%.0b-%.0s\n' foo bar
printf '(%*b)(%*s)\n' -4 foo -4 bar

format='%'`printf '%0100384d' 0`'d\n' 
printf $format 0

# failures in all bash versions through bash-3.0 - undercounted characters
unset vv
printf "  %s %s %s  \n%n" ab cd ef vv
echo "$vv"

# this doesn't work with printf(3) on all systems
#printf "%'s\n" foo

# test cases from an austin-group list discussion
# prints ^G as an extension
printf '%b\n' '\7'

# prints ^G
printf '%b\n' '\0007'

# prints NUL then 7
printf '\0007\n'

# prints no more than two hex digits
printf '\x07e\n'

# additional backslash escapes
printf '\"\?\n'

# failures with decimal precisions until after bash-3.1
printf '%0.5d\n' 1

printf '%05d\n' 1
printf '%5d\n' 1
printf '%0d\n' 1

# failures with various floating point formats and 0 after bash-3.2

printf "%G\n" 0
printf "%g\n" 0
printf "%4.2G\n" 0
printf "%4.2g\n" 0

printf "%G\n" 4
printf "%g\n" 4
printf "%4.2G\n" 4
printf "%4.2g\n" 4

printf "%F\n" 0
printf "%f\n" 0
printf "%4.2F\n" 0
printf "%4.2f\n" 0

printf "%F\n" 4
printf "%f\n" 4
printf "%4.2F\n" 4
printf "%4.2f\n" 4

printf "%E\n" 0
printf "%e\n" 0
printf "%4.2E\n" 0
printf "%4.2e\n" 0

printf "%E\n" 4
printf "%e\n" 4
printf "%4.2E\n" 4
printf "%4.2e\n" 4

printf "%08X\n" 2604292517

# make sure these format specifiers all output '' for empty string arguments
echo q
printf "%q\n" ""
printf "%q\n"

echo s
printf "%s\n" ''
printf "%s\n"

echo b
printf "%b\n" ''
printf "%b\n"

# bug in bash versions up to and including bash-3.2
v=yyy
printf -v var "%s" '/current/working/directory/*.@(m3|i3|ig|mg)'
shopt -s nullglob extglob
echo "x$(printf "%b" @(hugo))x"
printf -v var "%b" @(hugo); echo "x${var}x"

# make sure that missing arguments are always handled like the empty string
printf "<%3s><%3b>\n"

# other format specifiers with missing arguments
# 0
printf '%d\n'
# null char
printf '%c\n'

printf '%x\n'
printf '%4.2f\n'

printf '%b'
printf '%q\n'
printf '%Q\n'

# let's test some out-of-range integer errors for POSIX-specified behavior
TOOBIG=9223372036854775825
TOOSMALL=-9223372036854775815

printf_overflow $LINENO '%d\n' "$TOOBIG"
printf_overflow $LINENO '%d\n' "$TOOSMALL"

# arguments that are not completely converted generate warning messages
printf '%d\n' +
printf '%d\n' z
printf '%d\n' ''

# tests variable assignment with -v
${THIS_SH} ./printf1.sub
${THIS_SH} ./printf2.sub
${THIS_SH} ./printf3.sub
${THIS_SH} ./printf4.sub
${THIS_SH} ./printf5.sub
# multibyte characters with %ls/%S and %lc/%C
${THIS_SH} ./printf6.sub
${THIS_SH} ./printf7.sub

--------------------------------------------------------------------------------
---
(command (word "LC_ALL=C"))
(command (word "LC_NUMERIC=C"))
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "TMPF=$TMPDIR/printf-oflow-$RANDOM"))
(function "printf_overflow" (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (command (word "local") (word "r")) (command (word "line=$1"))) (command (word "shift"))) (command (word "rm") (word "-f") (word "\"$TMPF\""))) (command (word "printf") (word "\"$@\"") (redirect ">" "$TMPF"))) (command (word "r=$?"))) (if (command (word "[") (word "!") (word "-s") (word "\"$TMPF\"") (word "]")) (command (word "echo") (word "\"printf.tests: $line: expected overflow error output to stderr\"") (redirect ">&" 2)))) (command (word "rm") (word "-f") (word "\"$TMPF\""))) (command (word "return") (word "$r")))))
(command (word "printf"))
(command (word "printf") (word "--"))
(command (word "printf") (word "\"\""))
(command (word "printf") (word "--") (word "\"\""))
(command (word "printf") (word "-x"))
(command (word "printf") (word "-v") (word "invalid-var") (word "'abc\\n'"))
(command (word "printf") (word "'%s\\n%n'") (word "abc") (word "invalid-var"))
(command (word "unset") (word "var"))
(command (word "printf") (word "-v") (word "var") (word "\"%10d\"") (word "$RANDOM"))
(command (word "echo") (word "${#var}"))
(command (word "printf") (word "\"\\tone\\n\""))
(command (word "printf") (word "\"one\\ctwo\\n\""))
(command (word "printf") (word "\"4\\.2\\n\""))
(semi (command (word "printf") (word "\"no newline \"")) (command (word "printf") (word "\"now newline\\n\"")))
(command (word "printf") (word "\"%%\\n\""))
(semi (command (word "printf") (word "\"\\045\"")) (command (word "echo")))
(command (word "printf") (word "\"\\045d\\n\""))
(command (word "printf") (word "\"%c\\n\"") (word "ABCD"))
(command (word "printf") (word "\"%s\\n\"") (word "unquoted"))
(command (word "printf") (word "\"%s %q\\n\"") (word "unquoted") (word "quoted"))
(command (word "printf") (word "\"%s%10q\\n\"") (word "unquoted") (word "quoted"))
(command (word "printf") (word "\"%q\\n\"") (word "'this&that'"))
(command (word "S=\"a'b\""))
(command (word "S1=\"${S@Q}\""))
(command (word "T=';ls'"))
(command (word "printf") (word "'echo %.2q%q\\n'") (word "\"$S\"") (word "\"$T\""))
(command (word "printf") (word "'echo %.2Q%Q\\n'") (word "\"$S\"") (word "\"$T\""))
(command (word "printf") (word "'echo %.*s%q\\n'") (word "${#S1}") (word "\"$S1\"") (word "\"$T\""))
(command (word "printf") (word "'%.1Q\\n'") (word "'**'"))
(command (word "printf") (word "'%.*Q\\n'") (word "1") (word "'**'"))
(semi (command (word "printf") (word "\"%d \"") (word "1") (word "2") (word "3") (word "4") (word "5")) (command (word "printf") (word "\"\\n\"")))
(command (word "printf") (word "\"%s %d %d %d\\n\"") (word "onestring"))
(command (word "printf") (word "\"%s %d %u %4.2f\\n\"") (word "onestring"))
(command (word "printf") (word "--") (word "\"--%s %s--\\n\"") (word "4.2") (word "''"))
(command (word "printf") (word "--") (word "\"--%s %s--\\n\"") (word "4.2"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\n\\081'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\t\\0101'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\t\\101'"))
(command (word "echo") (word "-e") (word "\"\\01017\""))
(command (word "echo") (word "-e") (word "\"\\x417\""))
(command (word "printf") (word "\"%b\\n\"") (word "'\\01017'"))
(command (word "printf") (word "\"%b\\n\"") (word "'\\1017'"))
(command (word "printf") (word "\"%b\\n\"") (word "'\\x417'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\\"abcd\\\"'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "\"\\'abcd\\'\""))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'a\\\\x'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\x'"))
(command (word "Z1=$(printf -- \"%b\\n\" '\\a\\b\\e\\f\\r\\v')"))
(command (word "Z2=''"))
(if (command (word "[") (word "\"$Z1\"") (word "!=") (word "\"$Z2\"") (word "]")) (command (word "echo") (word "\"whoops: printf %b and $'' differ\"") (redirect ">&" 2)))
(command (word "unset") (word "Z1") (word "Z2"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "''"))
(command (word "printf") (word "--") (word "\"--%b--\\n\""))
(semi (command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'4.2\\c5.4\\n'")) (command (word "printf") (word "\"\\n\"")))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'4\\.2'"))
(command (word "printf") (word "--") (word "\"--%b--\\n\"") (word "'\\'"))
(command (word "printf") (word "\"\\n\"") (word "4.4") (word "BSD"))
(semi (command (word "printf") (word "\" \"") (word "4.4") (word "BSD")) (command (word "printf") (word "\"\\n\"")))
(command (word "printf") (word "\"%10.8s\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%*.*s\\n\"") (word "10") (word "8") (word "4.4BSD"))
(command (word "printf") (word "\"%10.8q\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%*.*q\\n\"") (word "10") (word "8") (word "4.4BSD"))
(command (word "printf") (word "\"%6b\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%*b\\n\"") (word "6") (word "4.4BSD"))
(command (word "printf") (word "\"%10b\\n\"") (word "4.4BSD"))
(command (word "printf") (word "--") (word "\"--%-10b--\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%4.2b\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%.3b\\n\"") (word "4.4BSD"))
(command (word "printf") (word "--") (word "\"--%-8b--\\n\"") (word "4.4BSD"))
(command (word "printf") (word "\"%d %u %i 0%o 0x%x 0x%X\\n\"") (word "255") (word "255") (word "255") (word "255") (word "255") (word "255"))
(command (word "printf") (word "\"%d %u %i %#o %#x %#X\\n\"") (word "255") (word "255") (word "255") (word "255") (word "255") (word "255"))
(command (word "printf") (word "\"%ld %lu %li 0%o 0x%x 0x%X\\n\"") (word "255") (word "255") (word "255") (word "255") (word "255") (word "255"))
(command (word "printf") (word "\"%ld %lu %li %#o %#x %#X\\n\"") (word "255") (word "255") (word "255") (word "255") (word "255") (word "255"))
(command (word "printf") (word "\"%10d\\n\"") (word "42"))
(command (word "printf") (word "\"%10d\\n\"") (word "-42"))
(command (word "printf") (word "\"%*d\\n\"") (word "10") (word "42"))
(command (word "printf") (word "\"%*d\\n\"") (word "10") (word "-42"))
(command (word "printf") (word "\"%4.2f\\n\"") (word "4.2"))
(command (word "printf") (word "\"%#4.2f\\n\"") (word "4.2"))
(command (word "printf") (word "\"%#4.1f\\n\"") (word "4.2"))
(command (word "printf") (word "\"%*.*f\\n\"") (word "4") (word "2") (word "4.2"))
(command (word "printf") (word "\"%#*.*f\\n\"") (word "4") (word "2") (word "4.2"))
(command (word "printf") (word "\"%#*.*f\\n\"") (word "4") (word "1") (word "4.2"))
(command (word "printf") (word "\"%E\\n\"") (word "4.2"))
(command (word "printf") (word "\"%e\\n\"") (word "4.2"))
(command (word "printf") (word "\"%6.1E\\n\"") (word "4.2"))
(command (word "printf") (word "\"%6.1e\\n\"") (word "4.2"))
(command (word "printf") (word "\"%G\\n\"") (word "4.2"))
(command (word "printf") (word "\"%g\\n\"") (word "4.2"))
(command (word "printf") (word "\"%6.2G\\n\"") (word "4.2"))
(command (word "printf") (word "\"%6.2g\\n\"") (word "4.2"))
(command (word "printf") (word "\"%d\\n\"") (word "\"'string'\""))
(command (word "printf") (word "\"%d\\n\"") (word "'\"string\"'"))
(command (word "printf") (word "\"%#o\\n\"") (word "\"'string'\""))
(command (word "printf") (word "\"%#o\\n\"") (word "'\"string\"'"))
(command (word "printf") (word "\"%#x\\n\"") (word "\"'string'\""))
(command (word "printf") (word "\"%#X\\n\"") (word "'\"string\"'"))
(command (word "printf") (word "\"%6.2f\\n\"") (word "\"'string'\""))
(command (word "printf") (word "\"%6.2f\\n\"") (word "'\"string\"'"))
(command (word "printf") (word "--") (word "\"--%6.4s--\\n\"") (word "abcdefghijklmnopqrstuvwxyz"))
(command (word "printf") (word "--") (word "\"--%6.4b--\\n\"") (word "abcdefghijklmnopqrstuvwxyz"))
(command (word "printf") (word "--") (word "\"--%12.10s--\\n\"") (word "abcdefghijklmnopqrstuvwxyz"))
(command (word "printf") (word "--") (word "\"--%12.10b--\\n\"") (word "abcdefghijklmnopqrstuvwxyz"))
(command (word "printf") (word "\"\\'abcd\\'\\n\""))
(command (word "printf") (word "\"%b\\n\"") (word "\\\\\\'abcd\\\\\\'"))
(command (word "printf") (word "'\\\\abcd\\\\\\n'"))
(command (word "printf") (word "\"%b\\n\"") (word "'\\\\abcd\\\\'"))
(command (word "printf") (word "\"%d\\n\"") (word "0x1a"))
(command (word "printf") (word "\"%d\\n\"") (word "032"))
(command (word "printf") (word "\"%d\\n\"") (word "26"))
(command (word "printf") (word "\"%10\""))
(command (word "printf") (word "\"ab%Mcd\\n\""))
(command (word "printf") (word "\"%y\"") (word "0"))
(command (word "printf") (word "\"%d\\n\"") (word "GNU"))
(command (word "printf") (word "\"%o\\n\"") (word "GNU"))
(command (word "printf") (word "\"%.0s\"") (word "foo"))
(command (word "printf") (word "\"%.*s\"") (word "0") (word "foo"))
(command (word "printf") (word "'%.0b-%.0s\\n'") (word "foo") (word "bar"))
(command (word "printf") (word "'(%*b)(%*s)\\n'") (word "-4") (word "foo") (word "-4") (word "bar"))
(command (word "format='%'`printf '%0100384d' 0`'d\\n'"))
(command (word "printf") (word "$format") (word "0"))
(command (word "unset") (word "vv"))
(command (word "printf") (word "\"  %s %s %s  \\n%n\"") (word "ab") (word "cd") (word "ef") (word "vv"))
(command (word "echo") (word "\"$vv\""))
(command (word "printf") (word "'%b\\n'") (word "'\\7'"))
(command (word "printf") (word "'%b\\n'") (word "'\\0007'"))
(command (word "printf") (word "'\\0007\\n'"))
(command (word "printf") (word "'\\x07e\\n'"))
(command (word "printf") (word "'\\\"\\?\\n'"))
(command (word "printf") (word "'%0.5d\\n'") (word "1"))
(command (word "printf") (word "'%05d\\n'") (word "1"))
(command (word "printf") (word "'%5d\\n'") (word "1"))
(command (word "printf") (word "'%0d\\n'") (word "1"))
(command (word "printf") (word "\"%G\\n\"") (word "0"))
(command (word "printf") (word "\"%g\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2G\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2g\\n\"") (word "0"))
(command (word "printf") (word "\"%G\\n\"") (word "4"))
(command (word "printf") (word "\"%g\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2G\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2g\\n\"") (word "4"))
(command (word "printf") (word "\"%F\\n\"") (word "0"))
(command (word "printf") (word "\"%f\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2F\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2f\\n\"") (word "0"))
(command (word "printf") (word "\"%F\\n\"") (word "4"))
(command (word "printf") (word "\"%f\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2F\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2f\\n\"") (word "4"))
(command (word "printf") (word "\"%E\\n\"") (word "0"))
(command (word "printf") (word "\"%e\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2E\\n\"") (word "0"))
(command (word "printf") (word "\"%4.2e\\n\"") (word "0"))
(command (word "printf") (word "\"%E\\n\"") (word "4"))
(command (word "printf") (word "\"%e\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2E\\n\"") (word "4"))
(command (word "printf") (word "\"%4.2e\\n\"") (word "4"))
(command (word "printf") (word "\"%08X\\n\"") (word "2604292517"))
(command (word "echo") (word "q"))
(command (word "printf") (word "\"%q\\n\"") (word "\"\""))
(command (word "printf") (word "\"%q\\n\""))
(command (word "echo") (word "s"))
(command (word "printf") (word "\"%s\\n\"") (word "''"))
(command (word "printf") (word "\"%s\\n\""))
(command (word "echo") (word "b"))
(command (word "printf") (word "\"%b\\n\"") (word "''"))
(command (word "printf") (word "\"%b\\n\""))
(command (word "v=yyy"))
(command (word "printf") (word "-v") (word "var") (word "\"%s\"") (word "'/current/working/directory/*.@(m3|i3|ig|mg)'"))
(command (word "shopt") (word "-s") (word "nullglob") (word "extglob"))
(command (word "echo") (word "\"x$(printf \"%b\" @(hugo))x\""))
(semi (command (word "printf") (word "-v") (word "var") (word "\"%b\"") (word "@(hugo)")) (command (word "echo") (word "\"x${var}x\"")))
(command (word "printf") (word "\"<%3s><%3b>\\n\""))
(command (word "printf") (word "'%d\\n'"))
(command (word "printf") (word "'%c\\n'"))
(command (word "printf") (word "'%x\\n'"))
(command (word "printf") (word "'%4.2f\\n'"))
(command (word "printf") (word "'%b'"))
(command (word "printf") (word "'%q\\n'"))
(command (word "printf") (word "'%Q\\n'"))
(command (word "TOOBIG=9223372036854775825"))
(command (word "TOOSMALL=-9223372036854775815"))
(command (word "printf_overflow") (word "$LINENO") (word "'%d\\n'") (word "\"$TOOBIG\""))
(command (word "printf_overflow") (word "$LINENO") (word "'%d\\n'") (word "\"$TOOSMALL\""))
(command (word "printf") (word "'%d\\n'") (word "+"))
(command (word "printf") (word "'%d\\n'") (word "z"))
(command (word "printf") (word "'%d\\n'") (word "''"))
(command (word "${THIS_SH}") (word "./printf1.sub"))
(command (word "${THIS_SH}") (word "./printf2.sub"))
(command (word "${THIS_SH}") (word "./printf3.sub"))
(command (word "${THIS_SH}") (word "./printf4.sub"))
(command (word "${THIS_SH}") (word "./printf5.sub"))
(command (word "${THIS_SH}") (word "./printf6.sub"))
(command (word "${THIS_SH}") (word "./printf7.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== procsub
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# process substitution constructs that have caused problems in the past
. ./test-glue-functions

eval cat <(echo test1)
eval "echo foo;cat" <(echo test2)

# this doesn't work, and it never should have
#unset f
#f=<(echo test3); cat "$f"

unset f
eval f=<(echo test4) "; cat \$f"

unset f

FN=$TMPDIR/bashtest-procsub-$$
cat >"$FN" <<EOF
echo "test 12" | wc -c | _cut_leading_spaces
cat "\$1"
EOF

source "$FN" <(echo test5)
rm -f "$FN"
unset FN

cat <( echo test6 ) <( echo test7 )
cat <( echo test8 ; sleep 2; echo test8a ) <( echo test9 )

# Zev Weiss 11/7/2012
fn() { cat | cat "$1"; }
fn <(:) < /dev/null

unset -f fn

f1(){
  cat $1
  date >/dev/null
}
f2(){
  date >/dev/null
  cat $1
}
cat <(echo hi)
f1 <(echo bye)
f2 <(echo l8r)

unset -f f1 f2

# set up conditions for test
ulimit -n 256

bug()
{
c=$(ulimit -n)
let c+=100
while let c--
do
	while read -ru3 x
	do
		echo -n :
	done 3< <(echo x)
done
echo
}

bug
unset -f bug

count_lines()
{
    wc -l < $1

    case "$1" in
    *sh-np*)	[ -e "$1" ] || { echo 0; echo 0; echo 0; echo 0; return; } ;;
    *) ;;
    esac

    wc -l < $1
    wc -l < $1
    true | wc -l < $1
    wc -l < $1
}

echo intern
count_lines <(date) | _cut_leading_spaces
unset -f count_lines

echo extern
FN=$TMPDIR/bashtest-$$
cat >$FN << \EOF
wc -l < $1
case $1 in *sh-np*) [ -e $1 ] || { echo 0; echo 0; echo 0; echo 0; return; } ;; esac
wc -l < $1
wc -l < $1
true | wc -l < $1
wc -l < $1
EOF

${THIS_SH} -c "source $FN <(date)" | _cut_leading_spaces
rm -f $FN

moo() { ls -l "$1" >/dev/null; ls -l "$1" >/dev/null; }; moo >(true)
moo() { ls -al "$1" >/dev/null; (true); ls -al "$1" >/dev/null; }; moo >(true)

unset -f moo

${THIS_SH} ./procsub1.sub
${THIS_SH} ./procsub2.sub

--------------------------------------------------------------------------------
---
(command (word ".") (word "./test-glue-functions"))
(command (word "eval") (word "cat") (word "<(echo test1)"))
(command (word "eval") (word "\"echo foo;cat\"") (word "<(echo test2)"))
(command (word "unset") (word "f"))
(command (word "eval") (word "f=<(echo test4)") (word "\"; cat \\$f\""))
(command (word "unset") (word "f"))
(command (word "FN=$TMPDIR/bashtest-procsub-$$"))
(command (word "cat") (redirect ">" ""$FN"") (redirect "<<" "echo "test 12" | wc -c | _cut_leading_spaces
cat "\$1"
"))
(command (word "source") (word "\"$FN\"") (word "<(echo test5)"))
(command (word "rm") (word "-f") (word "\"$FN\""))
(command (word "unset") (word "FN"))
(command (word "cat") (word "<(echo test6)") (word "<(echo test7)"))
(command (word "cat") (word "<(echo test8; sleep 2; echo test8a)") (word "<(echo test9)"))
(function "fn" (brace-group (pipe (command (word "cat")) (command (word "cat") (word "\"$1\"")))))
(command (word "fn") (word "<(:)") (redirect "<" "/dev/null"))
(command (word "unset") (word "-f") (word "fn"))
(function "f1" (brace-group (semi (command (word "cat") (word "$1")) (command (word "date") (redirect ">" "/dev/null")))))
(function "f2" (brace-group (semi (command (word "date") (redirect ">" "/dev/null")) (command (word "cat") (word "$1")))))
(command (word "cat") (word "<(echo hi)"))
(command (word "f1") (word "<(echo bye)"))
(command (word "f2") (word "<(echo l8r)"))
(command (word "unset") (word "-f") (word "f1") (word "f2"))
(command (word "ulimit") (word "-n") (word "256"))
(function "bug" (brace-group (semi (semi (semi (command (word "c=$(ulimit -n)")) (command (word "let") (word "c+=100"))) (while (command (word "let") (word "c--")) (while (command (word "read") (word "-ru3") (word "x")) (command (word "echo") (word "-n") (word ":"))) (redirect "<" "<(echo x)"))) (command (word "echo")))))
(command (word "bug"))
(command (word "unset") (word "-f") (word "bug"))
(function "count_lines" (brace-group (semi (semi (semi (semi (semi (command (word "wc") (word "-l") (redirect "<" "$1")) (case (word "\"$1\"") (pattern ((word "*sh-np*")) (or (command (word "[") (word "-e") (word "\"$1\"") (word "]")) (brace-group (semi (semi (semi (semi (command (word "echo") (word "0")) (command (word "echo") (word "0"))) (command (word "echo") (word "0"))) (command (word "echo") (word "0"))) (command (word "return")))))) (pattern ((word "*")) ()))) (command (word "wc") (word "-l") (redirect "<" "$1"))) (command (word "wc") (word "-l") (redirect "<" "$1"))) (pipe (command (word "true")) (command (word "wc") (word "-l") (redirect "<" "$1")))) (command (word "wc") (word "-l") (redirect "<" "$1")))))
(command (word "echo") (word "intern"))
(pipe (command (word "count_lines") (word "<(date)")) (command (word "_cut_leading_spaces")))
(command (word "unset") (word "-f") (word "count_lines"))
(command (word "echo") (word "extern"))
(command (word "FN=$TMPDIR/bashtest-$$"))
(command (word "cat") (redirect ">" "$FN") (redirect "<<" "wc -l < $1
case $1 in *sh-np*) [ -e $1 ] || { echo 0; echo 0; echo 0; echo 0; return; } ;; esac
wc -l < $1
wc -l < $1
true | wc -l < $1
wc -l < $1
"))
(pipe (command (word "${THIS_SH}") (word "-c") (word "\"source $FN <(date)\"")) (command (word "_cut_leading_spaces")))
(command (word "rm") (word "-f") (word "$FN"))
(semi (function "moo" (brace-group (semi (command (word "ls") (word "-l") (word "\"$1\"") (redirect ">" "/dev/null")) (command (word "ls") (word "-l") (word "\"$1\"") (redirect ">" "/dev/null"))))) (command (word "moo") (word ">(true)")))
(semi (function "moo" (brace-group (semi (semi (command (word "ls") (word "-al") (word "\"$1\"") (redirect ">" "/dev/null")) (subshell (command (word "true")))) (command (word "ls") (word "-al") (word "\"$1\"") (redirect ">" "/dev/null"))))) (command (word "moo") (word ">(true)")))
(command (word "unset") (word "-f") (word "moo"))
(command (word "${THIS_SH}") (word "./procsub1.sub"))
(command (word "${THIS_SH}") (word "./procsub2.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== quote
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
echo "Single Quote"
echo 'foo
bar'
echo 'foo
bar'
echo 'foo\
bar'

echo "Double Quote"
echo "foo
bar"
echo "foo
bar"
echo "foo\
bar" 

echo "Backslash Single Quote"
echo `echo 'foo
bar'`   
echo `echo 'foo  
bar'`   
echo `echo 'foo\
bar'`  

echo "Backslash Double Quote"
echo `echo "foo
bar"`
echo `echo "foo
bar"`
echo `echo "foo\
bar"`

echo "Double Quote Backslash Single Quote"
echo "`echo 'foo
bar'`"
echo "`echo 'foo
bar'`"
echo "`echo 'foo\
bar'`"

echo "Dollar Paren Single Quote"
echo $(echo 'foo
bar')
echo $(echo 'foo
bar')
echo $(echo 'foo\
bar')

echo "Dollar Paren Double Quote"
echo $(echo "foo
bar")
echo $(echo "foo
bar")
echo $(echo "foo\
bar")

echo "Double Quote Dollar Paren Single Quote"
echo "$(echo 'foo
bar')"
echo "$(echo 'foo
bar')"
echo "$(echo 'foo\
bar')"

# old-style command substitution parsing compatibility tests -- post bash-3.1
recho 'foo \\
bar'

recho 'foo \
bar'

echo `recho sed -e 's/[	:]/\\
/g'`

echo `recho sed -e 's/[	:]/\
/g'`

echo `recho 'foo\\
bar'`

echo `recho 'foo\
bar'`  

echo $(recho 'foo\
bar')

a=`echo 'a b c' | sed 's/ /\\
/g' | grep 'b'`
echo $a
a=`echo 'a b c' | sed 's/ /\\
/g'`
echo "$a"

recho `echo 'a\' b`

recho `echo '\$' bab`
recho `echo '\$foo' bab`
recho `echo '$foo' bab`

recho `echo '\`' ab`

recho `echo '\\' ab`

echo `echo '${'`

recho `echo "(\\")"`
# produces no output
: `: "\\""`
# ultimate workaround
recho `echo "(\")"`

# various strings ending in backslashes

echo 'string \'
echo "string \\"

echo string\ \\

echo ${foo:-'string \'}
echo "${foo:-string \\}"
echo ${foo:-string \\\}}

: ${TMPDIR:=/tmp}

${THIS_SH} -c 'echo escape\'
printf 'echo escape\' > $TMPDIR/quote-$$
${THIS_SH} $TMPDIR/quote-$$
rm -f $TMPDIR/quote-$$

${THIS_SH} ./quote1.sub
${THIS_SH} ./quote2.sub
${THIS_SH} ./quote3.sub
${THIS_SH} ./quote4.sub

--------------------------------------------------------------------------------
---
(command (word "echo") (word "\"Single Quote\""))
(command (word "echo") (word "'foo\nbar'"))
(command (word "echo") (word "'foo\nbar'"))
(command (word "echo") (word "'foo\\\nbar'"))
(command (word "echo") (word "\"Double Quote\""))
(command (word "echo") (word "\"foo\nbar\""))
(command (word "echo") (word "\"foo\nbar\""))
(command (word "echo") (word "\"foobar\""))
(command (word "echo") (word "\"Backslash Single Quote\""))
(command (word "echo") (word "`echo 'foo\nbar'`"))
(command (word "echo") (word "`echo 'foo  \nbar'`"))
(command (word "echo") (word "`echo 'foobar'`"))
(command (word "echo") (word "\"Backslash Double Quote\""))
(command (word "echo") (word "`echo \"foo\nbar\"`"))
(command (word "echo") (word "`echo \"foo\nbar\"`"))
(command (word "echo") (word "`echo \"foobar\"`"))
(command (word "echo") (word "\"Double Quote Backslash Single Quote\""))
(command (word "echo") (word "\"`echo 'foo\nbar'`\""))
(command (word "echo") (word "\"`echo 'foo\nbar'`\""))
(command (word "echo") (word "\"`echo 'foobar'`\""))
(command (word "echo") (word "\"Dollar Paren Single Quote\""))
(command (word "echo") (word "$(echo 'foo\nbar')"))
(command (word "echo") (word "$(echo 'foo\nbar')"))
(command (word "echo") (word "$(echo 'foo\\\nbar')"))
(command (word "echo") (word "\"Dollar Paren Double Quote\""))
(command (word "echo") (word "$(echo \"foo\nbar\")"))
(command (word "echo") (word "$(echo \"foo\nbar\")"))
(command (word "echo") (word "$(echo \"foobar\")"))
(command (word "echo") (word "\"Double Quote Dollar Paren Single Quote\""))
(command (word "echo") (word "\"$(echo 'foo\nbar')\""))
(command (word "echo") (word "\"$(echo 'foo\nbar')\""))
(command (word "echo") (word "\"$(echo 'foo\\\nbar')\""))
(command (word "recho") (word "'foo \\\\\nbar'"))
(command (word "recho") (word "'foo \\\nbar'"))
(command (word "echo") (word "`recho sed -e 's/[\t:]/\\\\\n/g'`"))
(command (word "echo") (word "`recho sed -e 's/[\t:]//g'`"))
(command (word "echo") (word "`recho 'foo\\\\\nbar'`"))
(command (word "echo") (word "`recho 'foobar'`"))
(command (word "echo") (word "$(recho 'foo\\\nbar')"))
(command (word "a=`echo 'a b c' | sed 's/ /\\\\\n/g' | grep 'b'`"))
(command (word "echo") (word "$a"))
(command (word "a=`echo 'a b c' | sed 's/ /\\\\\n/g'`"))
(command (word "echo") (word "\"$a\""))
(command (word "recho") (word "`echo 'a\\' b`"))
(command (word "recho") (word "`echo '\\$' bab`"))
(command (word "recho") (word "`echo '\\$foo' bab`"))
(command (word "recho") (word "`echo '$foo' bab`"))
(command (word "recho") (word "`echo '\\`' ab`"))
(command (word "recho") (word "`echo '\\\\' ab`"))
(command (word "echo") (word "`echo '${'`"))
(command (word "recho") (word "`echo \"(\\\\\")\"`"))
(command (word ":") (word "`: \"\\\\\"\"`"))
(command (word "recho") (word "`echo \"(\\\")\"`"))
(command (word "echo") (word "'string \\'"))
(command (word "echo") (word "\"string \\\\\""))
(command (word "echo") (word "string\\ \\\\"))
(command (word "echo") (word "${foo:-'string \\'}"))
(command (word "echo") (word "\"${foo:-string \\\\}\""))
(command (word "echo") (word "${foo:-string \\\\\\}}"))
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "${THIS_SH}") (word "-c") (word "'echo escape\\'"))
(command (word "printf") (word "'echo escape\\'") (redirect ">" "$TMPDIR/quote-$$"))
(command (word "${THIS_SH}") (word "$TMPDIR/quote-$$"))
(command (word "rm") (word "-f") (word "$TMPDIR/quote-$$"))
(command (word "${THIS_SH}") (word "./quote1.sub"))
(command (word "${THIS_SH}") (word "./quote2.sub"))
(command (word "${THIS_SH}") (word "./quote3.sub"))
(command (word "${THIS_SH}") (word "./quote4.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== quotearray
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# a set of tests for associative arrays in arithmetic contexts

declare -A assoc
key='x],b[$(echo uname >&2)'

(( assoc[$key]++ ))
declare -p assoc

(( assoc['$key']++ ))
declare -p assoc

(( assoc["$key"]++ ))
declare -p assoc

declare -A assoc

(( 'assoc[$key]++' ))
declare -p assoc

(( 'assoc[$key]'++ ))
declare -p assoc

(( "assoc[$key]++" ))
declare -p assoc

unset assoc

typeset -A a
b="80's"

((++a[$b]))

((++a["$b"]))
[[ $((++a[$b])) ]]
[[ $((++a["$b"])) ]]

echo ${a[$b]}
unset a

declare -A A

string=abcdefghijklmnopqrstuvwxyz

echo ${string:10:10}
k1='%'
k2='$(echo %)'

A[%]=10
A[']']=10
A[$k2]=5

k3=']'

echo ${string:A[%]:A[$k1]}
echo ${string:A[%]:A[$k2]}
echo ${string:A[%]:A[$k3]}

declare -p A

unset A string key

key='~'

declare -A A
A[$key]=42

declare -p A

echo $(( A[$key]++ ))
declare -p A

key='~0'
A[$key]=42
echo $(( A[$key]++ ))
declare -p A

declare -a a
key='~-2'
a[0]=12
a[$key]=42
echo $(( a[7<(4+2)] ))

declare -p a

unset A a key

declare -A A
declare -a a

sString="devel packager's guide"
i=2

A["$sString"]=$i
a[$i]=$sString

echo "${A[${a[i]}]}"
echo ${A["${a[i]}"]}

unset A a

#LANG=C
unset var assoc
var=\'\]
declare -Ai assoc
assoc[$var]=1
assoc[$var]+=1
((assoc['$var']++))
((assoc[$var]++))
typeset -p assoc

unset assoc

declare -A assoc
key1='` echo >&2 foo`'
key2='$( echo >&2 bar)'

assoc[$key1]=42
assoc[$key2]=63

echo $(( assoc[$key1] + assoc[$key2] ))
declare -p assoc
unset assoc

declare -a a
key='x],b[$(echo uname >&2)'
a[$key]=42

expr='a[$key]'

(( $expr ))
echo $?

echo $(( $expr ))
echo $?

echo $(( expr ))
echo $?

(( expr ))
echo $?

${THIS_SH} ./quotearray1.sub
${THIS_SH} ./quotearray2.sub
${THIS_SH} ./quotearray3.sub

# behavior of builtins with array subscripts @ and *
${THIS_SH} ./quotearray4.sub

# behavior of unset with quoted and unquoted array arguments
${THIS_SH} ./quotearray5.sub

--------------------------------------------------------------------------------
---
(command (word "declare") (word "-A") (word "assoc"))
(command (word "key='x],b[$(echo uname >&2)'"))
(arith (word " assoc[$key]++ "))
(command (word "declare") (word "-p") (word "assoc"))
(arith (word " assoc['$key']++ "))
(command (word "declare") (word "-p") (word "assoc"))
(arith (word " assoc[\"$key\"]++ "))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "declare") (word "-A") (word "assoc"))
(arith (word " 'assoc[$key]++' "))
(command (word "declare") (word "-p") (word "assoc"))
(arith (word " 'assoc[$key]'++ "))
(command (word "declare") (word "-p") (word "assoc"))
(arith (word " \"assoc[$key]++\" "))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "unset") (word "assoc"))
(command (word "typeset") (word "-A") (word "a"))
(command (word "b=\"80's\""))
(arith (word "++a[$b]"))
(arith (word "++a[\"$b\"]"))
(cond (cond-unary "-n" (cond-term "$((++a[$b]))")))
(cond (cond-unary "-n" (cond-term "$((++a["$b"]))")))
(command (word "echo") (word "${a[$b]}"))
(command (word "unset") (word "a"))
(command (word "declare") (word "-A") (word "A"))
(command (word "string=abcdefghijklmnopqrstuvwxyz"))
(command (word "echo") (word "${string:10:10}"))
(command (word "k1='%'"))
(command (word "k2='$(echo %)'"))
(command (word "A[%]=10"))
(command (word "A[']']=10"))
(command (word "A[$k2]=5"))
(command (word "k3=']'"))
(command (word "echo") (word "${string:A[%]:A[$k1]}"))
(command (word "echo") (word "${string:A[%]:A[$k2]}"))
(command (word "echo") (word "${string:A[%]:A[$k3]}"))
(command (word "declare") (word "-p") (word "A"))
(command (word "unset") (word "A") (word "string") (word "key"))
(command (word "key='~'"))
(command (word "declare") (word "-A") (word "A"))
(command (word "A[$key]=42"))
(command (word "declare") (word "-p") (word "A"))
(command (word "echo") (word "$(( A[$key]++ ))"))
(command (word "declare") (word "-p") (word "A"))
(command (word "key='~0'"))
(command (word "A[$key]=42"))
(command (word "echo") (word "$(( A[$key]++ ))"))
(command (word "declare") (word "-p") (word "A"))
(command (word "declare") (word "-a") (word "a"))
(command (word "key='~-2'"))
(command (word "a[0]=12"))
(command (word "a[$key]=42"))
(command (word "echo") (word "$(( a[7<(4+2)] ))"))
(command (word "declare") (word "-p") (word "a"))
(command (word "unset") (word "A") (word "a") (word "key"))
(command (word "declare") (word "-A") (word "A"))
(command (word "declare") (word "-a") (word "a"))
(command (word "sString=\"devel packager's guide\""))
(command (word "i=2"))
(command (word "A[\"$sString\"]=$i"))
(command (word "a[$i]=$sString"))
(command (word "echo") (word "\"${A[${a[i]}]}\""))
(command (word "echo") (word "${A[\"${a[i]}\"]}"))
(command (word "unset") (word "A") (word "a"))
(command (word "unset") (word "var") (word "assoc"))
(command (word "var=\\'\\]"))
(command (word "declare") (word "-Ai") (word "assoc"))
(command (word "assoc[$var]=1"))
(command (word "assoc[$var]+=1"))
(arith (word "assoc['$var']++"))
(arith (word "assoc[$var]++"))
(command (word "typeset") (word "-p") (word "assoc"))
(command (word "unset") (word "assoc"))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "key1='` echo >&2 foo`'"))
(command (word "key2='$( echo >&2 bar)'"))
(command (word "assoc[$key1]=42"))
(command (word "assoc[$key2]=63"))
(command (word "echo") (word "$(( assoc[$key1] + assoc[$key2] ))"))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "unset") (word "assoc"))
(command (word "declare") (word "-a") (word "a"))
(command (word "key='x],b[$(echo uname >&2)'"))
(command (word "a[$key]=42"))
(command (word "expr='a[$key]'"))
(arith (word " $expr "))
(command (word "echo") (word "$?"))
(command (word "echo") (word "$(( $expr ))"))
(command (word "echo") (word "$?"))
(command (word "echo") (word "$(( expr ))"))
(command (word "echo") (word "$?"))
(arith (word " expr "))
(command (word "echo") (word "$?"))
(command (word "${THIS_SH}") (word "./quotearray1.sub"))
(command (word "${THIS_SH}") (word "./quotearray2.sub"))
(command (word "${THIS_SH}") (word "./quotearray3.sub"))
(command (word "${THIS_SH}") (word "./quotearray4.sub"))
(command (word "${THIS_SH}") (word "./quotearray5.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== read
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
echo " a " | (read x; echo "$x.")

echo " a  b  " | ( read x y ; echo -"$x"-"$y"- )
echo " a  b\ " | ( read x y ; echo -"$x"-"$y"- )
echo " a  b  " | ( read x ; echo -"$x"- )
echo " a  b\ " | ( read x ; echo -"$x"- )

echo " a  b\ " | ( read -r x y ; echo -"$x"-"$y"- )
echo " a  b\ " | ( read -r x ; echo -"$x"- )

echo "\ a  b\ " | ( read -r x y ; echo -"$x"-"$y"- )
echo "\ a  b\ " | ( read -r x ; echo -"$x"- )
echo " \ a  b\ " | ( read -r x y ; echo -"$x"-"$y"- )
echo " \ a  b\ " | ( read -r x ; echo -"$x"- )

# input ending in backslash
printf 'abc\' | { read var ; recho "$var"; }
printf 'abc\' | { read -r var ; recho "$var"; }

# make sure that CTLESC and CTLNUL are passed through correctly
echo $'\001' | ( read var ; recho "$var" )
echo $'\001' | ( read ; recho "$REPLY" )

echo $'\177' | ( read var ; recho "$var" )
echo $'\177' | ( read ; recho "$REPLY" )

# make sure a backslash-quoted \\n still disappears from the input when
# we're not reading in `raw' mode, and no stray CTLESC chars are left in
# the input stream
echo $'ab\\\ncd' | ( read ; recho "$REPLY" )

echo "A B " > $TMPDIR/IN
unset x y z
read x y z < $TMPDIR/IN
echo 1: "x[$x] y[$y] z[$z]"
echo 1a: ${z-z not set}
read x < $TMPDIR/IN
echo 2: "x[$x]"
rm $TMPDIR/IN

# this is where the bash `read' behavior with respect to $REPLY differs
# from ksh93
echo "A B " > $TMPDIR/IN

read < $TMPDIR/IN
echo "[$REPLY]"

rm $TMPDIR/IN

echo " A B " > $TMPDIR/IN

read < $TMPDIR/IN
echo "[$REPLY]"

rm $TMPDIR/IN

# make sure that read with more variables than words sets the extra
# variables to the empty string

bvar=bvar
cvar=cvar
echo aa > $TMPDIR/IN
read avar bvar cvar < $TMPDIR/IN
echo =="$avar"==
echo =="$bvar"==
echo =="$cvar"==

rm $TMPDIR/IN

# test behavior of read with various settings of IFS

echo " foo" | { IFS= read line; recho "$line"; }

echo " foo" | { IFS= ; read line; recho "$line"; }

echo " foo" | { unset IFS ; read line; recho "$line"; }

echo " foo" | { IFS=$'\n' ; read line; recho "$line"; }

echo " foo" | { IFS=$' \n' ; read line; recho "$line"; }

echo " foo" | { IFS=$' \t\n' ; read line; recho "$line"; }

echo " foo" | { IFS=$':' ; read line; recho "$line"; }

# this leaves `b' readonly
readonly b
read a b c <<EOF
a b c
EOF

# the latest POSIX draft says $? should be > 1
echo a = $a b = $b c = $c stat = $?

# test read -d delim behavior
${THIS_SH} ./read1.sub

# test read -t timeout behavior
${THIS_SH} ./read2.sub

# test read -n nchars behavior
${THIS_SH} ./read3.sub

# test read -u fd behavior
${THIS_SH} ./read4.sub

# test behavior when IFS is not the default -- bug through bash-2.05b
${THIS_SH} ./read5.sub

# test behavior of read -t 0
${THIS_SH} ./read6.sub

# test behavior of readline timeouts
${THIS_SH} ./read7.sub

# test behavior of read -n and read -d on regular files
${THIS_SH} ./read8.sub

# test behavior of trailing IFS whitespace - POSIX conformance
${THIS_SH} ./read9.sub

# test behavior of read builtin modifying $IFS
${THIS_SH} ./read10.sub

--------------------------------------------------------------------------------
---
(pipe (command (word "echo") (word "\" a \"")) (subshell (semi (command (word "read") (word "x")) (command (word "echo") (word "\"$x.\"")))))
(pipe (command (word "echo") (word "\" a  b  \"")) (subshell (semi (command (word "read") (word "x") (word "y")) (command (word "echo") (word "-\"$x\"-\"$y\"-")))))
(pipe (command (word "echo") (word "\" a  b\\ \"")) (subshell (semi (command (word "read") (word "x") (word "y")) (command (word "echo") (word "-\"$x\"-\"$y\"-")))))
(pipe (command (word "echo") (word "\" a  b  \"")) (subshell (semi (command (word "read") (word "x")) (command (word "echo") (word "-\"$x\"-")))))
(pipe (command (word "echo") (word "\" a  b\\ \"")) (subshell (semi (command (word "read") (word "x")) (command (word "echo") (word "-\"$x\"-")))))
(pipe (command (word "echo") (word "\" a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x") (word "y")) (command (word "echo") (word "-\"$x\"-\"$y\"-")))))
(pipe (command (word "echo") (word "\" a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x")) (command (word "echo") (word "-\"$x\"-")))))
(pipe (command (word "echo") (word "\"\\ a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x") (word "y")) (command (word "echo") (word "-\"$x\"-\"$y\"-")))))
(pipe (command (word "echo") (word "\"\\ a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x")) (command (word "echo") (word "-\"$x\"-")))))
(pipe (command (word "echo") (word "\" \\ a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x") (word "y")) (command (word "echo") (word "-\"$x\"-\"$y\"-")))))
(pipe (command (word "echo") (word "\" \\ a  b\\ \"")) (subshell (semi (command (word "read") (word "-r") (word "x")) (command (word "echo") (word "-\"$x\"-")))))
(pipe (command (word "printf") (word "'abc\\'")) (brace-group (semi (command (word "read") (word "var")) (command (word "recho") (word "\"$var\"")))))
(pipe (command (word "printf") (word "'abc\\'")) (brace-group (semi (command (word "read") (word "-r") (word "var")) (command (word "recho") (word "\"$var\"")))))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read") (word "var")) (command (word "recho") (word "\"$var\"")))))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read")) (command (word "recho") (word "\"$REPLY\"")))))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read") (word "var")) (command (word "recho") (word "\"$var\"")))))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read")) (command (word "recho") (word "\"$REPLY\"")))))
(pipe (command (word "echo") (word "'ab\\\ncd'")) (subshell (semi (command (word "read")) (command (word "recho") (word "\"$REPLY\"")))))
(command (word "echo") (word "\"A B \"") (redirect ">" "$TMPDIR/IN"))
(command (word "unset") (word "x") (word "y") (word "z"))
(command (word "read") (word "x") (word "y") (word "z") (redirect "<" "$TMPDIR/IN"))
(command (word "echo") (word "1:") (word "\"x[$x] y[$y] z[$z]\""))
(command (word "echo") (word "1a:") (word "${z-z not set}"))
(command (word "read") (word "x") (redirect "<" "$TMPDIR/IN"))
(command (word "echo") (word "2:") (word "\"x[$x]\""))
(command (word "rm") (word "$TMPDIR/IN"))
(command (word "echo") (word "\"A B \"") (redirect ">" "$TMPDIR/IN"))
(command (word "read") (redirect "<" "$TMPDIR/IN"))
(command (word "echo") (word "\"[$REPLY]\""))
(command (word "rm") (word "$TMPDIR/IN"))
(command (word "echo") (word "\" A B \"") (redirect ">" "$TMPDIR/IN"))
(command (word "read") (redirect "<" "$TMPDIR/IN"))
(command (word "echo") (word "\"[$REPLY]\""))
(command (word "rm") (word "$TMPDIR/IN"))
(command (word "bvar=bvar"))
(command (word "cvar=cvar"))
(command (word "echo") (word "aa") (redirect ">" "$TMPDIR/IN"))
(command (word "read") (word "avar") (word "bvar") (word "cvar") (redirect "<" "$TMPDIR/IN"))
(command (word "echo") (word "==\"$avar\"=="))
(command (word "echo") (word "==\"$bvar\"=="))
(command (word "echo") (word "==\"$cvar\"=="))
(command (word "rm") (word "$TMPDIR/IN"))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (command (word "IFS=") (word "read") (word "line")) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "IFS=")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "unset") (word "IFS")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "IFS='\n'")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "IFS=' \n'")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "IFS=' \t\n'")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(pipe (command (word "echo") (word "\" foo\"")) (brace-group (semi (semi (command (word "IFS=':'")) (command (word "read") (word "line"))) (command (word "recho") (word "\"$line\"")))))
(command (word "readonly") (word "b"))
(command (word "read") (word "a") (word "b") (word "c") (redirect "<<" "a b c
"))
(command (word "echo") (word "a") (word "=") (word "$a") (word "b") (word "=") (word "$b") (word "c") (word "=") (word "$c") (word "stat") (word "=") (word "$?"))
(command (word "${THIS_SH}") (word "./read1.sub"))
(command (word "${THIS_SH}") (word "./read2.sub"))
(command (word "${THIS_SH}") (word "./read3.sub"))
(command (word "${THIS_SH}") (word "./read4.sub"))
(command (word "${THIS_SH}") (word "./read5.sub"))
(command (word "${THIS_SH}") (word "./read6.sub"))
(command (word "${THIS_SH}") (word "./read7.sub"))
(command (word "${THIS_SH}") (word "./read8.sub"))
(command (word "${THIS_SH}") (word "./read9.sub"))
(command (word "${THIS_SH}") (word "./read10.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== redir
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
: ${TMPDIR:=/tmp}

export LC_ALL=C
export LANG=C

# catch-all for remaining untested redirection stuff
set +o posix

# this should succeed silently
cat </dev/null >/dev/null 2>&1

echo abc > /tmp/redir-test
cat /tmp/redir-test

set -o noclobber

#this should be an error, so it needs the same fixed filename
echo def > /tmp/redir-test
cat /tmp/redir-test

# but this should succeed
echo def > $TMPDIR/redir-test-2
cat $TMPDIR/redir-test-2

# and so should this
echo def >| /tmp/redir-test
cat /tmp/redir-test

# this should work as normal
echo ghi >| $TMPDIR/redir-test-3
cat $TMPDIR/redir-test-3

set +o noclobber
rm -f /tmp/redir-test
rm -f $TMPDIR/redir-test-2 $TMPDIR/redir-test-3

# these are errors
fd=-1
exec <&$fd
exec $fd</dev/null
unset -v fd

# this should be an error
z="a b"
cat < $z

echo "Point 1"

exec 3</etc/passwd
exec 4>$TMPDIR/bash-a
exec 5>$TMPDIR/bash-b
echo "Point 2"

echo to a 1>&4
echo to b 1>&5
cat $TMPDIR/bash-a
cat $TMPDIR/bash-b
exec 11</dev/null
echo "Point 3"

echo to a 1>&4
echo to b 1>&5
cat $TMPDIR/bash-a
cat $TMPDIR/bash-b

exec 11<&-
echo "Point 4"

exec 6<>$TMPDIR/bash-c
echo to c 1>&6
cat $TMPDIR/bash-c
echo "Point 5"

# clean up before running scripts
exec 4>&- 5>&- 6<&$unset-		# ksh93 quirk with unset variable

rm -f $TMPDIR/bash-a $TMPDIR/bash-b $TMPDIR/bash-c

#
# Test the effect of input buffering on the shell's input
#
${THIS_SH} < redir1.sub

# more open, close, duplicate file descriptors
${THIS_SH} ./redir3.sub < ./redir3.in1

# still more redirections
${THIS_SH} ./redir4.sub < redir4.in1

# various forms of null redirection
testf()
{
	if [ -f "$1" ]; then
		rm -f "$1"
	else
		echo oops -- $1 not found
	fi
}

> $TMPDIR/null-redir-a
testf $TMPDIR/null-redir-a

$EXIT > $TMPDIR/null-redir-b
testf $TMPDIR/null-redir-b

( > $TMPDIR/null-redir-c )
testf $TMPDIR/null-redir-c

$EXIT > $TMPDIR/null-redir-d &
wait
testf $TMPDIR/null-redir-d

exit 3 | $EXIT > $TMPDIR/null-redir-e
echo $? -- ${PIPESTATUS[@]}
testf $TMPDIR/null-redir-e

exit 4 | > $TMPDIR/null-redir-f
echo $? -- ${PIPESTATUS[@]}
testf $TMPDIR/null-redir-f

> $TMPDIR/null-redir-g &
wait
testf $TMPDIR/null-redir-g

exec >$TMPDIR/null-redir-h &
wait
testf $TMPDIR/null-redir-h

# make sure async commands don't get /dev/null as stdin when an explicit
# input redirection is supplied
for x in 1 2 3; do
	{ read line ; echo $line ; } &
	wait
	{ read line ; echo $line ; } &
	wait
done << EOF
ab
cd
ef
gh
ij
kl
EOF

# make sure async commands get /dev/null as stdin in the absence of any
# input redirection
/bin/cat &
wait
echo $?

# make sure that loops work OK with here documents and are not run in
# subshells
while read line; do
	echo $line
	l2=$line
done << EOF
ab
cd
EOF
echo $l2

# These should not echo anything -- bug in versions before 2.04
( ( echo hello 1>&3 ) 3>&1 ) >/dev/null 2>&1

( ( echo hello 1>&3 ) 3>&1 ) >/dev/null 2>&1 | cat

# in posix mode, non-interactive shells are not allowed to perform
# filename expansion on input redirections, even if they expand to
# a single filename
set -o posix
cat < redir1.*

# test ksh93 dup-and-close (move fd) redirections
${THIS_SH} ./redir5.sub

# test behavior after a write error with a builtin command
${THIS_SH} ./redir6.sub

# problem with redirections using fds bash uses internally
: ${TMPDIR:=$TMPDIR}

trap 'rm -f $TMPDIR/bash-redir-$$' 0 1 2 3 6 15

echo before block
{
	echo before redir
	exec 10>&1
	echo after redir
} > $TMPDIR/bash-redir-$$

echo after block

${THIS_SH} ./redir7.sub

${THIS_SH} ./redir8.sub

exec 9>&2
command exec 2>>$TMPDIR/foo-$$
echo whatsis >&2
echo cat /tmp/foo
cat $TMPDIR/foo-$$
rm -f $TMPDIR/foo-$$
exec 2>&9
exec 9>&-

${THIS_SH} ./redir9.sub
${THIS_SH} ./redir10.sub
${THIS_SH} ./redir11.sub
${THIS_SH} ./redir12.sub

${THIS_SH} < ./redir13.in

--------------------------------------------------------------------------------
---
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "export") (word "LC_ALL=C"))
(command (word "export") (word "LANG=C"))
(command (word "set") (word "+o") (word "posix"))
(command (word "cat") (redirect "<" "/dev/null") (redirect ">" "/dev/null") (redirect ">&" 1))
(command (word "echo") (word "abc") (redirect ">" "/tmp/redir-test"))
(command (word "cat") (word "/tmp/redir-test"))
(command (word "set") (word "-o") (word "noclobber"))
(command (word "echo") (word "def") (redirect ">" "/tmp/redir-test"))
(command (word "cat") (word "/tmp/redir-test"))
(command (word "echo") (word "def") (redirect ">" "$TMPDIR/redir-test-2"))
(command (word "cat") (word "$TMPDIR/redir-test-2"))
(command (word "echo") (word "def") (redirect ">|" "/tmp/redir-test"))
(command (word "cat") (word "/tmp/redir-test"))
(command (word "echo") (word "ghi") (redirect ">|" "$TMPDIR/redir-test-3"))
(command (word "cat") (word "$TMPDIR/redir-test-3"))
(command (word "set") (word "+o") (word "noclobber"))
(command (word "rm") (word "-f") (word "/tmp/redir-test"))
(command (word "rm") (word "-f") (word "$TMPDIR/redir-test-2") (word "$TMPDIR/redir-test-3"))
(command (word "fd=-1"))
(command (word "exec") (redirect "<&" "$fd"))
(command (word "exec") (word "$fd") (redirect "<" "/dev/null"))
(command (word "unset") (word "-v") (word "fd"))
(command (word "z=\"a b\""))
(command (word "cat") (redirect "<" "$z"))
(command (word "echo") (word "\"Point 1\""))
(command (word "exec") (redirect "<" "/etc/passwd"))
(command (word "exec") (redirect ">" "$TMPDIR/bash-a"))
(command (word "exec") (redirect ">" "$TMPDIR/bash-b"))
(command (word "echo") (word "\"Point 2\""))
(command (word "echo") (word "to") (word "a") (redirect ">&" 4))
(command (word "echo") (word "to") (word "b") (redirect ">&" 5))
(command (word "cat") (word "$TMPDIR/bash-a"))
(command (word "cat") (word "$TMPDIR/bash-b"))
(command (word "exec") (redirect "<" "/dev/null"))
(command (word "echo") (word "\"Point 3\""))
(command (word "echo") (word "to") (word "a") (redirect ">&" 4))
(command (word "echo") (word "to") (word "b") (redirect ">&" 5))
(command (word "cat") (word "$TMPDIR/bash-a"))
(command (word "cat") (word "$TMPDIR/bash-b"))
(command (word "exec") (redirect ">&-" 0))
(command (word "echo") (word "\"Point 4\""))
(command (word "exec") (redirect "<>" "$TMPDIR/bash-c"))
(command (word "echo") (word "to") (word "c") (redirect ">&" 6))
(command (word "cat") (word "$TMPDIR/bash-c"))
(command (word "echo") (word "\"Point 5\""))
(command (word "exec") (redirect ">&-" 0) (redirect ">&-" 0) (redirect "<&" "$unset"))
(command (word "rm") (word "-f") (word "$TMPDIR/bash-a") (word "$TMPDIR/bash-b") (word "$TMPDIR/bash-c"))
(command (word "${THIS_SH}") (redirect "<" "redir1.sub"))
(command (word "${THIS_SH}") (word "./redir3.sub") (redirect "<" "./redir3.in1"))
(command (word "${THIS_SH}") (word "./redir4.sub") (redirect "<" "redir4.in1"))
(function "testf" (brace-group (if (command (word "[") (word "-f") (word "\"$1\"") (word "]")) (command (word "rm") (word "-f") (word "\"$1\"")) (command (word "echo") (word "oops") (word "--") (word "$1") (word "not") (word "found")))))
(command (redirect ">" "$TMPDIR/null-redir-a"))
(command (word "testf") (word "$TMPDIR/null-redir-a"))
(command (word "$EXIT") (redirect ">" "$TMPDIR/null-redir-b"))
(command (word "testf") (word "$TMPDIR/null-redir-b"))
(subshell (command (redirect ">" "$TMPDIR/null-redir-c")))
(command (word "testf") (word "$TMPDIR/null-redir-c"))
(background (command (word "$EXIT") (redirect ">" "$TMPDIR/null-redir-d")))
(command (word "wait"))
(command (word "testf") (word "$TMPDIR/null-redir-d"))
(pipe (command (word "exit") (word "3")) (command (word "$EXIT") (redirect ">" "$TMPDIR/null-redir-e")))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(command (word "testf") (word "$TMPDIR/null-redir-e"))
(pipe (command (word "exit") (word "4")) (command (redirect ">" "$TMPDIR/null-redir-f")))
(command (word "echo") (word "$?") (word "--") (word "${PIPESTATUS[@]}"))
(command (word "testf") (word "$TMPDIR/null-redir-f"))
(background (command (redirect ">" "$TMPDIR/null-redir-g")))
(command (word "wait"))
(command (word "testf") (word "$TMPDIR/null-redir-g"))
(background (command (word "exec") (redirect ">" "$TMPDIR/null-redir-h")))
(command (word "wait"))
(command (word "testf") (word "$TMPDIR/null-redir-h"))
(for (word "x") (in (word "1") (word "2") (word "3")) (semi (background (brace-group (semi (command (word "read") (word "line")) (command (word "echo") (word "$line")))) (command (word "wait"))) (background (brace-group (semi (command (word "read") (word "line")) (command (word "echo") (word "$line")))) (command (word "wait"))))) (redirect "<<" "ab
cd
ef
gh
ij
kl
")
(background (command (word "/bin/cat")))
(command (word "wait"))
(command (word "echo") (word "$?"))
(while (command (word "read") (word "line")) (semi (command (word "echo") (word "$line")) (command (word "l2=$line")))) (redirect "<<" "ab
cd
")
(command (word "echo") (word "$l2"))
(subshell (subshell (command (word "echo") (word "hello") (redirect ">&" 3))) (redirect ">&" 1)) (redirect ">" "/dev/null") (redirect ">&" 1)
(pipe (subshell (subshell (command (word "echo") (word "hello") (redirect ">&" 3))) (redirect ">&" 1)) (redirect ">" "/dev/null") (redirect ">&" 1) (command (word "cat")))
(command (word "set") (word "-o") (word "posix"))
(command (word "cat") (redirect "<" "redir1.*"))
(command (word "${THIS_SH}") (word "./redir5.sub"))
(command (word "${THIS_SH}") (word "./redir6.sub"))
(command (word ":") (word "${TMPDIR:=$TMPDIR}"))
(command (word "trap") (word "'rm -f $TMPDIR/bash-redir-$$'") (word "0") (word "1") (word "2") (word "3") (word "6") (word "15"))
(command (word "echo") (word "before") (word "block"))
(brace-group (semi (semi (command (word "echo") (word "before") (word "redir")) (command (word "exec") (redirect ">&" 1))) (command (word "echo") (word "after") (word "redir")))) (redirect ">" "$TMPDIR/bash-redir-$$")
(command (word "echo") (word "after") (word "block"))
(command (word "${THIS_SH}") (word "./redir7.sub"))
(command (word "${THIS_SH}") (word "./redir8.sub"))
(command (word "exec") (redirect ">&" 2))
(command (word "command") (word "exec") (redirect ">>" "$TMPDIR/foo-$$"))
(command (word "echo") (word "whatsis") (redirect ">&" 2))
(command (word "echo") (word "cat") (word "/tmp/foo"))
(command (word "cat") (word "$TMPDIR/foo-$$"))
(command (word "rm") (word "-f") (word "$TMPDIR/foo-$$"))
(command (word "exec") (redirect ">&" 9))
(command (word "exec") (redirect ">&-" 0))
(command (word "${THIS_SH}") (word "./redir9.sub"))
(command (word "${THIS_SH}") (word "./redir10.sub"))
(command (word "${THIS_SH}") (word "./redir11.sub"))
(command (word "${THIS_SH}") (word "./redir12.sub"))
(command (word "${THIS_SH}") (redirect "<" "./redir13.in"))
(command (word "--------------------------------------------------------------------------------"))
---

=== rhs-exp
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
selvecs='&m68kcoff_vec'
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\'$selvecs\'}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="$selvecs"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"$selvecs\"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\$selvecs\\}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=$selvecs}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\$selvecs}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\$selvecs"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'"$null"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\\$selvecs"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\'$selvecs\'"}"

recho TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\'$selvecs\'}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="$selvecs"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"$selvecs\"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\$selvecs\\}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=$selvecs}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\$selvecs}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\$selvecs"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'"$null"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\\$selvecs"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\'$selvecs\'"}

recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\p"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\p}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\\"}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS=\'}"
recho "TDEFAULTS = ${selvecs:+-DSELECT_VECS="\'"}"

recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\p"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\p}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\\"}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS=\'}
recho TDEFAULTS = ${selvecs:+-DSELECT_VECS="\'"}

# more tests for bash-3.0 behavior

var="a*b" ; echo "${var//\\*/}"
var="a*b" ; echo "${var//\*/}"

var="a?b" ; echo "${var//\\?/}"
var="a?b" ; echo "${var//\?/}"

var="a/b" ; echo "${var//\\//}"
var="a/b" ; echo "${var//\//}"

${THIS_SH} ./rhs-exp1.sub

--------------------------------------------------------------------------------
---
(command (word "selvecs='&m68kcoff_vec'"))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\'$selvecs\\'}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"$selvecs\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\\"$selvecs\\\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\\\$selvecs\\\\}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=$selvecs}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\$selvecs}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\$selvecs\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS='$selvecs'\"$null\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\\\$selvecs\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\'$selvecs\\'\"}\""))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS='$selvecs'}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\'$selvecs\\'}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"$selvecs\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\\"$selvecs\\\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\\\$selvecs\\\\}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=$selvecs}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\$selvecs}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\$selvecs\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS='$selvecs'\"$null\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\\\$selvecs\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\'$selvecs\\'\"}"))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\p\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\p}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\\\\"}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\\\}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\\'}\""))
(command (word "recho") (word "\"TDEFAULTS = ${selvecs:+-DSELECT_VECS=\"\\'\"}\""))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\p\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\p}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\\\\"}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\\\}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\\'}"))
(command (word "recho") (word "TDEFAULTS") (word "=") (word "${selvecs:+-DSELECT_VECS=\"\\'\"}"))
(semi (command (word "var=\"a*b\"")) (command (word "echo") (word "\"${var//\\\\*/}\"")))
(semi (command (word "var=\"a*b\"")) (command (word "echo") (word "\"${var//\\*/}\"")))
(semi (command (word "var=\"a?b\"")) (command (word "echo") (word "\"${var//\\\\?/}\"")))
(semi (command (word "var=\"a?b\"")) (command (word "echo") (word "\"${var//\\?/}\"")))
(semi (command (word "var=\"a/b\"")) (command (word "echo") (word "\"${var//\\\\//}\"")))
(semi (command (word "var=\"a/b\"")) (command (word "echo") (word "\"${var//\\//}\"")))
(command (word "${THIS_SH}") (word "./rhs-exp1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== rsh
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# test restricted shell mode -- these should all be errors
#
# things not tested for:
#	adding builtins dynamically with enable -f
#	importing function definitions from environment

${THIS_SH} ./rsh1.sub
${THIS_SH} ./rsh2.sub

set -r

cd /
PATH=$PATH:/usr/local/bin
SHELL=/bin/sh
/bin/sh -c 'echo /bin/sh executed'
/bin/cat foo | cat

. ./source.sub3

rm -f /tmp/restricted
echo abc > /tmp/restricted
if [ -f /tmp/restricted ]; then
	echo oops 1 -- output
fi
echo abc >> /tmp/restricted
if [ -f /tmp/restricted ]; then
	echo oops 2 -- append
fi

command -p date

set +r
set +o restricted

exec /bin/date

echo $0: after exec

--------------------------------------------------------------------------------
---
(command (word "${THIS_SH}") (word "./rsh1.sub"))
(command (word "${THIS_SH}") (word "./rsh2.sub"))
(command (word "set") (word "-r"))
(command (word "cd") (word "/"))
(command (word "PATH=$PATH:/usr/local/bin"))
(command (word "SHELL=/bin/sh"))
(command (word "/bin/sh") (word "-c") (word "'echo /bin/sh executed'"))
(pipe (command (word "/bin/cat") (word "foo")) (command (word "cat")))
(command (word ".") (word "./source.sub3"))
(command (word "rm") (word "-f") (word "/tmp/restricted"))
(command (word "echo") (word "abc") (redirect ">" "/tmp/restricted"))
(if (command (word "[") (word "-f") (word "/tmp/restricted") (word "]")) (command (word "echo") (word "oops") (word "1") (word "--") (word "output")))
(command (word "echo") (word "abc") (redirect ">>" "/tmp/restricted"))
(if (command (word "[") (word "-f") (word "/tmp/restricted") (word "]")) (command (word "echo") (word "oops") (word "2") (word "--") (word "append")))
(command (word "command") (word "-p") (word "date"))
(command (word "set") (word "+r"))
(command (word "set") (word "+o") (word "restricted"))
(command (word "exec") (word "/bin/date"))
(command (word "echo") (word "$0:") (word "after") (word "exec"))
(command (word "--------------------------------------------------------------------------------"))
---

=== set-e
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
if : ; then
	set -e
	N=95
	while :; do
		# expr returns 1 if expression is null or 0
		set +e
		N_MOD_100=`expr $N % 100`
		set -e
		echo $N_MOD_100
		N=`expr $N + 1`
		if [ $N -eq 110 ]; then
			break
		fi
	done
	set +e
fi

(
set -e
false
echo bad
)
echo $?

x=$(
set -e
false
echo bad
)
echo $? $x

# command subst should not inherit -e
set -e
echo $(false; echo ok)

if set +e
then
	false
fi
echo hi

set -e

# a failing command in the compound list following a while, until, or
# if should not cause the shell to exit

while false; do
	echo hi
done
echo while succeeded

x=1
until (( x == 4 )); do
	x=4
done
echo until succeeded: $x

if false; then
	echo oops
fi
echo if succeeded

# failing commands that are part of an AND or OR list should not
# cause the shell to exit
false && echo AND list failed
echo AND list succeeded

false || echo OR list succeeded

# more compound commands containing failing commands
for (( f=0; f<10; f++ )); do
	printf '%.2d ' $f
	false
done && echo done
echo

for f in {0..9}; do
	printf '%.2d ' $f
	false
done && echo done
echo

! false
echo ! succeeded

# make sure eval preserves the state of the -e flag and `!' reserved word
set -e
if eval false; then
	echo oops
fi
echo eval succeeded

! eval false
echo ! eval succeeded -- 1

! eval '(exit 5)'
echo ! eval succeeded -- 2

set -e
until builtin false; do echo a; break; done
echo $?

until eval false; do echo b; break; done
echo $?

: ${TMPDIR:=/tmp}
FN=$TMPDIR/set-e-$$
cat > $FN << EOF
false
echo after 1
false
EOF

set -e
until . $FN; do echo a; break; done
echo $?

rm -f $FN

set +e

${THIS_SH} ./set-e1.sub
${THIS_SH} ./set-e2.sub
${THIS_SH} ./set-e3.sub

--------------------------------------------------------------------------------
---
(if (command (word ":")) (semi (semi (semi (command (word "set") (word "-e")) (command (word "N=95"))) (while (command (word ":")) (semi (semi (semi (semi (semi (command (word "set") (word "+e")) (command (word "N_MOD_100=`expr $N % 100`"))) (command (word "set") (word "-e"))) (command (word "echo") (word "$N_MOD_100"))) (command (word "N=`expr $N + 1`"))) (if (command (word "[") (word "$N") (word "-eq") (word "110") (word "]")) (command (word "break")))))) (command (word "set") (word "+e"))))
(subshell (semi (semi (command (word "set") (word "-e")) (command (word "false"))) (command (word "echo") (word "bad"))))
(command (word "echo") (word "$?"))
(command (word "x=$(set -e\nfalse\necho bad)"))
(command (word "echo") (word "$?") (word "$x"))
(command (word "set") (word "-e"))
(command (word "echo") (word "$(false; echo ok)"))
(if (command (word "set") (word "+e")) (command (word "false")))
(command (word "echo") (word "hi"))
(command (word "set") (word "-e"))
(while (command (word "false")) (command (word "echo") (word "hi")))
(command (word "echo") (word "while") (word "succeeded"))
(command (word "x=1"))
(until (arith (word " x == 4 ")) (command (word "x=4")))
(command (word "echo") (word "until") (word "succeeded:") (word "$x"))
(if (command (word "false")) (command (word "echo") (word "oops")))
(command (word "echo") (word "if") (word "succeeded"))
(and (command (word "false")) (command (word "echo") (word "AND") (word "list") (word "failed")))
(command (word "echo") (word "AND") (word "list") (word "succeeded"))
(or (command (word "false")) (command (word "echo") (word "OR") (word "list") (word "succeeded")))
(and (arith-for (init (word "f=0")) (test (word "f<10")) (step (word "f++ ")) (semi (command (word "printf") (word "'%.2d '") (word "$f")) (command (word "false")))) (command (word "echo") (word "done")))
(command (word "echo"))
(and (for (word "f") (in (word "{0..9}")) (semi (command (word "printf") (word "'%.2d '") (word "$f")) (command (word "false")))) (command (word "echo") (word "done")))
(command (word "echo"))
(negation (command (word "false")))
(command (word "echo") (word "!") (word "succeeded"))
(command (word "set") (word "-e"))
(if (command (word "eval") (word "false")) (command (word "echo") (word "oops")))
(command (word "echo") (word "eval") (word "succeeded"))
(negation (command (word "eval") (word "false")))
(command (word "echo") (word "!") (word "eval") (word "succeeded") (word "--") (word "1"))
(negation (command (word "eval") (word "'(exit 5)'")))
(command (word "echo") (word "!") (word "eval") (word "succeeded") (word "--") (word "2"))
(command (word "set") (word "-e"))
(until (command (word "builtin") (word "false")) (semi (command (word "echo") (word "a")) (command (word "break"))))
(command (word "echo") (word "$?"))
(until (command (word "eval") (word "false")) (semi (command (word "echo") (word "b")) (command (word "break"))))
(command (word "echo") (word "$?"))
(command (word ":") (word "${TMPDIR:=/tmp}"))
(command (word "FN=$TMPDIR/set-e-$$"))
(command (word "cat") (redirect ">" "$FN") (redirect "<<" "false
echo after 1
false
"))
(command (word "set") (word "-e"))
(until (command (word ".") (word "$FN")) (semi (command (word "echo") (word "a")) (command (word "break"))))
(command (word "echo") (word "$?"))
(command (word "rm") (word "-f") (word "$FN"))
(command (word "set") (word "+e"))
(command (word "${THIS_SH}") (word "./set-e1.sub"))
(command (word "${THIS_SH}") (word "./set-e2.sub"))
(command (word "${THIS_SH}") (word "./set-e3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== set-x
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# $Id: set-x.tests,v 1.1 2002/12/09 13:12:37 rockyb Exp $
#
# Test that "set -x" shows what we think it should.
#
set -x
for ((i=0; i<=5; i++ )) ; do
  x=0
done
for i in 0 1 2 ; do
  x=i
done
case x in 
 0) x=i ;;
 *) x=i ;;
esac

foo=one
foo+=two
echo $foo

foo=one echo $foo

set +x

# test BASH_XTRACEFD
${THIS_SH} ./set-x1.sub

# compound assignment printing
${THIS_SH} ./set-x2.sub

--------------------------------------------------------------------------------
---
(command (word "set") (word "-x"))
(arith-for (init (word "i=0")) (test (word "i<=5")) (step (word "i++ ")) (command (word "x=0")))
(for (word "i") (in (word "0") (word "1") (word "2")) (command (word "x=i")))
(case (word "x") (pattern ((word "0")) (command (word "x=i"))) (pattern ((word "*")) (command (word "x=i"))))
(command (word "foo=one"))
(command (word "foo+=two"))
(command (word "echo") (word "$foo"))
(command (word "foo=one") (word "echo") (word "$foo"))
(command (word "set") (word "+x"))
(command (word "${THIS_SH}") (word "./set-x1.sub"))
(command (word "${THIS_SH}") (word "./set-x2.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== shopt
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# let's try an error message first
shopt -z

# first, set up a known environment
shopt -u cdable_vars
shopt -s cdspell
shopt -u checkhash
shopt -u checkwinsize
shopt -s cmdhist
shopt -u dotglob
shopt -u execfail
shopt -s expand_aliases
shopt -u extglob
shopt -u histreedit
shopt -u histappend
shopt -u histverify
shopt -s hostcomplete
shopt -u huponexit
shopt -s interactive_comments
shopt -u lithist
shopt -u mailwarn
shopt -u nocaseglob
shopt -u nullglob
shopt -s promptvars
shopt -u shift_verbose
shopt -s sourcepath
shopt -u xpg_echo

# Now, start checking the output
builtin printf -- "--\n"
shopt -p	# list 'em all
builtin printf -- "--\n"
# test specific variables
shopt -p huponexit
shopt -p checkwinsize
shopt -p sourcepath

builtin printf -- "--\n"
shopt -s -p
builtin printf -- "--\n"
shopt -u -p
builtin printf -- "--\n"
shopt -u

# Now set up another known environment
set +o allexport
set -o braceexpand
set +o errexit
set -o hashall
set -o histexpand
set +o keyword
set -o monitor
set +o noclobber
set +o noexec
set +o noglob
set +o notify
set +o nounset
set +o onecmd
set +o physical
set -o privileged
set +o verbose
set +o xtrace
set -o history
set +o ignoreeof
set -o interactive-comments
set +o posix
set -o emacs
set +o vi

# list 'em all
builtin printf -- "--\n"
shopt -o -p

builtin printf -- "--\n"
set -o
builtin printf -- "--\n"
set +o

# test specific variables
builtin printf -- "--\n"
shopt -p -o history
shopt -p -o verbose

builtin printf -- "--\n"
shopt -s -p -o
builtin printf -- "--\n"
shopt -u -p -o
builtin printf -- "--\n"
shopt -u -o

# errors
builtin printf -- "--\n"
shopt -p xyz1
shopt -o -p xyz1

${THIS_SH} ./shopt1.sub

# test whether or not temporary variable assignments that manipulate posix
# mode restore the previous state or the default non-posix state
${THIS_SH} -c 'shopt -s expand_aliases ; shopt expand_aliases ; POSIXLY_CORRECT=y true ; shopt expand_aliases'

--------------------------------------------------------------------------------
---
(command (word "shopt") (word "-z"))
(command (word "shopt") (word "-u") (word "cdable_vars"))
(command (word "shopt") (word "-s") (word "cdspell"))
(command (word "shopt") (word "-u") (word "checkhash"))
(command (word "shopt") (word "-u") (word "checkwinsize"))
(command (word "shopt") (word "-s") (word "cmdhist"))
(command (word "shopt") (word "-u") (word "dotglob"))
(command (word "shopt") (word "-u") (word "execfail"))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "shopt") (word "-u") (word "extglob"))
(command (word "shopt") (word "-u") (word "histreedit"))
(command (word "shopt") (word "-u") (word "histappend"))
(command (word "shopt") (word "-u") (word "histverify"))
(command (word "shopt") (word "-s") (word "hostcomplete"))
(command (word "shopt") (word "-u") (word "huponexit"))
(command (word "shopt") (word "-s") (word "interactive_comments"))
(command (word "shopt") (word "-u") (word "lithist"))
(command (word "shopt") (word "-u") (word "mailwarn"))
(command (word "shopt") (word "-u") (word "nocaseglob"))
(command (word "shopt") (word "-u") (word "nullglob"))
(command (word "shopt") (word "-s") (word "promptvars"))
(command (word "shopt") (word "-u") (word "shift_verbose"))
(command (word "shopt") (word "-s") (word "sourcepath"))
(command (word "shopt") (word "-u") (word "xpg_echo"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-p"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-p") (word "huponexit"))
(command (word "shopt") (word "-p") (word "checkwinsize"))
(command (word "shopt") (word "-p") (word "sourcepath"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-s") (word "-p"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-u") (word "-p"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-u"))
(command (word "set") (word "+o") (word "allexport"))
(command (word "set") (word "-o") (word "braceexpand"))
(command (word "set") (word "+o") (word "errexit"))
(command (word "set") (word "-o") (word "hashall"))
(command (word "set") (word "-o") (word "histexpand"))
(command (word "set") (word "+o") (word "keyword"))
(command (word "set") (word "-o") (word "monitor"))
(command (word "set") (word "+o") (word "noclobber"))
(command (word "set") (word "+o") (word "noexec"))
(command (word "set") (word "+o") (word "noglob"))
(command (word "set") (word "+o") (word "notify"))
(command (word "set") (word "+o") (word "nounset"))
(command (word "set") (word "+o") (word "onecmd"))
(command (word "set") (word "+o") (word "physical"))
(command (word "set") (word "-o") (word "privileged"))
(command (word "set") (word "+o") (word "verbose"))
(command (word "set") (word "+o") (word "xtrace"))
(command (word "set") (word "-o") (word "history"))
(command (word "set") (word "+o") (word "ignoreeof"))
(command (word "set") (word "-o") (word "interactive-comments"))
(command (word "set") (word "+o") (word "posix"))
(command (word "set") (word "-o") (word "emacs"))
(command (word "set") (word "+o") (word "vi"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-o") (word "-p"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "set") (word "-o"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "set") (word "+o"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-p") (word "-o") (word "history"))
(command (word "shopt") (word "-p") (word "-o") (word "verbose"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-s") (word "-p") (word "-o"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-u") (word "-p") (word "-o"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-u") (word "-o"))
(command (word "builtin") (word "printf") (word "--") (word "\"--\\n\""))
(command (word "shopt") (word "-p") (word "xyz1"))
(command (word "shopt") (word "-o") (word "-p") (word "xyz1"))
(command (word "${THIS_SH}") (word "./shopt1.sub"))
(command (word "${THIS_SH}") (word "-c") (word "'shopt -s expand_aliases ; shopt expand_aliases ; POSIXLY_CORRECT=y true ; shopt expand_aliases'"))
(command (word "--------------------------------------------------------------------------------"))
---

=== strip
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
v=`echo "" ; echo "" ; echo ""`
echo "'$v'"
v=`echo -n " ab "`
echo "'$v'"
v=`echo -n " "`
echo "'$v'"
v=`echo -n ""`
echo "'$v'"
v=`echo ""`
echo "'$v'"
v=`echo`
echo "'$v'"
v=`echo ababababababab`
echo "'$v'"
v=`echo "ababababababab  "`
echo "'$v'"
v=`echo -n "ababababababab  "`
echo "'$v'"
v=`echo -ne "abababa\nbababab  "`
echo "'$v'"
v="`echo -e '\n\n\n\n'`"
echo "'$v'"

--------------------------------------------------------------------------------
---
(command (word "v=`echo \"\" ; echo \"\" ; echo \"\"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo -n \" ab \"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo -n \" \"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo -n \"\"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo \"\"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo ababababababab`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo \"ababababababab  \"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo -n \"ababababababab  \"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=`echo -ne \"abababa\\nbababab  \"`"))
(command (word "echo") (word "\"'$v'\""))
(command (word "v=\"`echo -e '\\n\\n\\n\\n'`\""))
(command (word "echo") (word "\"'$v'\""))
(command (word "--------------------------------------------------------------------------------"))
---

=== test
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
if (( $UID == 0 )); then
	echo "test-tests: the test suite should not be run as root" >&2
fi

b()
{
	[ "$@" ]
	echo $?
}

t()
{
	test "$@"
	echo $?
}

echo 't'
t

echo 't -a noexist'
t -a noexist
echo 't -a run-all'
t -a run-all

echo 't -b run-all'
t -b run-all
echo 't -b /dev/jb1a'
t -b /dev/jb1a

echo 't -c run-all'
t -c run-all
echo 't -c /dev/tty'
t -c /dev/tty

echo 't -d run-all'
t -d run-all
echo 't -d /etc'
t -d /etc
echo 't -d ""'
t -d ""
echo 'b -d ""'
b -d ""

echo 't -e noexist'
t -e noexist
echo 't -e run-all'
t -e run-all

echo 't -f noexist'
t -f noexist
echo 't -f /dev/tty'
t -f /dev/tty
echo 't -f run-all'
t -f run-all

echo 't -g run-all'
t -g run-all

touch /tmp/test.setgid
chgrp ${GROUPS[0]} /tmp/test.setgid
chmod ug+x /tmp/test.setgid
chmod g+s /tmp/test.setgid
echo 't -g /tmp/test.setgid'
t -g /tmp/test.setgid
rm -f /tmp/test.setgid

echo 't -k run-all'
t -k run-all

echo 't -n ""'
t -n ""
echo 't -n "hello"'
t -n "hello"

echo 't -p run-all'
t -p run-all

echo 't -r noexist'
t -r noexist

if (( $UID != 0 )); then
	touch /tmp/test.noread
	chmod a-r /tmp/test.noread
	echo 't -r /tmp/test.noread'
	t -r /tmp/test.noread
	rm -f /tmp/test.noread
else
	echo 't -r /tmp/test.noread'
	echo 1
fi

echo 't -r run-all'
t -r run-all

echo 't -s noexist'
t -s noexist
echo 't -s /dev/null'
t -s /dev/null
echo 't -s run-all'
t -s run-all

echo 't -t 20'
t -t 20
echo 't -t 0'
t -t 0 < /dev/tty

echo 't -u noexist'
t -u noexist

echo 't -u run-all'
t -u run-all

touch /tmp/test.setuid
chmod u+x /tmp/test.setuid	# some systems require this to turn on setuid bit
chmod u+s /tmp/test.setuid
echo 't -u /tmp/test.setuid'
t -u /tmp/test.setuid
rm -f /tmp/test.setuid

echo 't -w noexist'
t -w noexist

if (( $UID != 0 )); then
	touch /tmp/test.nowrite
	chmod a-w /tmp/test.nowrite
	echo 't -w /tmp/test.nowrite'
	t -w /tmp/test.nowrite
	rm -f /tmp/test.nowrite
else
	echo 't -w /tmp/test.nowrite'
	echo 1
fi

echo 't -w /dev/null'
t -w /dev/null

echo 't -x noexist'
t -x noexist

touch /tmp/test.exec
chmod u+x /tmp/test.exec
echo 't -x /tmp/test.exec'
t -x /tmp/test.exec
rm -f /tmp/test.exec

touch /tmp/test.noexec
chmod u-x /tmp/test.noexec
echo 't -x /tmp/test.noexec'
t -x /tmp/test.noexec
rm -f /tmp/test.noexec

echo 't -z ""'
t -z ""
echo 't -z "foo"'
t -z "foo"

echo 't "foo"'
t "foo"
echo 't ""'
t ""

touch /tmp/test.owner
echo 't -O /tmp/test.owner'
t -O /tmp/test.owner
rm -f /tmp/test.owner

touch /tmp/test.socket
echo 't -S /tmp/test.socket'
t -S /tmp/test.socket	# false
rm -f /tmp/test.socket

touch /tmp/test.newer ; sleep 1; echo "hello" > /tmp/test.newer
echo 't -N /tmp/test.newer'
t -N /tmp/test.newer
rm -f /tmp/test.newer

echo 't "hello" = "hello"'
t "hello" = "hello"
echo 't "hello" = "goodbye"'
t "hello" = "goodbye"

echo 't "hello" == "hello"'
t "hello" == "hello"
echo 't "hello" == "goodbye"'
t "hello" == "goodbye"

echo 't "hello" != "hello"'
t "hello" != "hello"
echo 't "hello" != "goodbye"'
t "hello" != "goodbye"

echo 't "hello" < "goodbye"'
t "hello" \< "goodbye"
echo 't "hello" > "goodbye"'
t "hello" \> "goodbye"

echo 't ! "hello" > "goodbye"'
t "! hello" \> "goodbye"

echo 't 200 -eq 200'
t 200 -eq 200
echo 't 34 -eq 222'
t 34 -eq 222
echo 't -32 -eq 32'
t -32 -eq 32

echo 't 200 -ne 200'
t 200 -ne 200
echo 't 34 -ne 222'
t 34 -ne 222

echo 't 200 -gt 200'
t 200 -gt 200
echo 't 340 -gt 222'
t 340 -gt 222

echo 't 200 -ge 200'
t 200 -ge 200
echo 't 34 -ge 222'
t 34 -ge 222

echo 't 200 -lt 200'
t 200 -lt 200
echo 't 34 -lt 222'
t 34 -lt 222

echo 't 200 -le 200'
t 200 -le 200
echo 't 340 -le 222'
t 340 -le 222

echo 't 700 -le 1000 -a -n "1" -a "20" = "20"'
t 700 -le 1000 -a -n "1" -a "20" = "20"
echo 't ! \( 700 -le 1000 -a -n "1" -a "20" = "20" \)'
t ! \( 700 -le 1000 -a -n "1" -a "20" = "20" \)

# more traditional parsing algorithm
echo 't -n xx -a -z "" -a -t 0 -a -t'
t -n xx -a -z "" -a -t 0 -a -t

touch /tmp/abc
sleep 2
touch /tmp/def

echo 't /tmp/abc -nt /tmp/def'
t /tmp/abc -nt /tmp/def
echo 't /tmp/abc -ot /tmp/def'
t /tmp/abc -ot /tmp/def
echo 't /tmp/def -nt /tmp/abc'
t /tmp/def -nt /tmp/abc
echo 't /tmp/def -ot /tmp/abc'
t /tmp/def -ot /tmp/abc

echo 't /tmp/abc -ef /tmp/def'
t /tmp/abc -ef /tmp/def
ln /tmp/abc /tmp/ghi
echo 't /tmp/abc -ef /tmp/ghi'
t /tmp/abc -ef /tmp/ghi

rm /tmp/abc /tmp/def /tmp/ghi

touch /tmp/abc

echo 't noexist -ot /tmp/abc'
t noexist -ot /tmp/abc

echo 't /tmp/abc -ot noexist'
t /tmp/abc -ot noexist

echo 't noexist -nt /tmp/abc'
t noexist -nt /tmp/abc

echo 't noexist -ef /tmp/abc'
t noexist -ef /tmp/abc

echo 't -N noexist'
t -N noexist

# false; it's been read since modified
echo 't -N /tmp/abc'
t -N /tmp/abc

rm -f /tmp/abc

echo 't -r /dev/fd/0'
t -r /dev/fd/0
echo 't -w /dev/fd/1'
t -w /dev/fd/1
echo 't -w /dev/fd/2'
t -w /dev/fd/2

echo 't -r /dev/stdin'
t -r /dev/stdin
echo 't -w /dev/stdout'
t -w /dev/stdout
echo 't -w /dev/stderr'
t -w /dev/stderr

echo 't'
t
echo 'b'
b

echo 't 12 -eq 34'
t 12 -eq 34
echo 't ! 12 -eq 34'
t ! 12 -eq 34

echo 't -n abcd -o aaa'
t -n abcd -o aaa
echo 't -n abcd -o -z aaa'
t -n abcd -o -z aaa

echo 't -n abcd -a aaa'
t -n abcd -a aaa
echo 't -n abcd -a -z aaa'
t -n abcd -a -z aaa

# test set or unset shell options
set +o allexport
echo 't -o allexport'
t -o allexport
echo 't ! -o allexport'
t ! -o allexport

#test set or unset shell variables
unset unset
echo 't -v unset'
t -v unset
set=
echo 't -v set'
t -v set
set=set
echo 't -v set'
t -v set

echo 't -R UID'
t -R UID

echo 't xx -a yy'
t xx -a yy
echo 't xx -o ""'
t xx -o ""
echo 't xx -a ""'
t xx -a ""

echo 't -X -a -X'
t -X -a -X
echo 't -X -o -X'
t -X -o -X
echo 't -X -o ""'
t -X -o ""
echo 't -X -a ""'
t -X -a ""
echo 't "" -a -X'
t "" -a -X
echo 't "" -o -X'
t "" -o -X
echo 't "" -a ""'
t "" -a ""
echo 't "" -o ""'
t "" -o ""
echo 't true -o -X'
t true -o -X
echo 't true -a -X'
t true -a -X

echo 't ( -E )'
t \( -E \)
echo 't ( "" )'
t \( "" \)
echo 't ( -n xx )'
t \( -n xx \)

z=42

echo 't ! -z "$z"'
t ! -z "$z"

echo 't ! -n "$z"'
t ! -n "$z"

echo 't ! ! "$z"'
t ! ! "$z"

zero=
echo 't "$zero"'
t "$zero"
echo 't ! "$zero"'
t ! "$zero"
echo 'b "$zero"'
b "$zero"
echo 'b ! "$zero"'
b ! "$zero"

touch /tmp/test.group
chgrp ${GROUPS[0]} /tmp/test.group
echo 't -G /tmp/test.group'
t -G /tmp/test.group
rm /tmp/test.group

case "${THIS_SH}" in
/*)	SHNAME=${THIS_SH} ;;
*)	SHNAME=${PWD}/${THIS_SH} ;;
esac

if ln -s ${SHNAME} /tmp/test.symlink 2>/dev/null; then
	chgrp ${GROUPS[0]} /tmp/test.symlink 2>/dev/null
	echo 't -h /tmp/test.symlink'
	t -h /tmp/test.symlink
	# some systems don't let you remove this
	rm -f /tmp/test.symlink 2>/dev/null
else
	echo 't -h /tmp/test.symlink'
	echo 0
fi

# arithmetic constant errors
echo "t 4+3 -eq 7"
t 4+3 -eq 7
echo "b 4-5 -eq 7"
b 4-5 -eq 7

echo "t 9 -eq 4+5"
t 9 -eq 4+5
echo "b 9 -eq 4+5"
b 9 -eq 4+5

A=7
echo "t A -eq 7"
t A -eq 7
echo "b A -eq 7"
b A -eq 7

B=9
echo "t 9 -eq B"
t 9 -eq B
echo "b 9 -eq B"
b 9 -eq B

# badly formed expressions
echo 't ( 1 = 2'
t \( 1 = 2
echo 'b ( 1 = 2'
b \( 1 = 2

# more errors
t a b
t a b c
t -A v
# too many arguments -- argument expected is also reasonable
t 4 -eq 4 -a 2 -ne 5 -a 4 -ne
# too many arguments
t 4 -eq 4 -a 3 4
# syntax error
t -n xx -a -z "" -a -t 0 -t
# argument expected
t -n xx -a -z "" -a -t 0 -a

[
echo $?
[ -n xx
echo $?

t \( \)

# non-numeric arguments to `test -t' should return failure -- fix in 2.05
echo 't -t a'
t -t a
echo 't -t addsds'
t -t addsds
echo 't -t 42'
t -t 42
echo 't -t /dev/tty'
t -t /dev/tty
echo 't -t /dev/tty4'
t -t /dev/tty4
echo 't -t /dev/tty4444444...'
t -t /dev/tty4444444...

# fixed in bash-4.0-beta
t -t ' '

# ambiguous parenthesized test expressions with more than 4 arguments

t true -a \( ! -a \)
t true -a \( -n foo \)
t true -a \( foo \)

t 1 = 1 -a \( \)
t \( \)

t 1 = 1 -a \( \) -a -n ""

${THIS_SH} ./test1.sub

--------------------------------------------------------------------------------
---
(if (arith (word " $UID == 0 ")) (command (word "echo") (word "\"test-tests: the test suite should not be run as root\"") (redirect ">&" 2)))
(function "b" (brace-group (semi (command (word "[") (word "\"$@\"") (word "]")) (command (word "echo") (word "$?")))))
(function "t" (brace-group (semi (command (word "test") (word "\"$@\"")) (command (word "echo") (word "$?")))))
(command (word "echo") (word "'t'"))
(command (word "t"))
(command (word "echo") (word "'t -a noexist'"))
(command (word "t") (word "-a") (word "noexist"))
(command (word "echo") (word "'t -a run-all'"))
(command (word "t") (word "-a") (word "run-all"))
(command (word "echo") (word "'t -b run-all'"))
(command (word "t") (word "-b") (word "run-all"))
(command (word "echo") (word "'t -b /dev/jb1a'"))
(command (word "t") (word "-b") (word "/dev/jb1a"))
(command (word "echo") (word "'t -c run-all'"))
(command (word "t") (word "-c") (word "run-all"))
(command (word "echo") (word "'t -c /dev/tty'"))
(command (word "t") (word "-c") (word "/dev/tty"))
(command (word "echo") (word "'t -d run-all'"))
(command (word "t") (word "-d") (word "run-all"))
(command (word "echo") (word "'t -d /etc'"))
(command (word "t") (word "-d") (word "/etc"))
(command (word "echo") (word "'t -d \"\"'"))
(command (word "t") (word "-d") (word "\"\""))
(command (word "echo") (word "'b -d \"\"'"))
(command (word "b") (word "-d") (word "\"\""))
(command (word "echo") (word "'t -e noexist'"))
(command (word "t") (word "-e") (word "noexist"))
(command (word "echo") (word "'t -e run-all'"))
(command (word "t") (word "-e") (word "run-all"))
(command (word "echo") (word "'t -f noexist'"))
(command (word "t") (word "-f") (word "noexist"))
(command (word "echo") (word "'t -f /dev/tty'"))
(command (word "t") (word "-f") (word "/dev/tty"))
(command (word "echo") (word "'t -f run-all'"))
(command (word "t") (word "-f") (word "run-all"))
(command (word "echo") (word "'t -g run-all'"))
(command (word "t") (word "-g") (word "run-all"))
(command (word "touch") (word "/tmp/test.setgid"))
(command (word "chgrp") (word "${GROUPS[0]}") (word "/tmp/test.setgid"))
(command (word "chmod") (word "ug+x") (word "/tmp/test.setgid"))
(command (word "chmod") (word "g+s") (word "/tmp/test.setgid"))
(command (word "echo") (word "'t -g /tmp/test.setgid'"))
(command (word "t") (word "-g") (word "/tmp/test.setgid"))
(command (word "rm") (word "-f") (word "/tmp/test.setgid"))
(command (word "echo") (word "'t -k run-all'"))
(command (word "t") (word "-k") (word "run-all"))
(command (word "echo") (word "'t -n \"\"'"))
(command (word "t") (word "-n") (word "\"\""))
(command (word "echo") (word "'t -n \"hello\"'"))
(command (word "t") (word "-n") (word "\"hello\""))
(command (word "echo") (word "'t -p run-all'"))
(command (word "t") (word "-p") (word "run-all"))
(command (word "echo") (word "'t -r noexist'"))
(command (word "t") (word "-r") (word "noexist"))
(if (arith (word " $UID != 0 ")) (semi (semi (semi (semi (command (word "touch") (word "/tmp/test.noread")) (command (word "chmod") (word "a-r") (word "/tmp/test.noread"))) (command (word "echo") (word "'t -r /tmp/test.noread'"))) (command (word "t") (word "-r") (word "/tmp/test.noread"))) (command (word "rm") (word "-f") (word "/tmp/test.noread"))) (semi (command (word "echo") (word "'t -r /tmp/test.noread'")) (command (word "echo") (word "1"))))
(command (word "echo") (word "'t -r run-all'"))
(command (word "t") (word "-r") (word "run-all"))
(command (word "echo") (word "'t -s noexist'"))
(command (word "t") (word "-s") (word "noexist"))
(command (word "echo") (word "'t -s /dev/null'"))
(command (word "t") (word "-s") (word "/dev/null"))
(command (word "echo") (word "'t -s run-all'"))
(command (word "t") (word "-s") (word "run-all"))
(command (word "echo") (word "'t -t 20'"))
(command (word "t") (word "-t") (word "20"))
(command (word "echo") (word "'t -t 0'"))
(command (word "t") (word "-t") (word "0") (redirect "<" "/dev/tty"))
(command (word "echo") (word "'t -u noexist'"))
(command (word "t") (word "-u") (word "noexist"))
(command (word "echo") (word "'t -u run-all'"))
(command (word "t") (word "-u") (word "run-all"))
(command (word "touch") (word "/tmp/test.setuid"))
(command (word "chmod") (word "u+x") (word "/tmp/test.setuid"))
(command (word "chmod") (word "u+s") (word "/tmp/test.setuid"))
(command (word "echo") (word "'t -u /tmp/test.setuid'"))
(command (word "t") (word "-u") (word "/tmp/test.setuid"))
(command (word "rm") (word "-f") (word "/tmp/test.setuid"))
(command (word "echo") (word "'t -w noexist'"))
(command (word "t") (word "-w") (word "noexist"))
(if (arith (word " $UID != 0 ")) (semi (semi (semi (semi (command (word "touch") (word "/tmp/test.nowrite")) (command (word "chmod") (word "a-w") (word "/tmp/test.nowrite"))) (command (word "echo") (word "'t -w /tmp/test.nowrite'"))) (command (word "t") (word "-w") (word "/tmp/test.nowrite"))) (command (word "rm") (word "-f") (word "/tmp/test.nowrite"))) (semi (command (word "echo") (word "'t -w /tmp/test.nowrite'")) (command (word "echo") (word "1"))))
(command (word "echo") (word "'t -w /dev/null'"))
(command (word "t") (word "-w") (word "/dev/null"))
(command (word "echo") (word "'t -x noexist'"))
(command (word "t") (word "-x") (word "noexist"))
(command (word "touch") (word "/tmp/test.exec"))
(command (word "chmod") (word "u+x") (word "/tmp/test.exec"))
(command (word "echo") (word "'t -x /tmp/test.exec'"))
(command (word "t") (word "-x") (word "/tmp/test.exec"))
(command (word "rm") (word "-f") (word "/tmp/test.exec"))
(command (word "touch") (word "/tmp/test.noexec"))
(command (word "chmod") (word "u-x") (word "/tmp/test.noexec"))
(command (word "echo") (word "'t -x /tmp/test.noexec'"))
(command (word "t") (word "-x") (word "/tmp/test.noexec"))
(command (word "rm") (word "-f") (word "/tmp/test.noexec"))
(command (word "echo") (word "'t -z \"\"'"))
(command (word "t") (word "-z") (word "\"\""))
(command (word "echo") (word "'t -z \"foo\"'"))
(command (word "t") (word "-z") (word "\"foo\""))
(command (word "echo") (word "'t \"foo\"'"))
(command (word "t") (word "\"foo\""))
(command (word "echo") (word "'t \"\"'"))
(command (word "t") (word "\"\""))
(command (word "touch") (word "/tmp/test.owner"))
(command (word "echo") (word "'t -O /tmp/test.owner'"))
(command (word "t") (word "-O") (word "/tmp/test.owner"))
(command (word "rm") (word "-f") (word "/tmp/test.owner"))
(command (word "touch") (word "/tmp/test.socket"))
(command (word "echo") (word "'t -S /tmp/test.socket'"))
(command (word "t") (word "-S") (word "/tmp/test.socket"))
(command (word "rm") (word "-f") (word "/tmp/test.socket"))
(semi (semi (command (word "touch") (word "/tmp/test.newer")) (command (word "sleep") (word "1"))) (command (word "echo") (word "\"hello\"") (redirect ">" "/tmp/test.newer")))
(command (word "echo") (word "'t -N /tmp/test.newer'"))
(command (word "t") (word "-N") (word "/tmp/test.newer"))
(command (word "rm") (word "-f") (word "/tmp/test.newer"))
(command (word "echo") (word "'t \"hello\" = \"hello\"'"))
(command (word "t") (word "\"hello\"") (word "=") (word "\"hello\""))
(command (word "echo") (word "'t \"hello\" = \"goodbye\"'"))
(command (word "t") (word "\"hello\"") (word "=") (word "\"goodbye\""))
(command (word "echo") (word "'t \"hello\" == \"hello\"'"))
(command (word "t") (word "\"hello\"") (word "==") (word "\"hello\""))
(command (word "echo") (word "'t \"hello\" == \"goodbye\"'"))
(command (word "t") (word "\"hello\"") (word "==") (word "\"goodbye\""))
(command (word "echo") (word "'t \"hello\" != \"hello\"'"))
(command (word "t") (word "\"hello\"") (word "!=") (word "\"hello\""))
(command (word "echo") (word "'t \"hello\" != \"goodbye\"'"))
(command (word "t") (word "\"hello\"") (word "!=") (word "\"goodbye\""))
(command (word "echo") (word "'t \"hello\" < \"goodbye\"'"))
(command (word "t") (word "\"hello\"") (word "\\<") (word "\"goodbye\""))
(command (word "echo") (word "'t \"hello\" > \"goodbye\"'"))
(command (word "t") (word "\"hello\"") (word "\\>") (word "\"goodbye\""))
(command (word "echo") (word "'t ! \"hello\" > \"goodbye\"'"))
(command (word "t") (word "\"! hello\"") (word "\\>") (word "\"goodbye\""))
(command (word "echo") (word "'t 200 -eq 200'"))
(command (word "t") (word "200") (word "-eq") (word "200"))
(command (word "echo") (word "'t 34 -eq 222'"))
(command (word "t") (word "34") (word "-eq") (word "222"))
(command (word "echo") (word "'t -32 -eq 32'"))
(command (word "t") (word "-32") (word "-eq") (word "32"))
(command (word "echo") (word "'t 200 -ne 200'"))
(command (word "t") (word "200") (word "-ne") (word "200"))
(command (word "echo") (word "'t 34 -ne 222'"))
(command (word "t") (word "34") (word "-ne") (word "222"))
(command (word "echo") (word "'t 200 -gt 200'"))
(command (word "t") (word "200") (word "-gt") (word "200"))
(command (word "echo") (word "'t 340 -gt 222'"))
(command (word "t") (word "340") (word "-gt") (word "222"))
(command (word "echo") (word "'t 200 -ge 200'"))
(command (word "t") (word "200") (word "-ge") (word "200"))
(command (word "echo") (word "'t 34 -ge 222'"))
(command (word "t") (word "34") (word "-ge") (word "222"))
(command (word "echo") (word "'t 200 -lt 200'"))
(command (word "t") (word "200") (word "-lt") (word "200"))
(command (word "echo") (word "'t 34 -lt 222'"))
(command (word "t") (word "34") (word "-lt") (word "222"))
(command (word "echo") (word "'t 200 -le 200'"))
(command (word "t") (word "200") (word "-le") (word "200"))
(command (word "echo") (word "'t 340 -le 222'"))
(command (word "t") (word "340") (word "-le") (word "222"))
(command (word "echo") (word "'t 700 -le 1000 -a -n \"1\" -a \"20\" = \"20\"'"))
(command (word "t") (word "700") (word "-le") (word "1000") (word "-a") (word "-n") (word "\"1\"") (word "-a") (word "\"20\"") (word "=") (word "\"20\""))
(command (word "echo") (word "'t ! \\( 700 -le 1000 -a -n \"1\" -a \"20\" = \"20\" \\)'"))
(command (word "t") (word "!") (word "\\(") (word "700") (word "-le") (word "1000") (word "-a") (word "-n") (word "\"1\"") (word "-a") (word "\"20\"") (word "=") (word "\"20\"") (word "\\)"))
(command (word "echo") (word "'t -n xx -a -z \"\" -a -t 0 -a -t'"))
(command (word "t") (word "-n") (word "xx") (word "-a") (word "-z") (word "\"\"") (word "-a") (word "-t") (word "0") (word "-a") (word "-t"))
(command (word "touch") (word "/tmp/abc"))
(command (word "sleep") (word "2"))
(command (word "touch") (word "/tmp/def"))
(command (word "echo") (word "'t /tmp/abc -nt /tmp/def'"))
(command (word "t") (word "/tmp/abc") (word "-nt") (word "/tmp/def"))
(command (word "echo") (word "'t /tmp/abc -ot /tmp/def'"))
(command (word "t") (word "/tmp/abc") (word "-ot") (word "/tmp/def"))
(command (word "echo") (word "'t /tmp/def -nt /tmp/abc'"))
(command (word "t") (word "/tmp/def") (word "-nt") (word "/tmp/abc"))
(command (word "echo") (word "'t /tmp/def -ot /tmp/abc'"))
(command (word "t") (word "/tmp/def") (word "-ot") (word "/tmp/abc"))
(command (word "echo") (word "'t /tmp/abc -ef /tmp/def'"))
(command (word "t") (word "/tmp/abc") (word "-ef") (word "/tmp/def"))
(command (word "ln") (word "/tmp/abc") (word "/tmp/ghi"))
(command (word "echo") (word "'t /tmp/abc -ef /tmp/ghi'"))
(command (word "t") (word "/tmp/abc") (word "-ef") (word "/tmp/ghi"))
(command (word "rm") (word "/tmp/abc") (word "/tmp/def") (word "/tmp/ghi"))
(command (word "touch") (word "/tmp/abc"))
(command (word "echo") (word "'t noexist -ot /tmp/abc'"))
(command (word "t") (word "noexist") (word "-ot") (word "/tmp/abc"))
(command (word "echo") (word "'t /tmp/abc -ot noexist'"))
(command (word "t") (word "/tmp/abc") (word "-ot") (word "noexist"))
(command (word "echo") (word "'t noexist -nt /tmp/abc'"))
(command (word "t") (word "noexist") (word "-nt") (word "/tmp/abc"))
(command (word "echo") (word "'t noexist -ef /tmp/abc'"))
(command (word "t") (word "noexist") (word "-ef") (word "/tmp/abc"))
(command (word "echo") (word "'t -N noexist'"))
(command (word "t") (word "-N") (word "noexist"))
(command (word "echo") (word "'t -N /tmp/abc'"))
(command (word "t") (word "-N") (word "/tmp/abc"))
(command (word "rm") (word "-f") (word "/tmp/abc"))
(command (word "echo") (word "'t -r /dev/fd/0'"))
(command (word "t") (word "-r") (word "/dev/fd/0"))
(command (word "echo") (word "'t -w /dev/fd/1'"))
(command (word "t") (word "-w") (word "/dev/fd/1"))
(command (word "echo") (word "'t -w /dev/fd/2'"))
(command (word "t") (word "-w") (word "/dev/fd/2"))
(command (word "echo") (word "'t -r /dev/stdin'"))
(command (word "t") (word "-r") (word "/dev/stdin"))
(command (word "echo") (word "'t -w /dev/stdout'"))
(command (word "t") (word "-w") (word "/dev/stdout"))
(command (word "echo") (word "'t -w /dev/stderr'"))
(command (word "t") (word "-w") (word "/dev/stderr"))
(command (word "echo") (word "'t'"))
(command (word "t"))
(command (word "echo") (word "'b'"))
(command (word "b"))
(command (word "echo") (word "'t 12 -eq 34'"))
(command (word "t") (word "12") (word "-eq") (word "34"))
(command (word "echo") (word "'t ! 12 -eq 34'"))
(command (word "t") (word "!") (word "12") (word "-eq") (word "34"))
(command (word "echo") (word "'t -n abcd -o aaa'"))
(command (word "t") (word "-n") (word "abcd") (word "-o") (word "aaa"))
(command (word "echo") (word "'t -n abcd -o -z aaa'"))
(command (word "t") (word "-n") (word "abcd") (word "-o") (word "-z") (word "aaa"))
(command (word "echo") (word "'t -n abcd -a aaa'"))
(command (word "t") (word "-n") (word "abcd") (word "-a") (word "aaa"))
(command (word "echo") (word "'t -n abcd -a -z aaa'"))
(command (word "t") (word "-n") (word "abcd") (word "-a") (word "-z") (word "aaa"))
(command (word "set") (word "+o") (word "allexport"))
(command (word "echo") (word "'t -o allexport'"))
(command (word "t") (word "-o") (word "allexport"))
(command (word "echo") (word "'t ! -o allexport'"))
(command (word "t") (word "!") (word "-o") (word "allexport"))
(command (word "unset") (word "unset"))
(command (word "echo") (word "'t -v unset'"))
(command (word "t") (word "-v") (word "unset"))
(command (word "set="))
(command (word "echo") (word "'t -v set'"))
(command (word "t") (word "-v") (word "set"))
(command (word "set=set"))
(command (word "echo") (word "'t -v set'"))
(command (word "t") (word "-v") (word "set"))
(command (word "echo") (word "'t -R UID'"))
(command (word "t") (word "-R") (word "UID"))
(command (word "echo") (word "'t xx -a yy'"))
(command (word "t") (word "xx") (word "-a") (word "yy"))
(command (word "echo") (word "'t xx -o \"\"'"))
(command (word "t") (word "xx") (word "-o") (word "\"\""))
(command (word "echo") (word "'t xx -a \"\"'"))
(command (word "t") (word "xx") (word "-a") (word "\"\""))
(command (word "echo") (word "'t -X -a -X'"))
(command (word "t") (word "-X") (word "-a") (word "-X"))
(command (word "echo") (word "'t -X -o -X'"))
(command (word "t") (word "-X") (word "-o") (word "-X"))
(command (word "echo") (word "'t -X -o \"\"'"))
(command (word "t") (word "-X") (word "-o") (word "\"\""))
(command (word "echo") (word "'t -X -a \"\"'"))
(command (word "t") (word "-X") (word "-a") (word "\"\""))
(command (word "echo") (word "'t \"\" -a -X'"))
(command (word "t") (word "\"\"") (word "-a") (word "-X"))
(command (word "echo") (word "'t \"\" -o -X'"))
(command (word "t") (word "\"\"") (word "-o") (word "-X"))
(command (word "echo") (word "'t \"\" -a \"\"'"))
(command (word "t") (word "\"\"") (word "-a") (word "\"\""))
(command (word "echo") (word "'t \"\" -o \"\"'"))
(command (word "t") (word "\"\"") (word "-o") (word "\"\""))
(command (word "echo") (word "'t true -o -X'"))
(command (word "t") (word "true") (word "-o") (word "-X"))
(command (word "echo") (word "'t true -a -X'"))
(command (word "t") (word "true") (word "-a") (word "-X"))
(command (word "echo") (word "'t ( -E )'"))
(command (word "t") (word "\\(") (word "-E") (word "\\)"))
(command (word "echo") (word "'t ( \"\" )'"))
(command (word "t") (word "\\(") (word "\"\"") (word "\\)"))
(command (word "echo") (word "'t ( -n xx )'"))
(command (word "t") (word "\\(") (word "-n") (word "xx") (word "\\)"))
(command (word "z=42"))
(command (word "echo") (word "'t ! -z \"$z\"'"))
(command (word "t") (word "!") (word "-z") (word "\"$z\""))
(command (word "echo") (word "'t ! -n \"$z\"'"))
(command (word "t") (word "!") (word "-n") (word "\"$z\""))
(command (word "echo") (word "'t ! ! \"$z\"'"))
(command (word "t") (word "!") (word "!") (word "\"$z\""))
(command (word "zero="))
(command (word "echo") (word "'t \"$zero\"'"))
(command (word "t") (word "\"$zero\""))
(command (word "echo") (word "'t ! \"$zero\"'"))
(command (word "t") (word "!") (word "\"$zero\""))
(command (word "echo") (word "'b \"$zero\"'"))
(command (word "b") (word "\"$zero\""))
(command (word "echo") (word "'b ! \"$zero\"'"))
(command (word "b") (word "!") (word "\"$zero\""))
(command (word "touch") (word "/tmp/test.group"))
(command (word "chgrp") (word "${GROUPS[0]}") (word "/tmp/test.group"))
(command (word "echo") (word "'t -G /tmp/test.group'"))
(command (word "t") (word "-G") (word "/tmp/test.group"))
(command (word "rm") (word "/tmp/test.group"))
(case (word "\"${THIS_SH}\"") (pattern ((word "/*")) (command (word "SHNAME=${THIS_SH}"))) (pattern ((word "*")) (command (word "SHNAME=${PWD}/${THIS_SH}"))))
(if (command (word "ln") (word "-s") (word "${SHNAME}") (word "/tmp/test.symlink") (redirect ">" "/dev/null")) (semi (semi (semi (command (word "chgrp") (word "${GROUPS[0]}") (word "/tmp/test.symlink") (redirect ">" "/dev/null")) (command (word "echo") (word "'t -h /tmp/test.symlink'"))) (command (word "t") (word "-h") (word "/tmp/test.symlink"))) (command (word "rm") (word "-f") (word "/tmp/test.symlink") (redirect ">" "/dev/null"))) (semi (command (word "echo") (word "'t -h /tmp/test.symlink'")) (command (word "echo") (word "0"))))
(command (word "echo") (word "\"t 4+3 -eq 7\""))
(command (word "t") (word "4+3") (word "-eq") (word "7"))
(command (word "echo") (word "\"b 4-5 -eq 7\""))
(command (word "b") (word "4-5") (word "-eq") (word "7"))
(command (word "echo") (word "\"t 9 -eq 4+5\""))
(command (word "t") (word "9") (word "-eq") (word "4+5"))
(command (word "echo") (word "\"b 9 -eq 4+5\""))
(command (word "b") (word "9") (word "-eq") (word "4+5"))
(command (word "A=7"))
(command (word "echo") (word "\"t A -eq 7\""))
(command (word "t") (word "A") (word "-eq") (word "7"))
(command (word "echo") (word "\"b A -eq 7\""))
(command (word "b") (word "A") (word "-eq") (word "7"))
(command (word "B=9"))
(command (word "echo") (word "\"t 9 -eq B\""))
(command (word "t") (word "9") (word "-eq") (word "B"))
(command (word "echo") (word "\"b 9 -eq B\""))
(command (word "b") (word "9") (word "-eq") (word "B"))
(command (word "echo") (word "'t ( 1 = 2'"))
(command (word "t") (word "\\(") (word "1") (word "=") (word "2"))
(command (word "echo") (word "'b ( 1 = 2'"))
(command (word "b") (word "\\(") (word "1") (word "=") (word "2"))
(command (word "t") (word "a") (word "b"))
(command (word "t") (word "a") (word "b") (word "c"))
(command (word "t") (word "-A") (word "v"))
(command (word "t") (word "4") (word "-eq") (word "4") (word "-a") (word "2") (word "-ne") (word "5") (word "-a") (word "4") (word "-ne"))
(command (word "t") (word "4") (word "-eq") (word "4") (word "-a") (word "3") (word "4"))
(command (word "t") (word "-n") (word "xx") (word "-a") (word "-z") (word "\"\"") (word "-a") (word "-t") (word "0") (word "-t"))
(command (word "t") (word "-n") (word "xx") (word "-a") (word "-z") (word "\"\"") (word "-a") (word "-t") (word "0") (word "-a"))
(command (word "["))
(command (word "echo") (word "$?"))
(command (word "[") (word "-n") (word "xx"))
(command (word "echo") (word "$?"))
(command (word "t") (word "\\(") (word "\\)"))
(command (word "echo") (word "'t -t a'"))
(command (word "t") (word "-t") (word "a"))
(command (word "echo") (word "'t -t addsds'"))
(command (word "t") (word "-t") (word "addsds"))
(command (word "echo") (word "'t -t 42'"))
(command (word "t") (word "-t") (word "42"))
(command (word "echo") (word "'t -t /dev/tty'"))
(command (word "t") (word "-t") (word "/dev/tty"))
(command (word "echo") (word "'t -t /dev/tty4'"))
(command (word "t") (word "-t") (word "/dev/tty4"))
(command (word "echo") (word "'t -t /dev/tty4444444...'"))
(command (word "t") (word "-t") (word "/dev/tty4444444..."))
(command (word "t") (word "-t") (word "' '"))
(command (word "t") (word "true") (word "-a") (word "\\(") (word "!") (word "-a") (word "\\)"))
(command (word "t") (word "true") (word "-a") (word "\\(") (word "-n") (word "foo") (word "\\)"))
(command (word "t") (word "true") (word "-a") (word "\\(") (word "foo") (word "\\)"))
(command (word "t") (word "1") (word "=") (word "1") (word "-a") (word "\\(") (word "\\)"))
(command (word "t") (word "\\(") (word "\\)"))
(command (word "t") (word "1") (word "=") (word "1") (word "-a") (word "\\(") (word "\\)") (word "-a") (word "-n") (word "\"\""))
(command (word "${THIS_SH}") (word "./test1.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== tilde
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
wdir=$PWD
# this is needed because posix mode restricts tilde expansion to assignment
# statements preceding a command, instead of the default of expanding all
# assignment statements on the line (e.g., after `export').  Without this,
# the next-to-last test fails
set +o posix

HOME=/usr/xyz
SHELL=~/bash
echo ~ch\et
echo ~ch\et/foo
echo ~/"foo"
echo "~chet"/"foo"
echo \~chet/"foo"
echo \~chet/bar
echo ~\chet/bar
echo ~chet""/bar
echo ":~chet/"
echo abcd~chet
echo "SHELL=~/bash"
echo $SHELL
echo abcd:~chet
path=/usr/ucb:/bin:~/bin:~/tmp/bin:/usr/bin
echo $path

cd /usr
cd /tmp
echo ~-
echo ~+

XPATH=/bin:/usr/bin:.

# yes tilde expansion
PPATH=$XPATH:~/bin
echo "$PPATH"

# no tilde expansion
PPATH="$XPATH:~/bin"
echo "$PPATH"

# yes tilde expansion
export PPATH=$XPATH:~/bin
echo "$PPATH"
declare -x PPATH=$XPATH:~/bin
echo "$PPATH"

# no tilde expansion
export PPATH="$XPATH:~/bin"
echo "$PPATH"
declare -x PPATH="$XPATH:~/bin"
echo "$PPATH"

printf "%q\n" '~'

# more tests of tilde expansion when executing case commands
case ~ in
$HOME)	echo ok 1;;
*) echo bad 1 ;;
esac

case ~ in
~)	echo ok 2 ;;
\~)	echo bad 2a ;;
*)	echo bad 2b ;;
esac

case $unset in
"")	echo ok 3 ;;
*)	echo bad 3 ;;
esac

USER=root		# should exist just about everywhere
echo ~$USER

cd "$wdir"

# this test is incomplete; should also test assignment statements (tilde3.sub)
echo foo=bar:~
set -o posix
echo foo=bar:~

exit 0

--------------------------------------------------------------------------------
---
(command (word "wdir=$PWD"))
(command (word "set") (word "+o") (word "posix"))
(command (word "HOME=/usr/xyz"))
(command (word "SHELL=~/bash"))
(command (word "echo") (word "~ch\\et"))
(command (word "echo") (word "~ch\\et/foo"))
(command (word "echo") (word "~/\"foo\""))
(command (word "echo") (word "\"~chet\"/\"foo\""))
(command (word "echo") (word "\\~chet/\"foo\""))
(command (word "echo") (word "\\~chet/bar"))
(command (word "echo") (word "~\\chet/bar"))
(command (word "echo") (word "~chet\"\"/bar"))
(command (word "echo") (word "\":~chet/\""))
(command (word "echo") (word "abcd~chet"))
(command (word "echo") (word "\"SHELL=~/bash\""))
(command (word "echo") (word "$SHELL"))
(command (word "echo") (word "abcd:~chet"))
(command (word "path=/usr/ucb:/bin:~/bin:~/tmp/bin:/usr/bin"))
(command (word "echo") (word "$path"))
(command (word "cd") (word "/usr"))
(command (word "cd") (word "/tmp"))
(command (word "echo") (word "~-"))
(command (word "echo") (word "~+"))
(command (word "XPATH=/bin:/usr/bin:."))
(command (word "PPATH=$XPATH:~/bin"))
(command (word "echo") (word "\"$PPATH\""))
(command (word "PPATH=\"$XPATH:~/bin\""))
(command (word "echo") (word "\"$PPATH\""))
(command (word "export") (word "PPATH=$XPATH:~/bin"))
(command (word "echo") (word "\"$PPATH\""))
(command (word "declare") (word "-x") (word "PPATH=$XPATH:~/bin"))
(command (word "echo") (word "\"$PPATH\""))
(command (word "export") (word "PPATH=\"$XPATH:~/bin\""))
(command (word "echo") (word "\"$PPATH\""))
(command (word "declare") (word "-x") (word "PPATH=\"$XPATH:~/bin\""))
(command (word "echo") (word "\"$PPATH\""))
(command (word "printf") (word "\"%q\\n\"") (word "'~'"))
(case (word "~") (pattern ((word "$HOME")) (command (word "echo") (word "ok") (word "1"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "1"))))
(case (word "~") (pattern ((word "~")) (command (word "echo") (word "ok") (word "2"))) (pattern ((word "\\~")) (command (word "echo") (word "bad") (word "2a"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "2b"))))
(case (word "$unset") (pattern ((word "\"\"")) (command (word "echo") (word "ok") (word "3"))) (pattern ((word "*")) (command (word "echo") (word "bad") (word "3"))))
(command (word "USER=root"))
(command (word "echo") (word "~$USER"))
(command (word "cd") (word "\"$wdir\""))
(command (word "echo") (word "foo=bar:~"))
(command (word "set") (word "-o") (word "posix"))
(command (word "echo") (word "foo=bar:~"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---

=== tilde2
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
HOME=/usr/xyz
XPATH=/bin:/usr/bin:.

ADDPATH=PATH=~/bin:$XPATH

echo $ADDPATH

unset ADDPATH
: ${ADDPATH:=~/bin:~/bin2:$XPATH}
echo $ADDPATH

unset ADDPATH
: ${ADDPATH:=PATH=~/bin:~/bin2:$XPATH}
echo $ADDPATH

cat << !
~/bin
!

echo "~"

echo ${TPATH:-~}
echo "${TPATH:-~}"
echo "${TPATH:-"~"}"

echo "${XPATH+~}"

recho "\a"
recho "${TPATH:-\a}"

SHELL=~/bash
echo $SHELL

case $SHELL in
~/bash)	echo ok;;
*)	echo bad;;
esac

somevar=
echo "${somevar:-~}"
echo "${somevar:-"~"}"

echo make -k FOO=~/mumble

typeset FOO=~/mumble
echo "$FOO"

h=HOME=~
echo $h

export h=HOME=~
echo $h

x=1234
HOME='/usr/$x/abc'

echo ~

# behavior differs here in posix mode
set -o posix

eval echo $h
eval $h
echo $HOME

set +o posix

eval echo $h
eval $h
echo $HOME

$THIS_SH ./tilde3.sub

--------------------------------------------------------------------------------
---
(command (word "HOME=/usr/xyz"))
(command (word "XPATH=/bin:/usr/bin:."))
(command (word "ADDPATH=PATH=~/bin:$XPATH"))
(command (word "echo") (word "$ADDPATH"))
(command (word "unset") (word "ADDPATH"))
(command (word ":") (word "${ADDPATH:=~/bin:~/bin2:$XPATH}"))
(command (word "echo") (word "$ADDPATH"))
(command (word "unset") (word "ADDPATH"))
(command (word ":") (word "${ADDPATH:=PATH=~/bin:~/bin2:$XPATH}"))
(command (word "echo") (word "$ADDPATH"))
(command (word "cat") (redirect "<<" "~/bin
"))
(command (word "echo") (word "\"~\""))
(command (word "echo") (word "${TPATH:-~}"))
(command (word "echo") (word "\"${TPATH:-~}\""))
(command (word "echo") (word "\"${TPATH:-\"~\"}\""))
(command (word "echo") (word "\"${XPATH+~}\""))
(command (word "recho") (word "\"\\a\""))
(command (word "recho") (word "\"${TPATH:-\\a}\""))
(command (word "SHELL=~/bash"))
(command (word "echo") (word "$SHELL"))
(case (word "$SHELL") (pattern ((word "~/bash")) (command (word "echo") (word "ok"))) (pattern ((word "*")) (command (word "echo") (word "bad"))))
(command (word "somevar="))
(command (word "echo") (word "\"${somevar:-~}\""))
(command (word "echo") (word "\"${somevar:-\"~\"}\""))
(command (word "echo") (word "make") (word "-k") (word "FOO=~/mumble"))
(command (word "typeset") (word "FOO=~/mumble"))
(command (word "echo") (word "\"$FOO\""))
(command (word "h=HOME=~"))
(command (word "echo") (word "$h"))
(command (word "export") (word "h=HOME=~"))
(command (word "echo") (word "$h"))
(command (word "x=1234"))
(command (word "HOME='/usr/$x/abc'"))
(command (word "echo") (word "~"))
(command (word "set") (word "-o") (word "posix"))
(command (word "eval") (word "echo") (word "$h"))
(command (word "eval") (word "$h"))
(command (word "echo") (word "$HOME"))
(command (word "set") (word "+o") (word "posix"))
(command (word "eval") (word "echo") (word "$h"))
(command (word "eval") (word "$h"))
(command (word "echo") (word "$HOME"))
(command (word "$THIS_SH") (word "./tilde3.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== trap
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# test the trap code

trap 'echo exiting' 0
trap 'echo aborting' HUP INT QUIT ABRT TERM

# make sure a user-specified subshell runs the exit trap, but does not
# inherit the exit trap from a parent shell
( trap 'echo subshell exit' 0; exit 0 )
( exit 0 )

trap

func()
{
	trap 'echo ${FUNCNAME:-$0}[$LINENO] funcdebug' DEBUG
	echo funcdebug line
}

trap 'echo [$LINENO] debug' DEBUG
echo debug line

trap

func

trap

trap 'echo ${FUNCNAME:-$0}[$LINENO] debug' DEBUG
func2()
{
	echo func2debug line
}
declare -ft func2
func2

unset -f func2

trap '' DEBUG

trap

trap - debug

trap

trap - HUP
trap hup
trap '' INT
trap '' int

trap

# exit 0 in exit trap should set exit status
(
set -e
trap 'exit 0' EXIT
false   
echo bad
)
echo $?

# hmmm...should this set the handling to SIG_IGN for children, too?
trap '' USR2
./trap1.sub
trap - USR2

# test ERR trap
./trap2.sub

${THIS_SH} ./trap3.sub

${THIS_SH} ./trap4.sub

# This doesn't work right on all Unix versions
#${THIS_SH} ./trap5.sub

# Return trap issues
${THIS_SH} ./trap6.sub

# eval and ERR trap
${THIS_SH} ./trap7.sub

# SIGCHLD traps
${THIS_SH} ./trap8.sub

# return without argument in trap string 
${THIS_SH} ./trap9.sub

#
# show that setting a trap on SIGCHLD is not disastrous.
#
set -o monitor

trap 'echo caught a child death' SIGCHLD

sleep 7 & sleep 6 & sleep 5 &

# this will only catch the first, since there's a trap on SIGCHLD
wait

trap -p SIGCHLD
trap -P SIGCHLD

# all errors
trap -p -P 
trap -P
trap ''
trap -x

# Now reset some of the signals the shell handles specially back to
# their default values (with or without the SIG prefix)
trap - SIGINT QUIT TERM

trap

trap - SIGCHLD
wait

trap 512	# error
trap 0		# revert
trap -p EXIT

trap 'echo exiting' 0
trap -P EXIT

exit

--------------------------------------------------------------------------------
---
(command (word "trap") (word "'echo exiting'") (word "0"))
(command (word "trap") (word "'echo aborting'") (word "HUP") (word "INT") (word "QUIT") (word "ABRT") (word "TERM"))
(subshell (semi (command (word "trap") (word "'echo subshell exit'") (word "0")) (command (word "exit") (word "0"))))
(subshell (command (word "exit") (word "0")))
(command (word "trap"))
(function "func" (brace-group (semi (command (word "trap") (word "'echo ${FUNCNAME:-$0}[$LINENO] funcdebug'") (word "DEBUG")) (command (word "echo") (word "funcdebug") (word "line")))))
(command (word "trap") (word "'echo [$LINENO] debug'") (word "DEBUG"))
(command (word "echo") (word "debug") (word "line"))
(command (word "trap"))
(command (word "func"))
(command (word "trap"))
(command (word "trap") (word "'echo ${FUNCNAME:-$0}[$LINENO] debug'") (word "DEBUG"))
(function "func2" (brace-group (command (word "echo") (word "func2debug") (word "line"))))
(command (word "declare") (word "-ft") (word "func2"))
(command (word "func2"))
(command (word "unset") (word "-f") (word "func2"))
(command (word "trap") (word "''") (word "DEBUG"))
(command (word "trap"))
(command (word "trap") (word "-") (word "debug"))
(command (word "trap"))
(command (word "trap") (word "-") (word "HUP"))
(command (word "trap") (word "hup"))
(command (word "trap") (word "''") (word "INT"))
(command (word "trap") (word "''") (word "int"))
(command (word "trap"))
(subshell (semi (semi (semi (command (word "set") (word "-e")) (command (word "trap") (word "'exit 0'") (word "EXIT"))) (command (word "false"))) (command (word "echo") (word "bad"))))
(command (word "echo") (word "$?"))
(command (word "trap") (word "''") (word "USR2"))
(command (word "./trap1.sub"))
(command (word "trap") (word "-") (word "USR2"))
(command (word "./trap2.sub"))
(command (word "${THIS_SH}") (word "./trap3.sub"))
(command (word "${THIS_SH}") (word "./trap4.sub"))
(command (word "${THIS_SH}") (word "./trap6.sub"))
(command (word "${THIS_SH}") (word "./trap7.sub"))
(command (word "${THIS_SH}") (word "./trap8.sub"))
(command (word "${THIS_SH}") (word "./trap9.sub"))
(command (word "set") (word "-o") (word "monitor"))
(command (word "trap") (word "'echo caught a child death'") (word "SIGCHLD"))
(background (background (background (command (word "sleep") (word "7")) (command (word "sleep") (word "6"))) (command (word "sleep") (word "5"))))
(command (word "wait"))
(command (word "trap") (word "-p") (word "SIGCHLD"))
(command (word "trap") (word "-P") (word "SIGCHLD"))
(command (word "trap") (word "-p") (word "-P"))
(command (word "trap") (word "-P"))
(command (word "trap") (word "''"))
(command (word "trap") (word "-x"))
(command (word "trap") (word "-") (word "SIGINT") (word "QUIT") (word "TERM"))
(command (word "trap"))
(command (word "trap") (word "-") (word "SIGCHLD"))
(command (word "wait"))
(command (word "trap") (word "512"))
(command (word "trap") (word "0"))
(command (word "trap") (word "-p") (word "EXIT"))
(command (word "trap") (word "'echo exiting'") (word "0"))
(command (word "trap") (word "-P") (word "EXIT"))
(command (word "exit"))
(command (word "--------------------------------------------------------------------------------"))
---

=== type
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
set +o posix

hash -r
unalias -a

# this should echo nothing
type
# this should be a usage error
type -r ${THIS_SH}

# these should behave identically, but POSIX says command -v is silent if the name is not found
type notthere
command -v notthere

# but this will produce an error message
command -V notthere

unset -f func 2>/dev/null
func() { echo this is func; }

type -t func
type -t while
type -t builtin
type -t /bin/sh
type -t ${THIS_SH}
type -t mv

type func
# the following two should produce identical output
type while
type -a while
type builtin
type /bin/sh

command -v func
command -V func
command -v while
command -V while

alias morealias=more

# the following two lines should produce the same output
# post-3.0 patch makes command -v silent, as posix specifies
# first test with alias expansion off (should all fail or produce no output)
type -t morealias
type morealias
command -v morealias
alias -p
alias morealias

# then test with alias expansion on 
shopt -s expand_aliases
type morealias
type -t morealias
command -v morealias
alias -p
alias morealias

command -V morealias
shopt -u expand_aliases

command -v builtin
command -V builtin
command -v /bin/sh
command -V /bin/sh

unset -f func
type func
unalias morealias
type m

hash -r

hash -p /bin/sh sh
type -p sh

SHBASE=${THIS_SH##*/}
hash -p /tmp/$SHBASE $SHBASE
type -p $SHBASE
type $SHBASE

type -t $SHBASE

# make sure the hash table looks right
hash

# bug in versions of bash up to and including bash-3.2
f() {
        v=$'\001'
    }

type f | cat -v

${THIS_SH} type1.sub
${THIS_SH} type2.sub
${THIS_SH} type3.sub
${THIS_SH} type4.sub
${THIS_SH} type5.sub

--------------------------------------------------------------------------------
---
(command (word "set") (word "+o") (word "posix"))
(command (word "hash") (word "-r"))
(command (word "unalias") (word "-a"))
(command (word "type"))
(command (word "type") (word "-r") (word "${THIS_SH}"))
(command (word "type") (word "notthere"))
(command (word "command") (word "-v") (word "notthere"))
(command (word "command") (word "-V") (word "notthere"))
(command (word "unset") (word "-f") (word "func") (redirect ">" "/dev/null"))
(function "func" (brace-group (command (word "echo") (word "this") (word "is") (word "func"))))
(command (word "type") (word "-t") (word "func"))
(command (word "type") (word "-t") (word "while"))
(command (word "type") (word "-t") (word "builtin"))
(command (word "type") (word "-t") (word "/bin/sh"))
(command (word "type") (word "-t") (word "${THIS_SH}"))
(command (word "type") (word "-t") (word "mv"))
(command (word "type") (word "func"))
(command (word "type") (word "while"))
(command (word "type") (word "-a") (word "while"))
(command (word "type") (word "builtin"))
(command (word "type") (word "/bin/sh"))
(command (word "command") (word "-v") (word "func"))
(command (word "command") (word "-V") (word "func"))
(command (word "command") (word "-v") (word "while"))
(command (word "command") (word "-V") (word "while"))
(command (word "alias") (word "morealias=more"))
(command (word "type") (word "-t") (word "morealias"))
(command (word "type") (word "morealias"))
(command (word "command") (word "-v") (word "morealias"))
(command (word "alias") (word "-p"))
(command (word "alias") (word "morealias"))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "type") (word "morealias"))
(command (word "type") (word "-t") (word "morealias"))
(command (word "command") (word "-v") (word "morealias"))
(command (word "alias") (word "-p"))
(command (word "alias") (word "morealias"))
(command (word "command") (word "-V") (word "morealias"))
(command (word "shopt") (word "-u") (word "expand_aliases"))
(command (word "command") (word "-v") (word "builtin"))
(command (word "command") (word "-V") (word "builtin"))
(command (word "command") (word "-v") (word "/bin/sh"))
(command (word "command") (word "-V") (word "/bin/sh"))
(command (word "unset") (word "-f") (word "func"))
(command (word "type") (word "func"))
(command (word "unalias") (word "morealias"))
(command (word "type") (word "m"))
(command (word "hash") (word "-r"))
(command (word "hash") (word "-p") (word "/bin/sh") (word "sh"))
(command (word "type") (word "-p") (word "sh"))
(command (word "SHBASE=${THIS_SH##*/}"))
(command (word "hash") (word "-p") (word "/tmp/$SHBASE") (word "$SHBASE"))
(command (word "type") (word "-p") (word "$SHBASE"))
(command (word "type") (word "$SHBASE"))
(command (word "type") (word "-t") (word "$SHBASE"))
(command (word "hash"))
(function "f" (brace-group (command (word "v=''"))))
(pipe (command (word "type") (word "f")) (command (word "cat") (word "-v")))
(command (word "${THIS_SH}") (word "type1.sub"))
(command (word "${THIS_SH}") (word "type2.sub"))
(command (word "${THIS_SH}") (word "type3.sub"))
(command (word "${THIS_SH}") (word "type4.sub"))
(command (word "${THIS_SH}") (word "type5.sub"))
(command (word "--------------------------------------------------------------------------------"))
---

=== varenv
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# varenv.sh
#
# Test the behavior of the shell with respect to variable and environment
# assignments
#
expect()
{
	echo expect "$@"
}

a=1
b=2
c=3
d=4
e=5
f=6 g=7 h=8

a=3 b=4 $CHMOD $MODE $FN

# This should echo "3 4" according to Posix.2
expect "3 4"
echo $a $b

set -k

# Assignment statements made when no words are left affect the shell's
# environment
a=5 b=6 $CHMOD c=7 $MODE d=8 $FN e=9

expect "5 6 7 8 9"
echo $a $b $c $d $e

$CHMOD f=7 $MODE g=8 $FN h=9
expect "7 8 9"
echo $f $g $h

set +k

# The temporary environment does not affect variable expansion, only the
# environment given to the command

export HOME=/usr/chet
expect $HOME
echo $HOME

expect $HOME
HOME=/a/b/c /bin/echo $HOME

expect $HOME
echo $HOME

# This should echo /a/b/c
expect /a/b/c
HOME=/a/b/c printenv HOME

set -k

# This should echo $HOME 9, NOT /a/b/c 9

expect "$HOME"
HOME=/a/b/c /bin/echo $HOME c=9
expect "$HOME 7"
echo $HOME $c

# I claim the next two echo calls should give identical output.
# ksh agrees, the System V.3 sh does not

expect "/a/b/c 9 /a/b/c"
HOME=/a/b/c $ECHO a=$HOME c=9
echo $HOME $c $a

expect "/a/b/c 9 /a/b/c"
HOME=/a/b/c a=$HOME c=9
echo $HOME $c $a
set +k

# How do assignment statements affect subsequent assignments on the same
# line?
expect "/a/b/c /a/b/c"
HOME=/a/b/c a=$HOME
echo $HOME $a

# The system V.3 sh does this wrong; the last echo should output "1 1",
# but the system V.3 sh has it output "2 2".  Posix.2 says the assignment
# statements are processed left-to-right.  bash and ksh output the right
# thing
c=1
d=2
expect "1 2"
echo $c $d
d=$c c=$d
expect "1 1"
echo $c $d

# just for completeness
unset d c
expect unset
echo ${d-unset}

# no output
export a
a=bcde
export a
/bin/true 2>/dev/null

func()
{
	local YYZ

	YYZ="song by rush"
	echo $YYZ
	echo $A
}

YYZ="toronto airport"
A="AVAR"
echo $YYZ
echo $A
A=BVAR func
echo $YYZ
echo $A

export A
# Make sure expansion doesn't use assignment statements preceding a builtin
A=ZVAR echo $A

XPATH=/bin:/usr/bin:/usr/local/bin:.
func2()
{
	local z=yy
	local -a avar=( ${XPATH//: } )
	echo ${avar[@]}
	local
}

avar=42
echo $avar
func2
echo $avar

# try to set an attribute for an unset variable; make sure it persists
# when the variable is assigned a value
declare -i ivar

ivar=10

declare -p ivar
unset ivar

# export an unset variable, make sure it is not suddenly set, but make
# sure the export attribute persists when the variable is assigned a
# value
export ivar
echo ${ivar-unset}

ivar=42
declare -p ivar

# make sure set [-+]o ignoreeof and $IGNOREEOF are reflected
unset IGNOREEOF
set +o ignoreeof
set -o ignoreeof
if [ "$IGNOREEOF" -ne 10 ]; then
	echo "./varenv.sh: set -o ignoreeof is not reflected in IGNOREEOF" >&2
fi
unset IGNOREEOF
set +o ignoreeof

# older versions of bash used to not reset RANDOM in subshells correctly
[[ $RANDOM -eq $(echo $RANDOM) ]] && echo "RANDOM: problem with subshells"

# make sure that shopt -o is reflected in $SHELLOPTS
# first, get rid of things that might be set automatically via shell
# variables
set +o posix
set +o ignoreeof
set +o monitor
echo $-
echo ${SHELLOPTS}
shopt -so physical
echo $-
echo ${SHELLOPTS}

# and make sure it is readonly
readonly -p | grep SHELLOPTS

# This was an error in bash versions prior to bash-2.04.  The `set -a'
# should cause the assignment statement that's an argument to typeset
# to create an exported variable
unset FOOFOO
FOOFOO=bar
set -a
typeset FOOFOO=abcde

printenv FOOFOO

# test out export behavior of variable assignments preceding builtins and
# functions
$THIS_SH ./varenv1.sub

# more tests; bugs in bash up to version 2.05a
$THIS_SH ./varenv2.sub

# more tests; bugs in bash IFS scoping up through version 4.2
$THIS_SH ./varenv3.sub

# scoping problems with declare -g through bash-4.2
${THIS_SH} ./varenv4.sub

# more scoping and declaration problems with -g and arrays through bash-4.2
${THIS_SH} ./varenv5.sub

# variable scoping in the presence of nameref
${THIS_SH} ./varenv6.sub

# variable declaration problems with arrays and readonly local variables
${THIS_SH} ./varenv7.sub

# variable visibility problems with process substitution subshells in
# redirections
${THIS_SH} ./varenv8.sub

# make sure that builtins like readonly and export modify local array variables
# if executed in shell functions, like they modify local scalar variables
${THIS_SH} ./varenv9.sub

# more tests of unset and local variables with dynamic scoping
${THIS_SH} ./varenv10.sub

# tests of compound assignments in function scope
${THIS_SH} ./varenv11.sub

# temporary environment variable propagation and scoping in posix mode
${THIS_SH} ./varenv12.sub

# temporary environment and invalid shell identifier names
${THIS_SH} ./varenv13.sub

# localvar_inherit
${THIS_SH} ./varenv14.sub
${THIS_SH} ./varenv15.sub
${THIS_SH} ./varenv16.sub
${THIS_SH} ./varenv17.sub
${THIS_SH} ./varenv18.sub
${THIS_SH} ./varenv19.sub
${THIS_SH} ./varenv20.sub
${THIS_SH} ./varenv21.sub
${THIS_SH} ./varenv22.sub
${THIS_SH} ./varenv23.sub
${THIS_SH} ./varenv24.sub
${THIS_SH} ./varenv25.sub

# make sure variable scoping is done right
tt() { typeset a=b;echo a=$a; };a=z;echo a=$a;tt;echo a=$a

--------------------------------------------------------------------------------
---
(function "expect" (brace-group (command (word "echo") (word "expect") (word "\"$@\""))))
(command (word "a=1"))
(command (word "b=2"))
(command (word "c=3"))
(command (word "d=4"))
(command (word "e=5"))
(command (word "f=6") (word "g=7") (word "h=8"))
(command (word "a=3") (word "b=4") (word "$CHMOD") (word "$MODE") (word "$FN"))
(command (word "expect") (word "\"3 4\""))
(command (word "echo") (word "$a") (word "$b"))
(command (word "set") (word "-k"))
(command (word "a=5") (word "b=6") (word "$CHMOD") (word "c=7") (word "$MODE") (word "d=8") (word "$FN") (word "e=9"))
(command (word "expect") (word "\"5 6 7 8 9\""))
(command (word "echo") (word "$a") (word "$b") (word "$c") (word "$d") (word "$e"))
(command (word "$CHMOD") (word "f=7") (word "$MODE") (word "g=8") (word "$FN") (word "h=9"))
(command (word "expect") (word "\"7 8 9\""))
(command (word "echo") (word "$f") (word "$g") (word "$h"))
(command (word "set") (word "+k"))
(command (word "export") (word "HOME=/usr/chet"))
(command (word "expect") (word "$HOME"))
(command (word "echo") (word "$HOME"))
(command (word "expect") (word "$HOME"))
(command (word "HOME=/a/b/c") (word "/bin/echo") (word "$HOME"))
(command (word "expect") (word "$HOME"))
(command (word "echo") (word "$HOME"))
(command (word "expect") (word "/a/b/c"))
(command (word "HOME=/a/b/c") (word "printenv") (word "HOME"))
(command (word "set") (word "-k"))
(command (word "expect") (word "\"$HOME\""))
(command (word "HOME=/a/b/c") (word "/bin/echo") (word "$HOME") (word "c=9"))
(command (word "expect") (word "\"$HOME 7\""))
(command (word "echo") (word "$HOME") (word "$c"))
(command (word "expect") (word "\"/a/b/c 9 /a/b/c\""))
(command (word "HOME=/a/b/c") (word "$ECHO") (word "a=$HOME") (word "c=9"))
(command (word "echo") (word "$HOME") (word "$c") (word "$a"))
(command (word "expect") (word "\"/a/b/c 9 /a/b/c\""))
(command (word "HOME=/a/b/c") (word "a=$HOME") (word "c=9"))
(command (word "echo") (word "$HOME") (word "$c") (word "$a"))
(command (word "set") (word "+k"))
(command (word "expect") (word "\"/a/b/c /a/b/c\""))
(command (word "HOME=/a/b/c") (word "a=$HOME"))
(command (word "echo") (word "$HOME") (word "$a"))
(command (word "c=1"))
(command (word "d=2"))
(command (word "expect") (word "\"1 2\""))
(command (word "echo") (word "$c") (word "$d"))
(command (word "d=$c") (word "c=$d"))
(command (word "expect") (word "\"1 1\""))
(command (word "echo") (word "$c") (word "$d"))
(command (word "unset") (word "d") (word "c"))
(command (word "expect") (word "unset"))
(command (word "echo") (word "${d-unset}"))
(command (word "export") (word "a"))
(command (word "a=bcde"))
(command (word "export") (word "a"))
(command (word "/bin/true") (redirect ">" "/dev/null"))
(function "func" (brace-group (semi (semi (semi (command (word "local") (word "YYZ")) (command (word "YYZ=\"song by rush\""))) (command (word "echo") (word "$YYZ"))) (command (word "echo") (word "$A")))))
(command (word "YYZ=\"toronto airport\""))
(command (word "A=\"AVAR\""))
(command (word "echo") (word "$YYZ"))
(command (word "echo") (word "$A"))
(command (word "A=BVAR") (word "func"))
(command (word "echo") (word "$YYZ"))
(command (word "echo") (word "$A"))
(command (word "export") (word "A"))
(command (word "A=ZVAR") (word "echo") (word "$A"))
(command (word "XPATH=/bin:/usr/bin:/usr/local/bin:."))
(function "func2" (brace-group (semi (semi (semi (command (word "local") (word "z=yy")) (command (word "local") (word "-a") (word "avar=(${XPATH//: })"))) (command (word "echo") (word "${avar[@]}"))) (command (word "local")))))
(command (word "avar=42"))
(command (word "echo") (word "$avar"))
(command (word "func2"))
(command (word "echo") (word "$avar"))
(command (word "declare") (word "-i") (word "ivar"))
(command (word "ivar=10"))
(command (word "declare") (word "-p") (word "ivar"))
(command (word "unset") (word "ivar"))
(command (word "export") (word "ivar"))
(command (word "echo") (word "${ivar-unset}"))
(command (word "ivar=42"))
(command (word "declare") (word "-p") (word "ivar"))
(command (word "unset") (word "IGNOREEOF"))
(command (word "set") (word "+o") (word "ignoreeof"))
(command (word "set") (word "-o") (word "ignoreeof"))
(if (command (word "[") (word "\"$IGNOREEOF\"") (word "-ne") (word "10") (word "]")) (command (word "echo") (word "\"./varenv.sh: set -o ignoreeof is not reflected in IGNOREEOF\"") (redirect ">&" 2)))
(command (word "unset") (word "IGNOREEOF"))
(command (word "set") (word "+o") (word "ignoreeof"))
(and (cond (cond-binary "-eq" (cond-term "$RANDOM") (cond-term "$(echo $RANDOM)"))) (command (word "echo") (word "\"RANDOM: problem with subshells\"")))
(command (word "set") (word "+o") (word "posix"))
(command (word "set") (word "+o") (word "ignoreeof"))
(command (word "set") (word "+o") (word "monitor"))
(command (word "echo") (word "$-"))
(command (word "echo") (word "${SHELLOPTS}"))
(command (word "shopt") (word "-so") (word "physical"))
(command (word "echo") (word "$-"))
(command (word "echo") (word "${SHELLOPTS}"))
(pipe (command (word "readonly") (word "-p")) (command (word "grep") (word "SHELLOPTS")))
(command (word "unset") (word "FOOFOO"))
(command (word "FOOFOO=bar"))
(command (word "set") (word "-a"))
(command (word "typeset") (word "FOOFOO=abcde"))
(command (word "printenv") (word "FOOFOO"))
(command (word "$THIS_SH") (word "./varenv1.sub"))
(command (word "$THIS_SH") (word "./varenv2.sub"))
(command (word "$THIS_SH") (word "./varenv3.sub"))
(command (word "${THIS_SH}") (word "./varenv4.sub"))
(command (word "${THIS_SH}") (word "./varenv5.sub"))
(command (word "${THIS_SH}") (word "./varenv6.sub"))
(command (word "${THIS_SH}") (word "./varenv7.sub"))
(command (word "${THIS_SH}") (word "./varenv8.sub"))
(command (word "${THIS_SH}") (word "./varenv9.sub"))
(command (word "${THIS_SH}") (word "./varenv10.sub"))
(command (word "${THIS_SH}") (word "./varenv11.sub"))
(command (word "${THIS_SH}") (word "./varenv12.sub"))
(command (word "${THIS_SH}") (word "./varenv13.sub"))
(command (word "${THIS_SH}") (word "./varenv14.sub"))
(command (word "${THIS_SH}") (word "./varenv15.sub"))
(command (word "${THIS_SH}") (word "./varenv16.sub"))
(command (word "${THIS_SH}") (word "./varenv17.sub"))
(command (word "${THIS_SH}") (word "./varenv18.sub"))
(command (word "${THIS_SH}") (word "./varenv19.sub"))
(command (word "${THIS_SH}") (word "./varenv20.sub"))
(command (word "${THIS_SH}") (word "./varenv21.sub"))
(command (word "${THIS_SH}") (word "./varenv22.sub"))
(command (word "${THIS_SH}") (word "./varenv23.sub"))
(command (word "${THIS_SH}") (word "./varenv24.sub"))
(command (word "${THIS_SH}") (word "./varenv25.sub"))
(semi (semi (semi (semi (function "tt" (brace-group (semi (command (word "typeset") (word "a=b")) (command (word "echo") (word "a=$a"))))) (command (word "a=z"))) (command (word "echo") (word "a=$a"))) (command (word "tt"))) (command (word "echo") (word "a=$a")))
(command (word "--------------------------------------------------------------------------------"))
---

=== vredir
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
: ${TMPDIR:=/var/tmp}
TMPFILE=$TMPDIR/foo

bar()
{
exec {v}>>$TMPFILE
echo $v
}

bar

echo foo 1 >&$v
echo foo 2 >&$v
echo foo 3 >&$v

cat $TMPFILE
rm -f $TMPFILE

type bar
exec {v}>&-

# errors
readonly v=42
bar
exec {v}>&1

echo foo 1 2>&1 >&$v | { grep -q '\$v: Bad' || echo 'bad foo 1'; }
echo foo 2 2>&1 >&$v | { grep -q '\$v: Bad' || echo 'bad foo 2'; }
echo foo 3 2>&1 >&$v | { grep -q '\$v: Bad' || echo 'bad foo 3'; }

cat $TMPFILE
rm -f $TMPFILE

type bar

${THIS_SH} ./vredir1.sub

${THIS_SH} ./vredir2.sub

${THIS_SH} ./vredir3.sub

${THIS_SH} ./vredir4.sub

${THIS_SH} ./vredir5.sub

${THIS_SH} ./vredir6.sub

${THIS_SH} ./vredir7.sub
${THIS_SH} ./vredir8.sub

exit 0

--------------------------------------------------------------------------------
---
(command (word ":") (word "${TMPDIR:=/var/tmp}"))
(command (word "TMPFILE=$TMPDIR/foo"))
(function "bar" (brace-group (semi (command (word "exec") (redirect ">>" "$TMPFILE")) (command (word "echo") (word "$v")))))
(command (word "bar"))
(command (word "echo") (word "foo") (word "1") (redirect ">&" "$v"))
(command (word "echo") (word "foo") (word "2") (redirect ">&" "$v"))
(command (word "echo") (word "foo") (word "3") (redirect ">&" "$v"))
(command (word "cat") (word "$TMPFILE"))
(command (word "rm") (word "-f") (word "$TMPFILE"))
(command (word "type") (word "bar"))
(command (word "exec") (redirect ">&-" 0))
(command (word "readonly") (word "v=42"))
(command (word "bar"))
(command (word "exec") (redirect ">&" 1))
(pipe (command (word "echo") (word "foo") (word "1") (redirect ">&" 1) (redirect ">&" "$v")) (brace-group (or (command (word "grep") (word "-q") (word "'\\$v: Bad'")) (command (word "echo") (word "'bad foo 1'")))))
(pipe (command (word "echo") (word "foo") (word "2") (redirect ">&" 1) (redirect ">&" "$v")) (brace-group (or (command (word "grep") (word "-q") (word "'\\$v: Bad'")) (command (word "echo") (word "'bad foo 2'")))))
(pipe (command (word "echo") (word "foo") (word "3") (redirect ">&" 1) (redirect ">&" "$v")) (brace-group (or (command (word "grep") (word "-q") (word "'\\$v: Bad'")) (command (word "echo") (word "'bad foo 3'")))))
(command (word "cat") (word "$TMPFILE"))
(command (word "rm") (word "-f") (word "$TMPFILE"))
(command (word "type") (word "bar"))
(command (word "${THIS_SH}") (word "./vredir1.sub"))
(command (word "${THIS_SH}") (word "./vredir2.sub"))
(command (word "${THIS_SH}") (word "./vredir3.sub"))
(command (word "${THIS_SH}") (word "./vredir4.sub"))
(command (word "${THIS_SH}") (word "./vredir5.sub"))
(command (word "${THIS_SH}") (word "./vredir6.sub"))
(command (word "${THIS_SH}") (word "./vredir7.sub"))
(command (word "${THIS_SH}") (word "./vredir8.sub"))
(command (word "exit") (word "0"))
(command (word "--------------------------------------------------------------------------------"))
---
