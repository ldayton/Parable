# Converted from Oils corpus: builtin.txt

=== help
help
echo status=$? >&2
help help
echo status=$? >&2
help -- help
echo status=$? >&2
---
(command (word "help"))
(command (word "echo") (word "status=$?") (redirect ">&" 2))
(command (word "help") (word "help"))
(command (word "echo") (word "status=$?") (redirect ">&" 2))
(command (word "help") (word "--") (word "help"))
(command (word "echo") (word "status=$?") (redirect ">&" 2))
---

=== bad help topic
help ZZZ 2>$TMP/err.txt
echo "help=$?"
cat $TMP/err.txt | grep -i 'no help topics' >/dev/null
echo "grep=$?"
---
(command (word "help") (word "ZZZ") (redirect ">" "$TMP/err.txt"))
(command (word "echo") (word "\"help=$?\""))
(pipe (command (word "cat") (word "$TMP/err.txt")) (command (word "grep") (word "-i") (word "'no help topics'") (redirect ">" "/dev/null")))
(command (word "echo") (word "\"grep=$?\""))
---

=== mapfile
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile
  echo "n=${#MAPFILE[@]}"
  printf '[%s]\n' "${MAPFILE[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "mapfile")) (command (word "echo") (word "\"n=${#MAPFILE[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${MAPFILE[@]}\"")))))
---

=== readarray (synonym for mapfile)
type readarray >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  readarray
  echo "n=${#MAPFILE[@]}"
  printf '[%s]\n' "${MAPFILE[@]}"
}
---
(or (command (word "type") (word "readarray") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "readarray")) (command (word "echo") (word "\"n=${#MAPFILE[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${MAPFILE[@]}\"")))))
---

=== mapfile (array name): arr
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "mapfile") (word "arr")) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile (delimiter): -d delim
# Note: Bash-4.4+
type mapfile >/dev/null 2>&1 || exit 0
printf '%s:' {1..5..2} | {
  mapfile -d : arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s:'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "mapfile") (word "-d") (word ":") (word "arr")) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile (delimiter): -d '' (null-separated)
# Note: Bash-4.4+
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\0' {1..5..2} | {
  mapfile -d '' arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\0'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "mapfile") (word "-d") (word "''") (word "arr")) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile (truncate delim): -t
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "{1..5..2}")) (brace-group (semi (semi (command (word "mapfile") (word "-t") (word "arr")) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile -t doesn't remove \r
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\r\n' {1..5..2} | {
  mapfile -t arr
  argv.py "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\r\\n'") (word "{1..5..2}")) (brace-group (semi (command (word "mapfile") (word "-t") (word "arr")) (command (word "argv.py") (word "\"${arr[@]}\"")))))
---

=== mapfile -t bugs (ble.sh)
# empty line
mapfile -t lines <<< $'hello\n\nworld'
echo len=${#lines[@]}
#declare -p lines

# initial newline
mapfile -t lines <<< $'\nhello'
echo len=${#lines[@]}
#declare -p lines

# trailing newline
mapfile -t lines <<< $'hello\n'
echo len=${#lines[@]}
#declare -p lines
---
(command (word "mapfile") (word "-t") (word "lines") (redirect "<<<" "'hello

world'"))
(command (word "echo") (word "len=${#lines[@]}"))
(command (word "mapfile") (word "-t") (word "lines") (redirect "<<<" "'
hello'"))
(command (word "echo") (word "len=${#lines[@]}"))
(command (word "mapfile") (word "-t") (word "lines") (redirect "<<<" "'hello
'"))
(command (word "echo") (word "len=${#lines[@]}"))
---

=== mapfile (store position): -O start
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' a{0..2} | {
  arr=(x y z)
  mapfile -O 2 -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "a{0..2}")) (brace-group (semi (semi (semi (command (word "arr=(x y z)")) (command (word "mapfile") (word "-O") (word "2") (word "-t") (word "arr"))) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile (input range): -s start -n count
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' a{0..10} | {
  mapfile -s 5 -n 3 -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}
---
(or (command (word "type") (word "mapfile") (redirect ">" "/dev/null") (redirect ">&" 1)) (command (word "exit") (word "0")))
(pipe (command (word "printf") (word "'%s\\n'") (word "a{0..10}")) (brace-group (semi (semi (command (word "mapfile") (word "-s") (word "5") (word "-n") (word "3") (word "-t") (word "arr")) (command (word "echo") (word "\"n=${#arr[@]}\""))) (command (word "printf") (word "'[%s]\\n'") (word "\"${arr[@]}\"")))))
---

=== mapfile / readarray stdin  TODO: Fix me.
shopt -s lastpipe  # for bash

seq 2 | mapfile m
seq 3 | readarray r
echo ${#m[@]}
echo ${#r[@]}
---
(command (word "shopt") (word "-s") (word "lastpipe"))
(pipe (command (word "seq") (word "2")) (command (word "mapfile") (word "m")))
(pipe (command (word "seq") (word "3")) (command (word "readarray") (word "r")))
(command (word "echo") (word "${#m[@]}"))
(command (word "echo") (word "${#r[@]}"))
---

=== bind -l should report readline functions
# This test depends on the exact version
# bind -l | sort > _tmp/this-shell-bind-l.txt
# comm -23 $REPO_ROOT/spec/testdata/bind/bind_l_function_list.txt _tmp/this-shell-bind-l.txt

# More relaxed test
bind -l | grep accept-line
---
(pipe (command (word "bind") (word "-l")) (command (word "grep") (word "accept-line")))
---

=== bind -p -P to print function names and key bindings
# silly workaround for spec test format - change # comment to %
bind -p | grep vi-subst | sed 's/^#/%/'
echo

bind -P | grep vi-subst
---
(pipe (command (word "bind") (word "-p")) (pipe (command (word "grep") (word "vi-subst")) (command (word "sed") (word "'s/^#/%/'"))))
(command (word "echo"))
(pipe (command (word "bind") (word "-P")) (command (word "grep") (word "vi-subst")))
---

=== bind -s -S accepted
# TODO: add non-trivial tests here

bind -s
bind -S
---
(command (word "bind") (word "-s"))
(command (word "bind") (word "-S"))
---

=== bind -v -V accepted
bind -v | grep blink-matching-paren
echo

# transform silly quote so we don't mess up syntax highlighting
bind -V | grep blink-matching-paren | sed "s/\`/'/g"
---
(pipe (command (word "bind") (word "-v")) (command (word "grep") (word "blink-matching-paren")))
(command (word "echo"))
(pipe (command (word "bind") (word "-V")) (pipe (command (word "grep") (word "blink-matching-paren")) (command (word "sed") (word "\"s/\\`/'/g\""))))
---

=== bind -q
bind -q zz-bad
echo status=$?

# bash prints message to stdout

bind -q vi-subst
echo status=$?

bind -q yank
echo status=$?
---
(command (word "bind") (word "-q") (word "zz-bad"))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-q") (word "vi-subst"))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-q") (word "yank"))
(command (word "echo") (word "status=$?"))
---

=== bind -X
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -x '"\C-o\C-s\C-h": echo foo'
bind -X | grep -oF '\C-o\C-s\C-h'
bind -X | grep -oF 'echo foo'
echo status=$?
---
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-x") (word "'\"\\C-o\\C-s\\C-h\": echo foo'"))
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'echo foo'")))
(command (word "echo") (word "status=$?"))
---

=== bind -m with bind -x/-X
bind -X | grep -oF 'emacs|vi'
echo status=$?

bind -m emacs -x '"\C-o\C-s\C-h": echo emacs'
bind -m emacs -X | grep -oF 'emacs'
echo status=$?

bind -m vi -x '"\C-o\C-s\C-h": echo vi'
bind -m vi -X | grep -oF 'vi'
echo status=$?
---
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'emacs|vi'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-m") (word "emacs") (word "-x") (word "'\"\\C-o\\C-s\\C-h\": echo emacs'"))
(pipe (command (word "bind") (word "-m") (word "emacs") (word "-X")) (command (word "grep") (word "-oF") (word "'emacs'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-m") (word "vi") (word "-x") (word "'\"\\C-o\\C-s\\C-h\": echo vi'"))
(pipe (command (word "bind") (word "-m") (word "vi") (word "-X")) (command (word "grep") (word "-oF") (word "'vi'")))
(command (word "echo") (word "status=$?"))
---

=== bind -r
bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind '"\C-o\C-s\C-h": yank'
bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -r "\C-o\C-s\C-h"
bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?
---
(pipe (command (word "bind") (word "-q") (word "yank")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "'\"\\C-o\\C-s\\C-h\": yank'"))
(pipe (command (word "bind") (word "-q") (word "yank")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-r") (word "\"\\C-o\\C-s\\C-h\""))
(pipe (command (word "bind") (word "-q") (word "yank")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
---

=== bind -r of bind -x commands
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -x '"\C-o\C-s\C-h": echo foo'
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -r "\C-o\C-s\C-h"
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?
---
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-x") (word "'\"\\C-o\\C-s\\C-h\": echo foo'"))
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
(command (word "bind") (word "-r") (word "\"\\C-o\\C-s\\C-h\""))
(pipe (command (word "bind") (word "-X")) (command (word "grep") (word "-oF") (word "'\\C-o\\C-s\\C-h'")))
(command (word "echo") (word "status=$?"))
---

=== zero args: [ ]
[ ] || echo false
---
(or (command (word "[") (word "]")) (command (word "echo") (word "false")))
---

=== one arg: [ x ] where x is one of '=' '!' '(' ']'
[ = ]
echo status=$?
[ ] ]
echo status=$?
[ '!' ]
echo status=$?
[ '(' ]
echo status=$?
---
(command (word "[") (word "=") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "]") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "'!'") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "'('") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== one arg: empty string is false.  Equivalent to -n.
test 'a'  && echo true
test ''   || echo false
---
(and (command (word "test") (word "'a'")) (command (word "echo") (word "true")))
(or (command (word "test") (word "''")) (command (word "echo") (word "false")))
---

=== -a as unary operator (alias of -e)
# NOT IMPLEMENTED FOR OSH, but could be later.  See comment in core/id_kind.py.
[ -a / ]
echo status=$?
[ -a /nonexistent ]
echo status=$?
---
(command (word "[") (word "-a") (word "/") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-a") (word "/nonexistent") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== two args: -z with = ! ( ]
[ -z = ]
echo status=$?
[ -z ] ]
echo status=$?
[ -z '!' ]
echo status=$?
[ -z '(' ]
echo status=$?
---
(command (word "[") (word "-z") (word "=") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-z") (word "]") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-z") (word "'!'") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-z") (word "'('") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== three args
[ foo = '' ]
echo status=$?
[ foo -a '' ]
echo status=$?
[ foo -o '' ]
echo status=$?
[ ! -z foo ]
echo status=$?
[ \( foo \) ]
echo status=$?
---
(command (word "[") (word "foo") (word "=") (word "''") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "foo") (word "-a") (word "''") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "foo") (word "-o") (word "''") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "!") (word "-z") (word "foo") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "\\(") (word "foo") (word "\\)") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== four args
[ ! foo = foo ]
echo status=$?
[ \( -z foo \) ]
echo status=$?
---
(command (word "[") (word "!") (word "foo") (word "=") (word "foo") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "\\(") (word "-z") (word "foo") (word "\\)") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== test with extra args is syntax error
test -n x ]
echo status=$?
test -n x y
echo status=$?
---
(command (word "test") (word "-n") (word "x") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-n") (word "x") (word "y"))
(command (word "echo") (word "status=$?"))
---

=== ] syntax errors
[
echo status=$?
test  # not a syntax error
echo status=$?
[ -n x  # missing ]
echo status=$?
[ -n x ] y  # extra arg after ]
echo status=$?
[ -n x y  # extra arg
echo status=$?
---
(command (word "["))
(command (word "echo") (word "status=$?"))
(command (word "test"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-n") (word "x"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-n") (word "x") (word "]") (word "y"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-n") (word "x") (word "y"))
(command (word "echo") (word "status=$?"))
---

=== -n
test -n 'a'  && echo true
test -n ''   || echo false
---
(and (command (word "test") (word "-n") (word "'a'")) (command (word "echo") (word "true")))
(or (command (word "test") (word "-n") (word "''")) (command (word "echo") (word "false")))
---

=== ! -a
[ -z '' -a ! -z x ]
echo status=$?
---
(command (word "[") (word "-z") (word "''") (word "-a") (word "!") (word "-z") (word "x") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -o
[ -z x -o ! -z x ]
echo status=$?
---
(command (word "[") (word "-z") (word "x") (word "-o") (word "!") (word "-z") (word "x") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== ( )
[ -z '' -a '(' ! -z x ')' ]
echo status=$?
---
(command (word "[") (word "-z") (word "''") (word "-a") (word "'('") (word "!") (word "-z") (word "x") (word "')'") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== ( ) ! -a -o with system version of [
command [ --version
command [ -z '' -a '(' ! -z x ')' ] && echo true
---
(command (word "command") (word "[") (word "--version"))
(and (command (word "command") (word "[") (word "-z") (word "''") (word "-a") (word "'('") (word "!") (word "-z") (word "x") (word "')'") (word "]")) (command (word "echo") (word "true")))
---

=== == is alias for =
[ a = a ] && echo true
[ a == a ] && echo true
---
(and (command (word "[") (word "a") (word "=") (word "a") (word "]")) (command (word "echo") (word "true")))
(and (command (word "[") (word "a") (word "==") (word "a") (word "]")) (command (word "echo") (word "true")))
---

=== == and = does not do glob
[ abc = 'a*' ]
echo status=$?
[ abc == 'a*' ]
echo status=$?
---
(command (word "[") (word "abc") (word "=") (word "'a*'") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "abc") (word "==") (word "'a*'") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== [ with op variable
# OK -- parsed AFTER evaluation of vars
op='='
[ a $op a ] && echo true
[ a $op b ] || echo false
---
(command (word "op='='"))
(and (command (word "[") (word "a") (word "$op") (word "a") (word "]")) (command (word "echo") (word "true")))
(or (command (word "[") (word "a") (word "$op") (word "b") (word "]")) (command (word "echo") (word "false")))
---

=== [ with unquoted empty var
empty=''
[ $empty = '' ] && echo true
---
(command (word "empty=''"))
(and (command (word "[") (word "$empty") (word "=") (word "''") (word "]")) (command (word "echo") (word "true")))
---

=== [ compare with literal -f
# Hm this is the same
var=-f
[ $var = -f ] && echo true
[ '-f' = $var ] && echo true
---
(command (word "var=-f"))
(and (command (word "[") (word "$var") (word "=") (word "-f") (word "]")) (command (word "echo") (word "true")))
(and (command (word "[") (word "'-f'") (word "=") (word "$var") (word "]")) (command (word "echo") (word "true")))
---

=== [ '(' foo ] is runtime syntax error
[ '(' foo ]
echo status=$?
---
(command (word "[") (word "'('") (word "foo") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -z '>' implies two token lookahead
[ -z ] && echo true  # -z is operand
[ -z '>' ] || echo false  # -z is operator
[ -z '>' -- ] && echo true  # -z is operand
---
(and (command (word "[") (word "-z") (word "]")) (command (word "echo") (word "true")))
(or (command (word "[") (word "-z") (word "'>'") (word "]")) (command (word "echo") (word "false")))
(and (command (word "[") (word "-z") (word "'>'") (word "--") (word "]")) (command (word "echo") (word "true")))
---

=== operator/operand ambiguity with ]
# bash parses this as '-z' AND ']', which is true.  It's a syntax error in
# dash/mksh.
[ -z -a ] ]
echo status=$?
---
(command (word "[") (word "-z") (word "-a") (word "]") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== operator/operand ambiguity with -a
# bash parses it as '-z' AND '-a'.  It's a syntax error in mksh but somehow a
# runtime error in dash.
[ -z -a -a ]
echo status=$?
---
(command (word "[") (word "-z") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -d
test -d $TMP
echo status=$?
test -d $TMP/__nonexistent_Z_Z__
echo status=$?
---
(command (word "test") (word "-d") (word "$TMP"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-d") (word "$TMP/__nonexistent_Z_Z__"))
(command (word "echo") (word "status=$?"))
---

=== -x
rm -f $TMP/x
echo 'echo hi' > $TMP/x
test -x $TMP/x || echo 'no'
chmod +x $TMP/x
test -x $TMP/x && echo 'yes'
test -x $TMP/__nonexistent__ || echo 'bad'
---
(command (word "rm") (word "-f") (word "$TMP/x"))
(command (word "echo") (word "'echo hi'") (redirect ">" "$TMP/x"))
(or (command (word "test") (word "-x") (word "$TMP/x")) (command (word "echo") (word "'no'")))
(command (word "chmod") (word "+x") (word "$TMP/x"))
(and (command (word "test") (word "-x") (word "$TMP/x")) (command (word "echo") (word "'yes'")))
(or (command (word "test") (word "-x") (word "$TMP/__nonexistent__")) (command (word "echo") (word "'bad'")))
---

=== -r
echo '1' > $TMP/testr_yes
echo '2' > $TMP/testr_no
chmod -r $TMP/testr_no  # remove read permission
test -r $TMP/testr_yes && echo 'yes'
test -r $TMP/testr_no || echo 'no'
---
(command (word "echo") (word "'1'") (redirect ">" "$TMP/testr_yes"))
(command (word "echo") (word "'2'") (redirect ">" "$TMP/testr_no"))
(command (word "chmod") (word "-r") (word "$TMP/testr_no"))
(and (command (word "test") (word "-r") (word "$TMP/testr_yes")) (command (word "echo") (word "'yes'")))
(or (command (word "test") (word "-r") (word "$TMP/testr_no")) (command (word "echo") (word "'no'")))
---

=== -w
rm -f $TMP/testw_*
echo '1' > $TMP/testw_yes
echo '2' > $TMP/testw_no
chmod -w $TMP/testw_no  # remove write permission
test -w $TMP/testw_yes && echo 'yes'
test -w $TMP/testw_no || echo 'no'
---
(command (word "rm") (word "-f") (word "$TMP/testw_*"))
(command (word "echo") (word "'1'") (redirect ">" "$TMP/testw_yes"))
(command (word "echo") (word "'2'") (redirect ">" "$TMP/testw_no"))
(command (word "chmod") (word "-w") (word "$TMP/testw_no"))
(and (command (word "test") (word "-w") (word "$TMP/testw_yes")) (command (word "echo") (word "'yes'")))
(or (command (word "test") (word "-w") (word "$TMP/testw_no")) (command (word "echo") (word "'no'")))
---

=== -k for sticky bit
# not isolated: /tmp usually has sticky bit on
# https://en.wikipedia.org/wiki/Sticky_bit

test -k /tmp
echo status=$?

test -k /bin
echo status=$?
---
(command (word "test") (word "-k") (word "/tmp"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-k") (word "/bin"))
(command (word "echo") (word "status=$?"))
---

=== -h and -L test for symlink
tmp=$TMP/builtin-test-1
mkdir -p $tmp
touch $tmp/zz
ln -s -f $tmp/zz $tmp/symlink
ln -s -f $tmp/__nonexistent_ZZ__ $tmp/dangling
test -L $tmp/zz || echo no
test -h $tmp/zz || echo no
test -f $tmp/symlink && echo is-file
test -L $tmp/symlink && echo symlink
test -h $tmp/symlink && echo symlink
test -L $tmp/dangling && echo dangling
test -h $tmp/dangling  && echo dangling
test -f $tmp/dangling  || echo 'dangling is not file'
---
(command (word "tmp=$TMP/builtin-test-1"))
(command (word "mkdir") (word "-p") (word "$tmp"))
(command (word "touch") (word "$tmp/zz"))
(command (word "ln") (word "-s") (word "-f") (word "$tmp/zz") (word "$tmp/symlink"))
(command (word "ln") (word "-s") (word "-f") (word "$tmp/__nonexistent_ZZ__") (word "$tmp/dangling"))
(or (command (word "test") (word "-L") (word "$tmp/zz")) (command (word "echo") (word "no")))
(or (command (word "test") (word "-h") (word "$tmp/zz")) (command (word "echo") (word "no")))
(and (command (word "test") (word "-f") (word "$tmp/symlink")) (command (word "echo") (word "is-file")))
(and (command (word "test") (word "-L") (word "$tmp/symlink")) (command (word "echo") (word "symlink")))
(and (command (word "test") (word "-h") (word "$tmp/symlink")) (command (word "echo") (word "symlink")))
(and (command (word "test") (word "-L") (word "$tmp/dangling")) (command (word "echo") (word "dangling")))
(and (command (word "test") (word "-h") (word "$tmp/dangling")) (command (word "echo") (word "dangling")))
(or (command (word "test") (word "-f") (word "$tmp/dangling")) (command (word "echo") (word "'dangling is not file'")))
---

=== -t 1 for stdout
# There is no way to get a terminal in the test environment?
[ -t 1 ]
echo status=$?
---
(command (word "[") (word "-t") (word "1") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== [ -t invalid ]
[ -t invalid ]
echo status=$?
---
(command (word "[") (word "-t") (word "invalid") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -ot and -nt
touch -d 2017/12/31 $TMP/x
touch -d 2018/01/01 > $TMP/y
test $TMP/x -ot $TMP/y && echo 'older'
test $TMP/x -nt $TMP/y || echo 'not newer'
test $TMP/x -ot $TMP/x || echo 'not older than itself'
test $TMP/x -nt $TMP/x || echo 'not newer than itself'
---
(command (word "touch") (word "-d") (word "2017/12/31") (word "$TMP/x"))
(command (word "touch") (word "-d") (word "2018/01/01") (redirect ">" "$TMP/y"))
(and (command (word "test") (word "$TMP/x") (word "-ot") (word "$TMP/y")) (command (word "echo") (word "'older'")))
(or (command (word "test") (word "$TMP/x") (word "-nt") (word "$TMP/y")) (command (word "echo") (word "'not newer'")))
(or (command (word "test") (word "$TMP/x") (word "-ot") (word "$TMP/x")) (command (word "echo") (word "'not older than itself'")))
(or (command (word "test") (word "$TMP/x") (word "-nt") (word "$TMP/x")) (command (word "echo") (word "'not newer than itself'")))
---

=== [ a -eq b ]
[ a -eq a ]
echo status=$?
---
(command (word "[") (word "a") (word "-eq") (word "a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== test -s
test -s __nonexistent
echo status=$?
touch $TMP/empty
test -s $TMP/empty
echo status=$?
echo nonempty > $TMP/nonempty
test -s $TMP/nonempty
echo status=$?
---
(command (word "test") (word "-s") (word "__nonexistent"))
(command (word "echo") (word "status=$?"))
(command (word "touch") (word "$TMP/empty"))
(command (word "test") (word "-s") (word "$TMP/empty"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "nonempty") (redirect ">" "$TMP/nonempty"))
(command (word "test") (word "-s") (word "$TMP/nonempty"))
(command (word "echo") (word "status=$?"))
---

=== test -b -c -S (block, character, socket)
# NOTE: we do not have the "true" case

echo -b
test -b nonexistent
echo status=$?
test -b testdata
echo status=$?
test -b /
echo status=$?

echo -c
test -c nonexistent
echo status=$?
test -c testdata
echo status=$?

echo -S
test -S nonexistent
echo status=$?
test -S testdata
echo status=$?
---
(command (word "echo") (word "-b"))
(command (word "test") (word "-b") (word "nonexistent"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-b") (word "testdata"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-b") (word "/"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "-c"))
(command (word "test") (word "-c") (word "nonexistent"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-c") (word "testdata"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "-S"))
(command (word "test") (word "-S") (word "nonexistent"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-S") (word "testdata"))
(command (word "echo") (word "status=$?"))
---

=== test -p named pipe
mkfifo $TMP/fifo
test -p $TMP/fifo
echo status=$?

test -p testdata
echo status=$?
---
(command (word "mkfifo") (word "$TMP/fifo"))
(command (word "test") (word "-p") (word "$TMP/fifo"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-p") (word "testdata"))
(command (word "echo") (word "status=$?"))
---

=== -G and -O for effective user ID and group ID
mkdir -p $TMP/bin

test -O $TMP/bin
echo status=$?
test -O __nonexistent__
echo status=$?

test -G $TMP/bin
echo status=$?
test -G __nonexistent__
echo status=$?
---
(command (word "mkdir") (word "-p") (word "$TMP/bin"))
(command (word "test") (word "-O") (word "$TMP/bin"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-O") (word "__nonexistent__"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-G") (word "$TMP/bin"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-G") (word "__nonexistent__"))
(command (word "echo") (word "status=$?"))
---

=== -u for setuid, -g too
touch $TMP/setuid $TMP/setgid
chmod u+s $TMP/setuid
chmod g+s $TMP/setgid

test -u $TMP/setuid
echo status=$?

test -u $TMP/setgid
echo status=$?

test -g $TMP/setuid
echo status=$?

test -g $TMP/setgid
echo status=$?
---
(command (word "touch") (word "$TMP/setuid") (word "$TMP/setgid"))
(command (word "chmod") (word "u+s") (word "$TMP/setuid"))
(command (word "chmod") (word "g+s") (word "$TMP/setgid"))
(command (word "test") (word "-u") (word "$TMP/setuid"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-u") (word "$TMP/setgid"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-g") (word "$TMP/setuid"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-g") (word "$TMP/setgid"))
(command (word "echo") (word "status=$?"))
---

=== -v to test variable (bash)
test -v nonexistent
echo global=$?

g=1
test -v g
echo global=$?

f() {
  local f_var=0
  g
}

g() {
  test -v f_var
  echo dynamic=$?
  test -v g
  echo dynamic=$?
  test -v nonexistent
  echo dynamic=$?
}
f
---
(command (word "test") (word "-v") (word "nonexistent"))
(command (word "echo") (word "global=$?"))
(command (word "g=1"))
(command (word "test") (word "-v") (word "g"))
(command (word "echo") (word "global=$?"))
(function "f" (brace-group (semi (command (word "local") (word "f_var=0")) (command (word "g")))))
(function "g" (brace-group (semi (semi (semi (semi (semi (command (word "test") (word "-v") (word "f_var")) (command (word "echo") (word "dynamic=$?"))) (command (word "test") (word "-v") (word "g"))) (command (word "echo") (word "dynamic=$?"))) (command (word "test") (word "-v") (word "nonexistent"))) (command (word "echo") (word "dynamic=$?")))))
(command (word "f"))
---

=== test -o for options
# note: it's lame that the 'false' case is confused with the 'typo' case.
# but checking for error code 2 is unlikely anyway.
test -o nounset
echo status=$?

set -o nounset
test -o nounset
echo status=$?

test -o _bad_name_
echo status=$?
---
(command (word "test") (word "-o") (word "nounset"))
(command (word "echo") (word "status=$?"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "test") (word "-o") (word "nounset"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-o") (word "_bad_name_"))
(command (word "echo") (word "status=$?"))
---

=== -nt -ot
[ present -nt absent ] || exit 1
[ absent -ot present ] || exit 2
---
(or (command (word "[") (word "present") (word "-nt") (word "absent") (word "]")) (command (word "exit") (word "1")))
(or (command (word "[") (word "absent") (word "-ot") (word "present") (word "]")) (command (word "exit") (word "2")))
---

=== -ef
left=$TMP/left
right=$TMP/right
touch $left $right

ln -f $TMP/left $TMP/hardlink

test $left -ef $left && echo same
test $left -ef $TMP/hardlink && echo same
test $left -ef $right || echo different

test $TMP/__nonexistent -ef $right || echo different
---
(command (word "left=$TMP/left"))
(command (word "right=$TMP/right"))
(command (word "touch") (word "$left") (word "$right"))
(command (word "ln") (word "-f") (word "$TMP/left") (word "$TMP/hardlink"))
(and (command (word "test") (word "$left") (word "-ef") (word "$left")) (command (word "echo") (word "same")))
(and (command (word "test") (word "$left") (word "-ef") (word "$TMP/hardlink")) (command (word "echo") (word "same")))
(or (command (word "test") (word "$left") (word "-ef") (word "$right")) (command (word "echo") (word "different")))
(or (command (word "test") (word "$TMP/__nonexistent") (word "-ef") (word "$right")) (command (word "echo") (word "different")))
---

=== Overflow error
test -t 12345678910
echo status=$?
---
(command (word "test") (word "-t") (word "12345678910"))
(command (word "echo") (word "status=$?"))
---

=== Bug regression
test "$ipv6" = "yes" -a "$ipv6lib" != "none"
echo status=$?
---
(command (word "test") (word "\"$ipv6\"") (word "=") (word "\"yes\"") (word "-a") (word "\"$ipv6lib\"") (word "!=") (word "\"none\""))
(command (word "echo") (word "status=$?"))
---

=== test -c
test -c /dev/zero
echo status=$?
---
(command (word "test") (word "-c") (word "/dev/zero"))
(command (word "echo") (word "status=$?"))
---

=== test -S
test -S /dev/zero
echo status=$?
---
(command (word "test") (word "-S") (word "/dev/zero"))
(command (word "echo") (word "status=$?"))
---

=== bug from pnut: negative number $((-1))
# https://lobste.rs/s/lplim1/design_self_compiling_c_transpiler#c_km2ywc

[ $((-42)) -le 0 ]
echo status=$?

[ $((-1)) -le 0 ]
echo status=$?

echo

[ -1 -le 0 ]
echo status=$?

[ -42 -le 0 ]
echo status=$?

echo

test -1 -le 0
echo status=$?

test -42 -le 0
echo status=$?
---
(command (word "[") (word "$((-42))") (word "-le") (word "0") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "$((-1))") (word "-le") (word "0") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "[") (word "-1") (word "-le") (word "0") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-42") (word "-le") (word "0") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "test") (word "-1") (word "-le") (word "0"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-42") (word "-le") (word "0"))
(command (word "echo") (word "status=$?"))
---

=== negative octal numbers, etc.
# zero
[ -0 -eq 0 ]
echo zero=$?

# octal numbers can be negative
[ -0123 -eq -83 ]
echo octal=$?

# hex doesn't have negative numbers?
[ -0xff -eq -255 ]
echo hex=$?

# base N doesn't either
[ -64#a -eq -10 ]
echo baseN=$?
---
(command (word "[") (word "-0") (word "-eq") (word "0") (word "]"))
(command (word "echo") (word "zero=$?"))
(command (word "[") (word "-0123") (word "-eq") (word "-83") (word "]"))
(command (word "echo") (word "octal=$?"))
(command (word "[") (word "-0xff") (word "-eq") (word "-255") (word "]"))
(command (word "echo") (word "hex=$?"))
(command (word "[") (word "-64#a") (word "-eq") (word "-10") (word "]"))
(command (word "echo") (word "baseN=$?"))
---

=== More negative numbers
case $SH in dash) exit ;; esac

[[ -1 -le 0 ]]
echo status=$?

[[ $((-1)) -le 0 ]]
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(cond (cond-binary "-le" (cond-term "-1") (cond-term "0")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "-le" (cond-term "$((-1))") (cond-term "0")))
(command (word "echo") (word "status=$?"))
---

=== No octal, hex, base N conversion - leading 0 is a regular decimal
# arithmetic has octal conversion
echo $(( 073 ))
echo $(( -073 ))

echo

# Bracket does NOT have octal conversion!  That is annoying.
[ 073 -eq 73 ]
echo status=$?

[ -073 -eq -73 ]
echo status=$?

echo

[ 0xff -eq 255 ]
echo hex=$?
[ 64#a -eq 10 ]
echo baseN=$?
---
(command (word "echo") (word "$(( 073 ))"))
(command (word "echo") (word "$(( -073 ))"))
(command (word "echo"))
(command (word "[") (word "073") (word "-eq") (word "73") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-073") (word "-eq") (word "-73") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "[") (word "0xff") (word "-eq") (word "255") (word "]"))
(command (word "echo") (word "hex=$?"))
(command (word "[") (word "64#a") (word "-eq") (word "10") (word "]"))
(command (word "echo") (word "baseN=$?"))
---

=== Looks like octal, but digit is too big
# arithmetic has octal conversion
echo $(( 083 ))
echo status=$?

echo $(( -083 ))
echo status=$?

echo

# Bracket does NOT have octal conversion!  That is annoying.
[ 083 -eq 83 ]
echo status=$?

[ -083 -eq -83 ]
echo status=$?
---
(command (word "echo") (word "$(( 083 ))"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "$(( -083 ))"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "[") (word "083") (word "-eq") (word "83") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-083") (word "-eq") (word "-83") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== no recursive arith [ 1+2 -eq 3 ]
[ 1+2 -eq 3 ]
echo status=$?

s='1+2'
[ "$s" -eq 3 ]
echo status=$?
---
(command (word "[") (word "1+2") (word "-eq") (word "3") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "s='1+2'"))
(command (word "[") (word "\"$s\"") (word "-eq") (word "3") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== cd and $PWD
cd /
echo $PWD
---
(command (word "cd") (word "/"))
(command (word "echo") (word "$PWD"))
---

=== cd BAD/..
# Odd divergence in shells: dash and mksh normalize the path and don't check
# this error.
# TODO: I would like OSH to behave like bash and zsh, but separating chdir_arg
# and pwd_arg breaks case 17.

cd nonexistent_ZZ/..
echo status=$?
---
(command (word "cd") (word "nonexistent_ZZ/.."))
(command (word "echo") (word "status=$?"))
---

=== cd with 2 or more args - with strict_arg_parse
shopt -s strict_arg_parse

mkdir -p foo
cd foo
echo status=$?
cd ..
echo status=$?


cd foo bar
st=$?
if test $st -ne 0; then
  echo 'failed with multiple args'
fi
---
(command (word "shopt") (word "-s") (word "strict_arg_parse"))
(command (word "mkdir") (word "-p") (word "foo"))
(command (word "cd") (word "foo"))
(command (word "echo") (word "status=$?"))
(command (word "cd") (word ".."))
(command (word "echo") (word "status=$?"))
(command (word "cd") (word "foo") (word "bar"))
(command (word "st=$?"))
(if (command (word "test") (word "$st") (word "-ne") (word "0")) (command (word "echo") (word "'failed with multiple args'")))
---

=== cd with 2 or more args is allowed (strict_arg_parse disabled)
mkdir -p foo
cd foo bar
---
(command (word "mkdir") (word "-p") (word "foo"))
(command (word "cd") (word "foo") (word "bar"))
---

=== cd - without OLDPWD
cd - > /dev/null  # silence dash output
echo status=$?
#pwd
---
(command (word "cd") (word "-") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== $OLDPWD
cd /
cd $TMP
echo "old: $OLDPWD"
env | grep OLDPWD  # It's EXPORTED too!
cd -
---
(command (word "cd") (word "/"))
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "\"old: $OLDPWD\""))
(pipe (command (word "env")) (command (word "grep") (word "OLDPWD")))
(command (word "cd") (word "-"))
---

=== pwd
cd /
pwd
---
(command (word "cd") (word "/"))
(command (word "pwd"))
---

=== pwd after cd ..
dir=$TMP/dir-one/dir-two
mkdir -p $dir
cd $dir
echo $(basename $(pwd))
cd ..
echo $(basename $(pwd))
---
(command (word "dir=$TMP/dir-one/dir-two"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "echo") (word "$(basename $(pwd))"))
(command (word "cd") (word ".."))
(command (word "echo") (word "$(basename $(pwd))"))
---

=== pwd with symlink and -P
tmp=$TMP/builtins-pwd-1
mkdir -p $tmp/target
ln -s -f $tmp/target $tmp/symlink

cd $tmp/symlink

echo pwd:
basename $(pwd)

echo pwd -P:
basename $(pwd -P)
---
(command (word "tmp=$TMP/builtins-pwd-1"))
(command (word "mkdir") (word "-p") (word "$tmp/target"))
(command (word "ln") (word "-s") (word "-f") (word "$tmp/target") (word "$tmp/symlink"))
(command (word "cd") (word "$tmp/symlink"))
(command (word "echo") (word "pwd:"))
(command (word "basename") (word "$(pwd)"))
(command (word "echo") (word "pwd") (word "-P:"))
(command (word "basename") (word "$(pwd -P)"))
---

=== setting $PWD doesn't affect the value of 'pwd' builtin
dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir

PWD=foo
echo before $PWD
pwd
echo after $PWD
---
(command (word "dir=/tmp/oil-spec-test/pwd"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "PWD=foo"))
(command (word "echo") (word "before") (word "$PWD"))
(command (word "pwd"))
(command (word "echo") (word "after") (word "$PWD"))
---

=== unset PWD; then pwd
dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir

unset PWD
echo PWD=$PWD
pwd
echo PWD=$PWD
---
(command (word "dir=/tmp/oil-spec-test/pwd"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "unset") (word "PWD"))
(command (word "echo") (word "PWD=$PWD"))
(command (word "pwd"))
(command (word "echo") (word "PWD=$PWD"))
---

=== 'unset PWD; pwd' before any cd (tickles a rare corner case)
dir=/tmp/oil-spec-test/pwd-2
mkdir -p $dir
cd $dir

# ensure clean shell process state
$SH -c 'unset PWD; pwd'
---
(command (word "dir=/tmp/oil-spec-test/pwd-2"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "$SH") (word "-c") (word "'unset PWD; pwd'"))
---

=== lie about PWD; pwd before any cd
dir=/tmp/oil-spec-test/pwd-3
mkdir -p $dir
cd $dir

# ensure clean shell process state
$SH -c 'PWD=foo; pwd'
---
(command (word "dir=/tmp/oil-spec-test/pwd-3"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "$SH") (word "-c") (word "'PWD=foo; pwd'"))
---

=== remove pwd dir
dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir
pwd
rmdir $dir
echo status=$?
pwd
echo status=$?
---
(command (word "dir=/tmp/oil-spec-test/pwd"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "pwd"))
(command (word "rmdir") (word "$dir"))
(command (word "echo") (word "status=$?"))
(command (word "pwd"))
(command (word "echo") (word "status=$?"))
---

=== pwd in symlinked dir on shell initialization
tmp=$TMP/builtins-pwd-2
mkdir -p $tmp
mkdir -p $tmp/target
ln -s -f $tmp/target $tmp/symlink

cd $tmp/symlink
$SH -c 'basename $(pwd)'
unset PWD
$SH -c 'basename $(pwd)'
---
(command (word "tmp=$TMP/builtins-pwd-2"))
(command (word "mkdir") (word "-p") (word "$tmp"))
(command (word "mkdir") (word "-p") (word "$tmp/target"))
(command (word "ln") (word "-s") (word "-f") (word "$tmp/target") (word "$tmp/symlink"))
(command (word "cd") (word "$tmp/symlink"))
(command (word "$SH") (word "-c") (word "'basename $(pwd)'"))
(command (word "unset") (word "PWD"))
(command (word "$SH") (word "-c") (word "'basename $(pwd)'"))
---

=== Test the current directory after 'cd ..' involving symlinks
dir=$TMP/symlinktest
mkdir -p $dir
cd $dir
mkdir -p a/b/c
mkdir -p a/b/d
ln -s -f a/b/c c > /dev/null
cd c
cd ..
# Expecting a c/ (since we are in symlinktest) but osh gives c d (thinks we are
# in b/)
ls
---
(command (word "dir=$TMP/symlinktest"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "mkdir") (word "-p") (word "a/b/c"))
(command (word "mkdir") (word "-p") (word "a/b/d"))
(command (word "ln") (word "-s") (word "-f") (word "a/b/c") (word "c") (redirect ">" "/dev/null"))
(command (word "cd") (word "c"))
(command (word "cd") (word ".."))
(command (word "ls"))
---

=== cd with no arguments
HOME=$TMP/home
mkdir -p $HOME
cd
test $(pwd) = "$HOME" && echo OK
---
(command (word "HOME=$TMP/home"))
(command (word "mkdir") (word "-p") (word "$HOME"))
(command (word "cd"))
(and (command (word "test") (word "$(pwd)") (word "=") (word "\"$HOME\"")) (command (word "echo") (word "OK")))
---

=== cd to nonexistent dir
cd /nonexistent/dir
echo status=$?
---
(command (word "cd") (word "/nonexistent/dir"))
(command (word "echo") (word "status=$?"))
---

=== cd away from dir that was deleted
dir=$TMP/cd-nonexistent
mkdir -p $dir
cd $dir
rmdir $dir
cd $TMP
echo $(basename $OLDPWD)
echo status=$?
---
(command (word "dir=$TMP/cd-nonexistent"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "rmdir") (word "$dir"))
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "$(basename $OLDPWD)"))
(command (word "echo") (word "status=$?"))
---

=== cd permits double bare dash
cd -- /
echo $PWD
---
(command (word "cd") (word "--") (word "/"))
(command (word "echo") (word "$PWD"))
---

=== cd to symlink with -L and -P
targ=$TMP/cd-symtarget
lnk=$TMP/cd-symlink
mkdir -p $targ
ln -s $targ $lnk

# -L behavior is the default
cd $lnk
test $PWD = "$TMP/cd-symlink" && echo OK

cd -L $lnk
test $PWD = "$TMP/cd-symlink" && echo OK

cd -P $lnk
test $PWD = "$TMP/cd-symtarget" && echo OK || echo $PWD
---
(command (word "targ=$TMP/cd-symtarget"))
(command (word "lnk=$TMP/cd-symlink"))
(command (word "mkdir") (word "-p") (word "$targ"))
(command (word "ln") (word "-s") (word "$targ") (word "$lnk"))
(command (word "cd") (word "$lnk"))
(and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink\"")) (command (word "echo") (word "OK")))
(command (word "cd") (word "-L") (word "$lnk"))
(and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink\"")) (command (word "echo") (word "OK")))
(command (word "cd") (word "-P") (word "$lnk"))
(or (and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symtarget\"")) (command (word "echo") (word "OK"))) (command (word "echo") (word "$PWD")))
---

=== cd to relative path with -L and -P
die() { echo "$@"; exit 1; }

targ=$TMP/cd-symtarget/subdir
lnk=$TMP/cd-symlink
mkdir -p $targ
ln -s $TMP/cd-symtarget $lnk

# -L behavior is the default
cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd ..
test $PWD = "$TMP/cd-symlink" && echo OK

cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd -L ..
test $PWD = "$TMP/cd-symlink" && echo OK

cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd -P ..
test $PWD = "$TMP/cd-symtarget" && echo OK || echo $PWD
---
(function "die" (brace-group (semi (command (word "echo") (word "\"$@\"")) (command (word "exit") (word "1")))))
(command (word "targ=$TMP/cd-symtarget/subdir"))
(command (word "lnk=$TMP/cd-symlink"))
(command (word "mkdir") (word "-p") (word "$targ"))
(command (word "ln") (word "-s") (word "$TMP/cd-symtarget") (word "$lnk"))
(command (word "cd") (word "$lnk/subdir"))
(or (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink/subdir\"")) (command (word "die") (word "\"failed\"")))
(command (word "cd") (word ".."))
(and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink\"")) (command (word "echo") (word "OK")))
(command (word "cd") (word "$lnk/subdir"))
(or (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink/subdir\"")) (command (word "die") (word "\"failed\"")))
(command (word "cd") (word "-L") (word ".."))
(and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink\"")) (command (word "echo") (word "OK")))
(command (word "cd") (word "$lnk/subdir"))
(or (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symlink/subdir\"")) (command (word "die") (word "\"failed\"")))
(command (word "cd") (word "-P") (word ".."))
(or (and (command (word "test") (word "$PWD") (word "=") (word "\"$TMP/cd-symtarget\"")) (command (word "echo") (word "OK"))) (command (word "echo") (word "$PWD")))
---

=== unset PWD; cd /tmp is allowed (regression)
unset PWD; cd /tmp
pwd
---
(semi (command (word "unset") (word "PWD")) (command (word "cd") (word "/tmp")))
(command (word "pwd"))
---

=== CDPATH is respected
mkdir -p /tmp/spam/foo /tmp/eggs/foo

CDPATH='/tmp/spam:/tmp/eggs'

cd foo
echo status=$?
pwd
---
(command (word "mkdir") (word "-p") (word "/tmp/spam/foo") (word "/tmp/eggs/foo"))
(command (word "CDPATH='/tmp/spam:/tmp/eggs'"))
(command (word "cd") (word "foo"))
(command (word "echo") (word "status=$?"))
(command (word "pwd"))
---

=== Change directory in non-shell parent process (make or Python)
# inspired by Perl package bug

old_dir=$(pwd)

mkdir -p cpan/Encode/Byte

# Simulate make changing the dir
wrapped_chdir() {
  #set -- $SH -c 'echo BEFORE; pwd; echo CD; cd Byte; echo AFTER; pwd'

  set -- $SH -c 'cd Byte; pwd'
  # strace comes out the same - one getcwd() and one chdir()
  #set -- strace -e 'getcwd,chdir' "$@"

  python2 -c '
from __future__ import print_function
import os, sys, subprocess

argv = sys.argv[1:]
print("Python PWD = %r" % os.getenv("PWD"), file=sys.stderr)
print("Python argv = %r" % argv, file=sys.stderr)

os.chdir("cpan/Encode")
subprocess.check_call(argv)
' "$@"
}

#wrapped_chdir
new_dir=$(wrapped_chdir)

#echo $old_dir

# Make the test insensitive to absolute paths
echo "${new_dir##$old_dir}"
---
(command (word "old_dir=$(pwd)"))
(command (word "mkdir") (word "-p") (word "cpan/Encode/Byte"))
(function "wrapped_chdir" (brace-group (semi (command (word "set") (word "--") (word "$SH") (word "-c") (word "'cd Byte; pwd'")) (command (word "python2") (word "-c") (word "'\nfrom __future__ import print_function\nimport os, sys, subprocess\n\nargv = sys.argv[1:]\nprint(\"Python PWD = %r\" % os.getenv(\"PWD\"), file=sys.stderr)\nprint(\"Python argv = %r\" % argv, file=sys.stderr)\n\nos.chdir(\"cpan/Encode\")\nsubprocess.check_call(argv)\n'") (word "\"$@\"")))))
(command (word "new_dir=$(wrapped_chdir)"))
(command (word "echo") (word "\"${new_dir##$old_dir}\""))
---

=== What happens when inherited $PWD and current dir disagree?
DIR=/tmp/osh-spec-cd
mkdir -p $DIR
cd $DIR

old_dir=$(pwd)

mkdir -p cpan/Encode/Byte

# Simulate make changing the dir
wrapped_chdir() {
  #set -- $SH -c 'echo BEFORE; pwd; echo CD; cd Byte; echo AFTER; pwd'

  # disagreement before we gert here
  set -- $SH -c '
echo "PWD = $PWD"; pwd
cd Byte; echo cd=$?
echo "PWD = $PWD"; pwd
'

  # strace comes out the same - one getcwd() and one chdir()
  #set -- strace -e 'getcwd,chdir' "$@"

  python2 -c '
from __future__ import print_function
import os, sys, subprocess

argv = sys.argv[1:]
print("Python argv = %r" % argv, file=sys.stderr)

os.chdir("cpan/Encode")
print("Python PWD = %r" % os.getenv("PWD"), file=sys.stdout)
sys.stdout.flush()

subprocess.check_call(argv)
' "$@"
}

#unset PWD
wrapped_chdir
---
(command (word "DIR=/tmp/osh-spec-cd"))
(command (word "mkdir") (word "-p") (word "$DIR"))
(command (word "cd") (word "$DIR"))
(command (word "old_dir=$(pwd)"))
(command (word "mkdir") (word "-p") (word "cpan/Encode/Byte"))
(function "wrapped_chdir" (brace-group (semi (command (word "set") (word "--") (word "$SH") (word "-c") (word "'\necho \"PWD = $PWD\"; pwd\ncd Byte; echo cd=$?\necho \"PWD = $PWD\"; pwd\n'")) (command (word "python2") (word "-c") (word "'\nfrom __future__ import print_function\nimport os, sys, subprocess\n\nargv = sys.argv[1:]\nprint(\"Python argv = %r\" % argv, file=sys.stderr)\n\nos.chdir(\"cpan/Encode\")\nprint(\"Python PWD = %r\" % os.getenv(\"PWD\"), file=sys.stdout)\nsys.stdout.flush()\n\nsubprocess.check_call(argv)\n'") (word "\"$@\"")))))
(command (word "wrapped_chdir"))
---

=== Survey of getcwd() syscall
# This is not that important -- see core/sh_init.py
# Instead of verifying that stat('.') == stat(PWD), which is two sycalls,
# OSH just calls getcwd() unconditionally.

# so C++ leak sanitizer  doesn't print to stderr
export ASAN_OPTIONS='detect_leaks=0'

strace -e getcwd -- $SH -c 'echo hi; pwd; echo $PWD' 1> /dev/null 2> err.txt

wc -l err.txt
#cat err.txt
---
(command (word "export") (word "ASAN_OPTIONS='detect_leaks=0'"))
(command (word "strace") (word "-e") (word "getcwd") (word "--") (word "$SH") (word "-c") (word "'echo hi; pwd; echo $PWD'") (redirect ">" "/dev/null") (redirect ">" "err.txt"))
(command (word "wc") (word "-l") (word "err.txt"))
---

=== chdir is a synonym for cd - busybox ash
chdir /tmp

if test $? -ne 0; then
  echo fail
  exit
fi

pwd

# It's the same with no args, but mksh fails because of $HOME
#chdir
#echo status=$?
---
(command (word "chdir") (word "/tmp"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (semi (command (word "echo") (word "fail")) (command (word "exit"))))
(command (word "pwd"))
---

=== arguments to pwd
pwd /
---
(command (word "pwd") (word "/"))
---

=== pwd errors out on args with strict_arg_parse
shopt -s strict_arg_parse || true
pwd / >/dev/null || echo 'too many args!'
---
(or (command (word "shopt") (word "-s") (word "strict_arg_parse")) (command (word "true")))
(or (command (word "pwd") (word "/") (redirect ">" "/dev/null")) (command (word "echo") (word "'too many args!'")))
---

=== complete with no args and complete -p both print completion spec
set -e

complete

complete -W 'foo bar' mycommand

complete -p

complete -F myfunc other

complete
---
(command (word "set") (word "-e"))
(command (word "complete"))
(command (word "complete") (word "-W") (word "'foo bar'") (word "mycommand"))
(command (word "complete") (word "-p"))
(command (word "complete") (word "-F") (word "myfunc") (word "other"))
(command (word "complete"))
---

=== complete -F f is usage error
#complete -F f cmd

# Alias for complete -p
complete > /dev/null  # ignore OSH output for now
echo status=$?

# But this is an error
complete -F f
echo status=$?
---
(command (word "complete") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "complete") (word "-F") (word "f"))
(command (word "echo") (word "status=$?"))
---

=== complete with nonexistent function
complete -F invalidZZ -D
echo status=$?
---
(command (word "complete") (word "-F") (word "invalidZZ") (word "-D"))
(command (word "echo") (word "status=$?"))
---

=== complete with no action
complete foo
echo status=$?
---
(command (word "complete") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== -A function prints functions
add () { expr 4 + 4; }
div () { expr 6 / 2; }
ek () { echo hello; }
__ec () { echo hi; }
_ab () { expr 10 % 3; }
compgen -A function
echo --
compgen -A function _
---
(function "add" (brace-group (command (word "expr") (word "4") (word "+") (word "4"))))
(function "div" (brace-group (command (word "expr") (word "6") (word "/") (word "2"))))
(function "ek" (brace-group (command (word "echo") (word "hello"))))
(function "__ec" (brace-group (command (word "echo") (word "hi"))))
(function "_ab" (brace-group (command (word "expr") (word "10") (word "%") (word "3"))))
(command (word "compgen") (word "-A") (word "function"))
(command (word "echo") (word "--"))
(command (word "compgen") (word "-A") (word "function") (word "_"))
---

=== Invalid syntax
compgen -A foo
echo status=$?
---
(command (word "compgen") (word "-A") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== how compgen calls completion functions
foo_complete() {
  # first, cur, prev
  argv.py argv "$@"
  argv.py COMP_WORDS "${COMP_WORDS[@]}"
  argv.py COMP_CWORD "${COMP_CWORD}"
  argv.py COMP_LINE "${COMP_LINE}"
  argv.py COMP_POINT "${COMP_POINT}"
  #return 124
  COMPREPLY=(one two three)
}
compgen -F foo_complete foo a b c
---
(function "foo_complete" (brace-group (semi (semi (semi (semi (semi (command (word "argv.py") (word "argv") (word "\"$@\"")) (command (word "argv.py") (word "COMP_WORDS") (word "\"${COMP_WORDS[@]}\""))) (command (word "argv.py") (word "COMP_CWORD") (word "\"${COMP_CWORD}\""))) (command (word "argv.py") (word "COMP_LINE") (word "\"${COMP_LINE}\""))) (command (word "argv.py") (word "COMP_POINT") (word "\"${COMP_POINT}\""))) (command (word "COMPREPLY=(one two three)")))))
(command (word "compgen") (word "-F") (word "foo_complete") (word "foo") (word "a") (word "b") (word "c"))
---

=== complete -o -F (git)
foo() { echo foo; }
wrapper=foo
complete -o default -o nospace -F $wrapper git
---
(function "foo" (brace-group (command (word "echo") (word "foo"))))
(command (word "wrapper=foo"))
(command (word "complete") (word "-o") (word "default") (word "-o") (word "nospace") (word "-F") (word "$wrapper") (word "git"))
---

=== compopt with invalid syntax
compopt -o invalid
echo status=$?
---
(command (word "compopt") (word "-o") (word "invalid"))
(command (word "echo") (word "status=$?"))
---

=== compopt fails when not in completion function
# NOTE: Have to be executing a completion function
compopt -o filenames +o nospace
---
(command (word "compopt") (word "-o") (word "filenames") (word "+o") (word "nospace"))
---

=== compgen -f on invalid  dir
compgen -f /non-existing-dir/
---
(command (word "compgen") (word "-f") (word "/non-existing-dir/"))
---

=== compgen -f
mkdir -p $TMP/compgen
touch $TMP/compgen/{one,two,three}
cd $TMP/compgen
compgen -f | sort
echo --
compgen -f t | sort
---
(command (word "mkdir") (word "-p") (word "$TMP/compgen"))
(command (word "touch") (word "$TMP/compgen/{one,two,three}"))
(command (word "cd") (word "$TMP/compgen"))
(pipe (command (word "compgen") (word "-f")) (command (word "sort")))
(command (word "echo") (word "--"))
(pipe (command (word "compgen") (word "-f") (word "t")) (command (word "sort")))
---

=== compgen -v with local vars
v1_global=0
f() {
  local v2_local=0	 
  compgen -v v
}
f
---
(command (word "v1_global=0"))
(function "f" (brace-group (semi (command (word "local") (word "v2_local=0")) (command (word "compgen") (word "-v") (word "v")))))
(command (word "f"))
---

=== compgen -v on unknown var
compgen -v __nonexistent__
---
(command (word "compgen") (word "-v") (word "__nonexistent__"))
---

=== compgen -v P
cd > /dev/null  # for some reason in bash, this makes PIPESTATUS appear!
compgen -v P | grep -E '^PATH|PWD' | sort
---
(command (word "cd") (redirect ">" "/dev/null"))
(pipe (command (word "compgen") (word "-v") (word "P")) (pipe (command (word "grep") (word "-E") (word "'^PATH|PWD'")) (command (word "sort"))))
---

=== compgen -e with global/local exported vars
export v1_global=0
f() {
  local v2_local=0
  export v2_local
  compgen -e v
}
f
---
(command (word "export") (word "v1_global=0"))
(function "f" (brace-group (semi (semi (command (word "local") (word "v2_local=0")) (command (word "export") (word "v2_local"))) (command (word "compgen") (word "-e") (word "v")))))
(command (word "f"))
---

=== compgen -e on known, but unexported, var
unexported=0
compgen -e unexported
---
(command (word "unexported=0"))
(command (word "compgen") (word "-e") (word "unexported"))
---

=== compgen -e on unknown var
compgen -e __nonexistent__
---
(command (word "compgen") (word "-e") (word "__nonexistent__"))
---

=== compgen -e P
cd > /dev/null  # for some reason in bash, this makes PIPESTATUS appear!
compgen -e P | grep -E '^PATH|PWD' | sort
---
(command (word "cd") (redirect ">" "/dev/null"))
(pipe (command (word "compgen") (word "-e") (word "P")) (pipe (command (word "grep") (word "-E") (word "'^PATH|PWD'")) (command (word "sort"))))
---

=== compgen with actions: function / variable / file
mkdir -p $TMP/compgen2
touch $TMP/compgen2/{PA,Q}_FILE
cd $TMP/compgen2  # depends on previous test above!
PA_FUNC() { echo P; }
Q_FUNC() { echo Q; }
compgen -A function -A variable -A file PA
---
(command (word "mkdir") (word "-p") (word "$TMP/compgen2"))
(command (word "touch") (word "$TMP/compgen2/{PA,Q}_FILE"))
(command (word "cd") (word "$TMP/compgen2"))
(function "PA_FUNC" (brace-group (command (word "echo") (word "P"))))
(function "Q_FUNC" (brace-group (command (word "echo") (word "Q"))))
(command (word "compgen") (word "-A") (word "function") (word "-A") (word "variable") (word "-A") (word "file") (word "PA"))
---

=== compgen with actions: alias, setopt
alias v_alias='ls'
alias v_alias2='ls'
alias a1='ls'
compgen -A alias -A setopt v
---
(command (word "alias") (word "v_alias='ls'"))
(command (word "alias") (word "v_alias2='ls'"))
(command (word "alias") (word "a1='ls'"))
(command (word "compgen") (word "-A") (word "alias") (word "-A") (word "setopt") (word "v"))
---

=== compgen with actions: shopt
compgen -A shopt -P [ -S ] nu
---
(command (word "compgen") (word "-A") (word "shopt") (word "-P") (word "[") (word "-S") (word "]") (word "nu"))
---

=== compgen with action and suffix: helptopic
compgen -A helptopic -S ___ fal
---
(command (word "compgen") (word "-A") (word "helptopic") (word "-S") (word "___") (word "fal"))
---

=== compgen -A directory
cd $REPO_ROOT
compgen -A directory c | sort
---
(command (word "cd") (word "$REPO_ROOT"))
(pipe (command (word "compgen") (word "-A") (word "directory") (word "c")) (command (word "sort")))
---

=== compgen -A file
cd $REPO_ROOT
compgen -A file o | sort
---
(command (word "cd") (word "$REPO_ROOT"))
(pipe (command (word "compgen") (word "-A") (word "file") (word "o")) (command (word "sort")))
---

=== compgen -A user
# no assertion because this isn't hermetic
compgen -A user
---
(command (word "compgen") (word "-A") (word "user"))
---

=== compgen -A command completes external commands
# NOTE: this test isn't hermetic
compgen -A command xarg | uniq
echo status=$?
---
(pipe (command (word "compgen") (word "-A") (word "command") (word "xarg")) (command (word "uniq")))
(command (word "echo") (word "status=$?"))
---

=== compgen -A command completes functions and aliases
our_func() { echo ; }
our_func2() { echo ; }
alias our_alias=foo

compgen -A command our_
echo status=$?

# Introduce another function.  Note that we're missing test coverage for
# 'complete', i.e. bug #1064.
our_func3() { echo ; }

compgen -A command our_
echo status=$?
---
(function "our_func" (brace-group (command (word "echo"))))
(function "our_func2" (brace-group (command (word "echo"))))
(command (word "alias") (word "our_alias=foo"))
(command (word "compgen") (word "-A") (word "command") (word "our_"))
(command (word "echo") (word "status=$?"))
(function "our_func3" (brace-group (command (word "echo"))))
(command (word "compgen") (word "-A") (word "command") (word "our_"))
(command (word "echo") (word "status=$?"))
---

=== compgen -A command completes builtins and keywords
compgen -A command eva
echo status=$?
compgen -A command whil
echo status=$?
---
(command (word "compgen") (word "-A") (word "command") (word "eva"))
(command (word "echo") (word "status=$?"))
(command (word "compgen") (word "-A") (word "command") (word "whil"))
(command (word "echo") (word "status=$?"))
---

=== compgen -k shows the same keywords as bash
# bash adds ]] and } and coproc

# Use bash as an oracle
bash -c 'compgen -k' | sort > bash.txt

# osh vs. bash, or bash vs. bash
$SH -c 'compgen -k' | sort > this-shell.txt

#comm bash.txt this-shell.txt

# show lines in both files
comm -12 bash.txt this-shell.txt | egrep -v 'coproc|select'
---
(pipe (command (word "bash") (word "-c") (word "'compgen -k'")) (command (word "sort") (redirect ">" "bash.txt")))
(pipe (command (word "$SH") (word "-c") (word "'compgen -k'")) (command (word "sort") (redirect ">" "this-shell.txt")))
(pipe (command (word "comm") (word "-12") (word "bash.txt") (word "this-shell.txt")) (command (word "egrep") (word "-v") (word "'coproc|select'")))
---

=== compgen -k shows Oils keywords too
# YSH has a superset of keywords:
# const var
# setvar setglobal
# proc func typed
# call =   # hm = is not here

compgen -k | sort | egrep '^(const|var|setvar|setglobal|proc|func|typed|call|=)$'
echo --
---
(pipe (command (word "compgen") (word "-k")) (pipe (command (word "sort")) (command (word "egrep") (word "'^(const|var|setvar|setglobal|proc|func|typed|call|=)$'"))))
(command (word "echo") (word "--"))
---

=== compgen -k completes reserved shell keywords
compgen -k do | sort
echo status=$?
compgen -k el | sort
echo status=$?
---
(pipe (command (word "compgen") (word "-k") (word "do")) (command (word "sort")))
(command (word "echo") (word "status=$?"))
(pipe (command (word "compgen") (word "-k") (word "el")) (command (word "sort")))
(command (word "echo") (word "status=$?"))
---

=== -o filenames and -o nospace have no effect with compgen
# they are POSTPROCESSING.
compgen -o filenames -o nospace -W 'bin build'
---
(command (word "compgen") (word "-o") (word "filenames") (word "-o") (word "nospace") (word "-W") (word "'bin build'"))
---

=== -o plusdirs and -o dirnames with compgen
cd $REPO_ROOT
compgen -o plusdirs -W 'a b1 b2' b | sort
echo ---
compgen -o dirnames b | sort
---
(command (word "cd") (word "$REPO_ROOT"))
(pipe (command (word "compgen") (word "-o") (word "plusdirs") (word "-W") (word "'a b1 b2'") (word "b")) (command (word "sort")))
(command (word "echo") (word "---"))
(pipe (command (word "compgen") (word "-o") (word "dirnames") (word "b")) (command (word "sort")))
---

=== compgen -o default completes files and dirs
cd $REPO_ROOT
compgen -o default spec/t | sort
---
(command (word "cd") (word "$REPO_ROOT"))
(pipe (command (word "compgen") (word "-o") (word "default") (word "spec/t")) (command (word "sort")))
---

=== compgen doesn't respect -X for user-defined functions
# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
    $SH --rcfile /dev/null -i -c '
shopt -s extglob
fun() {
  COMPREPLY=(one two three bin)
}
compgen -X "@(two|bin)" -F fun
echo --
compgen -X "!@(two|bin)" -F fun
'
esac
---
(case (word "$SH") (pattern ((word "*bash") (word "*osh")) (command (word "$SH") (word "--rcfile") (word "/dev/null") (word "-i") (word "-c") (word "'\nshopt -s extglob\nfun() {\n  COMPREPLY=(one two three bin)\n}\ncompgen -X \"@(two|bin)\" -F fun\necho --\ncompgen -X \"!@(two|bin)\" -F fun\n'"))))
---

=== compgen -W words -X filter
# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
      $SH --rcfile /dev/null -i -c 'shopt -s extglob; compgen -X "@(two|bin)" -W "one two three bin"'
esac
---
(case (word "$SH") (pattern ((word "*bash") (word "*osh")) (command (word "$SH") (word "--rcfile") (word "/dev/null") (word "-i") (word "-c") (word "'shopt -s extglob; compgen -X \"@(two|bin)\" -W \"one two three bin\"'"))))
---

=== compgen -f -X filter -- $cur
cd $TMP
touch spam.py spam.sh
compgen -f -- sp | sort
echo --
# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
      $SH --rcfile /dev/null -i -c 'shopt -s extglob; compgen -f -X "!*.@(py)" -- sp'
esac
---
(command (word "cd") (word "$TMP"))
(command (word "touch") (word "spam.py") (word "spam.sh"))
(pipe (command (word "compgen") (word "-f") (word "--") (word "sp")) (command (word "sort")))
(command (word "echo") (word "--"))
(case (word "$SH") (pattern ((word "*bash") (word "*osh")) (command (word "$SH") (word "--rcfile") (word "/dev/null") (word "-i") (word "-c") (word "'shopt -s extglob; compgen -f -X \"!*.@(py)\" -- sp'"))))
---

=== compgen doesn't need shell quoting
# There is an obsolete comment in bash_completion that claims the opposite.
cd $TMP
touch 'foo bar'
touch "foo'bar"
compgen -f "foo b"
compgen -f "foo'"
---
(command (word "cd") (word "$TMP"))
(command (word "touch") (word "'foo bar'"))
(command (word "touch") (word "\"foo'bar\""))
(command (word "compgen") (word "-f") (word "\"foo b\""))
(command (word "compgen") (word "-f") (word "\"foo'\""))
---

=== compgen -W 'one two three'
cd $REPO_ROOT
compgen -W 'one two three'
echo --
compgen -W 'v1 v2 three' -A directory v
echo --
compgen -A directory -W 'v1 v2 three' v  # order doesn't matter
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "compgen") (word "-W") (word "'one two three'"))
(command (word "echo") (word "--"))
(command (word "compgen") (word "-W") (word "'v1 v2 three'") (word "-A") (word "directory") (word "v"))
(command (word "echo") (word "--"))
(command (word "compgen") (word "-A") (word "directory") (word "-W") (word "'v1 v2 three'") (word "v"))
---

=== compgen -W evaluates code in $()
IFS=':%'
compgen -W '$(echo "spam:eggs%ham cheese")'
---
(command (word "IFS=':%'"))
(command (word "compgen") (word "-W") (word "'$(echo \"spam:eggs%ham cheese\")'"))
---

=== compgen -W uses IFS, and delimiters are escaped with \
IFS=':%'
compgen -W 'spam:eggs%ham cheese\:colon'
---
(command (word "IFS=':%'"))
(command (word "compgen") (word "-W") (word "'spam:eggs%ham cheese\\:colon'"))
---

=== Parse errors for compgen -W and complete -W
# bash doesn't detect as many errors because it lacks static parsing.
compgen -W '${'
echo status=$?
complete -W '${' foo
echo status=$?
---
(command (word "compgen") (word "-W") (word "'${'"))
(command (word "echo") (word "status=$?"))
(command (word "complete") (word "-W") (word "'${'") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== Runtime errors for compgen -W
compgen -W 'foo $(( 1 / 0 )) bar'
echo status=$?
---
(command (word "compgen") (word "-W") (word "'foo $(( 1 / 0 )) bar'"))
(command (word "echo") (word "status=$?"))
---

=== Runtime errors for compgen -F func
_foo() {
  COMPREPLY=( foo bar )
  COMPREPLY+=( $(( 1 / 0 )) )  # FATAL, but we still have candidates
}
compgen -F _foo foo
echo status=$?
---
(function "_foo" (brace-group (semi (command (word "COMPREPLY=(foo bar)")) (command (word "COMPREPLY+=($(( 1 / 0 )))")))))
(command (word "compgen") (word "-F") (word "_foo") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== compgen -W '' cmd is not a usage error
# Bug fix due to '' being falsey in Python
compgen -W '' -- foo
echo status=$?
---
(command (word "compgen") (word "-W") (word "''") (word "--") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== compgen -A builtin
compgen -A builtin g
---
(command (word "compgen") (word "-A") (word "builtin") (word "g"))
---

=== complete -C vs. compgen -C
f() { echo foo; echo bar; }

# Bash prints warnings: -C option may not work as you expect
#                       -F option may not work as you expect
#
# https://unix.stackexchange.com/questions/117987/compgen-warning-c-option-not-working-as-i-expected
#
# compexport fixes this problem, because it invokves ShellFuncAction, whcih
# sets COMP_ARGV, COMP_WORDS, etc.
#
# Should we print a warning?

compgen -C f b
echo compgen=$?

complete -C f b
echo complete=$?
---
(function "f" (brace-group (semi (command (word "echo") (word "foo")) (command (word "echo") (word "bar")))))
(command (word "compgen") (word "-C") (word "f") (word "b"))
(command (word "echo") (word "compgen=$?"))
(command (word "complete") (word "-C") (word "f") (word "b"))
(command (word "echo") (word "complete=$?"))
---

=== compadjust with empty COMP_ARGV
case $SH in bash) exit ;; esac

COMP_ARGV=()
compadjust words
argv.py "${words[@]}"
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "COMP_ARGV=()"))
(command (word "compadjust") (word "words"))
(command (word "argv.py") (word "\"${words[@]}\""))
---

=== compadjust with sparse COMP_ARGV
case $SH in bash) exit ;; esac

COMP_ARGV=({0..9})
unset -v 'COMP_ARGV['{1,3,4,6,7,8}']'
compadjust words
argv.py "${words[@]}"
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "COMP_ARGV=({0..9})"))
(command (word "unset") (word "-v") (word "'COMP_ARGV['{1,3,4,6,7,8}']'"))
(command (word "compadjust") (word "words"))
(command (word "argv.py") (word "\"${words[@]}\""))
---

=== compgen -F with scalar COMPREPLY
_comp_cmd_test() {
  unset -v COMPREPLY
  COMPREPLY=hello
}
compgen -F _comp_cmd_test
---
(function "_comp_cmd_test" (brace-group (semi (command (word "unset") (word "-v") (word "COMPREPLY")) (command (word "COMPREPLY=hello")))))
(command (word "compgen") (word "-F") (word "_comp_cmd_test"))
---

=== pushd/popd
set -o errexit
cd /
pushd /tmp
echo -n pwd=; pwd
popd
echo -n pwd=; pwd
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "cd") (word "/"))
(command (word "pushd") (word "/tmp"))
(semi (command (word "echo") (word "-n") (word "pwd=")) (command (word "pwd")))
(command (word "popd"))
(semi (command (word "echo") (word "-n") (word "pwd=")) (command (word "pwd")))
---

=== pushd usage
pushd -z
echo status=$?
pushd /tmp >/dev/null
echo status=$?
pushd -- /tmp >/dev/null
echo status=$?
---
(command (word "pushd") (word "-z"))
(command (word "echo") (word "status=$?"))
(command (word "pushd") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "pushd") (word "--") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== popd usage error
pushd / >/dev/null
popd zzz
echo status=$?

popd -- >/dev/null
echo status=$?

popd -z
echo status=$?
---
(command (word "pushd") (word "/") (redirect ">" "/dev/null"))
(command (word "popd") (word "zzz"))
(command (word "echo") (word "status=$?"))
(command (word "popd") (word "--") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "popd") (word "-z"))
(command (word "echo") (word "status=$?"))
---

=== popd returns error on empty directory stack
message=$(popd 2>&1)
echo $?
echo "$message" | grep -o "directory stack"
---
(command (word "message=$(popd 2>&1)"))
(command (word "echo") (word "$?"))
(pipe (command (word "echo") (word "\"$message\"")) (command (word "grep") (word "-o") (word "\"directory stack\"")))
---

=== cd replaces the lowest entry on the directory stack!
# stable temp dir
dir=/tmp/oils-spec/builtin-dirs

mkdir -p $dir
cd $dir

pushd /tmp >/dev/null
echo pushd=$?

dirs

cd /
echo cd=$?

dirs

popd >/dev/null
echo popd=$?

popd >/dev/null
echo popd=$?
---
(command (word "dir=/tmp/oils-spec/builtin-dirs"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "pushd") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "pushd=$?"))
(command (word "dirs"))
(command (word "cd") (word "/"))
(command (word "echo") (word "cd=$?"))
(command (word "dirs"))
(command (word "popd") (redirect ">" "/dev/null"))
(command (word "echo") (word "popd=$?"))
(command (word "popd") (redirect ">" "/dev/null"))
(command (word "echo") (word "popd=$?"))
---

=== dirs builtin
cd /
dirs
---
(command (word "cd") (word "/"))
(command (word "dirs"))
---

=== dirs -c to clear the stack
set -o errexit
cd /
pushd /tmp >/dev/null  # zsh pushd doesn't print anything, but bash does
echo --
dirs
dirs -c
echo --
dirs
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "cd") (word "/"))
(command (word "pushd") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "--"))
(command (word "dirs"))
(command (word "dirs") (word "-c"))
(command (word "echo") (word "--"))
(command (word "dirs"))
---

=== dirs -v to print numbered stack, one entry per line
set -o errexit
cd /
pushd /tmp >/dev/null
echo --
dirs -v
pushd /dev >/dev/null
echo --
dirs -v
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "cd") (word "/"))
(command (word "pushd") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "--"))
(command (word "dirs") (word "-v"))
(command (word "pushd") (word "/dev") (redirect ">" "/dev/null"))
(command (word "echo") (word "--"))
(command (word "dirs") (word "-v"))
---

=== dirs -p to print one entry per line
set -o errexit
cd /
pushd /tmp >/dev/null
echo --
dirs -p
pushd /dev >/dev/null
echo --
dirs -p
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "cd") (word "/"))
(command (word "pushd") (word "/tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "--"))
(command (word "dirs") (word "-p"))
(command (word "pushd") (word "/dev") (redirect ">" "/dev/null"))
(command (word "echo") (word "--"))
(command (word "dirs") (word "-p"))
---

=== dirs -l to print in long format, no tilde prefix
# Can't use the OSH test harness for this because
# /home/<username> may be included in a path.
cd /
HOME=/tmp
mkdir -p $HOME/oil_test
pushd $HOME/oil_test >/dev/null
dirs
dirs -l
---
(command (word "cd") (word "/"))
(command (word "HOME=/tmp"))
(command (word "mkdir") (word "-p") (word "$HOME/oil_test"))
(command (word "pushd") (word "$HOME/oil_test") (redirect ">" "/dev/null"))
(command (word "dirs"))
(command (word "dirs") (word "-l"))
---

=== dirs to print using tilde-prefix format
cd /
HOME=/tmp
mkdir -p $HOME/oil_test
pushd $HOME/oil_test >/dev/null
dirs
---
(command (word "cd") (word "/"))
(command (word "HOME=/tmp"))
(command (word "mkdir") (word "-p") (word "$HOME/oil_test"))
(command (word "pushd") (word "$HOME/oil_test") (redirect ">" "/dev/null"))
(command (word "dirs"))
---

=== dirs test converting true home directory to tilde
cd /
HOME=/tmp
mkdir -p $HOME/oil_test/$HOME
pushd $HOME/oil_test/$HOME >/dev/null
dirs
---
(command (word "cd") (word "/"))
(command (word "HOME=/tmp"))
(command (word "mkdir") (word "-p") (word "$HOME/oil_test/$HOME"))
(command (word "pushd") (word "$HOME/oil_test/$HOME") (redirect ">" "/dev/null"))
(command (word "dirs"))
---

=== dirs don't convert to tilde when $HOME is substring
cd /
mkdir -p /tmp/oil_test
mkdir -p /tmp/oil_tests
HOME=/tmp/oil_test
pushd /tmp/oil_tests
dirs

#### dirs tilde test when $HOME is exactly $PWD
cd /
mkdir -p /tmp/oil_test
HOME=/tmp/oil_test
pushd $HOME
dirs
---
(command (word "cd") (word "/"))
(command (word "mkdir") (word "-p") (word "/tmp/oil_test"))
(command (word "mkdir") (word "-p") (word "/tmp/oil_tests"))
(command (word "HOME=/tmp/oil_test"))
(command (word "pushd") (word "/tmp/oil_tests"))
(command (word "dirs"))
(command (word "cd") (word "/"))
(command (word "mkdir") (word "-p") (word "/tmp/oil_test"))
(command (word "HOME=/tmp/oil_test"))
(command (word "pushd") (word "$HOME"))
(command (word "dirs"))
---

=== dirs test of path alias `..`
cd /tmp
pushd .. >/dev/null
dirs
---
(command (word "cd") (word "/tmp"))
(command (word "pushd") (word "..") (redirect ">" "/dev/null"))
(command (word "dirs"))
---

=== dirs test of path alias `.`
cd /tmp
pushd . >/dev/null
dirs
---
(command (word "cd") (word "/tmp"))
(command (word "pushd") (word ".") (redirect ">" "/dev/null"))
(command (word "dirs"))
---

=== pushd does not take more than one argument
pushd . . >/dev/null || echo too many args!
---
(or (command (word "pushd") (word ".") (word ".") (redirect ">" "/dev/null")) (command (word "echo") (word "too") (word "many") (word "args!")))
---

=== dirs does not take arguments
dirs a || echo failed
dirs -l a || echo failed
---
(or (command (word "dirs") (word "a")) (command (word "echo") (word "failed")))
(or (command (word "dirs") (word "-l") (word "a")) (command (word "echo") (word "failed")))
---

=== echo dashes
echo -
echo --
echo ---
---
(command (word "echo") (word "-"))
(command (word "echo") (word "--"))
(command (word "echo") (word "---"))
---

=== echo backslashes
echo \\
echo '\'
echo '\\'
echo "\\"
---
(command (word "echo") (word "\\\\"))
(command (word "echo") (word "'\\'"))
(command (word "echo") (word "'\\\\'"))
(command (word "echo") (word "\"\\\\\""))
---

=== echo -e backslashes
echo -e \\
echo -e '\'
echo -e '\\'
echo -e "\\"
echo

# backslash at end of line
echo -e '\
line2'
---
(command (word "echo") (word "-e") (word "\\\\"))
(command (word "echo") (word "-e") (word "'\\'"))
(command (word "echo") (word "-e") (word "'\\\\'"))
(command (word "echo") (word "-e") (word "\"\\\\\""))
(command (word "echo"))
(command (word "echo") (word "-e") (word "'\\\nline2'"))
---

=== echo -en
echo -en 'abc\ndef\n'
---
(command (word "echo") (word "-en") (word "'abc\\ndef\\n'"))
---

=== echo -ez (invalid flag)
# bash differs from the other three shells, but its behavior is possibly more
# sensible, if you're going to ignore the error.  It doesn't make sense for
# the 'e' to mean 2 different things simultaneously: flag and literal to be
# printed.
echo -ez 'abc\n'
---
(command (word "echo") (word "-ez") (word "'abc\\n'"))
---

=== echo -e with embedded newline
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'foo
bar'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "'foo\nbar'"))
---

=== echo -e line continuation
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'foo\
bar'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "'foo\\\nbar'"))
---

=== echo -e with C escapes
# https://www.gnu.org/software/bash/manual/bashref.html#Bourne-Shell-Builtins
# not sure why \c is like NUL?
# zsh doesn't allow \E for some reason.
echo -e '\a\b\d\e\f'
---
(command (word "echo") (word "-e") (word "'\\a\\b\\d\\e\\f'"))
---

=== echo -e with whitespace C escapes
echo -e '\n\r\t\v'
---
(command (word "echo") (word "-e") (word "'\\n\\r\\t\\v'"))
---

=== \0
echo -e 'ab\0cd'
---
(command (word "echo") (word "-e") (word "'ab\\0cd'"))
---

=== \c stops processing input
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags xy  'ab\cde'  'zzz'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "xy") (word "'ab\\cde'") (word "'zzz'"))
---

=== echo -e with hex escape
echo -e 'abcd\x65f'
---
(command (word "echo") (word "-e") (word "'abcd\\x65f'"))
---

=== echo -e with octal escape
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\044e'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "'abcd\\044e'"))
---

=== echo -e with 4 digit unicode escape
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\u0065f'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "'abcd\\u0065f'"))
---

=== echo -e with 8 digit unicode escape
flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\U00000065f'
---
(command (word "flags='-e'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags=''"))))
(command (word "echo") (word "$flags") (word "'abcd\\U00000065f'"))
---

=== \0377 is the highest octal byte
echo -en '\03777' | od -A n -t x1 | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-en") (word "'\\03777'")) (pipe (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== \0400 is one more than the highest octal byte
# It is 256 % 256 which gets interpreted as a NUL byte.
echo -en '\04000' | od -A n -t x1 | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-en") (word "'\\04000'")) (pipe (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== \0777 is out of range
flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\0777' | od -A n -t x1 | sed 's/ \+/ /g'
---
(command (word "flags='-en'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags='-n'"))))
(pipe (command (word "echo") (word "$flags") (word "'\\0777'")) (pipe (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== incomplete hex escape
echo -en 'abcd\x6' | od -A n -c | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-en") (word "'abcd\\x6'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== \x
# I consider mksh and zsh a bug because \x is not an escape
echo -e '\x' '\xg' | od -A n -c | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-e") (word "'\\x'") (word "'\\xg'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== incomplete octal escape
flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags 'abcd\04' | od -A n -c | sed 's/ \+/ /g'
---
(command (word "flags='-en'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags='-n'"))))
(pipe (command (word "echo") (word "$flags") (word "'abcd\\04'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== incomplete unicode escape
echo -en 'abcd\u006' | od -A n -c | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-en") (word "'abcd\\u006'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== \u6
flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\u6' | od -A n -c | sed 's/ \+/ /g'
---
(command (word "flags='-en'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags='-n'"))))
(pipe (command (word "echo") (word "$flags") (word "'\\u6'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== \0 \1 \8
# \0 is special, but \1 isn't in bash
# \1 is special in dash!  geez
flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\0' '\1' '\8' | od -A n -c | sed 's/ \+/ /g'
---
(command (word "flags='-en'"))
(case (word "$SH") (pattern ((word "dash")) (command (word "flags='-n'"))))
(pipe (command (word "echo") (word "$flags") (word "'\\0'") (word "'\\1'") (word "'\\8'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== echo to redirected directory is an error
mkdir -p dir

echo foo > ./dir
echo status=$?
printf foo > ./dir
echo status=$?
---
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "echo") (word "foo") (redirect ">" "./dir"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "foo") (redirect ">" "./dir"))
(command (word "echo") (word "status=$?"))
---

=== Eval
eval "a=3"
echo $a
---
(command (word "eval") (word "\"a=3\""))
(command (word "echo") (word "$a"))
---

=== eval accepts/ignores --
eval -- echo hi
---
(command (word "eval") (word "--") (word "echo") (word "hi"))
---

=== eval usage
eval -
echo $?
eval -z
echo $?
---
(command (word "eval") (word "-"))
(command (word "echo") (word "$?"))
(command (word "eval") (word "-z"))
(command (word "echo") (word "$?"))
---

=== eval string with 'break continue return error'
set -e

sh_func_that_evals() {
  local code_str=$1
  for i in 1 2; do
    echo $i
    eval "$code_str"
  done
  echo 'end func'
}

for code_str in break continue return false; do
  echo "--- $code_str"
  sh_func_that_evals "$code_str"
done
echo status=$?
---
(command (word "set") (word "-e"))
(function "sh_func_that_evals" (brace-group (semi (semi (command (word "local") (word "code_str=$1")) (for (word "i") (in (word "1") (word "2")) (semi (command (word "echo") (word "$i")) (command (word "eval") (word "\"$code_str\""))))) (command (word "echo") (word "'end func'")))))
(for (word "code_str") (in (word "break") (word "continue") (word "return") (word "false")) (semi (command (word "echo") (word "\"--- $code_str\"")) (command (word "sh_func_that_evals") (word "\"$code_str\""))))
(command (word "echo") (word "status=$?"))
---

=== exit within eval (regression)
eval 'exit 42'
echo 'should not get here'
---
(command (word "eval") (word "'exit 42'"))
(command (word "echo") (word "'should not get here'"))
---

=== exit within source (regression)
cd $TMP
echo 'exit 42' > lib.sh
. ./lib.sh
echo 'should not get here'
---
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "'exit 42'") (redirect ">" "lib.sh"))
(command (word ".") (word "./lib.sh"))
(command (word "echo") (word "'should not get here'"))
---

=== Source
lib=$TMP/spec-test-lib.sh
echo 'LIBVAR=libvar' > $lib
. $lib  # dash doesn't have source
echo $LIBVAR
---
(command (word "lib=$TMP/spec-test-lib.sh"))
(command (word "echo") (word "'LIBVAR=libvar'") (redirect ">" "$lib"))
(command (word ".") (word "$lib"))
(command (word "echo") (word "$LIBVAR"))
---

=== source accepts/ignores --
echo 'echo foo' > $TMP/foo.sh
source -- $TMP/foo.sh
---
(command (word "echo") (word "'echo foo'") (redirect ">" "$TMP/foo.sh"))
(command (word "source") (word "--") (word "$TMP/foo.sh"))
---

=== Source nonexistent
source /nonexistent/path
echo status=$?
---
(command (word "source") (word "/nonexistent/path"))
(command (word "echo") (word "status=$?"))
---

=== Source with no arguments
source
echo status=$?
---
(command (word "source"))
(command (word "echo") (word "status=$?"))
---

=== Source with arguments
. $REPO_ROOT/spec/testdata/show-argv.sh foo bar  # dash doesn't have source
---
(command (word ".") (word "$REPO_ROOT/spec/testdata/show-argv.sh") (word "foo") (word "bar"))
---

=== Source from a function, mutating argv and defining a local var
f() {
  . $REPO_ROOT/spec/testdata/source-argv.sh              # no argv
  . $REPO_ROOT/spec/testdata/source-argv.sh args to src  # new argv
  echo $@
  echo foo=$foo  # defined in source-argv.sh
}
f args to func
echo foo=$foo  # not defined
---
(function "f" (brace-group (semi (semi (semi (command (word ".") (word "$REPO_ROOT/spec/testdata/source-argv.sh")) (command (word ".") (word "$REPO_ROOT/spec/testdata/source-argv.sh") (word "args") (word "to") (word "src"))) (command (word "echo") (word "$@"))) (command (word "echo") (word "foo=$foo")))))
(command (word "f") (word "args") (word "to") (word "func"))
(command (word "echo") (word "foo=$foo"))
---

=== Source with syntax error
# TODO: We should probably use dash behavior of a fatal error.
# Although set-o errexit handles this.  We don't want to break the invariant
# that a builtin like 'source' behaves like an external program.  An external
# program can't halt the shell!
echo 'echo >' > $TMP/syntax-error.sh
. $TMP/syntax-error.sh
echo status=$?
---
(command (word "echo") (word "'echo >'") (redirect ">" "$TMP/syntax-error.sh"))
(command (word ".") (word "$TMP/syntax-error.sh"))
(command (word "echo") (word "status=$?"))
---

=== Eval with syntax error
eval 'echo >'
echo status=$?
---
(command (word "eval") (word "'echo >'"))
(command (word "echo") (word "status=$?"))
---

=== Eval in does tilde expansion
x="~"
eval y="$x"  # scalar
test "$x" = "$y" || echo FALSE
[[ $x == /* ]] || echo FALSE  # doesn't start with /
[[ $y == /* ]] && echo TRUE

#argv "$x" "$y"
---
(command (word "x=\"~\""))
(command (word "eval") (word "y=\"$x\""))
(or (command (word "test") (word "\"$x\"") (word "=") (word "\"$y\"")) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "$x") (cond-term "/*"))) (command (word "echo") (word "FALSE")))
(and (cond (cond-binary "==" (cond-term "$y") (cond-term "/*"))) (command (word "echo") (word "TRUE")))
---

=== Eval in bash does tilde expansion in array
# the "make" plugin in bash-completion relies on this?  wtf?
x="~"

# UPSTREAM CODE

#eval array=( "$x" )

# FIXED CODE -- proper quoting.

eval 'array=(' "$x" ')'  # array

test "$x" = "${array[0]}" || echo FALSE
[[ $x == /* ]] || echo FALSE  # doesn't start with /
[[ "${array[0]}" == /* ]] && echo TRUE
---
(command (word "x=\"~\""))
(command (word "eval") (word "'array=('") (word "\"$x\"") (word "')'"))
(or (command (word "test") (word "\"$x\"") (word "=") (word "\"${array[0]}\"")) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "$x") (cond-term "/*"))) (command (word "echo") (word "FALSE")))
(and (cond (cond-binary "==" (cond-term ""${array[0]}"") (cond-term "/*"))) (command (word "echo") (word "TRUE")))
---

=== source works for files in current directory (bash only)
cd $TMP
echo "echo current dir" > cmd
. cmd
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "\"echo current dir\"") (redirect ">" "cmd"))
(command (word ".") (word "cmd"))
(command (word "echo") (word "status=$?"))
---

=== source looks in PATH for files
mkdir -p dir
echo "echo hi" > dir/cmd
PATH="dir:$PATH"
. cmd
rm dir/cmd
---
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "echo") (word "\"echo hi\"") (redirect ">" "dir/cmd"))
(command (word "PATH=\"dir:$PATH\""))
(command (word ".") (word "cmd"))
(command (word "rm") (word "dir/cmd"))
---

=== source finds files in PATH before current dir
cd $TMP
mkdir -p dir
echo "echo path" > dir/cmd
echo "echo current dir" > cmd
PATH="dir:$PATH"
. cmd
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "echo") (word "\"echo path\"") (redirect ">" "dir/cmd"))
(command (word "echo") (word "\"echo current dir\"") (redirect ">" "cmd"))
(command (word "PATH=\"dir:$PATH\""))
(command (word ".") (word "cmd"))
(command (word "echo") (word "status=$?"))
---

=== source works for files in subdirectory
mkdir -p dir
echo "echo path" > dir/cmd
. dir/cmd
rm dir/cmd
---
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "echo") (word "\"echo path\"") (redirect ">" "dir/cmd"))
(command (word ".") (word "dir/cmd"))
(command (word "rm") (word "dir/cmd"))
---

=== source doesn't crash when targeting a directory
cd $TMP
mkdir -p dir
. ./dir/
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "mkdir") (word "-p") (word "dir"))
(command (word ".") (word "./dir/"))
(command (word "echo") (word "status=$?"))
---

=== sourcing along PATH should ignore directories
mkdir -p _tmp/shell
mkdir -p _tmp/dir/hello.sh
printf 'echo hi' >_tmp/shell/hello.sh

DIR=$PWD/_tmp/dir
SHELL=$PWD/_tmp/shell

# Should find the file hello.sh right away and source it
PATH="$SHELL:$PATH" . hello.sh
echo status=$?

# Should fail because hello.sh cannot be found
PATH="$DIR:$SHELL:$PATH" . hello.sh
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp/shell"))
(command (word "mkdir") (word "-p") (word "_tmp/dir/hello.sh"))
(command (word "printf") (word "'echo hi'") (redirect ">" "_tmp/shell/hello.sh"))
(command (word "DIR=$PWD/_tmp/dir"))
(command (word "SHELL=$PWD/_tmp/shell"))
(command (word "PATH=\"$SHELL:$PATH\"") (word ".") (word "hello.sh"))
(command (word "echo") (word "status=$?"))
(command (word "PATH=\"$DIR:$SHELL:$PATH\"") (word ".") (word "hello.sh"))
(command (word "echo") (word "status=$?"))
---

=== fc -l lists history commands
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -ln lists history commands without numbers
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -ln
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -ln\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -lr lists history commands in reverse order
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lr
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -lr\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -lnr lists history commands without numbers in reverse order
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lnr
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -lnr\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l lists history commands with default page size
printf "echo %s\n" {1..16} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..16}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l [first] where first is an index
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l 2\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l [first] where first is an offset from current command
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l -3
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l -3\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l [first] [last] where first and last are indexes
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 2 3
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l 2 3\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l [first] [last] where first and last are offsets from current command
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l -3 -2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l -3 -2\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -l [first] [last] where first and last are reversed indexes
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 3 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -l 3 2\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc -lr [first] [last] where first and last are reversed indexes does not undo reverse
printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lr 3 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(pipe (command (word "echo") (word "'\nHISTFILE=tmp\nhistory -c\nhistory -r\n\nfc -lr 3 2\n'")) (command (word "$SH") (word "--norc") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== fc ignores too many args
fc -l 0 1 2 || echo too many args!
---
(or (command (word "fc") (word "-l") (word "0") (word "1") (word "2")) (command (word "echo") (word "too") (word "many") (word "args!")))
---

=== fc errors out on too many args with strict_arg_parse
shopt -s strict_arg_parse || true
fc -l 0 1 2 || echo too many args!
---
(or (command (word "shopt") (word "-s") (word "strict_arg_parse")) (command (word "true")))
(or (command (word "fc") (word "-l") (word "0") (word "1") (word "2")) (command (word "echo") (word "too") (word "many") (word "args!")))
---

=== fc -l when no history is present
fc -l
---
(command (word "fc") (word "-l"))
---

=== getopts empty
set -- 
getopts 'a:' opt
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--"))
(command (word "getopts") (word "'a:'") (word "opt"))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts sees unknown arg
set -- -Z
getopts 'a:' opt
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--") (word "-Z"))
(command (word "getopts") (word "'a:'") (word "opt"))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts three invocations
set -- -h -c foo
getopts 'hc:' opt
echo status=$? opt=$opt
getopts 'hc:' opt
echo status=$? opt=$opt
getopts 'hc:' opt
echo status=$? opt=$opt
---
(command (word "set") (word "--") (word "-h") (word "-c") (word "foo"))
(command (word "getopts") (word "'hc:'") (word "opt"))
(command (word "echo") (word "status=$?") (word "opt=$opt"))
(command (word "getopts") (word "'hc:'") (word "opt"))
(command (word "echo") (word "status=$?") (word "opt=$opt"))
(command (word "getopts") (word "'hc:'") (word "opt"))
(command (word "echo") (word "status=$?") (word "opt=$opt"))
---

=== getopts resets OPTARG
set -- -c foo -h
getopts 'hc:' opt
echo status=$? opt=$opt OPTARG=$OPTARG
getopts 'hc:' opt
echo status=$? opt=$opt OPTARG=$OPTARG
---
(command (word "set") (word "--") (word "-c") (word "foo") (word "-h"))
(command (word "getopts") (word "'hc:'") (word "opt"))
(command (word "echo") (word "status=$?") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "'hc:'") (word "opt"))
(command (word "echo") (word "status=$?") (word "opt=$opt") (word "OPTARG=$OPTARG"))
---

=== OPTARG is empty (not unset) after parsing a flag doesn't take an arg
set -u
getopts 'ab' name '-a'
echo name=$name
echo OPTARG=$OPTARG
---
(command (word "set") (word "-u"))
(command (word "getopts") (word "'ab'") (word "name") (word "'-a'"))
(command (word "echo") (word "name=$name"))
(command (word "echo") (word "OPTARG=$OPTARG"))
---

=== Basic getopts invocation
set -- -h -c foo x y z
FLAG_h=0
FLAG_c=''
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
shift $(( OPTIND - 1 ))
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@
---
(command (word "set") (word "--") (word "-h") (word "-c") (word "foo") (word "x") (word "y") (word "z"))
(command (word "FLAG_h=0"))
(command (word "FLAG_c=''"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\"")))))
(command (word "shift") (word "$(( OPTIND - 1 ))"))
(command (word "echo") (word "h=$FLAG_h") (word "c=$FLAG_c") (word "optind=$OPTIND") (word "argv=$@"))
---

=== getopts with invalid variable name
set -- -c foo -h
getopts 'hc:' opt-
echo status=$? opt=$opt OPTARG=$OPTARG OPTIND=$OPTIND
---
(command (word "set") (word "--") (word "-c") (word "foo") (word "-h"))
(command (word "getopts") (word "'hc:'") (word "opt-"))
(command (word "echo") (word "status=$?") (word "opt=$opt") (word "OPTARG=$OPTARG") (word "OPTIND=$OPTIND"))
---

=== getopts with invalid flag
set -- -h -x
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?
---
(command (word "set") (word "--") (word "-h") (word "-x"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\""))) (pattern ((word "'?'")) (semi (command (word "echo") (word "ERROR") (word "$OPTIND")) (command (word "exit") (word "2"))))))
(command (word "echo") (word "status=$?"))
---

=== getopts with with -
set -- -h -
echo "$@"
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?
---
(command (word "set") (word "--") (word "-h") (word "-"))
(command (word "echo") (word "\"$@\""))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\""))) (pattern ((word "'?'")) (semi (command (word "echo") (word "ERROR") (word "$OPTIND")) (command (word "exit") (word "2"))))))
(command (word "echo") (word "status=$?"))
---

=== getopts missing required argument
set -- -h -c
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?
---
(command (word "set") (word "--") (word "-h") (word "-c"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\""))) (pattern ((word "'?'")) (semi (command (word "echo") (word "ERROR") (word "$OPTIND")) (command (word "exit") (word "2"))))))
(command (word "echo") (word "status=$?"))
---

=== getopts doesn't look for flags after args
set -- x -h -c y
FLAG_h=0
FLAG_c=''
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
shift $(( OPTIND - 1 ))
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@
---
(command (word "set") (word "--") (word "x") (word "-h") (word "-c") (word "y"))
(command (word "FLAG_h=0"))
(command (word "FLAG_c=''"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\"")))))
(command (word "shift") (word "$(( OPTIND - 1 ))"))
(command (word "echo") (word "h=$FLAG_h") (word "c=$FLAG_c") (word "optind=$OPTIND") (word "argv=$@"))
---

=== getopts with explicit args
# NOTE: Alpine doesn't appear to use this, but bash-completion does.
FLAG_h=0
FLAG_c=''
arg=''
set -- A B C
while getopts "hc:" opt -h -c foo x y z; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@
---
(command (word "FLAG_h=0"))
(command (word "FLAG_c=''"))
(command (word "arg=''"))
(command (word "set") (word "--") (word "A") (word "B") (word "C"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt") (word "-h") (word "-c") (word "foo") (word "x") (word "y") (word "z")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\"")))))
(command (word "echo") (word "h=$FLAG_h") (word "c=$FLAG_c") (word "optind=$OPTIND") (word "argv=$@"))
---

=== OPTIND
echo $OPTIND
---
(command (word "echo") (word "$OPTIND"))
---

=== OPTIND after multiple getopts with same spec
while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set -- -h -c foo x y z
while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set --
while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND
---
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (command (word "echo") (word "'-'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
(command (word "set") (word "--") (word "-h") (word "-c") (word "foo") (word "x") (word "y") (word "z"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (command (word "echo") (word "'-'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
(command (word "set") (word "--"))
(while (command (word "getopts") (word "\"hc:\"") (word "opt")) (command (word "echo") (word "'-'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
---

=== OPTIND after multiple getopts with different spec
# Wow this is poorly specified!  A fundamental design problem with the global
# variable OPTIND.
set -- -a
while getopts "ab:" opt; do
  echo '.'
done
echo OPTIND=$OPTIND

set -- -c -d -e foo
while getopts "cde:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set -- -f
while getopts "f:" opt; do
  echo '_'
done
echo OPTIND=$OPTIND
---
(command (word "set") (word "--") (word "-a"))
(while (command (word "getopts") (word "\"ab:\"") (word "opt")) (command (word "echo") (word "'.'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
(command (word "set") (word "--") (word "-c") (word "-d") (word "-e") (word "foo"))
(while (command (word "getopts") (word "\"cde:\"") (word "opt")) (command (word "echo") (word "'-'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
(command (word "set") (word "--") (word "-f"))
(while (command (word "getopts") (word "\"f:\"") (word "opt")) (command (word "echo") (word "'_'")))
(command (word "echo") (word "OPTIND=$OPTIND"))
---

=== OPTIND narrowed down
FLAG_a=
FLAG_b=
FLAG_c=
FLAG_d=
FLAG_e=
set -- -a
while getopts "ab:" opt; do
  case $opt in
    a) FLAG_a=1 ;;
    b) FLAG_b="$OPTARG" ;;
  esac
done
# Bash doesn't reset OPTIND!  It skips over c!  mksh at least warns about this!
# You have to reset OPTIND yourself.

set -- -c -d -e E
while getopts "cde:" opt; do
  case $opt in
    c) FLAG_c=1 ;;
    d) FLAG_d=1 ;;
    e) FLAG_e="$OPTARG" ;;
  esac
done

echo a=$FLAG_a b=$FLAG_b c=$FLAG_c d=$FLAG_d e=$FLAG_e
---
(command (word "FLAG_a="))
(command (word "FLAG_b="))
(command (word "FLAG_c="))
(command (word "FLAG_d="))
(command (word "FLAG_e="))
(command (word "set") (word "--") (word "-a"))
(while (command (word "getopts") (word "\"ab:\"") (word "opt")) (case (word "$opt") (pattern ((word "a")) (command (word "FLAG_a=1"))) (pattern ((word "b")) (command (word "FLAG_b=\"$OPTARG\"")))))
(command (word "set") (word "--") (word "-c") (word "-d") (word "-e") (word "E"))
(while (command (word "getopts") (word "\"cde:\"") (word "opt")) (case (word "$opt") (pattern ((word "c")) (command (word "FLAG_c=1"))) (pattern ((word "d")) (command (word "FLAG_d=1"))) (pattern ((word "e")) (command (word "FLAG_e=\"$OPTARG\"")))))
(command (word "echo") (word "a=$FLAG_a") (word "b=$FLAG_b") (word "c=$FLAG_c") (word "d=$FLAG_d") (word "e=$FLAG_e"))
---

=== Getopts parses the function's arguments
FLAG_h=0
FLAG_c=''
myfunc() {
  while getopts "hc:" opt; do
    case $opt in
      h) FLAG_h=1 ;;
      c) FLAG_c="$OPTARG" ;;
    esac
  done
}
set -- -h -c foo x y z
myfunc -c bar
echo h=$FLAG_h c=$FLAG_c opt=$opt optind=$OPTIND argv=$@
---
(command (word "FLAG_h=0"))
(command (word "FLAG_c=''"))
(function "myfunc" (brace-group (while (command (word "getopts") (word "\"hc:\"") (word "opt")) (case (word "$opt") (pattern ((word "h")) (command (word "FLAG_h=1"))) (pattern ((word "c")) (command (word "FLAG_c=\"$OPTARG\"")))))))
(command (word "set") (word "--") (word "-h") (word "-c") (word "foo") (word "x") (word "y") (word "z"))
(command (word "myfunc") (word "-c") (word "bar"))
(command (word "echo") (word "h=$FLAG_h") (word "c=$FLAG_c") (word "opt=$opt") (word "optind=$OPTIND") (word "argv=$@"))
---

=== Local OPTIND
# minimal test case extracted from bash-completion
min() {
  local OPTIND=1

  while getopts "n:e:o:i:s" flag "$@"; do
    echo "loop $OPTIND";
  done
}
min -s
---
(function "min" (brace-group (semi (command (word "local") (word "OPTIND=1")) (while (command (word "getopts") (word "\"n:e:o:i:s\"") (word "flag") (word "\"$@\"")) (command (word "echo") (word "\"loop $OPTIND\""))))))
(command (word "min") (word "-s"))
---

=== two flags: -ab
getopts "ab" opt -ab
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab" opt -ab
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
---
(command (word "getopts") (word "\"ab\"") (word "opt") (word "-ab"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"ab\"") (word "opt") (word "-ab"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
---

=== flag and arg: -c10
getopts "c:" opt -c10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "c:" opt -c10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
---
(command (word "getopts") (word "\"c:\"") (word "opt") (word "-c10"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"c:\"") (word "opt") (word "-c10"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
---

=== More Smooshing 1
getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
---
(command (word "getopts") (word "\"ab:c:\"") (word "opt") (word "-ab") (word "hi") (word "-c") (word "hello"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"ab:c:\"") (word "opt") (word "-ab") (word "hi") (word "-c") (word "hello"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"ab:c:\"") (word "opt") (word "-ab") (word "hi") (word "-c") (word "hello"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
---

=== More Smooshing 2
getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
---
(command (word "getopts") (word "\"abc:\"") (word "opt") (word "-abc10"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"abc:\"") (word "opt") (word "-abc10"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
(command (word "getopts") (word "\"abc:\"") (word "opt") (word "-abc10"))
(command (word "echo") (word "OPTIND=$OPTIND") (word "opt=$opt") (word "OPTARG=$OPTARG"))
---

=== OPTIND should be >= 1 (regression)
OPTIND=-1
getopts a: foo
echo status=$?

OPTIND=0
getopts a: foo
echo status=$?
---
(command (word "OPTIND=-1"))
(command (word "getopts") (word "a:") (word "foo"))
(command (word "echo") (word "status=$?"))
(command (word "OPTIND=0"))
(command (word "getopts") (word "a:") (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== getopts bug #1523
$SH $REPO_ROOT/spec/testdata/getopts-1523.sh -abcdef -abcde
---
(command (word "$SH") (word "$REPO_ROOT/spec/testdata/getopts-1523.sh") (word "-abcdef") (word "-abcde"))
---

=== More regression for #1523
$SH $REPO_ROOT/spec/testdata/getopts-1523.sh -abcdef -xyz
---
(command (word "$SH") (word "$REPO_ROOT/spec/testdata/getopts-1523.sh") (word "-abcdef") (word "-xyz"))
---

=== getopts silent error reporting - invalid option
# Leading : in optspec enables silent mode: OPTARG=option char, no error msg
set -- -Z
getopts ':a:' opt 2>&1
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--") (word "-Z"))
(command (word "getopts") (word "':a:'") (word "opt") (redirect ">&" 1))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts silent error reporting - missing required argument
# Silent mode returns ':' and sets OPTARG to option char
set -- -a
getopts ':a:' opt 2>&1
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--") (word "-a"))
(command (word "getopts") (word "':a:'") (word "opt") (redirect ">&" 1))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts normal mode - invalid option (compare with silent)
# Normal mode: OPTARG is empty, prints error message
set -- -Z
getopts 'a:' opt 2>/dev/null
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--") (word "-Z"))
(command (word "getopts") (word "'a:'") (word "opt") (redirect ">" "/dev/null"))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts normal mode - missing required argument (compare with silent)
# Normal mode returns '?', OPTARG is empty
set -- -a
getopts 'a:' opt 2>/dev/null
echo "status=$? opt=$opt OPTARG=$OPTARG"
---
(command (word "set") (word "--") (word "-a"))
(command (word "getopts") (word "'a:'") (word "opt") (redirect ">" "/dev/null"))
(command (word "echo") (word "\"status=$? opt=$opt OPTARG=$OPTARG\""))
---

=== getopts handles '--' #2579
set -- "-a" "--"
while getopts "a" name; do
        case "$name" in
                a)
                        echo "a"
                        ;;
                ?)
                        echo "?"
                        ;;
        esac
done
echo "name=$name"
echo "$OPTIND"
---
(command (word "set") (word "--") (word "\"-a\"") (word "\"--\""))
(while (command (word "getopts") (word "\"a\"") (word "name")) (case (word "\"$name\"") (pattern ((word "a")) (command (word "echo") (word "\"a\""))) (pattern ((word "?")) (command (word "echo") (word "\"?\"")))))
(command (word "echo") (word "\"name=$name\""))
(command (word "echo") (word "\"$OPTIND\""))
---

=== getopts leaves all args after '--' as operands #2579
set -- "-a" "--" "-c" "operand"
while getopts "a" name; do
    case "$name" in
        a)
            echo "a"
            ;;
        c)
            echo "c"
            ;;
        ?)
            echo "?"
            ;;
    esac
done
shift $((OPTIND - 1))
echo "$#"
echo "$@"
---
(command (word "set") (word "--") (word "\"-a\"") (word "\"--\"") (word "\"-c\"") (word "\"operand\""))
(while (command (word "getopts") (word "\"a\"") (word "name")) (case (word "\"$name\"") (pattern ((word "a")) (command (word "echo") (word "\"a\""))) (pattern ((word "c")) (command (word "echo") (word "\"c\""))) (pattern ((word "?")) (command (word "echo") (word "\"?\"")))))
(command (word "shift") (word "$((OPTIND - 1))"))
(command (word "echo") (word "\"$#\""))
(command (word "echo") (word "\"$@\""))
---

=== history -a
rm -f tmp

echo '
history -c

HISTFILE=tmp
echo 1
history -a
cat tmp

echo 2

cat tmp
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "rm") (word "-f") (word "tmp"))
(pipe (command (word "echo") (word "'\nhistory -c\n\nHISTFILE=tmp\necho 1\nhistory -a\ncat tmp\n\necho 2\n\ncat tmp\n'")) (command (word "$SH") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== history -w writes out the in-memory history to the history file
cd $TMP

# Populate a history file with a command to be overwritten
echo 'cmd old' > tmp
HISTFILE=tmp
history -c
echo 'cmd new' > /dev/null
history -w # Overwrite history file

# Verify that old command is gone
grep 'old' tmp > /dev/null
echo "found=$?"
---
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "'cmd old'") (redirect ">" "tmp"))
(command (word "HISTFILE=tmp"))
(command (word "history") (word "-c"))
(command (word "echo") (word "'cmd new'") (redirect ">" "/dev/null"))
(command (word "history") (word "-w"))
(command (word "grep") (word "'old'") (word "tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "\"found=$?\""))
---

=== history -r reads from the history file, and appends it to the current history
cd $TMP
printf "cmd orig%s\n" {1..10} > tmp
HISTFILE=tmp

history -c

history -r
history -r

history | grep orig | wc -l
---
(command (word "cd") (word "$TMP"))
(command (word "printf") (word "\"cmd orig%s\\n\"") (word "{1..10}") (redirect ">" "tmp"))
(command (word "HISTFILE=tmp"))
(command (word "history") (word "-c"))
(command (word "history") (word "-r"))
(command (word "history") (word "-r"))
(pipe (command (word "history")) (pipe (command (word "grep") (word "orig")) (command (word "wc") (word "-l"))))
---

=== history -n reads *new* commands from the history file, and appends them to the current history
# NB: Based on line ranges, not contents

cd $TMP

printf "cmd orig%s\n" {1..10} > tmp1
cp tmp1 tmp2
printf "cmd new%s\n" {1..10} >> tmp2

history -c
HISTFILE=tmp1 history -r
HISTFILE=tmp2 history -n

history | grep orig | wc -l
history | grep new | wc -l
---
(command (word "cd") (word "$TMP"))
(command (word "printf") (word "\"cmd orig%s\\n\"") (word "{1..10}") (redirect ">" "tmp1"))
(command (word "cp") (word "tmp1") (word "tmp2"))
(command (word "printf") (word "\"cmd new%s\\n\"") (word "{1..10}") (redirect ">>" "tmp2"))
(command (word "history") (word "-c"))
(command (word "HISTFILE=tmp1") (word "history") (word "-r"))
(command (word "HISTFILE=tmp2") (word "history") (word "-n"))
(pipe (command (word "history")) (pipe (command (word "grep") (word "orig")) (command (word "wc") (word "-l"))))
(pipe (command (word "history")) (pipe (command (word "grep") (word "new")) (command (word "wc") (word "-l"))))
---

=== history -c clears in-memory history
$SH --norc -i <<'EOF'
echo 'foo' > /dev/null
echo 'bar' > /dev/null
history -c 
history | wc -l
EOF

case $SH in bash) echo '^D' ;; esac
---
(command (word "$SH") (word "--norc") (word "-i") (redirect "<<" "echo 'foo' > /dev/null
echo 'bar' > /dev/null
history -c 
history | wc -l
"))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== history -d to delete 1 item
cd $TMP
HISTFILE=tmp
printf "cmd orig%s\n" {1..3} > tmp
history -c
history -r
history -d 1
history | grep orig1 > /dev/null
echo "status=$?"
---
(command (word "cd") (word "$TMP"))
(command (word "HISTFILE=tmp"))
(command (word "printf") (word "\"cmd orig%s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(command (word "history") (word "-c"))
(command (word "history") (word "-r"))
(command (word "history") (word "-d") (word "1"))
(pipe (command (word "history")) (command (word "grep") (word "orig1") (redirect ">" "/dev/null")))
(command (word "echo") (word "\"status=$?\""))
---

=== history -d to delete history from end
# bash 4 doesn't support negative indices or ranges

rm -f myhist
export HISTFILE=myhist

$SH --norc -i <<'EOF'

echo 42
echo 43
echo 44

history -a

history -d 1
echo status=$?

# Invalid integers
history -d -1
echo status=$?
history -d -2
echo status=$?
history -d 99
echo status=$?

case $SH in bash*) echo '^D' ;; esac

EOF
---
(command (word "rm") (word "-f") (word "myhist"))
(command (word "export") (word "HISTFILE=myhist"))
(command (word "$SH") (word "--norc") (word "-i") (redirect "<<" "
echo 42
echo 43
echo 44

history -a

history -d 1
echo status=$?

# Invalid integers
history -d -1
echo status=$?
history -d -2
echo status=$?
history -d 99
echo status=$?

case $SH in bash*) echo '^D' ;; esac

"))
---

=== HISTFILE is defined initially
echo '
if test -n $HISTFILE; then echo exists; fi
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(pipe (command (word "echo") (word "'\nif test -n $HISTFILE; then echo exists; fi\n'")) (command (word "$SH") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== HISTFILE must point to a file
rm -f _tmp/does-not-exist

echo '
HISTFILE=_tmp/does-not-exist
history -r
echo status=$?
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "rm") (word "-f") (word "_tmp/does-not-exist"))
(pipe (command (word "echo") (word "'\nHISTFILE=_tmp/does-not-exist\nhistory -r\necho status=$?\n'")) (command (word "$SH") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== HISTFILE set to array
echo '
HISTFILE=(a b c)
history -a
echo status=$?
' | $SH -i

case $SH in bash) echo '^D' ;; esac

# note that bash actually writes the file 'a', since that's ${HISTFILE[0]} 
---
(pipe (command (word "echo") (word "'\nHISTFILE=(a b c)\nhistory -a\necho status=$?\n'")) (command (word "$SH") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== HISTFILE unset
echo '
unset HISTFILE
history -a
echo status=$?
' | $SH -i

case $SH in bash) echo '^D' ;; esac
---
(pipe (command (word "echo") (word "'\nunset HISTFILE\nhistory -a\necho status=$?\n'")) (command (word "$SH") (word "-i")))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== history usage
history not-a-number
echo status=$?

history 3 too-many
echo status=$?
---
(command (word "history") (word "not-a-number"))
(command (word "echo") (word "status=$?"))
(command (word "history") (word "3") (word "too-many"))
(command (word "echo") (word "status=$?"))
---

=== HISTSIZE shrinks the in-memory history when changed
cd $TMP
printf "cmd %s\n" {1..10} > tmp
HISTFILE=tmp
history -c
history -r
history | wc -l
HISTSIZE=5
history | wc -l
---
(command (word "cd") (word "$TMP"))
(command (word "printf") (word "\"cmd %s\\n\"") (word "{1..10}") (redirect ">" "tmp"))
(command (word "HISTFILE=tmp"))
(command (word "history") (word "-c"))
(command (word "history") (word "-r"))
(pipe (command (word "history")) (command (word "wc") (word "-l")))
(command (word "HISTSIZE=5"))
(pipe (command (word "history")) (command (word "wc") (word "-l")))
---

=== HISTFILESIZE shrinks the history file when changed
cd $TMP
printf "cmd %s\n" {1..10} > tmp
HISTFILE=tmp
HISTFILESIZE=5
cat tmp | wc -l
---
(command (word "cd") (word "$TMP"))
(command (word "printf") (word "\"cmd %s\\n\"") (word "{1..10}") (redirect ">" "tmp"))
(command (word "HISTFILE=tmp"))
(command (word "HISTFILESIZE=5"))
(pipe (command (word "cat") (word "tmp")) (command (word "wc") (word "-l")))
---

=== recording history can be toggled with set -o/+o history
cd $TMP
printf "echo %s\n" {1..3} > tmp
HISTFILE=tmp $SH -i <<'EOF'
set +o history
echo "not recorded" >> /dev/null
set -o history
echo "recorded" >> /dev/null
EOF

case $SH in bash) echo '^D' ;; esac

grep "not recorded" tmp >> /dev/null
echo status=$?
grep "recorded" tmp >> /dev/null
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "printf") (word "\"echo %s\\n\"") (word "{1..3}") (redirect ">" "tmp"))
(command (word "HISTFILE=tmp") (word "$SH") (word "-i") (redirect "<<" "set +o history
echo "not recorded" >> /dev/null
set -o history
echo "recorded" >> /dev/null
"))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
(command (word "grep") (word "\"not recorded\"") (word "tmp") (redirect ">>" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "grep") (word "\"recorded\"") (word "tmp") (redirect ">>" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== shopt histappend toggle check
shopt -s histappend
echo status=$?
shopt -p histappend
shopt -u histappend
echo status=$?
shopt -p histappend

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac
---
(command (word "shopt") (word "-s") (word "histappend"))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-p") (word "histappend"))
(command (word "shopt") (word "-u") (word "histappend"))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-p") (word "histappend"))
(case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'"))))
---

=== shopt histappend - osh ignores shopt and appends, bash sometimes overwrites
# When set, bash always appends when exiting, no matter what. 
# When unset, bash will append anyway as long the # of new commands < the hist length
# Either way, the file is truncated to HISTFILESIZE afterwards.
# osh always appends

cd $TMP 

export HISTSIZE=10
export HISTFILESIZE=1000
export HISTFILE=tmp

histappend_test() {
  local histopt
  if [[ "$1" == true ]]; then
    histopt='shopt -s histappend'
  else
    histopt='shopt -u histappend'
  fi

  printf "cmd orig%s\n" {1..10} > tmp

  $SH --norc -i <<EOF
  HISTSIZE=2 # Stifle the history down to 2 commands
  $histopt
  # Now run >2 commands to trigger bash's overwrite behavior
  echo cmd new1 > /dev/null
  echo cmd new2 > /dev/null
  echo cmd new3 > /dev/null
EOF

  case $SH in bash) echo '^D' ;; esac
}

# If we force histappend, bash won't overwrite the history file
histappend_test true
grep "orig" tmp > /dev/null
echo status=$?

# If we don't force histappend, bash will overwrite the history file when the number of cmds exceeds HISTSIZE
histappend_test false
grep "orig" tmp > /dev/null
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "export") (word "HISTSIZE=10"))
(command (word "export") (word "HISTFILESIZE=1000"))
(command (word "export") (word "HISTFILE=tmp"))
(function "histappend_test" (brace-group (semi (semi (semi (semi (command (word "local") (word "histopt")) (if (cond (cond-binary "==" (cond-term ""$1"") (cond-term "true"))) (command (word "histopt='shopt -s histappend'")) (command (word "histopt='shopt -u histappend'")))) (command (word "printf") (word "\"cmd orig%s\\n\"") (word "{1..10}") (redirect ">" "tmp"))) (command (word "$SH") (word "--norc") (word "-i") (redirect "<<" "  HISTSIZE=2 # Stifle the history down to 2 commands
  $histopt
  # Now run >2 commands to trigger bash's overwrite behavior
  echo cmd new1 > /dev/null
  echo cmd new2 > /dev/null
  echo cmd new3 > /dev/null
"))) (case (word "$SH") (pattern ((word "bash")) (command (word "echo") (word "'^D'")))))))
(command (word "histappend_test") (word "true"))
(command (word "grep") (word "\"orig\"") (word "tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "histappend_test") (word "false"))
(command (word "grep") (word "\"orig\"") (word "tmp") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== kill -15 kills the process with SIGTERM
case $SH in mksh) exit ;; esac  # mksh is flaky

sleep 0.1 &
pid=$!
kill -15 $pid
echo kill=$?

wait $pid
echo wait=$?  # 143 is 128 + SIGTERM
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-15") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill -KILL kills the process with SIGKILL
sleep 0.1 & 
pid=$!
kill -KILL $pid 
echo kill=$?

wait $pid
echo wait=$?  # 137 is 128 + SIGKILL
---
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-KILL") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill -n 9 specifies the signal number
#case $SH in mksh|dash) exit ;; esac

sleep 0.1 &
pid=$!
kill -n 9 $pid
echo kill=$?

wait $pid
echo wait=$?
---
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-n") (word "9") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill -s TERM specifies the signal name
sleep 0.1 &
pid=$!
kill -s TERM $pid
echo kill=$?

wait $pid
echo wait=$?
---
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-s") (word "TERM") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill -terM -SigterM isn't case sensitive
case $SH in mksh|dash|zsh) exit ;; esac

sleep 0.1 &
pid=$!
kill -SigterM $pid
echo kill=$?
wait $pid
echo wait=$?

sleep 0.1 &
pid=$!
kill -terM $pid
echo kill=$?
wait $pid
echo wait=$?
---
(case (word "$SH") (pattern ((word "mksh") (word "dash") (word "zsh")) (command (word "exit"))))
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-SigterM") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-terM") (word "$pid"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill HUP pid gives the correct error
case $SH in dash) exit ;; esac
sleep 0.1 &
builtin kill HUP $pid
echo $?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(background (command (word "sleep") (word "0.1")))
(command (word "builtin") (word "kill") (word "HUP") (word "$pid"))
(command (word "echo") (word "$?"))
---

=== kill -l shows signals
case $SH in dash) exit ;; esac

# Check if at least the HUP flag is reported.  The output format of all shells
# is different and the available signals may depend on your environment

builtin kill -l | grep HUP > /dev/null
echo $?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(pipe (command (word "builtin") (word "kill") (word "-l")) (command (word "grep") (word "HUP") (redirect ">" "/dev/null")))
(command (word "echo") (word "$?"))
---

=== kill -L also shows signals
case $SH in mksh|dash|zsh) exit ;; esac

builtin kill -L | grep HUP > /dev/null
echo $?
---
(case (word "$SH") (pattern ((word "mksh") (word "dash") (word "zsh")) (command (word "exit"))))
(pipe (command (word "builtin") (word "kill") (word "-L")) (command (word "grep") (word "HUP") (redirect ">" "/dev/null")))
(command (word "echo") (word "$?"))
---

=== kill -l 10 TERM translates between names and numbers
case $SH in mksh|dash) exit ;; esac

builtin kill -l 10 11 12
echo status=$?
echo

builtin kill -l SIGUSR1 SIGSEGV USR2
echo status=$?
echo

# mixed kind
builtin kill -l 10 SIGSEGV 12
echo status=$?
echo
---
(case (word "$SH") (pattern ((word "mksh") (word "dash")) (command (word "exit"))))
(command (word "builtin") (word "kill") (word "-l") (word "10") (word "11") (word "12"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "builtin") (word "kill") (word "-l") (word "SIGUSR1") (word "SIGSEGV") (word "USR2"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "builtin") (word "kill") (word "-l") (word "10") (word "SIGSEGV") (word "12"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
---

=== kill -L checks for invalid input
case $SH in mksh|dash) exit ;; esac

builtin kill -L 10 BAD 12
echo status=$?
echo

builtin kill -L USR1 9999 USR2
echo status=$?
echo
---
(case (word "$SH") (pattern ((word "mksh") (word "dash")) (command (word "exit"))))
(command (word "builtin") (word "kill") (word "-L") (word "10") (word "BAD") (word "12"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "builtin") (word "kill") (word "-L") (word "USR1") (word "9999") (word "USR2"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
---

=== kill -l with exit code
kill -l 134 # 128 + 6 (ABRT)
---
(command (word "kill") (word "-l") (word "134"))
---

=== kill -l with 128 is invalid
kill -l 128
if [ $? -ne 0 ]; then
    echo "invalid"
fi
---
(command (word "kill") (word "-l") (word "128"))
(if (command (word "[") (word "$?") (word "-ne") (word "0") (word "]")) (command (word "echo") (word "\"invalid\"")))
---

=== kill -l 0 returns EXIT
kill -l 0
---
(command (word "kill") (word "-l") (word "0"))
---

=== kill -l 0 INT lists both signals
kill -l 0 INT
---
(command (word "kill") (word "-l") (word "0") (word "INT"))
---

=== kill -9999 is an invalid signal
case $SH in dash)  exit ;; esac
sleep 0.1 &
pid=$!
kill -9999 $pid > /dev/null
echo kill=$?

wait $pid
echo wait=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(command (word "kill") (word "-9999") (word "$pid") (redirect ">" "/dev/null"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "$pid"))
(command (word "echo") (word "wait=$?"))
---

=== kill -15 %% kills current job
#case $SH in mksh|dash) exit ;; esac

sleep 0.5 &
pid=$!
kill -15 %%
echo kill=$?

wait %%
echo wait=$?

# no such job
wait %%
echo wait=$?
---
(background (command (word "sleep") (word "0.5")))
(command (word "pid=$!"))
(command (word "kill") (word "-15") (word "%%"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "%%"))
(command (word "echo") (word "wait=$?"))
(command (word "wait") (word "%%"))
(command (word "echo") (word "wait=$?"))
---

=== kill -15 %- kills previous job
#case $SH in mksh|dash) exit ;; esac

sleep 0.1 &  # previous job
sleep 0.2 &  # current job

kill -15 %-
echo kill=$?

wait %-
echo wait=$?

# what does bash define here as the previous job?  May be a bug
#wait %-
#echo wait=$?
---
(background (command (word "sleep") (word "0.1")))
(background (command (word "sleep") (word "0.2")))
(command (word "kill") (word "-15") (word "%-"))
(command (word "echo") (word "kill=$?"))
(command (word "wait") (word "%-"))
(command (word "echo") (word "wait=$?"))
---

=== kill multiple pids at once
sleep 0.1 &
pid1=$!
sleep 0.1 &
pid2=$!
sleep 0.1 &
pid3=$!

kill $pid1 $pid2 $pid3
echo $?
---
(background (command (word "sleep") (word "0.1")))
(command (word "pid1=$!"))
(background (command (word "sleep") (word "0.1")))
(command (word "pid2=$!"))
(background (command (word "sleep") (word "0.1")))
(command (word "pid3=$!"))
(command (word "kill") (word "$pid1") (word "$pid2") (word "$pid3"))
(command (word "echo") (word "$?"))
---

=== kill pid and job at once
sleep 0.1 &
pid=$!
sleep 0.1 &
kill %2 $pid
echo $?
---
(background (command (word "sleep") (word "0.1")))
(command (word "pid=$!"))
(background (command (word "sleep") (word "0.1")))
(command (word "kill") (word "%2") (word "$pid"))
(command (word "echo") (word "$?"))
---

=== Numeric signal out of range - OSH may send it anyway
sleep 0.1 &

# OSH doesn't validate this, but that could be useful for non-portable signals,
# which we don't have a name for.

kill -s 9999 %%
echo kill=$?

wait
echo wait=$?
---
(background (command (word "sleep") (word "0.1")))
(command (word "kill") (word "-s") (word "9999") (word "%%"))
(command (word "echo") (word "kill=$?"))
(command (word "wait"))
(command (word "echo") (word "wait=$?"))
---

=== builtin declare a=(x y) is allowed
case $SH in dash|zsh|mksh|ash) exit ;; esac

$SH -c 'declare a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi

$SH -c 'builtin declare a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi

$SH -c 'builtin declare -a a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "$SH") (word "-c") (word "'declare a=(x y); declare -p a'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'fail'")))
(command (word "$SH") (word "-c") (word "'builtin declare a=(x y); declare -p a'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'fail'")))
(command (word "$SH") (word "-c") (word "'builtin declare -a a=(x y); declare -p a'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'fail'")))
---

=== command export,readonly
case $SH in zsh) exit ;; esac

# dash doesn't have declare typeset

command export c=export
echo c=$c

command readonly c=readonly
echo c=$c

echo --

command command export cc=export
echo cc=$cc

command command readonly cc=readonly
echo cc=$cc
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "command") (word "export") (word "c=export"))
(command (word "echo") (word "c=$c"))
(command (word "command") (word "readonly") (word "c=readonly"))
(command (word "echo") (word "c=$c"))
(command (word "echo") (word "--"))
(command (word "command") (word "command") (word "export") (word "cc=export"))
(command (word "echo") (word "cc=$cc"))
(command (word "command") (word "command") (word "readonly") (word "cc=readonly"))
(command (word "echo") (word "cc=$cc"))
---

=== command local
f() {
  command local s=local
  echo s=$s
}

f
---
(function "f" (brace-group (semi (command (word "command") (word "local") (word "s=local")) (command (word "echo") (word "s=$s")))))
(command (word "f"))
---

=== export, builtin export
x='a b'

export y=$x
echo $y

builtin export z=$x
echo $z
---
(command (word "x='a b'"))
(command (word "export") (word "y=$x"))
(command (word "echo") (word "$y"))
(command (word "builtin") (word "export") (word "z=$x"))
(command (word "echo") (word "$z"))
---

=== \builtin declare - ble.sh relies on it
case $SH in dash|mksh|ash) exit ;; esac

x='a b'

builtin declare c=$x
echo $c

\builtin declare d=$x
echo $d

'builtin' declare e=$x
echo $e

b=builtin
$b declare f=$x
echo $f

b=b
${b}uiltin declare g=$x
echo $g
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "x='a b'"))
(command (word "builtin") (word "declare") (word "c=$x"))
(command (word "echo") (word "$c"))
(command (word "\\builtin") (word "declare") (word "d=$x"))
(command (word "echo") (word "$d"))
(command (word "'builtin'") (word "declare") (word "e=$x"))
(command (word "echo") (word "$e"))
(command (word "b=builtin"))
(command (word "$b") (word "declare") (word "f=$x"))
(command (word "echo") (word "$f"))
(command (word "b=b"))
(command (word "${b}uiltin") (word "declare") (word "g=$x"))
(command (word "echo") (word "$g"))
---

=== \command readonly - similar issue
case $SH in zsh) exit ;; esac

# \command readonly is equivalent to \builtin declare
# except dash implements it

x='a b'

readonly b=$x
echo $b

command readonly c=$x
echo $c

\command readonly d=$x
echo $d

'command' readonly e=$x
echo $e

# The issue here is that we have a heuristic in EvalWordSequence2:
# fs len(part_vals) == 1
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "x='a b'"))
(command (word "readonly") (word "b=$x"))
(command (word "echo") (word "$b"))
(command (word "command") (word "readonly") (word "c=$x"))
(command (word "echo") (word "$c"))
(command (word "\\command") (word "readonly") (word "d=$x"))
(command (word "echo") (word "$d"))
(command (word "'command'") (word "readonly") (word "e=$x"))
(command (word "echo") (word "$e"))
---

=== Dynamic $c readonly - bash and dash change behavior, mksh bug
case $SH in zsh) exit ;; esac

x='a b'

z=command
$z readonly c=$x
echo $c

z=c
${z}ommand readonly d=$x
echo $d
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "x='a b'"))
(command (word "z=command"))
(command (word "$z") (word "readonly") (word "c=$x"))
(command (word "echo") (word "$c"))
(command (word "z=c"))
(command (word "${z}ommand") (word "readonly") (word "d=$x"))
(command (word "echo") (word "$d"))
---

=== static builtin command ASSIGN, command builtin ASSIGN
case $SH in dash|ash|zsh) exit ;; esac

# dash doesn't have declare typeset

builtin command export bc=export
echo bc=$bc

builtin command readonly bc=readonly
echo bc=$bc

echo --

command builtin export cb=export
echo cb=$cb

command builtin readonly cb=readonly
echo cb=$cb
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "zsh")) (command (word "exit"))))
(command (word "builtin") (word "command") (word "export") (word "bc=export"))
(command (word "echo") (word "bc=$bc"))
(command (word "builtin") (word "command") (word "readonly") (word "bc=readonly"))
(command (word "echo") (word "bc=$bc"))
(command (word "echo") (word "--"))
(command (word "command") (word "builtin") (word "export") (word "cb=export"))
(command (word "echo") (word "cb=$cb"))
(command (word "command") (word "builtin") (word "readonly") (word "cb=readonly"))
(command (word "echo") (word "cb=$cb"))
---

=== dynamic builtin command ASSIGN, command builtin ASSIGN
case $SH in dash|ash|zsh) exit ;; esac

b=builtin
c=command
e=export
r=readonly

$b $c export bc=export
echo bc=$bc

$b $c readonly bc=readonly
echo bc=$bc

echo --

$c $b export cb=export
echo cb=$cb

$c $b readonly cb=readonly
echo cb=$cb

echo --

$b $c $e bce=export
echo bce=$bce

$b $c $r bcr=readonly
echo bcr=$bcr

echo --

$c $b $e cbe=export
echo cbe=$cbe

$c $b $r cbr=readonly
echo cbr=$cbr
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "zsh")) (command (word "exit"))))
(command (word "b=builtin"))
(command (word "c=command"))
(command (word "e=export"))
(command (word "r=readonly"))
(command (word "$b") (word "$c") (word "export") (word "bc=export"))
(command (word "echo") (word "bc=$bc"))
(command (word "$b") (word "$c") (word "readonly") (word "bc=readonly"))
(command (word "echo") (word "bc=$bc"))
(command (word "echo") (word "--"))
(command (word "$c") (word "$b") (word "export") (word "cb=export"))
(command (word "echo") (word "cb=$cb"))
(command (word "$c") (word "$b") (word "readonly") (word "cb=readonly"))
(command (word "echo") (word "cb=$cb"))
(command (word "echo") (word "--"))
(command (word "$b") (word "$c") (word "$e") (word "bce=export"))
(command (word "echo") (word "bce=$bce"))
(command (word "$b") (word "$c") (word "$r") (word "bcr=readonly"))
(command (word "echo") (word "bcr=$bcr"))
(command (word "echo") (word "--"))
(command (word "$c") (word "$b") (word "$e") (word "cbe=export"))
(command (word "echo") (word "cbe=$cbe"))
(command (word "$c") (word "$b") (word "$r") (word "cbr=readonly"))
(command (word "echo") (word "cbr=$cbr"))
---

=== builtin typeset, export,readonly
case $SH in dash|ash) exit ;; esac

builtin typeset s=typeset
echo s=$s

builtin export s=export
echo s=$s

builtin readonly s=readonly
echo s=$s

echo --

builtin builtin typeset s2=typeset
echo s2=$s2

builtin builtin export s2=export
echo s2=$s2

builtin builtin readonly s2=readonly
echo s2=$s2
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(command (word "builtin") (word "typeset") (word "s=typeset"))
(command (word "echo") (word "s=$s"))
(command (word "builtin") (word "export") (word "s=export"))
(command (word "echo") (word "s=$s"))
(command (word "builtin") (word "readonly") (word "s=readonly"))
(command (word "echo") (word "s=$s"))
(command (word "echo") (word "--"))
(command (word "builtin") (word "builtin") (word "typeset") (word "s2=typeset"))
(command (word "echo") (word "s2=$s2"))
(command (word "builtin") (word "builtin") (word "export") (word "s2=export"))
(command (word "echo") (word "s2=$s2"))
(command (word "builtin") (word "builtin") (word "readonly") (word "s2=readonly"))
(command (word "echo") (word "s2=$s2"))
---

=== builtin declare,local
case $SH in dash|ash|mksh) exit ;; esac

builtin declare s=declare
echo s=$s

f() {
  builtin local s=local
  echo s=$s
}

f
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "mksh")) (command (word "exit"))))
(command (word "builtin") (word "declare") (word "s=declare"))
(command (word "echo") (word "s=$s"))
(function "f" (brace-group (semi (command (word "builtin") (word "local") (word "s=local")) (command (word "echo") (word "s=$s")))))
(command (word "f"))
---

=== command -v
myfunc() { echo x; }
command -v echo
echo $?

command -v myfunc
echo $?

command -v nonexistent  # doesn't print anything
echo nonexistent=$?

command -v ''  # BUG FIX, shouldn't succeed
echo empty=$?

command -v for
echo $?
---
(function "myfunc" (brace-group (command (word "echo") (word "x"))))
(command (word "command") (word "-v") (word "echo"))
(command (word "echo") (word "$?"))
(command (word "command") (word "-v") (word "myfunc"))
(command (word "echo") (word "$?"))
(command (word "command") (word "-v") (word "nonexistent"))
(command (word "echo") (word "nonexistent=$?"))
(command (word "command") (word "-v") (word "''"))
(command (word "echo") (word "empty=$?"))
(command (word "command") (word "-v") (word "for"))
(command (word "echo") (word "$?"))
---

=== command -v executable, builtin
#command -v grep ls

command -v grep | egrep -o '/[^/]+$'
command -v ls | egrep -o '/[^/]+$'
echo

command -v true
command -v eval
---
(pipe (command (word "command") (word "-v") (word "grep")) (command (word "egrep") (word "-o") (word "'/[^/]+$'")))
(pipe (command (word "command") (word "-v") (word "ls")) (command (word "egrep") (word "-o") (word "'/[^/]+$'")))
(command (word "echo"))
(command (word "command") (word "-v") (word "true"))
(command (word "command") (word "-v") (word "eval"))
---

=== command -v with multiple names
# ALL FOUR SHELLS behave differently here!
#
# bash chooses to swallow the error!  We agree with zsh if ANY word lookup
# fails, then the whole thing fails.

myfunc() { echo x; }
command -v echo myfunc ZZZ for
echo status=$?
---
(function "myfunc" (brace-group (command (word "echo") (word "x"))))
(command (word "command") (word "-v") (word "echo") (word "myfunc") (word "ZZZ") (word "for"))
(command (word "echo") (word "status=$?"))
---

=== command -v doesn't find non-executable file
# PATH resolution is different

mkdir -p _tmp
PATH="_tmp:$PATH"
touch _tmp/non-executable _tmp/executable
chmod +x _tmp/executable

command -v _tmp/non-executable
echo status=$?

command -v _tmp/executable
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "PATH=\"_tmp:$PATH\""))
(command (word "touch") (word "_tmp/non-executable") (word "_tmp/executable"))
(command (word "chmod") (word "+x") (word "_tmp/executable"))
(command (word "command") (word "-v") (word "_tmp/non-executable"))
(command (word "echo") (word "status=$?"))
(command (word "command") (word "-v") (word "_tmp/executable"))
(command (word "echo") (word "status=$?"))
---

=== command -v doesn't find executable dir
mkdir -p _tmp
PATH="_tmp:$PATH"
mkdir _tmp/cat

command -v _tmp/cat
echo status=$?
command -v cat
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "PATH=\"_tmp:$PATH\""))
(command (word "mkdir") (word "_tmp/cat"))
(command (word "command") (word "-v") (word "_tmp/cat"))
(command (word "echo") (word "status=$?"))
(command (word "command") (word "-v") (word "cat"))
(command (word "echo") (word "status=$?"))
---

=== command -V
myfunc() { echo x; }

shopt -s expand_aliases
alias ll='ls -l'

backtick=\`
command -V ll | sed "s/$backtick/'/g"
echo status=$?

command -V echo
echo status=$?

# Paper over insignificant difference
command -V myfunc | sed 's/shell function/function/'
echo status=$?

command -V nonexistent  # doesn't print anything
echo status=$?

command -V for
echo status=$?
---
(function "myfunc" (brace-group (command (word "echo") (word "x"))))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "ll='ls -l'"))
(command (word "backtick=\\`"))
(pipe (command (word "command") (word "-V") (word "ll")) (command (word "sed") (word "\"s/$backtick/'/g\"")))
(command (word "echo") (word "status=$?"))
(command (word "command") (word "-V") (word "echo"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "command") (word "-V") (word "myfunc")) (command (word "sed") (word "'s/shell function/function/'")))
(command (word "echo") (word "status=$?"))
(command (word "command") (word "-V") (word "nonexistent"))
(command (word "echo") (word "status=$?"))
(command (word "command") (word "-V") (word "for"))
(command (word "echo") (word "status=$?"))
---

=== command -V nonexistent
command -V nonexistent 2>err.txt
echo status=$?
fgrep -o 'nonexistent: not found' err.txt || true
---
(command (word "command") (word "-V") (word "nonexistent") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(or (command (word "fgrep") (word "-o") (word "'nonexistent: not found'") (word "err.txt")) (command (word "true")))
---

=== command skips function lookup
seq() {
  echo "$@"
}
command  # no-op
seq 3
command seq 3
# subshell shouldn't fork another process (but we don't have a good way of
# testing it)
( command seq 3 )
---
(function "seq" (brace-group (command (word "echo") (word "\"$@\""))))
(command (word "command"))
(command (word "seq") (word "3"))
(command (word "command") (word "seq") (word "3"))
(subshell (command (word "command") (word "seq") (word "3")))
---

=== command command seq 3
command command seq 3
---
(command (word "command") (word "command") (word "seq") (word "3"))
---

=== command command -v seq
seq() {
  echo 3
}
command command -v seq
---
(function "seq" (brace-group (command (word "echo") (word "3"))))
(command (word "command") (word "command") (word "-v") (word "seq"))
---

=== command -p (override existing program)
# Tests whether command -p overrides the path
# tr chosen because we need a simple non-builtin
mkdir -p $TMP/bin
echo "echo wrong" > $TMP/bin/tr
chmod +x $TMP/bin/tr
PATH="$TMP/bin:$PATH"
echo aaa | tr "a" "b"
echo aaa | command -p tr "a" "b"
rm $TMP/bin/tr
---
(command (word "mkdir") (word "-p") (word "$TMP/bin"))
(command (word "echo") (word "\"echo wrong\"") (redirect ">" "$TMP/bin/tr"))
(command (word "chmod") (word "+x") (word "$TMP/bin/tr"))
(command (word "PATH=\"$TMP/bin:$PATH\""))
(pipe (command (word "echo") (word "aaa")) (command (word "tr") (word "\"a\"") (word "\"b\"")))
(pipe (command (word "echo") (word "aaa")) (command (word "command") (word "-p") (word "tr") (word "\"a\"") (word "\"b\"")))
(command (word "rm") (word "$TMP/bin/tr"))
---

=== command -p (hide tool in custom path)
mkdir -p $TMP/bin
echo "echo hello" > $TMP/bin/hello
chmod +x $TMP/bin/hello
export PATH=$TMP/bin
command -p hello
---
(command (word "mkdir") (word "-p") (word "$TMP/bin"))
(command (word "echo") (word "\"echo hello\"") (redirect ">" "$TMP/bin/hello"))
(command (word "chmod") (word "+x") (word "$TMP/bin/hello"))
(command (word "export") (word "PATH=$TMP/bin"))
(command (word "command") (word "-p") (word "hello"))
---

=== command -p (find hidden tool in default path)
export PATH=''
command -p ls
---
(command (word "export") (word "PATH=''"))
(command (word "command") (word "-p") (word "ls"))
---

=== $(command type ls)
type() { echo FUNCTION; }
type
s=$(command type echo)
echo $s | grep builtin > /dev/null
echo status=$?
---
(function "type" (brace-group (command (word "echo") (word "FUNCTION"))))
(command (word "type"))
(command (word "s=$(command type echo)"))
(pipe (command (word "echo") (word "$s")) (command (word "grep") (word "builtin") (redirect ">" "/dev/null")))
(command (word "echo") (word "status=$?"))
---

=== builtin
cd () { echo "hi"; }
cd
builtin cd / && pwd
unset -f cd
---
(function "cd" (brace-group (command (word "echo") (word "\"hi\""))))
(command (word "cd"))
(and (command (word "builtin") (word "cd") (word "/")) (command (word "pwd")))
(command (word "unset") (word "-f") (word "cd"))
---

=== builtin ls not found
builtin ls
---
(command (word "builtin") (word "ls"))
---

=== builtin usage
builtin
echo status=$?

builtin --
echo status=$?

builtin -- false
echo status=$?
---
(command (word "builtin"))
(command (word "echo") (word "status=$?"))
(command (word "builtin") (word "--"))
(command (word "echo") (word "status=$?"))
(command (word "builtin") (word "--") (word "false"))
(command (word "echo") (word "status=$?"))
---

=== builtin command echo hi
builtin command echo hi
---
(command (word "builtin") (word "command") (word "echo") (word "hi"))
---

=== history builtin usage
history
echo status=$?
history +5  # hm bash considers this valid
echo status=$?
history -5  # invalid flag
echo status=$?
history f 
echo status=$?
history too many args
echo status=$?
---
(command (word "history"))
(command (word "echo") (word "status=$?"))
(command (word "history") (word "+5"))
(command (word "echo") (word "status=$?"))
(command (word "history") (word "-5"))
(command (word "echo") (word "status=$?"))
(command (word "history") (word "f"))
(command (word "echo") (word "status=$?"))
(command (word "history") (word "too") (word "many") (word "args"))
(command (word "echo") (word "status=$?"))
---

=== Print shell strings with weird chars: set and printf %q and ${x@Q}
# bash declare -p will print binary data, which makes this invalid UTF-8!
foo=$(/bin/echo -e 'a\nb\xffc'\'d)

# let's test the easier \x01, which doesn't give bash problems
foo=$(/bin/echo -e 'a\nb\x01c'\'d)

# dash:
#   only supports 'set'; prints it on multiple lines with binary data
#   switches to "'" for single quotes, not \'
# zsh:
#   print binary data all the time, except for printf %q
#   does print $'' strings
# mksh:
#   prints binary data for @Q
#   prints $'' strings

# All are very inconsistent.

case $SH in dash|mksh|zsh) return ;; esac


set | grep -A1 foo

# Will print multi-line and binary data literally!
#declare -p foo

printf 'pf  %q\n' "$foo"

echo '@Q ' ${foo@Q}
---
(command (word "foo=$(/bin/echo -e 'a\\nb\\xffc'\\'d)"))
(command (word "foo=$(/bin/echo -e 'a\\nb\\x01c'\\'d)"))
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "return"))))
(pipe (command (word "set")) (command (word "grep") (word "-A1") (word "foo")))
(command (word "printf") (word "'pf  %q\\n'") (word "\"$foo\""))
(command (word "echo") (word "'@Q '") (word "${foo@Q}"))
---

=== Print shell strings with normal chars: set and printf %q and ${x@Q}
# There are variations on whether quotes are printed

case $SH in dash|zsh) return ;; esac

foo=spam

set | grep -A1 foo

# Will print multi-line and binary data literally!
typeset -p foo

printf 'pf  %q\n' "$foo"

echo '@Q ' ${foo@Q}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "return"))))
(command (word "foo=spam"))
(pipe (command (word "set")) (command (word "grep") (word "-A1") (word "foo")))
(command (word "typeset") (word "-p") (word "foo"))
(command (word "printf") (word "'pf  %q\\n'") (word "\"$foo\""))
(command (word "echo") (word "'@Q '") (word "${foo@Q}"))
---

=== time pipeline
time echo hi | wc -c
---
(time (pipe (command (word "echo") (word "hi")) (command (word "wc") (word "-c"))))
---

=== shift
set -- 1 2 3 4
shift
echo "$@"
shift 2
echo "$@"
---
(command (word "set") (word "--") (word "1") (word "2") (word "3") (word "4"))
(command (word "shift"))
(command (word "echo") (word "\"$@\""))
(command (word "shift") (word "2"))
(command (word "echo") (word "\"$@\""))
---

=== Shifting too far
set -- 1
shift 2
---
(command (word "set") (word "--") (word "1"))
(command (word "shift") (word "2"))
---

=== Invalid shift argument
shift ZZZ
---
(command (word "shift") (word "ZZZ"))
---

=== printf with no args
printf
---
(command (word "printf"))
---

=== printf -v %s
var=foo
printf -v $var %s 'hello there'
argv.py "$foo"
---
(command (word "var=foo"))
(command (word "printf") (word "-v") (word "$var") (word "%s") (word "'hello there'"))
(command (word "argv.py") (word "\"$foo\""))
---

=== printf -v %q
val='"quoted" with spaces and \'

# quote 'val' and store it in foo
printf -v foo %q "$val"
# then round trip back to eval
eval "bar=$foo"

# debugging:
#echo foo="$foo"
#echo bar="$bar"
#echo val="$val"

test "$bar" = "$val" && echo OK
---
(command (word "val='\"quoted\" with spaces and \\'"))
(command (word "printf") (word "-v") (word "foo") (word "%q") (word "\"$val\""))
(command (word "eval") (word "\"bar=$foo\""))
(and (command (word "test") (word "\"$bar\"") (word "=") (word "\"$val\"")) (command (word "echo") (word "OK")))
---

=== printf -v a[1]
a=(a b c)
printf -v 'a[1]' %s 'foo'
echo status=$?
argv.py "${a[@]}"
---
(command (word "a=(a b c)"))
(command (word "printf") (word "-v") (word "'a[1]'") (word "%s") (word "'foo'"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== printf -v syntax error
printf -v 'a[' %s 'foo'
echo status=$?
---
(command (word "printf") (word "-v") (word "'a['") (word "%s") (word "'foo'"))
(command (word "echo") (word "status=$?"))
---

=== dynamic declare instead of %s
var=foo
declare $var='hello there'
argv.py "$foo"
---
(command (word "var=foo"))
(command (word "declare") (word "$var='hello there'"))
(command (word "argv.py") (word "\"$foo\""))
---

=== dynamic declare instead of %q
var=foo
val='"quoted" with spaces and \'
# I think this is bash 4.4 only.
declare $var="${val@Q}"
echo "$foo"
---
(command (word "var=foo"))
(command (word "val='\"quoted\" with spaces and \\'"))
(command (word "declare") (word "$var=\"${val@Q}\""))
(command (word "echo") (word "\"$foo\""))
---

=== printf -v dynamic scope
case $SH in mksh|zsh|dash|ash) echo not implemented; exit ;; esac
# OK so printf is like assigning to a var.
# printf -v foo %q "$bar" is like
# foo=${bar@Q}
dollar='dollar'
f() {
  local mylocal=foo
  printf -v dollar %q '$'  # assign foo to a quoted dollar
  printf -v mylocal %q 'mylocal'
  echo dollar=$dollar
  echo mylocal=$mylocal
}
echo dollar=$dollar
echo --
f
echo --
echo dollar=$dollar
echo mylocal=$mylocal
---
(case (word "$SH") (pattern ((word "mksh") (word "zsh") (word "dash") (word "ash")) (semi (command (word "echo") (word "not") (word "implemented")) (command (word "exit")))))
(command (word "dollar='dollar'"))
(function "f" (brace-group (semi (semi (semi (semi (command (word "local") (word "mylocal=foo")) (command (word "printf") (word "-v") (word "dollar") (word "%q") (word "'$'"))) (command (word "printf") (word "-v") (word "mylocal") (word "%q") (word "'mylocal'"))) (command (word "echo") (word "dollar=$dollar"))) (command (word "echo") (word "mylocal=$mylocal")))))
(command (word "echo") (word "dollar=$dollar"))
(command (word "echo") (word "--"))
(command (word "f"))
(command (word "echo") (word "--"))
(command (word "echo") (word "dollar=$dollar"))
(command (word "echo") (word "mylocal=$mylocal"))
---

=== printf with too few arguments
printf -- '-%s-%s-%s-\n' 'a b' 'x y'
---
(command (word "printf") (word "--") (word "'-%s-%s-%s-\\n'") (word "'a b'") (word "'x y'"))
---

=== printf with too many arguments
printf -- '-%s-%s-\n' a b c d e
---
(command (word "printf") (word "--") (word "'-%s-%s-\\n'") (word "a") (word "b") (word "c") (word "d") (word "e"))
---

=== printf width strings
printf '[%5s]\n' abc
printf '[%-5s]\n' abc
---
(command (word "printf") (word "'[%5s]\\n'") (word "abc"))
(command (word "printf") (word "'[%-5s]\\n'") (word "abc"))
---

=== printf integer
printf '%d\n' 42
printf '%i\n' 42  # synonym
printf '%d\n' \'a # if first character is a quote, use character code
printf '%d\n' \"a # double quotes work too
printf '[%5d]\n' 42
printf '[%-5d]\n' 42
printf '[%05d]\n' 42
#printf '[%-05d]\n' 42  # the leading 0 is meaningless
#[42   ]
---
(command (word "printf") (word "'%d\\n'") (word "42"))
(command (word "printf") (word "'%i\\n'") (word "42"))
(command (word "printf") (word "'%d\\n'") (word "\\'a"))
(command (word "printf") (word "'%d\\n'") (word "\\\"a"))
(command (word "printf") (word "'[%5d]\\n'") (word "42"))
(command (word "printf") (word "'[%-5d]\\n'") (word "42"))
(command (word "printf") (word "'[%05d]\\n'") (word "42"))
---

=== printf %6.4d -- "precision" does padding for integers
printf '[%6.4d]\n' 42
printf '[%.4d]\n' 42
printf '[%6.d]\n' 42
echo --
printf '[%6.4d]\n' -42
printf '[%.4d]\n' -42
printf '[%6.d]\n' -42
---
(command (word "printf") (word "'[%6.4d]\\n'") (word "42"))
(command (word "printf") (word "'[%.4d]\\n'") (word "42"))
(command (word "printf") (word "'[%6.d]\\n'") (word "42"))
(command (word "echo") (word "--"))
(command (word "printf") (word "'[%6.4d]\\n'") (word "-42"))
(command (word "printf") (word "'[%.4d]\\n'") (word "-42"))
(command (word "printf") (word "'[%6.d]\\n'") (word "-42"))
---

=== printf %6.4x X o
printf '[%6.4x]\n' 42
printf '[%.4x]\n' 42
printf '[%6.x]\n' 42
echo --
printf '[%6.4X]\n' 42
printf '[%.4X]\n' 42
printf '[%6.X]\n' 42
echo --
printf '[%6.4o]\n' 42
printf '[%.4o]\n' 42
printf '[%6.o]\n' 42
---
(command (word "printf") (word "'[%6.4x]\\n'") (word "42"))
(command (word "printf") (word "'[%.4x]\\n'") (word "42"))
(command (word "printf") (word "'[%6.x]\\n'") (word "42"))
(command (word "echo") (word "--"))
(command (word "printf") (word "'[%6.4X]\\n'") (word "42"))
(command (word "printf") (word "'[%.4X]\\n'") (word "42"))
(command (word "printf") (word "'[%6.X]\\n'") (word "42"))
(command (word "echo") (word "--"))
(command (word "printf") (word "'[%6.4o]\\n'") (word "42"))
(command (word "printf") (word "'[%.4o]\\n'") (word "42"))
(command (word "printf") (word "'[%6.o]\\n'") (word "42"))
---

=== %06d zero padding vs. %6.6d
printf '[%06d]\n' 42
printf '[%06d]\n' -42  # 6 TOTAL
echo --
printf '[%6.6d]\n' 42
printf '[%6.6d]\n' -42  # 6 + 1 for the - sign!!!
---
(command (word "printf") (word "'[%06d]\\n'") (word "42"))
(command (word "printf") (word "'[%06d]\\n'") (word "-42"))
(command (word "echo") (word "--"))
(command (word "printf") (word "'[%6.6d]\\n'") (word "42"))
(command (word "printf") (word "'[%6.6d]\\n'") (word "-42"))
---

=== %06x %06X %06o
printf '[%06x]\n' 42
printf '[%06X]\n' 42
printf '[%06o]\n' 42
---
(command (word "printf") (word "'[%06x]\\n'") (word "42"))
(command (word "printf") (word "'[%06X]\\n'") (word "42"))
(command (word "printf") (word "'[%06o]\\n'") (word "42"))
---

=== %06s is no-op
printf '(%6s)\n' 42
printf '(%6s)\n' -42
printf '(%06s)\n' 42
printf '(%06s)\n' -42
echo status=$?
---
(command (word "printf") (word "'(%6s)\\n'") (word "42"))
(command (word "printf") (word "'(%6s)\\n'") (word "-42"))
(command (word "printf") (word "'(%06s)\\n'") (word "42"))
(command (word "printf") (word "'(%06s)\\n'") (word "-42"))
(command (word "echo") (word "status=$?"))
---

=== printf %6.4s does both truncation and padding
printf '[%6s]\n' foo
printf '[%6.4s]\n' foo
printf '[%-6.4s]\n' foo
printf '[%6s]\n' spam-eggs
printf '[%6.4s]\n' spam-eggs
printf '[%-6.4s]\n' spam-eggs
---
(command (word "printf") (word "'[%6s]\\n'") (word "foo"))
(command (word "printf") (word "'[%6.4s]\\n'") (word "foo"))
(command (word "printf") (word "'[%-6.4s]\\n'") (word "foo"))
(command (word "printf") (word "'[%6s]\\n'") (word "spam-eggs"))
(command (word "printf") (word "'[%6.4s]\\n'") (word "spam-eggs"))
(command (word "printf") (word "'[%-6.4s]\\n'") (word "spam-eggs"))
---

=== printf %6.0s and %0.0s
printf '[%6.0s]\n' foo
printf '[%0.0s]\n' foo
---
(command (word "printf") (word "'[%6.0s]\\n'") (word "foo"))
(command (word "printf") (word "'[%0.0s]\\n'") (word "foo"))
---

=== printf %6.s and %0.s
printf '[%6.s]\n' foo
printf '[%0.s]\n' foo
---
(command (word "printf") (word "'[%6.s]\\n'") (word "foo"))
(command (word "printf") (word "'[%0.s]\\n'") (word "foo"))
---

=== printf %*.*s (width/precision from args)
printf '[%*s]\n' 9 hello
printf '[%.*s]\n' 3 hello
printf '[%*.3s]\n' 9 hello
printf '[%9.*s]\n' 3 hello
printf '[%*.*s]\n' 9 3 hello
---
(command (word "printf") (word "'[%*s]\\n'") (word "9") (word "hello"))
(command (word "printf") (word "'[%.*s]\\n'") (word "3") (word "hello"))
(command (word "printf") (word "'[%*.3s]\\n'") (word "9") (word "hello"))
(command (word "printf") (word "'[%9.*s]\\n'") (word "3") (word "hello"))
(command (word "printf") (word "'[%*.*s]\\n'") (word "9") (word "3") (word "hello"))
---

=== unsigned / octal / hex
printf '[%u]\n' 42
printf '[%o]\n' 42
printf '[%x]\n' 42
printf '[%X]\n' 42
echo

printf '[%X]\n' \'a  # if first character is a quote, use character code
printf '[%X]\n' \'ab # extra chars ignored
---
(command (word "printf") (word "'[%u]\\n'") (word "42"))
(command (word "printf") (word "'[%o]\\n'") (word "42"))
(command (word "printf") (word "'[%x]\\n'") (word "42"))
(command (word "printf") (word "'[%X]\\n'") (word "42"))
(command (word "echo"))
(command (word "printf") (word "'[%X]\\n'") (word "\\'a"))
(command (word "printf") (word "'[%X]\\n'") (word "\\'ab"))
---

=== unsigned / octal / hex big
for big in $(( 1 << 32 )) $(( (1 << 63) - 1 )); do
  printf '[%u]\n' $big
  printf '[%o]\n' $big
  printf '[%x]\n' $big
  printf '[%X]\n' $big
  echo
done
---
(for (word "big") (in (word "$(( 1 << 32 ))") (word "$(( (1 << 63) - 1 ))")) (semi (semi (semi (semi (command (word "printf") (word "'[%u]\\n'") (word "$big")) (command (word "printf") (word "'[%o]\\n'") (word "$big"))) (command (word "printf") (word "'[%x]\\n'") (word "$big"))) (command (word "printf") (word "'[%X]\\n'") (word "$big"))) (command (word "echo"))))
---

=== empty string (osh is more strict)
printf '%d\n' ''
---
(command (word "printf") (word "'%d\\n'") (word "''"))
---

=== No char after ' => zero code point
# most shells use 0 here
printf '%d\n' \'
printf '%d\n' \"
---
(command (word "printf") (word "'%d\\n'") (word "\\'"))
(command (word "printf") (word "'%d\\n'") (word "\\\""))
---

=== Unicode char with '
case $SH in mksh) echo 'weird bug'; exit ;; esac

# the mu character is U+03BC

printf '%x\n' \'
printf '%u\n' \'
printf '%o\n' \'
echo

u3=
# u4=

printf '%x\n' \'$u3
printf '%u\n' \'$u3
printf '%o\n' \'$u3
echo

# mksh DOES respect unicode on the new Debian bookworm.
# but even building the SAME SOURCE from scratch, somehow it doesn't on Ubuntu 8.
# TBH I should probably just upgrade the mksh version.
#
# $ ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# 
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ cat /etc/os-release
# NAME="Ubuntu"
# VERSION="18.04.5 LTS (Bionic Beaver)"
# ID=ubuntu
# ID_LIKE=debian
# PRETTY_NAME="Ubuntu 18.04.5 LTS"
# VERSION_ID="18.04"
# HOME_URL="https://www.ubuntu.com/"
# SUPPORT_URL="https://help.ubuntu.com/"
# BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
# PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
# VERSION_CODENAME=bionic
# UBUNTU_CODENAME=bionic
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ env|egrep 'LC|LANG'
# LANG=en_US.UTF-8
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_CTYPE=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LANG=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=en_US.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=en_US.utf-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
---
(case (word "$SH") (pattern ((word "mksh")) (semi (command (word "echo") (word "'weird bug'")) (command (word "exit")))))
(command (word "printf") (word "'%x\\n'") (word "\\'"))
(command (word "printf") (word "'%u\\n'") (word "\\'"))
(command (word "printf") (word "'%o\\n'") (word "\\'"))
(command (word "echo"))
(command (word "u3="))
(command (word "printf") (word "'%x\\n'") (word "\\'$u3"))
(command (word "printf") (word "'%u\\n'") (word "\\'$u3"))
(command (word "printf") (word "'%o\\n'") (word "\\'$u3"))
(command (word "echo"))
---

=== Invalid UTF-8
echo bytes1
not_utf8=$(python2 -c 'print("\xce\xce")')

printf '%x\n' \'$not_utf8
printf '%u\n' \'$not_utf8
printf '%o\n' \'$not_utf8
echo

echo bytes2
not_utf8=$(python2 -c 'print("\xbc\xbc")')
printf '%x\n' \'$not_utf8
printf '%u\n' \'$not_utf8
printf '%o\n' \'$not_utf8
echo

# Copied from data_lang/utf8_test.cc

echo overlong2
overlong2=$(python2 -c 'print("\xC1\x81")')
printf '%x\n' \'$overlong2
printf '%u\n' \'$overlong2
printf '%o\n' \'$overlong2
echo

echo overlong3
overlong3=$(python2 -c 'print("\xE0\x81\x81")')
printf '%x\n' \'$overlong3
printf '%u\n' \'$overlong3
printf '%o\n' \'$overlong3
echo
---
(command (word "echo") (word "bytes1"))
(command (word "not_utf8=$(python2 -c 'print(\"\\xce\\xce\")')"))
(command (word "printf") (word "'%x\\n'") (word "\\'$not_utf8"))
(command (word "printf") (word "'%u\\n'") (word "\\'$not_utf8"))
(command (word "printf") (word "'%o\\n'") (word "\\'$not_utf8"))
(command (word "echo"))
(command (word "echo") (word "bytes2"))
(command (word "not_utf8=$(python2 -c 'print(\"\\xbc\\xbc\")')"))
(command (word "printf") (word "'%x\\n'") (word "\\'$not_utf8"))
(command (word "printf") (word "'%u\\n'") (word "\\'$not_utf8"))
(command (word "printf") (word "'%o\\n'") (word "\\'$not_utf8"))
(command (word "echo"))
(command (word "echo") (word "overlong2"))
(command (word "overlong2=$(python2 -c 'print(\"\\xC1\\x81\")')"))
(command (word "printf") (word "'%x\\n'") (word "\\'$overlong2"))
(command (word "printf") (word "'%u\\n'") (word "\\'$overlong2"))
(command (word "printf") (word "'%o\\n'") (word "\\'$overlong2"))
(command (word "echo"))
(command (word "echo") (word "overlong3"))
(command (word "overlong3=$(python2 -c 'print(\"\\xE0\\x81\\x81\")')"))
(command (word "printf") (word "'%x\\n'") (word "\\'$overlong3"))
(command (word "printf") (word "'%u\\n'") (word "\\'$overlong3"))
(command (word "printf") (word "'%o\\n'") (word "\\'$overlong3"))
(command (word "echo"))
---

=== Too large
case $SH in mksh) echo 'weird bug'; exit ;; esac

echo too large
too_large=$(python2 -c 'print("\xF4\x91\x84\x91")')
printf '%x\n' \'$too_large
printf '%u\n' \'$too_large
printf '%o\n' \'$too_large
echo
---
(case (word "$SH") (pattern ((word "mksh")) (semi (command (word "echo") (word "'weird bug'")) (command (word "exit")))))
(command (word "echo") (word "too") (word "large"))
(command (word "too_large=$(python2 -c 'print(\"\\xF4\\x91\\x84\\x91\")')"))
(command (word "printf") (word "'%x\\n'") (word "\\'$too_large"))
(command (word "printf") (word "'%u\\n'") (word "\\'$too_large"))
(command (word "printf") (word "'%o\\n'") (word "\\'$too_large"))
(command (word "echo"))
---

=== negative numbers with unsigned / octal / hex
printf '[%u]\n' -42
echo status=$?

printf '[%o]\n' -42
echo status=$?

printf '[%x]\n' -42
echo status=$?

printf '[%X]\n' -42
echo status=$?
---
(command (word "printf") (word "'[%u]\\n'") (word "-42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%o]\\n'") (word "-42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%x]\\n'") (word "-42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%X]\\n'") (word "-42"))
(command (word "echo") (word "status=$?"))
---

=== printf floating point (not required, but they all implement it)
printf '[%f]\n' 3.14159
printf '[%.2f]\n' 3.14159
printf '[%8.2f]\n' 3.14159
printf '[%-8.2f]\n' 3.14159
printf '[%-f]\n' 3.14159
printf '[%-f]\n' 3.14
---
(command (word "printf") (word "'[%f]\\n'") (word "3.14159"))
(command (word "printf") (word "'[%.2f]\\n'") (word "3.14159"))
(command (word "printf") (word "'[%8.2f]\\n'") (word "3.14159"))
(command (word "printf") (word "'[%-8.2f]\\n'") (word "3.14159"))
(command (word "printf") (word "'[%-f]\\n'") (word "3.14159"))
(command (word "printf") (word "'[%-f]\\n'") (word "3.14"))
---

=== printf floating point with - and 0
printf '[%8.4f]\n' 3.14
printf '[%08.4f]\n' 3.14
printf '[%8.04f]\n' 3.14  # meaning less 0
printf '[%08.04f]\n' 3.14
echo ---
# these all boil down to the same thing.  The -, 8, and 4 are respected, but
# none of the 0 are.
printf '[%-8.4f]\n' 3.14
printf '[%-08.4f]\n' 3.14
printf '[%-8.04f]\n' 3.14
printf '[%-08.04f]\n' 3.14
---
(command (word "printf") (word "'[%8.4f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%08.4f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%8.04f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%08.04f]\\n'") (word "3.14"))
(command (word "echo") (word "---"))
(command (word "printf") (word "'[%-8.4f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%-08.4f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%-8.04f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%-08.04f]\\n'") (word "3.14"))
---

=== printf eE fF gG
printf '[%e]\n' 3.14
printf '[%E]\n' 3.14
printf '[%f]\n' 3.14
# bash is the only one that implements %F?  Is it a synonym?
#printf '[%F]\n' 3.14
printf '[%g]\n' 3.14
printf '[%G]\n' 3.14
---
(command (word "printf") (word "'[%e]\\n'") (word "3.14"))
(command (word "printf") (word "'[%E]\\n'") (word "3.14"))
(command (word "printf") (word "'[%f]\\n'") (word "3.14"))
(command (word "printf") (word "'[%g]\\n'") (word "3.14"))
(command (word "printf") (word "'[%G]\\n'") (word "3.14"))
---

=== printf backslash escapes
argv.py "$(printf 'a\tb')"
argv.py "$(printf '\xE2\x98\xA0')"
argv.py "$(printf '\044e')"
argv.py "$(printf '\0377')"  # out of range
---
(command (word "argv.py") (word "\"$(printf 'a\\tb')\""))
(command (word "argv.py") (word "\"$(printf '\\xE2\\x98\\xA0')\""))
(command (word "argv.py") (word "\"$(printf '\\044e')\""))
(command (word "argv.py") (word "\"$(printf '\\0377')\""))
---

=== printf octal backslash escapes
argv.py "$(printf '\0377')"
argv.py "$(printf '\377')"
---
(command (word "argv.py") (word "\"$(printf '\\0377')\""))
(command (word "argv.py") (word "\"$(printf '\\377')\""))
---

=== printf unicode backslash escapes
argv.py "$(printf '\u2620')"
argv.py "$(printf '\U0000065f')"
---
(command (word "argv.py") (word "\"$(printf '\\u2620')\""))
(command (word "argv.py") (word "\"$(printf '\\U0000065f')\""))
---

=== printf invalid backslash escape (is ignored)
printf '[\Z]\n'
---
(command (word "printf") (word "'[\\Z]\\n'"))
---

=== printf % escapes
printf '[%%]\n'
---
(command (word "printf") (word "'[%%]\\n'"))
---

=== printf %c ASCII
printf '%c\n' a
printf '%c\n' ABC
printf '%cZ\n' ABC
---
(command (word "printf") (word "'%c\\n'") (word "a"))
(command (word "printf") (word "'%c\\n'") (word "ABC"))
(command (word "printf") (word "'%cZ\\n'") (word "ABC"))
---

=== printf %c unicode - prints the first BYTE of a string - it does not respect UTF-8
# TODO: in YSH, this should be deprecated
case $SH in dash|ash) exit ;; esac

show_bytes() {
  od -A n -t x1
}
twomu=$'\u03bc\u03bc'
printf '[%s]\n' "$twomu"

# Hm this cuts off a UTF-8 character?
printf '%c' "$twomu" | show_bytes
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(function "show_bytes" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "x1"))))
(command (word "twomu=''"))
(command (word "printf") (word "'[%s]\\n'") (word "\"$twomu\""))
(pipe (command (word "printf") (word "'%c'") (word "\"$twomu\"")) (command (word "show_bytes")))
---

=== printf invalid format
printf '%z' 42
echo status=$?
printf '%-z' 42
echo status=$?
---
(command (word "printf") (word "'%z'") (word "42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%-z'") (word "42"))
(command (word "echo") (word "status=$?"))
---

=== printf %q
x='a b'
printf '[%q]\n' "$x"
---
(command (word "x='a b'"))
(command (word "printf") (word "'[%q]\\n'") (word "\"$x\""))
---

=== printf %6q (width)
# NOTE: coreutils /usr/bin/printf does NOT implement this %6q !!!
x='a b'
printf '[%6q]\n' "$x"
printf '[%1q]\n' "$x"
---
(command (word "x='a b'"))
(command (word "printf") (word "'[%6q]\\n'") (word "\"$x\""))
(command (word "printf") (word "'[%1q]\\n'") (word "\"$x\""))
---

=== printf negative numbers
printf '[%d] ' -42
echo status=$?
printf '[%i] ' -42
echo status=$?

# extra LEADING space too
printf '[%d] ' ' -42'
echo status=$?
printf '[%i] ' ' -42'
echo status=$?

# extra TRAILING space too
printf '[%d] ' ' -42 '
echo status=$?
printf '[%i] ' ' -42 '
echo status=$?

# extra TRAILING chars
printf '[%d] ' ' -42z'
echo status=$?
printf '[%i] ' ' -42z'
echo status=$?

exit 0  # ok
---
(command (word "printf") (word "'[%d] '") (word "-42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%i] '") (word "-42"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%d] '") (word "' -42'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%i] '") (word "' -42'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%d] '") (word "' -42 '"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%i] '") (word "' -42 '"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%d] '") (word "' -42z'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'[%i] '") (word "' -42z'"))
(command (word "echo") (word "status=$?"))
(command (word "exit") (word "0"))
---

=== printf + and space flags
# I didn't know these existed -- I only knew about - and 0 !
printf '[%+d]\n' 42
printf '[%+d]\n' -42
printf '[% d]\n' 42
printf '[% d]\n' -42
---
(command (word "printf") (word "'[%+d]\\n'") (word "42"))
(command (word "printf") (word "'[%+d]\\n'") (word "-42"))
(command (word "printf") (word "'[% d]\\n'") (word "42"))
(command (word "printf") (word "'[% d]\\n'") (word "-42"))
---

=== printf # flag
# I didn't know these existed -- I only knew about - and 0 !
# Note: '#' flag for integers outputs a prefix ONLY WHEN the value is non-zero
printf '[%#o][%#o]\n' 0 42
printf '[%#x][%#x]\n' 0 42
printf '[%#X][%#X]\n' 0 42
echo ---
# Note: '#' flag for %f, %g always outputs the decimal point.
printf '[%.0f][%#.0f]\n' 3 3
# Note: In addition, '#' flag for %g does not omit zeroes in fraction
printf '[%g][%#g]\n' 3 3
---
(command (word "printf") (word "'[%#o][%#o]\\n'") (word "0") (word "42"))
(command (word "printf") (word "'[%#x][%#x]\\n'") (word "0") (word "42"))
(command (word "printf") (word "'[%#X][%#X]\\n'") (word "0") (word "42"))
(command (word "echo") (word "---"))
(command (word "printf") (word "'[%.0f][%#.0f]\\n'") (word "3") (word "3"))
(command (word "printf") (word "'[%g][%#g]\\n'") (word "3") (word "3"))
---

=== Runtime error for invalid integer
x=3abc
printf '%d\n' $x
echo status=$?
printf '%d\n' xyz
echo status=$?
---
(command (word "x=3abc"))
(command (word "printf") (word "'%d\\n'") (word "$x"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%d\\n'") (word "xyz"))
(command (word "echo") (word "status=$?"))
---

=== %(strftime format)T
# The result depends on timezone
export TZ=Asia/Tokyo
printf '%(%Y-%m-%d)T\n' 1557978599
export TZ=US/Eastern
printf '%(%Y-%m-%d)T\n' 1557978599
echo status=$?
---
(command (word "export") (word "TZ=Asia/Tokyo"))
(command (word "printf") (word "'%(%Y-%m-%d)T\\n'") (word "1557978599"))
(command (word "export") (word "TZ=US/Eastern"))
(command (word "printf") (word "'%(%Y-%m-%d)T\\n'") (word "1557978599"))
(command (word "echo") (word "status=$?"))
---

=== %(strftime format)T doesn't respect TZ if not exported
# note: this test leaks!  It assumes that /etc/localtime is NOT Portugal.

TZ=Portugal  # NOT exported
localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

# TZ is respected
export TZ=Portugal
tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

#echo $localtime
#echo $tz

if ! test "$localtime" = "$tz"; then
  echo 'not equal'
fi
---
(command (word "TZ=Portugal"))
(command (word "localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\\n' 1557978599)"))
(command (word "export") (word "TZ=Portugal"))
(command (word "tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\\n' 1557978599)"))
(if (negation (command (word "test") (word "\"$localtime\"") (word "=") (word "\"$tz\""))) (command (word "echo") (word "'not equal'")))
---

=== %(strftime format)T TZ in environ but not in shell's memory
# note: this test leaks!  It assumes that /etc/localtime is NOT Portugal.

# TZ is respected
export TZ=Portugal
tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

unset TZ  # unset in the shell, but still in the environment

localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

if ! test "$localtime" = "$tz"; then
  echo 'not equal'
fi
---
(command (word "export") (word "TZ=Portugal"))
(command (word "tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\\n' 1557978599)"))
(command (word "unset") (word "TZ"))
(command (word "localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\\n' 1557978599)"))
(if (negation (command (word "test") (word "\"$localtime\"") (word "=") (word "\"$tz\""))) (command (word "echo") (word "'not equal'")))
---

=== %10.5(strftime format)T
# The result depends on timezone
export TZ=Asia/Tokyo
printf '[%10.5(%Y-%m-%d)T]\n' 1557978599
export TZ=US/Eastern
printf '[%10.5(%Y-%m-%d)T]\n' 1557978599
echo status=$?
---
(command (word "export") (word "TZ=Asia/Tokyo"))
(command (word "printf") (word "'[%10.5(%Y-%m-%d)T]\\n'") (word "1557978599"))
(command (word "export") (word "TZ=US/Eastern"))
(command (word "printf") (word "'[%10.5(%Y-%m-%d)T]\\n'") (word "1557978599"))
(command (word "echo") (word "status=$?"))
---

=== Regression for 'printf x y'
printf x y
printf '%s\n' z
---
(command (word "printf") (word "x") (word "y"))
(command (word "printf") (word "'%s\\n'") (word "z"))
---

=== bash truncates long strftime string at 128
case $SH in ash|dash|mksh|zsh) exit ;; esac

strftime-format() {
  local n=$1

  # Prints increasingly long format strings:
  # %(%Y)T %(%Y)T %(%Y%Y)T ...

  echo -n '%('
  for i in $(seq $n); do
    echo -n '%Y'
  done
  echo -n ')T'
}

printf $(strftime-format 1) | wc --bytes
printf $(strftime-format 10) | wc --bytes
printf $(strftime-format 30) | wc --bytes
printf $(strftime-format 31) | wc --bytes
printf $(strftime-format 32) | wc --bytes

case $SH in
  (*/_bin/cxx-dbg/*)    
    # Ensure that oils-for-unix detects the truncation of a fixed buffer.
    # bash has a buffer of 128.

    set +o errexit
    (
      printf $(strftime-format 1000)
    )
    status=$?
    if test $status -ne 1; then
      echo FAIL
    fi
    ;;
esac
---
(case (word "$SH") (pattern ((word "ash") (word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(function "strftime-format" (brace-group (semi (semi (semi (command (word "local") (word "n=$1")) (command (word "echo") (word "-n") (word "'%('"))) (for (word "i") (in (word "$(seq $n)")) (command (word "echo") (word "-n") (word "'%Y'")))) (command (word "echo") (word "-n") (word "')T'")))))
(pipe (command (word "printf") (word "$(strftime-format 1)")) (command (word "wc") (word "--bytes")))
(pipe (command (word "printf") (word "$(strftime-format 10)")) (command (word "wc") (word "--bytes")))
(pipe (command (word "printf") (word "$(strftime-format 30)")) (command (word "wc") (word "--bytes")))
(pipe (command (word "printf") (word "$(strftime-format 31)")) (command (word "wc") (word "--bytes")))
(pipe (command (word "printf") (word "$(strftime-format 32)")) (command (word "wc") (word "--bytes")))
(case (word "$SH") (pattern ((word "*/_bin/cxx-dbg/*")) (semi (semi (semi (command (word "set") (word "+o") (word "errexit")) (subshell (command (word "printf") (word "$(strftime-format 1000)")))) (command (word "status=$?"))) (if (command (word "test") (word "$status") (word "-ne") (word "1")) (command (word "echo") (word "FAIL"))))))
---

=== printf positive integer overflow
# %i seems like a synonym for %d

for fmt in '%u\n' '%d\n'; do
  # bash considers this in range for %u
  # same with mksh
  # zsh cuts everything off after 19 digits
  # ash truncates everything
  printf "$fmt" '18446744073709551615'
  echo status=$?
  printf "$fmt" '18446744073709551616'
  echo status=$?
  echo
done
---
(for (word "fmt") (in (word "'%u\\n'") (word "'%d\\n'")) (semi (semi (semi (semi (command (word "printf") (word "\"$fmt\"") (word "'18446744073709551615'")) (command (word "echo") (word "status=$?"))) (command (word "printf") (word "\"$fmt\"") (word "'18446744073709551616'"))) (command (word "echo") (word "status=$?"))) (command (word "echo"))))
---

=== printf negative integer overflow
# %i seems like a synonym for %d

for fmt in '%u\n' '%d\n'; do

  printf "$fmt" '-18446744073709551615'
  echo status=$?
  printf "$fmt" '-18446744073709551616'
  echo status=$?
  echo
done
---
(for (word "fmt") (in (word "'%u\\n'") (word "'%d\\n'")) (semi (semi (semi (semi (command (word "printf") (word "\"$fmt\"") (word "'-18446744073709551615'")) (command (word "echo") (word "status=$?"))) (command (word "printf") (word "\"$fmt\"") (word "'-18446744073709551616'"))) (command (word "echo") (word "status=$?"))) (command (word "echo"))))
---

=== printf %b does backslash escaping
printf '[%s]\n' '\044'  # escapes not evaluated
printf '[%b]\n' '\044'  # YES, escapes evaluated
echo

printf '[%s]\n' '\x7e'  # escapes not evaluated
printf '[%b]\n' '\x7e'  # YES, escapes evaluated
echo

# not a valid escape
printf '[%s]\n' '\A'
printf '[%b]\n' '\A'
---
(command (word "printf") (word "'[%s]\\n'") (word "'\\044'"))
(command (word "printf") (word "'[%b]\\n'") (word "'\\044'"))
(command (word "echo"))
(command (word "printf") (word "'[%s]\\n'") (word "'\\x7e'"))
(command (word "printf") (word "'[%b]\\n'") (word "'\\x7e'"))
(command (word "echo"))
(command (word "printf") (word "'[%s]\\n'") (word "'\\A'"))
(command (word "printf") (word "'[%b]\\n'") (word "'\\A'"))
---

=== printf %b unicode escapes
printf '[%s]\n' '\u03bc'  # escapes not evaluated
printf '[%b]\n' '\u03bc'  # YES, escapes evaluated
---
(command (word "printf") (word "'[%s]\\n'") (word "'\\u03bc'"))
(command (word "printf") (word "'[%b]\\n'") (word "'\\u03bc'"))
---

=== printf %b respects \c early return
printf '[%b]\n' 'ab\ncd\cxy'
echo $?
---
(command (word "printf") (word "'[%b]\\n'") (word "'ab\\ncd\\cxy'"))
(command (word "echo") (word "$?"))
---

=== printf %b supports octal escapes, both \141 and \0141
printf 'three %b\n' '\141'  # di
printf 'four  %b\n' '\0141'
echo

# trailing 9
printf '%b\n' '\1419'
printf '%b\n' '\01419'

# Notes:
#
# - echo -e: 
#   - NO  3 digit octal  - echo -e '\141' does not work
#   - YES 4 digit octal
# - printf %b
#   - YES 3 digit octal
#   - YES 4 digit octal
# - printf string (outer)
#   - YES 3 digit octal
#   - NO  4 digit octal
# - $'' and $PS1
#   - YES 3 digit octal
#   - NO  4 digit octal
---
(command (word "printf") (word "'three %b\\n'") (word "'\\141'"))
(command (word "printf") (word "'four  %b\\n'") (word "'\\0141'"))
(command (word "echo"))
(command (word "printf") (word "'%b\\n'") (word "'\\1419'"))
(command (word "printf") (word "'%b\\n'") (word "'\\01419'"))
---

=== printf %b with truncated octal escapes
# 8 is not a valid octal digit

printf '%b\n' '\558'
printf '%b\n' '\0558'
echo

show_bytes() {
  od -A n -t x1
}
printf '%b' '\7' | show_bytes
printf '%b' '\07' | show_bytes
printf '%b' '\007' | show_bytes
printf '%b' '\0007' | show_bytes
---
(command (word "printf") (word "'%b\\n'") (word "'\\558'"))
(command (word "printf") (word "'%b\\n'") (word "'\\0558'"))
(command (word "echo"))
(function "show_bytes" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "x1"))))
(pipe (command (word "printf") (word "'%b'") (word "'\\7'")) (command (word "show_bytes")))
(pipe (command (word "printf") (word "'%b'") (word "'\\07'")) (command (word "show_bytes")))
(pipe (command (word "printf") (word "'%b'") (word "'\\007'")) (command (word "show_bytes")))
(pipe (command (word "printf") (word "'%b'") (word "'\\0007'")) (command (word "show_bytes")))
---

=== printf %d %X support hex 0x5 and octal 055
echo hex
printf '%d\n' 0x55
printf '%X\n' 0x55

echo hex CAPS
printf '%d\n' 0X55
printf '%X\n' 0X55

echo octal 3
printf '%d\n' 055
printf '%X\n' 055

echo octal 4
printf '%d\n' 0055
printf '%X\n' 0055

echo octal 5
printf '%d\n' 00055
printf '%X\n' 00055
---
(command (word "echo") (word "hex"))
(command (word "printf") (word "'%d\\n'") (word "0x55"))
(command (word "printf") (word "'%X\\n'") (word "0x55"))
(command (word "echo") (word "hex") (word "CAPS"))
(command (word "printf") (word "'%d\\n'") (word "0X55"))
(command (word "printf") (word "'%X\\n'") (word "0X55"))
(command (word "echo") (word "octal") (word "3"))
(command (word "printf") (word "'%d\\n'") (word "055"))
(command (word "printf") (word "'%X\\n'") (word "055"))
(command (word "echo") (word "octal") (word "4"))
(command (word "printf") (word "'%d\\n'") (word "0055"))
(command (word "printf") (word "'%X\\n'") (word "0055"))
(command (word "echo") (word "octal") (word "5"))
(command (word "printf") (word "'%d\\n'") (word "00055"))
(command (word "printf") (word "'%X\\n'") (word "00055"))
---

=== printf %d with + prefix (positive sign)
echo decimal
printf '%d\n' +42

echo octal
printf '%d\n' +077

echo hex lowercase
printf '%d\n' +0xab

echo hex uppercase
printf '%d\n' +0XAB
---
(command (word "echo") (word "decimal"))
(command (word "printf") (word "'%d\\n'") (word "+42"))
(command (word "echo") (word "octal"))
(command (word "printf") (word "'%d\\n'") (word "+077"))
(command (word "echo") (word "hex") (word "lowercase"))
(command (word "printf") (word "'%d\\n'") (word "+0xab"))
(command (word "echo") (word "hex") (word "uppercase"))
(command (word "printf") (word "'%d\\n'") (word "+0XAB"))
---

=== leading spaces are accepted in value given to %d %X, but not trailing spaces
case $SH in zsh) exit ;; esac

# leading space is allowed
printf '%d\n' ' -123'
echo status=$?
printf '%d\n' ' -123 '
echo status=$?

echo ---

printf '%d\n' ' +077'
echo status=$?

printf '%d\n' ' +0xff'
echo status=$?

printf '%X\n' ' +0xff'
echo status=$?

printf '%x\n' ' +0xff'
echo status=$?
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "printf") (word "'%d\\n'") (word "' -123'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%d\\n'") (word "' -123 '"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "---"))
(command (word "printf") (word "'%d\\n'") (word "' +077'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%d\\n'") (word "' +0xff'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%X\\n'") (word "' +0xff'"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%x\\n'") (word "' +0xff'"))
(command (word "echo") (word "status=$?"))
---

=== Arbitrary base 64#a is rejected (unlike in shell arithmetic)
printf '%d\n' '64#a'
echo status=$?

# bash, dash, and mksh print 64 and return status 1
# zsh and ash print 0 and return status 1
# OSH rejects it completely (prints nothing) and returns status 1
---
(command (word "printf") (word "'%d\\n'") (word "'64#a'"))
(command (word "echo") (word "status=$?"))
---

=== exec builtin
exec echo hi
---
(command (word "exec") (word "echo") (word "hi"))
---

=== exec builtin with redirects
exec 1>&2
echo 'to stderr'
---
(command (word "exec") (redirect ">&" 2))
(command (word "echo") (word "'to stderr'"))
---

=== exec builtin with here doc
# This has in a separate file because both code and data can be read from
# stdin.
$SH $REPO_ROOT/spec/bin/builtins-exec-here-doc-helper.sh
---
(command (word "$SH") (word "$REPO_ROOT/spec/bin/builtins-exec-here-doc-helper.sh"))
---

=== exec builtin accepts --
exec -- echo hi
---
(command (word "exec") (word "--") (word "echo") (word "hi"))
---

=== exec -- 2>&1
exec -- 3>&1
echo stdout 1>&3
---
(command (word "exec") (word "--") (redirect ">&" 1))
(command (word "echo") (word "stdout") (redirect ">&" 3))
---

=== Exit out of function
f() { exit 3; }
f
exit 4
---
(function "f" (brace-group (command (word "exit") (word "3"))))
(command (word "f"))
(command (word "exit") (word "4"))
---

=== Exit builtin with invalid arg
exit invalid
# Rationale: runtime errors are 1
---
(command (word "exit") (word "invalid"))
---

=== Exit builtin with too many args
# This is a parse error in OSH.
exit 7 8 9
echo status=$?
---
(command (word "exit") (word "7") (word "8") (word "9"))
(command (word "echo") (word "status=$?"))
---

=== time with brace group argument
err=time-$(basename $SH).txt
{
  time {
    sleep 0.01
    sleep 0.02
  }
} 2> $err

grep --only-matching user $err
echo result=$?

# Regression: check fractional seconds
gawk '
BEGIN { ok = 0 }
match( $0, /\.([0-9]+)/, m) {
  if (m[1] > 0) {  # check fractional seconds
    ok = 1
  }
}
END { if (ok) { print "non-zero" } }
' $err
---
(command (word "err=time-$(basename $SH).txt"))
(brace-group (time (brace-group (semi (command (word "sleep") (word "0.01")) (command (word "sleep") (word "0.02")))))) (redirect ">" "$err")
(command (word "grep") (word "--only-matching") (word "user") (word "$err"))
(command (word "echo") (word "result=$?"))
(command (word "gawk") (word "'\nBEGIN { ok = 0 }\nmatch( $0, /\\.([0-9]+)/, m) {\n  if (m[1] > 0) {  # check fractional seconds\n    ok = 1\n  }\n}\nEND { if (ok) { print \"non-zero\" } }\n'") (word "$err"))
---

=== get umask
umask | grep '[0-9]\+'  # check for digits
---
(pipe (command (word "umask")) (command (word "grep") (word "'[0-9]\\+'")))
---

=== set umask in octal
rm -f $TMP/umask-one $TMP/umask-two
umask 0002
echo one > $TMP/umask-one
umask 0022
echo two > $TMP/umask-two
stat -c '%a' $TMP/umask-one $TMP/umask-two
---
(command (word "rm") (word "-f") (word "$TMP/umask-one") (word "$TMP/umask-two"))
(command (word "umask") (word "0002"))
(command (word "echo") (word "one") (redirect ">" "$TMP/umask-one"))
(command (word "umask") (word "0022"))
(command (word "echo") (word "two") (redirect ">" "$TMP/umask-two"))
(command (word "stat") (word "-c") (word "'%a'") (word "$TMP/umask-one") (word "$TMP/umask-two"))
---

=== set umask symbolically
umask 0002  # begin in a known state for the test
rm -f $TMP/umask-one $TMP/umask-two
echo one > $TMP/umask-one
umask g-w,o-w
echo two > $TMP/umask-two
stat -c '%a' $TMP/umask-one $TMP/umask-two
---
(command (word "umask") (word "0002"))
(command (word "rm") (word "-f") (word "$TMP/umask-one") (word "$TMP/umask-two"))
(command (word "echo") (word "one") (redirect ">" "$TMP/umask-one"))
(command (word "umask") (word "g-w,o-w"))
(command (word "echo") (word "two") (redirect ">" "$TMP/umask-two"))
(command (word "stat") (word "-c") (word "'%a'") (word "$TMP/umask-one") (word "$TMP/umask-two"))
---

=== ulimit with no flags is like -f
ulimit > no-flags.txt
echo status=$?

ulimit -f > f.txt
echo status=$?

diff -u no-flags.txt f.txt
echo diff=$?

# Print everything
# ulimit -a
---
(command (word "ulimit") (redirect ">" "no-flags.txt"))
(command (word "echo") (word "status=$?"))
(command (word "ulimit") (word "-f") (redirect ">" "f.txt"))
(command (word "echo") (word "status=$?"))
(command (word "diff") (word "-u") (word "no-flags.txt") (word "f.txt"))
(command (word "echo") (word "diff=$?"))
---

=== ulimit too many args
ulimit 1 2
if test $? -ne 0; then
  echo pass
else
  echo fail
fi

#ulimit -f
---
(command (word "ulimit") (word "1") (word "2"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "pass")) (command (word "echo") (word "fail")))
---

=== ulimit negative flag
ulimit -f

# interpreted as a flag
ulimit -f -42
if test $? -ne 0; then
  echo pass
else
  echo fail
fi
---
(command (word "ulimit") (word "-f"))
(command (word "ulimit") (word "-f") (word "-42"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "pass")) (command (word "echo") (word "fail")))
---

=== ulimit negative arg
ulimit -f

# an arg
ulimit -f -- -42
if test $? -ne 0; then
  echo pass
else
  echo fail
fi
---
(command (word "ulimit") (word "-f"))
(command (word "ulimit") (word "-f") (word "--") (word "-42"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "pass")) (command (word "echo") (word "fail")))
---

=== ulimit -a doesn't take arg
case $SH in bash) exit ;; esac

ulimit -a 42
if test $? -ne 0; then
  echo 'failure that was expected'
fi
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "ulimit") (word "-a") (word "42"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'failure that was expected'")))
---

=== ulimit doesn't accept multiple flags - reduce confusion between shells
# - bash, zsh, busybox ash accept multiple "commands", which requires custom
#   flag parsing, like

#   ulimit -f 999 -n
#   ulimit -f 999 -n 888
#
# - dash and mksh accept a single ARG
#
# we want to make it clear we're like the latter

# can't print all and -f
ulimit -f -a >/dev/null
echo status=$?

ulimit -f -n >/dev/null
echo status=$?

ulimit -f -n 999 >/dev/null
echo status=$?
---
(command (word "ulimit") (word "-f") (word "-a") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "ulimit") (word "-f") (word "-n") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
(command (word "ulimit") (word "-f") (word "-n") (word "999") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== YSH readability: ulimit --all the same as ulimit -a
case $SH in bash|dash|mksh|zsh) exit ;; esac

ulimit -a > short.txt
ulimit --all > long.txt

wc -l short.txt long.txt

diff -u short.txt long.txt
echo status=$?
---
(case (word "$SH") (pattern ((word "bash") (word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(command (word "ulimit") (word "-a") (redirect ">" "short.txt"))
(command (word "ulimit") (word "--all") (redirect ">" "long.txt"))
(command (word "wc") (word "-l") (word "short.txt") (word "long.txt"))
(command (word "diff") (word "-u") (word "short.txt") (word "long.txt"))
(command (word "echo") (word "status=$?"))
---

=== ulimit accepts 'unlimited'
for arg in zz unlimited; do
  echo "  arg $arg"
  ulimit -f
  echo status=$?
  ulimit -f $arg
  if test $? -ne 0; then
    echo 'FAILED'
  fi
  echo
done
---
(for (word "arg") (in (word "zz") (word "unlimited")) (semi (semi (semi (semi (semi (command (word "echo") (word "\"  arg $arg\"")) (command (word "ulimit") (word "-f"))) (command (word "echo") (word "status=$?"))) (command (word "ulimit") (word "-f") (word "$arg"))) (if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'FAILED'")))) (command (word "echo"))))
---

=== ulimit of 2**32, 2**31 (int overflow)
echo -n 'one '; ulimit -f


ulimit -f $(( 1 << 32 ))

echo -n 'two '; ulimit -f


# mksh fails because it overflows signed int, turning into negative number
ulimit -f $(( 1 << 31 ))

echo -n 'three '; ulimit -f
---
(semi (command (word "echo") (word "-n") (word "'one '")) (command (word "ulimit") (word "-f")))
(command (word "ulimit") (word "-f") (word "$(( 1 << 32 ))"))
(semi (command (word "echo") (word "-n") (word "'two '")) (command (word "ulimit") (word "-f")))
(command (word "ulimit") (word "-f") (word "$(( 1 << 31 ))"))
(semi (command (word "echo") (word "-n") (word "'three '")) (command (word "ulimit") (word "-f")))
---

=== ulimit that is 64 bits
# no 64-bit integers
case $SH in mksh) exit ;; esac

echo -n 'before '; ulimit -f

# 1 << 63 overflows signed int

# 512 is 1 << 9, so make it 62-9 = 53 bits

lim=$(( 1 << 53 ))
#echo $lim

# bash says this is out of range
ulimit -f $lim

echo -n 'after '; ulimit -f
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(semi (command (word "echo") (word "-n") (word "'before '")) (command (word "ulimit") (word "-f")))
(command (word "lim=$(( 1 << 53 ))"))
(command (word "ulimit") (word "-f") (word "$lim"))
(semi (command (word "echo") (word "-n") (word "'after '")) (command (word "ulimit") (word "-f")))
---

=== arg that would overflow 64 bits is detected
# no 64-bit integers
case $SH in mksh) exit ;; esac

echo -n 'before '; ulimit -f

# 1 << 63 overflows signed int

lim=$(( (1 << 62) + 1 ))
#echo lim=$lim

# bash detects that this is out of range
# so does osh-cpp, but not osh-cpython

ulimit -f $lim
echo -n 'after '; ulimit -f
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(semi (command (word "echo") (word "-n") (word "'before '")) (command (word "ulimit") (word "-f")))
(command (word "lim=$(( (1 << 62) + 1 ))"))
(command (word "ulimit") (word "-f") (word "$lim"))
(semi (command (word "echo") (word "-n") (word "'after '")) (command (word "ulimit") (word "-f")))
---

=== ulimit -f 1 prevents files larger 512 bytes
trap - XFSZ  # don't handle this

rm -f err.txt
touch err.txt

bytes() {
  local n=$1
  local st=0
  for i in $(seq $n); do
    echo -n x
    st=$?
    if test $st -ne 0; then
      echo "ERROR: echo failed with status $st" >> err.txt
    fi
  done
}

ulimit -f 1

bytes 512 > ok.txt
echo 512 status=$?

bytes 513 > too-big.txt
echo 513 status=$?
echo

wc --bytes ok.txt too-big.txt
echo

cat err.txt
---
(command (word "trap") (word "-") (word "XFSZ"))
(command (word "rm") (word "-f") (word "err.txt"))
(command (word "touch") (word "err.txt"))
(function "bytes" (brace-group (semi (semi (command (word "local") (word "n=$1")) (command (word "local") (word "st=0"))) (for (word "i") (in (word "$(seq $n)")) (semi (semi (command (word "echo") (word "-n") (word "x")) (command (word "st=$?"))) (if (command (word "test") (word "$st") (word "-ne") (word "0")) (command (word "echo") (word "\"ERROR: echo failed with status $st\"") (redirect ">>" "err.txt"))))))))
(command (word "ulimit") (word "-f") (word "1"))
(command (word "bytes") (word "512") (redirect ">" "ok.txt"))
(command (word "echo") (word "512") (word "status=$?"))
(command (word "bytes") (word "513") (redirect ">" "too-big.txt"))
(command (word "echo") (word "513") (word "status=$?"))
(command (word "echo"))
(command (word "wc") (word "--bytes") (word "ok.txt") (word "too-big.txt"))
(command (word "echo"))
(command (word "cat") (word "err.txt"))
---

=== write big file with ulimit
# I think this will test write() errors, rather than the final flush() error
# (which is currently skipped by C++

{ echo 'ulimit -f 1'
  # More than 8 KiB may cause a flush()
  python2 -c 'print("echo " + "X"*9000 + " >out.txt")'
  echo 'echo inner=$?'
} > big.sh

$SH big.sh
echo outer=$?
---
(brace-group (semi (semi (command (word "echo") (word "'ulimit -f 1'")) (command (word "python2") (word "-c") (word "'print(\"echo \" + \"X\"*9000 + \" >out.txt\")'"))) (command (word "echo") (word "'echo inner=$?'")))) (redirect ">" "big.sh")
(command (word "$SH") (word "big.sh"))
(command (word "echo") (word "outer=$?"))
---

=== ulimit -S for soft limit (default), -H for hard limit
case $SH in dash|zsh) exit ;; esac

# Note: ulimit -n -S 1111 is OK in osh/dash/mksh, but not bash/zsh
# Mus be ulimit -S -n 1111

show_state() {
  local msg=$1
  echo "$msg"
  echo -n '  '; ulimit -S -t
  echo -n '  '; ulimit -H -t
  echo
}

show_state 'init'

ulimit -S -t 123456
show_state '-S'

ulimit -H -t 123457
show_state '-H'

ulimit -t 123455
show_state 'no flag'

echo 'GET'

ulimit -S -t 123454
echo -n '  '; ulimit -t
echo -n '  '; ulimit -S -t
echo -n '  '; ulimit -H -t
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(function "show_state" (brace-group (semi (semi (semi (semi (semi (semi (command (word "local") (word "msg=$1")) (command (word "echo") (word "\"$msg\""))) (command (word "echo") (word "-n") (word "'  '"))) (command (word "ulimit") (word "-S") (word "-t"))) (command (word "echo") (word "-n") (word "'  '"))) (command (word "ulimit") (word "-H") (word "-t"))) (command (word "echo")))))
(command (word "show_state") (word "'init'"))
(command (word "ulimit") (word "-S") (word "-t") (word "123456"))
(command (word "show_state") (word "'-S'"))
(command (word "ulimit") (word "-H") (word "-t") (word "123457"))
(command (word "show_state") (word "'-H'"))
(command (word "ulimit") (word "-t") (word "123455"))
(command (word "show_state") (word "'no flag'"))
(command (word "echo") (word "'GET'"))
(command (word "ulimit") (word "-S") (word "-t") (word "123454"))
(semi (command (word "echo") (word "-n") (word "'  '")) (command (word "ulimit") (word "-t")))
(semi (command (word "echo") (word "-n") (word "'  '")) (command (word "ulimit") (word "-S") (word "-t")))
(semi (command (word "echo") (word "-n") (word "'  '")) (command (word "ulimit") (word "-H") (word "-t")))
---

=== Changing resource limit is denied
# Not sure why these don't work
case $SH in dash|mksh) exit ;; esac


flag=-t

ulimit -S -H $flag 100
echo both=$?

ulimit -S $flag 90
echo soft=$?

ulimit -S $flag 95
echo soft=$?

ulimit -S $flag 105
if test $? -ne 0; then
  echo soft OK
else
  echo soft fail
fi

ulimit -H $flag 200
if test $? -ne 0; then
  echo hard OK
else
  echo hard fail
fi
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "flag=-t"))
(command (word "ulimit") (word "-S") (word "-H") (word "$flag") (word "100"))
(command (word "echo") (word "both=$?"))
(command (word "ulimit") (word "-S") (word "$flag") (word "90"))
(command (word "echo") (word "soft=$?"))
(command (word "ulimit") (word "-S") (word "$flag") (word "95"))
(command (word "echo") (word "soft=$?"))
(command (word "ulimit") (word "-S") (word "$flag") (word "105"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "soft") (word "OK")) (command (word "echo") (word "soft") (word "fail")))
(command (word "ulimit") (word "-H") (word "$flag") (word "200"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "hard") (word "OK")) (command (word "echo") (word "hard") (word "fail")))
---

=== ulimit -n limits file descriptors
# OSH bug
# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/alpine.20build.20failures.20-.20make.20-.20ulimit.20-n.2064/with/519691301

$SH -c 'ulimit -n 64; echo hi >out'
echo status=$?

$SH -c 'ulimit -n 0; echo hi >out'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'ulimit -n 64; echo hi >out'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'ulimit -n 0; echo hi >out'"))
(command (word "echo") (word "status=$?"))
---

=== read line from here doc
# NOTE: there are TABS below
read x <<EOF
A		B C D E
FG
EOF
echo "[$x]"
---
(command (word "read") (word "x") (redirect "<<" "A		B C D E
FG
"))
(command (word "echo") (word "\"[$x]\""))
---

=== read from empty file
echo -n '' > $TMP/empty.txt
read x < $TMP/empty.txt
argv.py "status=$?" "$x"

# No variable name, behaves the same
read < $TMP/empty.txt
argv.py "status=$?" "$REPLY"
---
(command (word "echo") (word "-n") (word "''") (redirect ">" "$TMP/empty.txt"))
(command (word "read") (word "x") (redirect "<" "$TMP/empty.txt"))
(command (word "argv.py") (word "\"status=$?\"") (word "\"$x\""))
(command (word "read") (redirect "<" "$TMP/empty.txt"))
(command (word "argv.py") (word "\"status=$?\"") (word "\"$REPLY\""))
---

=== read /dev/null
read -n 1 </dev/null
echo $?
---
(command (word "read") (word "-n") (word "1") (redirect "<" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== read with zero args
echo | read
echo status=$?
---
(pipe (command (word "echo")) (command (word "read")))
(command (word "echo") (word "status=$?"))
---

=== read builtin with no newline returns status 1
# This is odd because the variable is populated successfully.  OSH/YSH might
# need a separate put reading feature that doesn't use IFS.

echo -n ZZZ | { read x; echo status=$?; echo $x; }
---
(pipe (command (word "echo") (word "-n") (word "ZZZ")) (brace-group (semi (semi (command (word "read") (word "x")) (command (word "echo") (word "status=$?"))) (command (word "echo") (word "$x")))))
---

=== read builtin splits value across multiple vars
# NOTE: there are TABS below
read x y z <<EOF
A		B C D E 
FG
EOF
echo "[$x/$y/$z]"
---
(command (word "read") (word "x") (word "y") (word "z") (redirect "<<" "A		B C D E 
FG
"))
(command (word "echo") (word "\"[$x/$y/$z]\""))
---

=== read builtin with too few variables
set -o errexit
set -o nounset  # hm this doesn't change it
read x y z <<EOF
A B
EOF
echo /$x/$y/$z/
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "read") (word "x") (word "y") (word "z") (redirect "<<" "A B
"))
(command (word "echo") (word "/$x/$y/$z/"))
---

=== read -n (with $REPLY)
echo 12345 > $TMP/readn.txt
read -n 4 x < $TMP/readn.txt
read -n 2 < $TMP/readn.txt  # Do it again with no variable
argv.py $x $REPLY
---
(command (word "echo") (word "12345") (redirect ">" "$TMP/readn.txt"))
(command (word "read") (word "-n") (word "4") (word "x") (redirect "<" "$TMP/readn.txt"))
(command (word "read") (word "-n") (word "2") (redirect "<" "$TMP/readn.txt"))
(command (word "argv.py") (word "$x") (word "$REPLY"))
---

=== IFS= read -n (OSH regression: value saved in tempenv)
echo XYZ > "$TMP/readn.txt"
IFS= TMOUT= read -n 1 char < "$TMP/readn.txt"
argv.py "$char"
---
(command (word "echo") (word "XYZ") (redirect ">" ""$TMP/readn.txt""))
(command (word "IFS=") (word "TMOUT=") (word "read") (word "-n") (word "1") (word "char") (redirect "<" ""$TMP/readn.txt""))
(command (word "argv.py") (word "\"$char\""))
---

=== read -n doesn't strip whitespace (bug fix)
case $SH in dash|zsh) exit ;; esac

echo '  a b  ' | (read -n 4; echo "[$REPLY]")
echo '  a b  ' | (read -n 5; echo "[$REPLY]")
echo '  a b  ' | (read -n 6; echo "[$REPLY]")
echo

echo 'one var strips whitespace'
echo '  a b  ' | (read -n 4 myvar; echo "[$myvar]")
echo '  a b  ' | (read -n 5 myvar; echo "[$myvar]")
echo '  a b  ' | (read -n 6 myvar; echo "[$myvar]")
echo

echo 'three vars'
echo '  a b  ' | (read -n 4 x y z; echo "[$x] [$y] [$z]")
echo '  a b  ' | (read -n 5 x y z; echo "[$x] [$y] [$z]")
echo '  a b  ' | (read -n 6 x y z; echo "[$x] [$y] [$z]")
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "4")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "5")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "6")) (command (word "echo") (word "\"[$REPLY]\"")))))
(command (word "echo"))
(command (word "echo") (word "'one var strips whitespace'"))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "4") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "5") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "6") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(command (word "echo"))
(command (word "echo") (word "'three vars'"))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "4") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "5") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "-n") (word "6") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
---

=== read -d -n - respects delimiter and splits
case $SH in dash|zsh|ash) exit ;; esac

echo 'delim c'
echo '  a b c ' | (read -d 'c' -n 3; echo "[$REPLY]")
echo '  a b c ' | (read -d 'c' -n 4; echo "[$REPLY]")
echo '  a b c ' | (read -d 'c' -n 5; echo "[$REPLY]")
echo

echo 'one var'
echo '  a b c ' | (read -d 'c' -n 3 myvar; echo "[$myvar]")
echo '  a b c ' | (read -d 'c' -n 4 myvar; echo "[$myvar]")
echo '  a b c ' | (read -d 'c' -n 5 myvar; echo "[$myvar]")
echo

echo 'three vars'
echo '  a b c ' | (read -d 'c' -n 3 x y z; echo "[$x] [$y] [$z]")
echo '  a b c ' | (read -d 'c' -n 4 x y z; echo "[$x] [$y] [$z]")
echo '  a b c ' | (read -d 'c' -n 5 x y z; echo "[$x] [$y] [$z]")
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "ash")) (command (word "exit"))))
(command (word "echo") (word "'delim c'"))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "3")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "4")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "5")) (command (word "echo") (word "\"[$REPLY]\"")))))
(command (word "echo"))
(command (word "echo") (word "'one var'"))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "3") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "4") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "5") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(command (word "echo"))
(command (word "echo") (word "'three vars'"))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "3") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "4") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
(pipe (command (word "echo") (word "'  a b c '")) (subshell (semi (command (word "read") (word "-d") (word "'c'") (word "-n") (word "5") (word "x") (word "y") (word "z")) (command (word "echo") (word "\"[$x] [$y] [$z]\"")))))
---

=== read -n with invalid arg
read -n not_a_number
echo status=$?
---
(command (word "read") (word "-n") (word "not_a_number"))
(command (word "echo") (word "status=$?"))
---

=== read -n from pipe
case $SH in dash|ash|zsh) exit ;; esac

echo abcxyz | { read -n 3; echo reply=$REPLY; }
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "zsh")) (command (word "exit"))))
(pipe (command (word "echo") (word "abcxyz")) (brace-group (semi (command (word "read") (word "-n") (word "3")) (command (word "echo") (word "reply=$REPLY")))))
---

=== read without args uses $REPLY, no splitting occurs (without -n)
# mksh and zsh implement splitting with $REPLY, bash/ash don't

echo '  a b  ' | (read; echo "[$REPLY]")
echo '  a b  ' | (read myvar; echo "[$myvar]")

echo '  a b  \
  line2' | (read; echo "[$REPLY]")
echo '  a b  \
  line2' | (read myvar; echo "[$myvar]")

# Now test with -r
echo '  a b  \
  line2' | (read -r; echo "[$REPLY]")
echo '  a b  \
  line2' | (read -r myvar; echo "[$myvar]")
---
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b  '")) (subshell (semi (command (word "read") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b  \\\n  line2'")) (subshell (semi (command (word "read")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b  \\\n  line2'")) (subshell (semi (command (word "read") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
(pipe (command (word "echo") (word "'  a b  \\\n  line2'")) (subshell (semi (command (word "read") (word "-r")) (command (word "echo") (word "\"[$REPLY]\"")))))
(pipe (command (word "echo") (word "'  a b  \\\n  line2'")) (subshell (semi (command (word "read") (word "-r") (word "myvar")) (command (word "echo") (word "\"[$myvar]\"")))))
---

=== read -n vs. -N
# dash, ash and zsh do not implement read -N
# mksh treats -N exactly the same as -n
case $SH in dash|ash|zsh) exit ;; esac

# bash docs: https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

echo 'a b c' > $TMP/readn.txt

echo 'read -n'
read -n 5 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
read -n 4 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
echo

echo 'read -N'
read -N 5 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
read -N 4 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "zsh")) (command (word "exit"))))
(command (word "echo") (word "'a b c'") (redirect ">" "$TMP/readn.txt"))
(command (word "echo") (word "'read -n'"))
(semi (command (word "read") (word "-n") (word "5") (word "A") (word "B") (word "C") (redirect "<" "$TMP/readn.txt")) (command (word "echo") (word "\"'$A' '$B' '$C'\"")))
(semi (command (word "read") (word "-n") (word "4") (word "A") (word "B") (word "C") (redirect "<" "$TMP/readn.txt")) (command (word "echo") (word "\"'$A' '$B' '$C'\"")))
(command (word "echo"))
(command (word "echo") (word "'read -N'"))
(semi (command (word "read") (word "-N") (word "5") (word "A") (word "B") (word "C") (redirect "<" "$TMP/readn.txt")) (command (word "echo") (word "\"'$A' '$B' '$C'\"")))
(semi (command (word "read") (word "-N") (word "4") (word "A") (word "B") (word "C") (redirect "<" "$TMP/readn.txt")) (command (word "echo") (word "\"'$A' '$B' '$C'\"")))
---

=== read -N ignores delimiters
case $SH in dash|ash|zsh) exit ;; esac

echo $'a\nb\nc' > $TMP/read-lines.txt

read -N 3 out < $TMP/read-lines.txt
echo "$out"
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "zsh")) (command (word "exit"))))
(command (word "echo") (word "'a\nb\nc'") (redirect ">" "$TMP/read-lines.txt"))
(command (word "read") (word "-N") (word "3") (word "out") (redirect "<" "$TMP/read-lines.txt"))
(command (word "echo") (word "\"$out\""))
---

=== read will unset extranous vars
echo 'a b' > $TMP/read-few.txt

c='some value'
read a b c < $TMP/read-few.txt
echo "'$a' '$b' '$c'"

case $SH in dash) exit ;; esac # dash does not implement -n

c='some value'
read -n 3 a b c < $TMP/read-few.txt
echo "'$a' '$b' '$c'"
---
(command (word "echo") (word "'a b'") (redirect ">" "$TMP/read-few.txt"))
(command (word "c='some value'"))
(command (word "read") (word "a") (word "b") (word "c") (redirect "<" "$TMP/read-few.txt"))
(command (word "echo") (word "\"'$a' '$b' '$c'\""))
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "c='some value'"))
(command (word "read") (word "-n") (word "3") (word "a") (word "b") (word "c") (redirect "<" "$TMP/read-few.txt"))
(command (word "echo") (word "\"'$a' '$b' '$c'\""))
---

=== read -r ignores backslashes
echo 'one\ two' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"
---
(command (word "echo") (word "'one\\ two'") (redirect ">" "$TMP/readr.txt"))
(command (word "read") (word "escaped") (redirect "<" "$TMP/readr.txt"))
(command (word "read") (word "-r") (word "raw") (redirect "<" "$TMP/readr.txt"))
(command (word "argv.py") (word "\"$escaped\"") (word "\"$raw\""))
---

=== read -r with other backslash escapes
echo 'one\ two\x65three' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"
# mksh respects the hex escapes here, but other shells don't!
---
(command (word "echo") (word "'one\\ two\\x65three'") (redirect ">" "$TMP/readr.txt"))
(command (word "read") (word "escaped") (redirect "<" "$TMP/readr.txt"))
(command (word "read") (word "-r") (word "raw") (redirect "<" "$TMP/readr.txt"))
(command (word "argv.py") (word "\"$escaped\"") (word "\"$raw\""))
---

=== read with line continuation reads multiple physical lines
# NOTE: osh failing because of file descriptor issue.  stdin has to be closed!
tmp=$TMP/$(basename $SH)-readr.txt
echo -e 'one\\\ntwo\n' > $tmp
read escaped < $tmp
read -r raw < $tmp
argv.py "$escaped" "$raw"
---
(command (word "tmp=$TMP/$(basename $SH)-readr.txt"))
(command (word "echo") (word "-e") (word "'one\\\\\\ntwo\\n'") (redirect ">" "$tmp"))
(command (word "read") (word "escaped") (redirect "<" "$tmp"))
(command (word "read") (word "-r") (word "raw") (redirect "<" "$tmp"))
(command (word "argv.py") (word "\"$escaped\"") (word "\"$raw\""))
---

=== read multiple vars spanning many lines
read x y << 'EOF'
one-\
two three-\
four five-\
six
EOF
argv.py "$x" "$y" "$z"
---
(command (word "read") (word "x") (word "y") (redirect "<<" "one-\
two three-\
four five-\
six
"))
(command (word "argv.py") (word "\"$x\"") (word "\"$y\"") (word "\"$z\""))
---

=== read -r with \n
echo '\nline' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"
# dash/mksh/zsh are bugs because at least the raw mode should let you read a
# literal \n.
---
(command (word "echo") (word "'\\nline'") (redirect ">" "$TMP/readr.txt"))
(command (word "read") (word "escaped") (redirect "<" "$TMP/readr.txt"))
(command (word "read") (word "-r") (word "raw") (redirect "<" "$TMP/readr.txt"))
(command (word "argv.py") (word "\"$escaped\"") (word "\"$raw\""))
---

=== read -s from pipe, not a terminal
case $SH in dash|zsh) exit ;; esac

# It's hard to really test this because it requires a terminal.  We hit a
# different code path when reading through a pipe.  There can be bugs there
# too!

echo foo | { read -s; echo $REPLY; }
echo bar | { read -n 2 -s; echo $REPLY; }

# Hm no exit 1 here?  Weird
echo b | { read -n 2 -s; echo $?; echo $REPLY; }
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(pipe (command (word "echo") (word "foo")) (brace-group (semi (command (word "read") (word "-s")) (command (word "echo") (word "$REPLY")))))
(pipe (command (word "echo") (word "bar")) (brace-group (semi (command (word "read") (word "-n") (word "2") (word "-s")) (command (word "echo") (word "$REPLY")))))
(pipe (command (word "echo") (word "b")) (brace-group (semi (semi (command (word "read") (word "-n") (word "2") (word "-s")) (command (word "echo") (word "$?"))) (command (word "echo") (word "$REPLY")))))
---

=== read with IFS=$'\n'
# The leading spaces are stripped if they appear in IFS.
IFS=$(echo -e '\n')
read var <<EOF
  a b c
  d e f
EOF
echo "[$var]"
---
(command (word "IFS=$(echo -e '\\n')"))
(command (word "read") (word "var") (redirect "<<" "  a b c
  d e f
"))
(command (word "echo") (word "\"[$var]\""))
---

=== read multiple lines with IFS=:
# The leading spaces are stripped if they appear in IFS.
# IFS chars are escaped with :.
tmp=$TMP/$(basename $SH)-read-ifs.txt
IFS=:
cat >$tmp <<'EOF'
  \\a :b\: c:d\
  e
EOF
read a b c d < $tmp
# Use printf because echo in dash/mksh interprets escapes, while it doesn't in
# bash.
printf "%s\n" "[$a|$b|$c|$d]"
---
(command (word "tmp=$TMP/$(basename $SH)-read-ifs.txt"))
(command (word "IFS=:"))
(command (word "cat") (redirect ">" "$tmp") (redirect "<<" "  \\a :b\: c:d\
  e
"))
(command (word "read") (word "a") (word "b") (word "c") (word "d") (redirect "<" "$tmp"))
(command (word "printf") (word "\"%s\\n\"") (word "\"[$a|$b|$c|$d]\""))
---

=== read with IFS=''
IFS=''
read x y <<EOF
  a b c d
EOF
echo "[$x|$y]"
---
(command (word "IFS=''"))
(command (word "read") (word "x") (word "y") (redirect "<<" "  a b c d
"))
(command (word "echo") (word "\"[$x|$y]\""))
---

=== read does not respect C backslash escapes
# bash doesn't respect these, but other shells do.  Gah!  I think bash
# behavior makes more sense.  It only escapes IFS.
echo '\a \b \c \d \e \f \g \h \x65 \145 \i' > $TMP/read-c.txt
read line < $TMP/read-c.txt
echo $line
---
(command (word "echo") (word "'\\a \\b \\c \\d \\e \\f \\g \\h \\x65 \\145 \\i'") (redirect ">" "$TMP/read-c.txt"))
(command (word "read") (word "line") (redirect "<" "$TMP/read-c.txt"))
(command (word "echo") (word "$line"))
---

=== dynamic scope used to set vars
f() {
  read head << EOF
ref: refs/heads/dev/andy
EOF
}
f
echo $head
---
(function "f" (brace-group (command (word "read") (word "head") (redirect "<<" "ref: refs/heads/dev/andy
"))))
(command (word "f"))
(command (word "echo") (word "$head"))
---

=== read -a reads into array
# read -a is used in bash-completion
# none of these shells implement it
case $SH in
  *mksh|*dash|*zsh|*/ash)
    exit 2;
    ;;
esac

read -a myarray <<'EOF'
a b c\ d
EOF
argv.py "${myarray[@]}"

# arguments are ignored here
read -r -a array2 extra arguments <<'EOF'
a b c\ d
EOF
argv.py "${array2[@]}"
argv.py "${extra[@]}"
argv.py "${arguments[@]}"
---
(case (word "$SH") (pattern ((word "*mksh") (word "*dash") (word "*zsh") (word "*/ash")) (command (word "exit") (word "2"))))
(command (word "read") (word "-a") (word "myarray") (redirect "<<" "a b c\ d
"))
(command (word "argv.py") (word "\"${myarray[@]}\""))
(command (word "read") (word "-r") (word "-a") (word "array2") (word "extra") (word "arguments") (redirect "<<" "a b c\ d
"))
(command (word "argv.py") (word "\"${array2[@]}\""))
(command (word "argv.py") (word "\"${extra[@]}\""))
(command (word "argv.py") (word "\"${arguments[@]}\""))
---

=== read -d : (colon-separated records)
printf a,b,c:d,e,f:g,h,i | {
  IFS=,
  read -d : v1
  echo "v1=$v1"
  read -d : v1 v2
  echo "v1=$v1 v2=$v2"
  read -d : v1 v2 v3
  echo "v1=$v1 v2=$v2 v3=$v3"
}
---
(pipe (command (word "printf") (word "a,b,c:d,e,f:g,h,i")) (brace-group (semi (semi (semi (semi (semi (semi (command (word "IFS=,")) (command (word "read") (word "-d") (word ":") (word "v1"))) (command (word "echo") (word "\"v1=$v1\""))) (command (word "read") (word "-d") (word ":") (word "v1") (word "v2"))) (command (word "echo") (word "\"v1=$v1 v2=$v2\""))) (command (word "read") (word "-d") (word ":") (word "v1") (word "v2") (word "v3"))) (command (word "echo") (word "\"v1=$v1 v2=$v2 v3=$v3\"")))))
---

=== read -d '' (null-separated records)
printf 'a,b,c\0d,e,f\0g,h,i' | {
  IFS=,
  read -d '' v1
  echo "v1=$v1"
  read -d '' v1 v2
  echo "v1=$v1 v2=$v2"
  read -d '' v1 v2 v3
  echo "v1=$v1 v2=$v2 v3=$v3"
}
---
(pipe (command (word "printf") (word "'a,b,c\\0d,e,f\\0g,h,i'")) (brace-group (semi (semi (semi (semi (semi (semi (command (word "IFS=,")) (command (word "read") (word "-d") (word "''") (word "v1"))) (command (word "echo") (word "\"v1=$v1\""))) (command (word "read") (word "-d") (word "''") (word "v1") (word "v2"))) (command (word "echo") (word "\"v1=$v1 v2=$v2\""))) (command (word "read") (word "-d") (word "''") (word "v1") (word "v2") (word "v3"))) (command (word "echo") (word "\"v1=$v1 v2=$v2 v3=$v3\"")))))
---

=== read -rd
read -rd '' var <<EOF
foo
bar
EOF
echo "$var"
---
(command (word "read") (word "-rd") (word "''") (word "var") (redirect "<<" "foo
bar
"))
(command (word "echo") (word "\"$var\""))
---

=== read -d when there's no delimiter
{ read -d : part
  echo $part $?
  read -d : part
  echo $part $?
} <<EOF
foo:bar
EOF
---
(brace-group (semi (semi (semi (command (word "read") (word "-d") (word ":") (word "part")) (command (word "echo") (word "$part") (word "$?"))) (command (word "read") (word "-d") (word ":") (word "part"))) (command (word "echo") (word "$part") (word "$?")))) (redirect "<<" "foo:bar
")
---

=== read -t 0 tests if input is available
case $SH in dash|zsh|mksh) exit ;; esac

# is there input available?
read -t 0 < /dev/null
echo $?

# floating point
read -t 0.0 < /dev/null
echo $?

# floating point
echo foo | { read -t 0; echo reply=$REPLY; }
echo $?
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "mksh")) (command (word "exit"))))
(command (word "read") (word "-t") (word "0") (redirect "<" "/dev/null"))
(command (word "echo") (word "$?"))
(command (word "read") (word "-t") (word "0.0") (redirect "<" "/dev/null"))
(command (word "echo") (word "$?"))
(pipe (command (word "echo") (word "foo")) (brace-group (semi (command (word "read") (word "-t") (word "0")) (command (word "echo") (word "reply=$REPLY")))))
(command (word "echo") (word "$?"))
---

=== read -t 0.5
case $SH in dash) exit ;; esac

read -t 0.5 < /dev/null
echo $?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "read") (word "-t") (word "0.5") (redirect "<" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== read -t -0.5 is invalid
# bash appears to just take the absolute value?

read -t -0.5 < /dev/null
echo $?
---
(command (word "read") (word "-t") (word "-0.5") (redirect "<" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== read -u
case $SH in dash|mksh) exit ;; esac

# file descriptor
read -u 3 3<<EOF
hi
EOF
echo reply=$REPLY
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "read") (word "-u") (word "3") (redirect "<<" "hi
"))
(command (word "echo") (word "reply=$REPLY"))
---

=== read -u syntax error
read -u -3
echo status=$?
---
(command (word "read") (word "-u") (word "-3"))
(command (word "echo") (word "status=$?"))
---

=== read -u -s
case $SH in dash|mksh) exit ;; esac

# file descriptor
read -s -u 3 3<<EOF
hi
EOF
echo reply=$REPLY
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "read") (word "-s") (word "-u") (word "3") (redirect "<<" "hi
"))
(command (word "echo") (word "reply=$REPLY"))
---

=== read -u 3 -d 5
case $SH in dash|mksh) exit ;; esac

# file descriptor
read -u 3 -d 5 3<<EOF
123456789
EOF
echo reply=$REPLY
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "read") (word "-u") (word "3") (word "-d") (word "5") (redirect "<<" "123456789
"))
(command (word "echo") (word "reply=$REPLY"))
---

=== read -u 3 -d b -N 6
case $SH in ash|zsh) exit ;; esac

# file descriptor
read -u 3 -d b -N 4 3<<EOF
ababababa
EOF
echo reply=$REPLY
# test end on EOF
read -u 3 -d b -N 6 3<<EOF
ab
EOF
echo reply=$REPLY
---
(case (word "$SH") (pattern ((word "ash") (word "zsh")) (command (word "exit"))))
(command (word "read") (word "-u") (word "3") (word "-d") (word "b") (word "-N") (word "4") (redirect "<<" "ababababa
"))
(command (word "echo") (word "reply=$REPLY"))
(command (word "read") (word "-u") (word "3") (word "-d") (word "b") (word "-N") (word "6") (redirect "<<" "ab
"))
(command (word "echo") (word "reply=$REPLY"))
---

=== read -N doesn't respect delimiter, while read -n does
case $SH in dash|zsh|ash) exit ;; esac

echo foobar | { read -n 5 -d b; echo $REPLY; }
echo foobar | { read -N 5 -d b; echo $REPLY; }
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "ash")) (command (word "exit"))))
(pipe (command (word "echo") (word "foobar")) (brace-group (semi (command (word "read") (word "-n") (word "5") (word "-d") (word "b")) (command (word "echo") (word "$REPLY")))))
(pipe (command (word "echo") (word "foobar")) (brace-group (semi (command (word "read") (word "-N") (word "5") (word "-d") (word "b")) (command (word "echo") (word "$REPLY")))))
---

=== read -p (not fully tested)
# hm DISABLED if we're not going to the terminal
# so we're only testing that it accepts the flag here

case $SH in dash|mksh|zsh) exit ;; esac

echo hi | { read -p 'P'; echo $REPLY; }
echo hi | { read -p 'P' -n 1; echo $REPLY; }
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(pipe (command (word "echo") (word "hi")) (brace-group (semi (command (word "read") (word "-p") (word "'P'")) (command (word "echo") (word "$REPLY")))))
(pipe (command (word "echo") (word "hi")) (brace-group (semi (command (word "read") (word "-p") (word "'P'") (word "-n") (word "1")) (command (word "echo") (word "$REPLY")))))
---

=== read usage
read -n -1
echo status=$?
---
(command (word "read") (word "-n") (word "-1"))
(command (word "echo") (word "status=$?"))
---

=== read with smooshed args
echo hi | { read -rn1 var; echo var=$var; }
---
(pipe (command (word "echo") (word "hi")) (brace-group (semi (command (word "read") (word "-rn1") (word "var")) (command (word "echo") (word "var=$var")))))
---

=== read -r -d '' for NUL strings, e.g. find -print0
case $SH in dash|zsh|mksh) exit ;; esac  # NOT IMPLEMENTED

mkdir -p read0
cd read0
rm -f *

touch a\\b\\c\\d  # -r is necessary!

find . -type f -a -print0 | { read -r -d ''; echo "[$REPLY]"; }
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "mksh")) (command (word "exit"))))
(command (word "mkdir") (word "-p") (word "read0"))
(command (word "cd") (word "read0"))
(command (word "rm") (word "-f") (word "*"))
(command (word "touch") (word "a\\\\b\\\\c\\\\d"))
(pipe (command (word "find") (word ".") (word "-type") (word "f") (word "-a") (word "-print0")) (brace-group (semi (command (word "read") (word "-r") (word "-d") (word "''")) (command (word "echo") (word "\"[$REPLY]\"")))))
---

=== read from redirected directory is non-fatal error
# This tickles an infinite loop bug in our version of mksh!  TODO: upgrade the
# version and enable this
case $SH in mksh) return ;; esac

cd $TMP
mkdir -p dir
read x < ./dir
echo status=$?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "return"))))
(command (word "cd") (word "$TMP"))
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "read") (word "x") (redirect "<" "./dir"))
(command (word "echo") (word "status=$?"))
---

=== read -n from directory
case $SH in dash|ash) return ;; esac  # not implemented

# same hanging bug
case $SH in mksh) return ;; esac

mkdir -p dir
read -n 3 x < ./dir
echo status=$?
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "return"))))
(case (word "$SH") (pattern ((word "mksh")) (command (word "return"))))
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "read") (word "-n") (word "3") (word "x") (redirect "<" "./dir"))
(command (word "echo") (word "status=$?"))
---

=== mapfile from directory (bash doesn't handle errors)
case $SH in dash|ash|mksh|zsh) return ;; esac  # not implemented

mkdir -p dir
mapfile $x < ./dir
echo status=$?
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "mksh") (word "zsh")) (command (word "return"))))
(command (word "mkdir") (word "-p") (word "dir"))
(command (word "mapfile") (word "$x") (redirect "<" "./dir"))
(command (word "echo") (word "status=$?"))
---

=== read -n 0
case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'a\b\c\d\e\f' | (read -n 0; argv.py "$REPLY")
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit") (word "99"))))
(pipe (command (word "echo") (word "'a\\b\\c\\d\\e\\f'")) (subshell (semi (command (word "read") (word "-n") (word "0")) (command (word "argv.py") (word "\"$REPLY\"")))))
---

=== read -n and backslash escape
case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'a\b\c\d\e\f' | (read -n 5; argv.py "$REPLY")
echo 'a\ \ \ \ \ ' | (read -n 5; argv.py "$REPLY")
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit") (word "99"))))
(pipe (command (word "echo") (word "'a\\b\\c\\d\\e\\f'")) (subshell (semi (command (word "read") (word "-n") (word "5")) (command (word "argv.py") (word "\"$REPLY\"")))))
(pipe (command (word "echo") (word "'a\\ \\ \\ \\ \\ '")) (subshell (semi (command (word "read") (word "-n") (word "5")) (command (word "argv.py") (word "\"$REPLY\"")))))
---

=== read -n 4 with incomplete backslash
case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'abc\def\ghijklmn' | (read -n 4; argv.py "$REPLY")
echo '   \xxx\xxxxxxxx' | (read -n 4; argv.py "$REPLY")

# bash implements "-n NUM" as number of characters
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit") (word "99"))))
(pipe (command (word "echo") (word "'abc\\def\\ghijklmn'")) (subshell (semi (command (word "read") (word "-n") (word "4")) (command (word "argv.py") (word "\"$REPLY\"")))))
(pipe (command (word "echo") (word "'   \\xxx\\xxxxxxxx'")) (subshell (semi (command (word "read") (word "-n") (word "4")) (command (word "argv.py") (word "\"$REPLY\"")))))
---

=== read -n 4 with backslash + delim
case $SH in zsh) exit 99;; esac  # read -n not implemented

echo $'abc\\\ndefg' | (read -n 4; argv.py "$REPLY")
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit") (word "99"))))
(pipe (command (word "echo") (word "'abc\\\ndefg'")) (subshell (semi (command (word "read") (word "-n") (word "4")) (command (word "argv.py") (word "\"$REPLY\"")))))
---

=== "backslash + newline" should be swallowed regardless of "-d <delim>"
printf '%s\n' 'a b\' 'c d' | (read; argv.py "$REPLY")
printf '%s\n' 'a b\,c d'   | (read; argv.py "$REPLY")
printf '%s\n' 'a b\' 'c d' | (read -d ,; argv.py "$REPLY")
printf '%s\n' 'a b\,c d'   | (read -d ,; argv.py "$REPLY")
---
(pipe (command (word "printf") (word "'%s\\n'") (word "'a b\\'") (word "'c d'")) (subshell (semi (command (word "read")) (command (word "argv.py") (word "\"$REPLY\"")))))
(pipe (command (word "printf") (word "'%s\\n'") (word "'a b\\,c d'")) (subshell (semi (command (word "read")) (command (word "argv.py") (word "\"$REPLY\"")))))
(pipe (command (word "printf") (word "'%s\\n'") (word "'a b\\'") (word "'c d'")) (subshell (semi (command (word "read") (word "-d") (word ",")) (command (word "argv.py") (word "\"$REPLY\"")))))
(pipe (command (word "printf") (word "'%s\\n'") (word "'a b\\,c d'")) (subshell (semi (command (word "read") (word "-d") (word ",")) (command (word "argv.py") (word "\"$REPLY\"")))))
---

=== empty input and splitting
case $SH in mksh|ash|dash|zsh) exit 99; esac
echo '' | (read -a a; argv.py "${a[@]}")
IFS=x
echo '' | (read -a a; argv.py "${a[@]}")
IFS=
echo '' | (read -a a; argv.py "${a[@]}")
---
(case (word "$SH") (pattern ((word "mksh") (word "ash") (word "dash") (word "zsh")) (command (word "exit") (word "99"))))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(command (word "IFS=x"))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(command (word "IFS="))
(pipe (command (word "echo") (word "''")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
---

=== IFS='x ' read -a: trailing spaces (unlimited split)
case $SH in mksh|ash|dash|zsh) exit 99; esac
IFS='x '
echo 'a b'     | (read -a a; argv.py "${a[@]}")
echo 'a b '    | (read -a a; argv.py "${a[@]}")
echo 'a bx'    | (read -a a; argv.py "${a[@]}")
echo 'a bx '   | (read -a a; argv.py "${a[@]}")
echo 'a b x'   | (read -a a; argv.py "${a[@]}")
echo 'a b x '  | (read -a a; argv.py "${a[@]}")
echo 'a b x x' | (read -a a; argv.py "${a[@]}")
---
(case (word "$SH") (pattern ((word "mksh") (word "ash") (word "dash") (word "zsh")) (command (word "exit") (word "99"))))
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "'a b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a b '")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a bx'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a bx '")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a b x'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a b x '")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a b x x'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
---

=== IFS='x ' read a b: trailing spaces (with max_split)
echo 'hello world  test   ' | (read a b; argv.py "$a" "$b")
echo '-- IFS=x --'
IFS='x '
echo 'a ax  x  '     | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x'    | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x  '  | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x  a' | (read a b; argv.py "$a" "$b")
---
(pipe (command (word "echo") (word "'hello world  test   '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(command (word "echo") (word "'-- IFS=x --'"))
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "'a ax  x  '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'a ax  x  x'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'a ax  x  x  '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'a ax  x  x  a'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
---

=== IFS='x ' read -a: intermediate spaces (unlimited split)
case $SH in mksh|ash|dash|zsh) exit 99; esac
IFS='x '
echo 'a x b'   | (read -a a; argv.py "${a[@]}")
echo 'a xx b'  | (read -a a; argv.py "${a[@]}")
echo 'a xxx b' | (read -a a; argv.py "${a[@]}")
echo 'a x xb'  | (read -a a; argv.py "${a[@]}")
echo 'a x x b' | (read -a a; argv.py "${a[@]}")
echo 'ax b'    | (read -a a; argv.py "${a[@]}")
echo 'ax xb'   | (read -a a; argv.py "${a[@]}")
echo 'ax  xb'  | (read -a a; argv.py "${a[@]}")
echo 'ax x xb' | (read -a a; argv.py "${a[@]}")
---
(case (word "$SH") (pattern ((word "mksh") (word "ash") (word "dash") (word "zsh")) (command (word "exit") (word "99"))))
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "'a x b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a xx b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a xxx b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a x xb'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'a x x b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'ax b'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'ax xb'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'ax  xb'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
(pipe (command (word "echo") (word "'ax x xb'")) (subshell (semi (command (word "read") (word "-a") (word "a")) (command (word "argv.py") (word "\"${a[@]}\"")))))
---

=== IFS='x ' incomplete backslash
echo ' a b \' | (read a; argv.py "$a")
echo ' a b \' | (read a b; argv.py "$a" "$b")
IFS='x '
echo $'a ax  x    \\\nhello' | (read a b; argv.py "$a" "$b")
---
(pipe (command (word "echo") (word "' a b \\'")) (subshell (semi (command (word "read") (word "a")) (command (word "argv.py") (word "\"$a\"")))))
(pipe (command (word "echo") (word "' a b \\'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "'a ax  x    \\\nhello'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
---

=== IFS='\ ' and backslash escaping
IFS='\ '
echo "hello\ world  test" | (read a b; argv.py "$a" "$b")
IFS='\'
echo "hello\ world  test" | (read a b; argv.py "$a" "$b")
---
(command (word "IFS='\\ '"))
(pipe (command (word "echo") (word "\"hello\\ world  test\"")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(command (word "IFS='\\'"))
(pipe (command (word "echo") (word "\"hello\\ world  test\"")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
---

=== max_split and backslash escaping
echo 'Aa b \ a\ b' | (read a b; argv.py "$a" "$b")
echo 'Aa b \ a\ b' | (read a b c; argv.py "$a" "$b" "$c")
echo 'Aa b \ a\ b' | (read a b c d; argv.py "$a" "$b" "$c" "$d")
---
(pipe (command (word "echo") (word "'Aa b \\ a\\ b'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'Aa b \\ a\\ b'")) (subshell (semi (command (word "read") (word "a") (word "b") (word "c")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"") (word "\"$c\"")))))
(pipe (command (word "echo") (word "'Aa b \\ a\\ b'")) (subshell (semi (command (word "read") (word "a") (word "b") (word "c") (word "d")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"") (word "\"$c\"") (word "\"$d\"")))))
---

=== IFS=x read a b <<< xxxxxx
IFS='x '
echo x     | (read a b; argv.py "$a" "$b")
echo xx    | (read a b; argv.py "$a" "$b")
echo xxx   | (read a b; argv.py "$a" "$b")
echo xxxx  | (read a b; argv.py "$a" "$b")
echo xxxxx | (read a b; argv.py "$a" "$b")
echo '-- spaces --'
echo 'x    ' | (read a b; argv.py "$a" "$b")
echo 'xx   ' | (read a b; argv.py "$a" "$b")
echo 'xxx  ' | (read a b; argv.py "$a" "$b")
echo 'xxxx ' | (read a b; argv.py "$a" "$b")
echo 'xxxxx' | (read a b; argv.py "$a" "$b")
echo '-- with char --'
echo 'xa    ' | (read a b; argv.py "$a" "$b")
echo 'xax   ' | (read a b; argv.py "$a" "$b")
echo 'xaxx  ' | (read a b; argv.py "$a" "$b")
echo 'xaxxx ' | (read a b; argv.py "$a" "$b")
echo 'xaxxxx' | (read a b; argv.py "$a" "$b")
---
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "x")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "xx")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "xxx")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "xxxx")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "xxxxx")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(command (word "echo") (word "'-- spaces --'"))
(pipe (command (word "echo") (word "'x    '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xx   '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xxx  '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xxxx '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xxxxx'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(command (word "echo") (word "'-- with char --'"))
(pipe (command (word "echo") (word "'xa    '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xax   '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xaxx  '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xaxxx '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
(pipe (command (word "echo") (word "'xaxxxx'")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
---

=== read and "\ "
IFS='x '
check() { echo "$1" | (read a b; argv.py "$a" "$b"); }

echo '-- xs... --'
check 'x '
check 'x \ '
check 'x \ \ '
check 'x \ \ \ '
echo '-- xe... --'
check 'x\ '
check 'x\ \ '
check 'x\ \ \ '
check 'x\  '
check 'x\  '
check 'x\    '

# check 'xx\ '
# check 'xx\ '
---
(command (word "IFS='x '"))
(function "check" (brace-group (pipe (command (word "echo") (word "\"$1\"")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))))
(command (word "echo") (word "'-- xs... --'"))
(command (word "check") (word "'x '"))
(command (word "check") (word "'x \\ '"))
(command (word "check") (word "'x \\ \\ '"))
(command (word "check") (word "'x \\ \\ \\ '"))
(command (word "echo") (word "'-- xe... --'"))
(command (word "check") (word "'x\\ '"))
(command (word "check") (word "'x\\ \\ '"))
(command (word "check") (word "'x\\ \\ \\ '"))
(command (word "check") (word "'x\\  '"))
(command (word "check") (word "'x\\  '"))
(command (word "check") (word "'x\\    '"))
---

=== read bash bug
IFS='x '
echo 'x\  \ ' | (read a b; argv.py "$a" "$b")
---
(command (word "IFS='x '"))
(pipe (command (word "echo") (word "'x\\  \\ '")) (subshell (semi (command (word "read") (word "a") (word "b")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"")))))
---

=== can continue after unknown option
#
# TODO: this is the posix special builtin logic?
# dash and mksh make this a fatal error no matter what.

set -o errexit
set -o STRICT || true # unknown option
echo hello
---
(command (word "set") (word "-o") (word "errexit"))
(or (command (word "set") (word "-o") (word "STRICT")) (command (word "true")))
(command (word "echo") (word "hello"))
---

=== set with both options and argv
set -o errexit a b c
echo "$@"
false
echo done
---
(command (word "set") (word "-o") (word "errexit") (word "a") (word "b") (word "c"))
(command (word "echo") (word "\"$@\""))
(command (word "false"))
(command (word "echo") (word "done"))
---

=== nounset with "$@"
set a b c
set -u  # shouldn't touch argv
echo "$@"
---
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "set") (word "-u"))
(command (word "echo") (word "\"$@\""))
---

=== set -u -- clears argv
set a b c
set -u -- # shouldn't touch argv
echo "$@"
---
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "set") (word "-u") (word "--"))
(command (word "echo") (word "\"$@\""))
---

=== set -u -- x y z
set a b c
set -u -- x y z
echo "$@"
---
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "set") (word "-u") (word "--") (word "x") (word "y") (word "z"))
(command (word "echo") (word "\"$@\""))
---

=== set -u with undefined variable exits the interpreter
# non-interactive
$SH -c 'set -u; echo before; echo $x; echo after'
if test $? -ne 0; then
  echo OK
fi

# interactive
$SH -i -c 'set -u; echo before; echo $x; echo after'
if test $? -ne 0; then
  echo OK
fi
---
(command (word "$SH") (word "-c") (word "'set -u; echo before; echo $x; echo after'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "OK")))
(command (word "$SH") (word "-i") (word "-c") (word "'set -u; echo before; echo $x; echo after'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "OK")))
---

=== set -u with undefined var in interactive shell does NOT exit the interpreter
# In bash, it aborts the LINE only.  The next line is executed!

# non-interactive
$SH -c 'set -u; echo before; echo $x; echo after
echo line2
'
if test $? -ne 0; then
  echo OK
fi

# interactive
$SH -i -c 'set -u; echo before; echo $x; echo after
echo line2
'
if test $? -ne 0; then
  echo OK
fi
---
(command (word "$SH") (word "-c") (word "'set -u; echo before; echo $x; echo after\necho line2\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "OK")))
(command (word "$SH") (word "-i") (word "-c") (word "'set -u; echo before; echo $x; echo after\necho line2\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "OK")))
---

=== set -u error can break out of nested evals
$SH -c '
set -u
test_function_2() {
  x=$blarg
}
test_function() {
  eval "test_function_2"
}

echo before
eval test_function
echo after
'
# status must be non-zero: bash uses 1, ash/dash exit 2
if test $? -ne 0; then
  echo OK
fi
---
(command (word "$SH") (word "-c") (word "'\nset -u\ntest_function_2() {\n  x=$blarg\n}\ntest_function() {\n  eval \"test_function_2\"\n}\n\necho before\neval test_function\necho after\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "OK")))
---

=== reset option with long flag
set -o errexit
set +o errexit
echo "[$unset]"
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "set") (word "+o") (word "errexit"))
(command (word "echo") (word "\"[$unset]\""))
---

=== reset option with short flag
set -u 
set +u
echo "[$unset]"
---
(command (word "set") (word "-u"))
(command (word "set") (word "+u"))
(command (word "echo") (word "\"[$unset]\""))
---

=== set -eu (flag parsing)
set -eu 
echo "[$unset]"
echo status=$?
---
(command (word "set") (word "-eu"))
(command (word "echo") (word "\"[$unset]\""))
(command (word "echo") (word "status=$?"))
---

=== set -o lists options
# NOTE: osh doesn't use the same format yet.
set -o | grep -o noexec
---
(pipe (command (word "set") (word "-o")) (command (word "grep") (word "-o") (word "noexec")))
---

=== 'set' and 'eval' round trip
# NOTE: not testing arrays and associative arrays!
_space='[ ]'
_whitespace=$'[\t\r\n]'
_sq="'single quotes'"
_backslash_dq="\\ \""
_unicode=$'[\u03bc]'

# Save the variables
varfile=$TMP/vars-$(basename $SH).txt

set | grep '^_' > "$varfile"

# Unset variables
unset _space _whitespace _sq _backslash_dq _unicode
echo [ $_space $_whitespace $_sq $_backslash_dq $_unicode ]

# Restore them

. $varfile
echo "Code saved to $varfile" 1>&2  # for debugging

test "$_space" = '[ ]' && echo OK
test "$_whitespace" = $'[\t\r\n]' && echo OK
test "$_sq" = "'single quotes'" && echo OK
test "$_backslash_dq" = "\\ \"" && echo OK
test "$_unicode" = $'[\u03bc]' && echo OK
---
(command (word "_space='[ ]'"))
(command (word "_whitespace='[\t\n]'"))
(command (word "_sq=\"'single quotes'\""))
(command (word "_backslash_dq=\"\\\\ \\\"\""))
(command (word "_unicode='[]'"))
(command (word "varfile=$TMP/vars-$(basename $SH).txt"))
(pipe (command (word "set")) (command (word "grep") (word "'^_'") (redirect ">" ""$varfile"")))
(command (word "unset") (word "_space") (word "_whitespace") (word "_sq") (word "_backslash_dq") (word "_unicode"))
(command (word "echo") (word "[") (word "$_space") (word "$_whitespace") (word "$_sq") (word "$_backslash_dq") (word "$_unicode") (word "]"))
(command (word ".") (word "$varfile"))
(command (word "echo") (word "\"Code saved to $varfile\"") (redirect ">&" 2))
(and (command (word "test") (word "\"$_space\"") (word "=") (word "'[ ]'")) (command (word "echo") (word "OK")))
(and (command (word "test") (word "\"$_whitespace\"") (word "=") (word "'[\t\n]'")) (command (word "echo") (word "OK")))
(and (command (word "test") (word "\"$_sq\"") (word "=") (word "\"'single quotes'\"")) (command (word "echo") (word "OK")))
(and (command (word "test") (word "\"$_backslash_dq\"") (word "=") (word "\"\\\\ \\\"\"")) (command (word "echo") (word "OK")))
(and (command (word "test") (word "\"$_unicode\"") (word "=") (word "'[]'")) (command (word "echo") (word "OK")))
---

=== set - - and so forth
set a b
echo "$@"

set - a b
echo "$@"

set -- a b
echo "$@"

set - -
echo "$@"

set -- --
echo "$@"

# note: zsh is different, and yash is totally different
---
(command (word "set") (word "a") (word "b"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "-") (word "a") (word "b"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "--") (word "a") (word "b"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "-") (word "-"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "--") (word "--"))
(command (word "echo") (word "\"$@\""))
---

=== set - leading single dash is ignored, turns off xtrace verbose (#2364)
show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set -x -v
show_options
echo

set - a b c
echo "$@"
show_options
echo

# dash that's not leading is not special
set x - y z
echo "$@"
---
(function "show_options" (brace-group (semi (case (word "$-") (pattern ((word "*v*")) (command (word "echo") (word "verbose-on")))) (case (word "$-") (pattern ((word "*x*")) (command (word "echo") (word "xtrace-on")))))))
(command (word "set") (word "-x") (word "-v"))
(command (word "show_options"))
(command (word "echo"))
(command (word "set") (word "-") (word "a") (word "b") (word "c"))
(command (word "echo") (word "\"$@\""))
(command (word "show_options"))
(command (word "echo"))
(command (word "set") (word "x") (word "-") (word "y") (word "z"))
(command (word "echo") (word "\"$@\""))
---

=== set - stops option processing like set --
case $SH in zsh) exit ;; esac

show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set -x - -v

show_options
echo argv "$@"
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(function "show_options" (brace-group (semi (case (word "$-") (pattern ((word "*v*")) (command (word "echo") (word "verbose-on")))) (case (word "$-") (pattern ((word "*x*")) (command (word "echo") (word "xtrace-on")))))))
(command (word "set") (word "-x") (word "-") (word "-v"))
(command (word "show_options"))
(command (word "echo") (word "argv") (word "\"$@\""))
---

=== A single + is an ignored flag; not an argument
case $SH in zsh) exit ;; esac

show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set +
echo plus "$@"

set -x + -v x y
show_options
echo plus "$@"
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(function "show_options" (brace-group (semi (case (word "$-") (pattern ((word "*v*")) (command (word "echo") (word "verbose-on")))) (case (word "$-") (pattern ((word "*x*")) (command (word "echo") (word "xtrace-on")))))))
(command (word "set") (word "+"))
(command (word "echo") (word "plus") (word "\"$@\""))
(command (word "set") (word "-x") (word "+") (word "-v") (word "x") (word "y"))
(command (word "show_options"))
(command (word "echo") (word "plus") (word "\"$@\""))
---

=== set - + and + -
set - +
echo "$@"

set + -
echo "$@"
---
(command (word "set") (word "-") (word "+"))
(command (word "echo") (word "\"$@\""))
(command (word "set") (word "+") (word "-"))
(command (word "echo") (word "\"$@\""))
---

=== set -a exports variables
set -a
FOO=bar
BAZ=qux
printenv.py FOO BAZ
---
(command (word "set") (word "-a"))
(command (word "FOO=bar"))
(command (word "BAZ=qux"))
(command (word "printenv.py") (word "FOO") (word "BAZ"))
---

=== set +a stops exporting
set -a
FOO=exported
set +a
BAR=not_exported
printenv.py FOO BAR
---
(command (word "set") (word "-a"))
(command (word "FOO=exported"))
(command (word "set") (word "+a"))
(command (word "BAR=not_exported"))
(command (word "printenv.py") (word "FOO") (word "BAR"))
---

=== set -o allexport (long form)
set -o allexport
VAR1=value1
set +o allexport
VAR2=value2
printenv.py VAR1 VAR2
---
(command (word "set") (word "-o") (word "allexport"))
(command (word "VAR1=value1"))
(command (word "set") (word "+o") (word "allexport"))
(command (word "VAR2=value2"))
(command (word "printenv.py") (word "VAR1") (word "VAR2"))
---

=== variables set before set -a are not exported
BEFORE=before_value
set -a
AFTER=after_value
printenv.py BEFORE AFTER
---
(command (word "BEFORE=before_value"))
(command (word "set") (word "-a"))
(command (word "AFTER=after_value"))
(command (word "printenv.py") (word "BEFORE") (word "AFTER"))
---

=== set -a exports local variables
set -a
f() {
  local ZZZ=zzz
  printenv.py ZZZ
}
f
---
(command (word "set") (word "-a"))
(function "f" (brace-group (semi (command (word "local") (word "ZZZ=zzz")) (command (word "printenv.py") (word "ZZZ")))))
(command (word "f"))
---

=== set -a exports declare variables
set -a
declare ZZZ=zzz
printenv.py ZZZ
---
(command (word "set") (word "-a"))
(command (word "declare") (word "ZZZ=zzz"))
(command (word "printenv.py") (word "ZZZ"))
---

=== true is not special; prefix assignments don't persist, it can be redefined
foo=bar true
echo foo=$foo

true() {
  echo true func
}
foo=bar true
echo foo=$foo
---
(command (word "foo=bar") (word "true"))
(command (word "echo") (word "foo=$foo"))
(function "true" (brace-group (command (word "echo") (word "true") (word "func"))))
(command (word "foo=bar") (word "true"))
(command (word "echo") (word "foo=$foo"))
---

=== Prefix assignments persist after special builtins, like : (set -o posix)
case $SH in
  bash) set -o posix ;;
esac

foo=bar :
echo foo=$foo

# Not true when you use 'builtin'
z=Z builtin :
echo z=$Z
---
(case (word "$SH") (pattern ((word "bash")) (command (word "set") (word "-o") (word "posix"))))
(command (word "foo=bar") (word ":"))
(command (word "echo") (word "foo=$foo"))
(command (word "z=Z") (word "builtin") (word ":"))
(command (word "echo") (word "z=$Z"))
---

=== Prefix assignments persist after readonly, but NOT exported (set -o posix)
# Bash only implements it behind the posix option
case $SH in
  bash) set -o posix ;;
esac
foo=bar readonly spam=eggs
echo foo=$foo
echo spam=$spam

# should NOT be exported
printenv.py foo
printenv.py spam
---
(case (word "$SH") (pattern ((word "bash")) (command (word "set") (word "-o") (word "posix"))))
(command (word "foo=bar") (word "readonly") (word "spam=eggs"))
(command (word "echo") (word "foo=$foo"))
(command (word "echo") (word "spam=$spam"))
(command (word "printenv.py") (word "foo"))
(command (word "printenv.py") (word "spam"))
---

=== Prefix binding for exec is a special case (versus e.g. readonly)
pre1=pre1 readonly x=x
pre2=pre2 exec sh -c 'echo pre1=$pre1 x=$x pre2=$pre2'
---
(command (word "pre1=pre1") (word "readonly") (word "x=x"))
(command (word "pre2=pre2") (word "exec") (word "sh") (word "-c") (word "'echo pre1=$pre1 x=$x pre2=$pre2'"))
---

=== exec without args is a special case of the special case in some shells
FOO=bar exec >& 2
echo FOO=$FOO
#declare -p | grep FOO
---
(command (word "FOO=bar") (word "exec") (redirect ">&" 2))
(command (word "echo") (word "FOO=$FOO"))
---

=== Which shells allow special builtins to be redefined?
eval() {
  echo 'eval func' "$@"
}
eval 'echo hi'

# we allow redefinition, but the definition is NOT used!
---
(function "eval" (brace-group (command (word "echo") (word "'eval func'") (word "\"$@\""))))
(command (word "eval") (word "'echo hi'"))
---

=== Special builtins can't be redefined as shell functions (set -o posix)
case $SH in
  bash) set -o posix ;;
esac

eval 'echo hi'

eval() {
  echo 'sh func' "$@"
}

eval 'echo hi'
---
(case (word "$SH") (pattern ((word "bash")) (command (word "set") (word "-o") (word "posix"))))
(command (word "eval") (word "'echo hi'"))
(function "eval" (brace-group (command (word "echo") (word "'sh func'") (word "\"$@\""))))
(command (word "eval") (word "'echo hi'"))
---

=== Non-special builtins CAN be redefined as functions
test -n "$BASH_VERSION" && set -o posix
true() {
  echo 'true func'
}
true hi
echo status=$?
---
(and (command (word "test") (word "-n") (word "\"$BASH_VERSION\"")) (command (word "set") (word "-o") (word "posix")))
(function "true" (brace-group (command (word "echo") (word "'true func'"))))
(command (word "true") (word "hi"))
(command (word "echo") (word "status=$?"))
---

=== Shift is special and fails whole script
# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14
#
# 2.8.1 - Consequences of shell errors
#
# Special built-ins should exit a non-interactive shell
# bash and busybox dont't implement this even with set -o posix, so it seems risky
# dash and mksh do it; so does AT&T ksh

$SH -c '
if test -n "$BASH_VERSION"; then
  set -o posix
fi
set -- a b
shift 3
echo status=$?
'
if test "$?" != 0; then
  echo 'non-zero status'
fi
---
(command (word "$SH") (word "-c") (word "'\nif test -n \"$BASH_VERSION\"; then\n  set -o posix\nfi\nset -- a b\nshift 3\necho status=$?\n'"))
(if (command (word "test") (word "\"$?\"") (word "!=") (word "0")) (command (word "echo") (word "'non-zero status'")))
---

=== set is special and fails whole script, even if using || true
$SH -c '
if test -n "$BASH_VERSION"; then
  set -o posix
fi

shopt -s invalid_ || true
echo ok
set -o invalid_ || true
echo should not get here
'
if test "$?" != 0; then
  echo 'non-zero status'
fi
---
(command (word "$SH") (word "-c") (word "'\nif test -n \"$BASH_VERSION\"; then\n  set -o posix\nfi\n\nshopt -s invalid_ || true\necho ok\nset -o invalid_ || true\necho should not get here\n'"))
(if (command (word "test") (word "\"$?\"") (word "!=") (word "0")) (command (word "echo") (word "'non-zero status'")))
---

=== bash 'type' gets confused - says 'function', but runs builtin
case $SH in dash|mksh|zsh|ash|yash) exit ;; esac

echo TRUE
type -t true  # builtin
true() { echo true func; }
type -t true  # now a function
echo ---

echo EVAL

type -t eval  # builtin
# define function before set -o posix
eval() { echo "shell function: $1"; }
# bash runs the FUNCTION, but OSH finds the special builtin
# OSH doesn't need set -o posix
eval 'echo before posix'

if test -n "$BASH_VERSION"; then
  # this makes the eval definition invisible!
  set -o posix
fi

eval 'echo after posix'  # this is the builtin eval
# bash claims it's a function, but it's a builtin
type -t eval

# it finds the function and the special builtin
#type -a eval
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh") (word "ash") (word "yash")) (command (word "exit"))))
(command (word "echo") (word "TRUE"))
(command (word "type") (word "-t") (word "true"))
(function "true" (brace-group (command (word "echo") (word "true") (word "func"))))
(command (word "type") (word "-t") (word "true"))
(command (word "echo") (word "---"))
(command (word "echo") (word "EVAL"))
(command (word "type") (word "-t") (word "eval"))
(function "eval" (brace-group (command (word "echo") (word "\"shell function: $1\""))))
(command (word "eval") (word "'echo before posix'"))
(if (command (word "test") (word "-n") (word "\"$BASH_VERSION\"")) (command (word "set") (word "-o") (word "posix")))
(command (word "eval") (word "'echo after posix'"))
(command (word "type") (word "-t") (word "eval"))
---

=== command, builtin - both can be redefined, not special (regression)
case $SH in dash|ash|yash) exit ;; esac

builtin echo b
command echo c

builtin() {
  echo builtin-redef "$@"
}

command() {
  echo command-redef "$@"
}

builtin echo b
command echo c
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "yash")) (command (word "exit"))))
(command (word "builtin") (word "echo") (word "b"))
(command (word "command") (word "echo") (word "c"))
(function "builtin" (brace-group (command (word "echo") (word "builtin-redef") (word "\"$@\""))))
(function "command" (brace-group (command (word "echo") (word "command-redef") (word "\"$@\""))))
(command (word "builtin") (word "echo") (word "b"))
(command (word "command") (word "echo") (word "c"))
---

=== times shows two formatted lines
output=$(times)
echo "$output" | while read line
do
	echo "$line" | egrep -q '[0-9]+m[0-9]+.[0-9]+s [0-9]+m[0-9]+.[0-9]+s' && echo "pass"
done

echo "$output" | wc -l
---
(command (word "output=$(times)"))
(pipe (command (word "echo") (word "\"$output\"")) (while (command (word "read") (word "line")) (and (pipe (command (word "echo") (word "\"$line\"")) (command (word "egrep") (word "-q") (word "'[0-9]+m[0-9]+.[0-9]+s [0-9]+m[0-9]+.[0-9]+s'"))) (command (word "echo") (word "\"pass\"")))))
(pipe (command (word "echo") (word "\"$output\"")) (command (word "wc") (word "-l")))
---

=== trap -l
trap -l | grep INT >/dev/null
---
(pipe (command (word "trap") (word "-l")) (command (word "grep") (word "INT") (redirect ">" "/dev/null")))
---

=== trap -p
trap 'echo exit' EXIT

trap -p > parent.txt

grep EXIT parent.txt >/dev/null
if test $? -eq 0; then
  echo shown
else
  echo not shown
fi
---
(command (word "trap") (word "'echo exit'") (word "EXIT"))
(command (word "trap") (word "-p") (redirect ">" "parent.txt"))
(command (word "grep") (word "EXIT") (word "parent.txt") (redirect ">" "/dev/null"))
(if (command (word "test") (word "$?") (word "-eq") (word "0")) (command (word "echo") (word "shown")) (command (word "echo") (word "not") (word "shown")))
---

=== trap -p in child is BUGGY in bash
# It shows the trap even though it doesn't execute it!

trap 'echo exit' EXIT

trap -p | cat > child.txt

grep EXIT child.txt >/dev/null
if test $? -eq 0; then
  echo shown
else
  echo not shown
fi
---
(command (word "trap") (word "'echo exit'") (word "EXIT"))
(pipe (command (word "trap") (word "-p")) (command (word "cat") (redirect ">" "child.txt")))
(command (word "grep") (word "EXIT") (word "child.txt") (redirect ">" "/dev/null"))
(if (command (word "test") (word "$?") (word "-eq") (word "0")) (command (word "echo") (word "shown")) (command (word "echo") (word "not") (word "shown")))
---

=== trap DEBUG ignores $?
debuglog() {
  echo "  [$@]"
  return 42     # IGNORED FAILURE
}

trap 'debuglog $LINENO' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?
---
(function "debuglog" (brace-group (semi (command (word "echo") (word "\"  [$@]\"")) (command (word "return") (word "42")))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "A"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "B"))
(command (word "echo") (word "status=$?"))
---

=== but trap DEBUG respects errexit
set -o errexit

debuglog() {
  echo "  [$@]"
  return 42
}

trap 'debuglog $LINENO' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?
---
(command (word "set") (word "-o") (word "errexit"))
(function "debuglog" (brace-group (semi (command (word "echo") (word "\"  [$@]\"")) (command (word "return") (word "42")))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "A"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "B"))
(command (word "echo") (word "status=$?"))
---

=== trap DEBUG with 'return'
debuglog() {
  echo "  [$@]"
}

trap 'debuglog $LINENO; return 42' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO; return 42'") (word "DEBUG"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "A"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "B"))
(command (word "echo") (word "status=$?"))
---

=== trap DEBUG with 'exit'
debuglog() {
  echo "  [$@]"
}

trap 'debuglog $LINENO; exit 42' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO; exit 42'") (word "DEBUG"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "A"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "B"))
(command (word "echo") (word "status=$?"))
---

=== trap DEBUG with non-compound commands
case $SH in dash|mksh) exit ;; esac

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

echo a
echo b; echo c

echo d && echo e
echo f || echo g

(( h = 42 ))
[[ j == j ]]

var=value

readonly r=value
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(command (word "echo") (word "a"))
(semi (command (word "echo") (word "b")) (command (word "echo") (word "c")))
(and (command (word "echo") (word "d")) (command (word "echo") (word "e")))
(or (command (word "echo") (word "f")) (command (word "echo") (word "g")))
(arith (word " h = 42 "))
(cond (cond-binary "==" (cond-term "j") (cond-term "j")))
(command (word "var=value"))
(command (word "readonly") (word "r=value"))
---

=== trap DEBUG and control flow
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

while true; do
  echo hello
  break
done
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(while (command (word "true")) (semi (command (word "echo") (word "hello")) (command (word "break"))))
---

=== trap DEBUG and command sub / subshell
case $SH in dash|mksh) exit ;; esac

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

echo "result = $(echo command sub; echo two)"
( echo subshell
  echo two
)
echo done
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(command (word "echo") (word "\"result = $(echo command sub; echo two)\""))
(subshell (semi (command (word "echo") (word "subshell")) (command (word "echo") (word "two"))))
(command (word "echo") (word "done"))
---

=== trap DEBUG not run in forked interpreter for first pipeline part
debuglog() {
  #echo "  PID=$$ BASHPID=$BASHPID LINENO=$1"
  echo "  LINENO=$1"
}
trap 'debuglog $LINENO' DEBUG

{ echo pipe1;
  echo pipe2; } \
  | cat
echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  LINENO=$1\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(pipe (brace-group (semi (command (word "echo") (word "pipe1")) (command (word "echo") (word "pipe2")))) (command (word "cat")))
(command (word "echo") (word "ok"))
---

=== One 'echo' in first pipeline part - why does bash behave differently from case above?
# TODO: bash runs the trap 3 times, and osh only twice.  I don't see why.  Is
# it because Process::Run() does trap_state.ClearForSubProgram()?  Probably
#echo top PID=$$ BASHPID=$BASHPID
#shopt -s lastpipe

debuglog() {
  #echo "  PID=$$ BASHPID=$BASHPID LINENO=$1"
  #echo "  LINENO=$1 $BASH_COMMAND"
  # LINENO=6 echo pipeline
  # LINENO=7 cat
  echo "  LINENO=$1"
}
trap 'debuglog $LINENO' DEBUG

echo pipeline \
  | cat
echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  LINENO=$1\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(pipe (command (word "echo") (word "pipeline")) (command (word "cat")))
(command (word "echo") (word "ok"))
---

=== trap DEBUG and pipeline (lastpipe difference)
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

# gets run for each one of these
{ echo a; echo b; }

# only run for the last one, maybe I guess because traps aren't inherited?
{ echo x; echo y; } | wc -l

# bash runs for all of these, but OSH doesn't because we have SubProgramThunk
# Hm.
date | cat | wc -l

date |
  cat |
  wc -l
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(brace-group (semi (command (word "echo") (word "a")) (command (word "echo") (word "b"))))
(pipe (brace-group (semi (command (word "echo") (word "x")) (command (word "echo") (word "y")))) (command (word "wc") (word "-l")))
(pipe (command (word "date")) (pipe (command (word "cat")) (command (word "wc") (word "-l"))))
(pipe (command (word "date")) (pipe (command (word "cat")) (command (word "wc") (word "-l"))))
---

=== trap DEBUG function call
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

f() {
  local mylocal=1
  for i in "$@"; do
    echo i=$i
  done
}

f A B  # executes ONCE here, but does NOT go into the function call

echo next

f X Y

echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(function "f" (brace-group (semi (command (word "local") (word "mylocal=1")) (for (word "i") (in (word "\"$@\"")) (command (word "echo") (word "i=$i"))))))
(command (word "f") (word "A") (word "B"))
(command (word "echo") (word "next"))
(command (word "f") (word "X") (word "Y"))
(command (word "echo") (word "ok"))
---

=== trap DEBUG case
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

name=foo.py

case $name in 
  *.py)
    echo python
    ;;
  *.sh)
    echo shell
    ;;
esac
echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(command (word "name=foo.py"))
(case (word "$name") (pattern ((word "*.py")) (command (word "echo") (word "python"))) (pattern ((word "*.sh")) (command (word "echo") (word "shell"))))
(command (word "echo") (word "ok"))
---

=== trap DEBUG for each
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

for x in 1 2; do
  echo x=$x
done

echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(for (word "x") (in (word "1") (word "2")) (command (word "echo") (word "x=$x")))
(command (word "echo") (word "ok"))
---

=== trap DEBUG for expr
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

for (( i =3 ; i < 5; ++i )); do
  echo i=$i
done

echo ok
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(arith-for (init (word "i =3 ")) (test (word "i < 5")) (step (word "++i ")) (command (word "echo") (word "i=$i")))
(command (word "echo") (word "ok"))
---

=== trap DEBUG if while
debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

if test x = x; then
  echo if
fi 

while test x != x; do
  echo while
done
---
(function "debuglog" (brace-group (command (word "echo") (word "\"  [$@]\""))))
(command (word "trap") (word "'debuglog $LINENO'") (word "DEBUG"))
(if (command (word "test") (word "x") (word "=") (word "x")) (command (word "echo") (word "if")))
(while (command (word "test") (word "x") (word "!=") (word "x")) (command (word "echo") (word "while")))
---

=== trap RETURN
profile() {
  echo "profile [$@]"
}
g() {
  echo --
  echo g
  echo --
  return
}
f() {
  echo --
  echo f
  echo --
  g
}
# RETURN trap doesn't fire when a function returns, only when a script returns?
# That's not what the manual says.
trap 'profile x y' RETURN
f
. $REPO_ROOT/spec/testdata/return-helper.sh
---
(function "profile" (brace-group (command (word "echo") (word "\"profile [$@]\""))))
(function "g" (brace-group (semi (semi (semi (command (word "echo") (word "--")) (command (word "echo") (word "g"))) (command (word "echo") (word "--"))) (command (word "return")))))
(function "f" (brace-group (semi (semi (semi (command (word "echo") (word "--")) (command (word "echo") (word "f"))) (command (word "echo") (word "--"))) (command (word "g")))))
(command (word "trap") (word "'profile x y'") (word "RETURN"))
(command (word "f"))
(command (word ".") (word "$REPO_ROOT/spec/testdata/return-helper.sh"))
---

=== Compare trap DEBUG vs. trap ERR
# Pipelines and AndOr are problematic

# THREE each
trap 'echo dbg $LINENO' DEBUG

false | false | false

false || false || false

! true

trap - DEBUG


# ONE EACH
trap 'echo err $LINENO' ERR

false | false | false

false || false || false

! true  # not run

echo ok
---
(command (word "trap") (word "'echo dbg $LINENO'") (word "DEBUG"))
(pipe (command (word "false")) (pipe (command (word "false")) (command (word "false"))))
(or (or (command (word "false")) (command (word "false"))) (command (word "false")))
(negation (command (word "true")))
(command (word "trap") (word "-") (word "DEBUG"))
(command (word "trap") (word "'echo err $LINENO'") (word "ERR"))
(pipe (command (word "false")) (pipe (command (word "false")) (command (word "false"))))
(or (or (command (word "false")) (command (word "false"))) (command (word "false")))
(negation (command (word "true")))
(command (word "echo") (word "ok"))
---

=== Combine DEBUG trap and USR1 trap
case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO usr1' USR1
trap 'false; echo $LINENO dbg' DEBUG

sh -c "kill -USR1 $$"
echo after=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "trap") (word "'false; echo $LINENO usr1'") (word "USR1"))
(command (word "trap") (word "'false; echo $LINENO dbg'") (word "DEBUG"))
(command (word "sh") (word "-c") (word "\"kill -USR1 $$\""))
(command (word "echo") (word "after=$?"))
---

=== Combine ERR trap and USR1 trap
case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO usr1' USR1
trap 'false; echo $LINENO err' ERR

sh -c "kill -USR1 $$"
echo after=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "trap") (word "'false; echo $LINENO usr1'") (word "USR1"))
(command (word "trap") (word "'false; echo $LINENO err'") (word "ERR"))
(command (word "sh") (word "-c") (word "\"kill -USR1 $$\""))
(command (word "echo") (word "after=$?"))
---

=== Combine DEBUG trap and ERR trap
case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO err' ERR
trap 'false; echo $LINENO debug' DEBUG

false
echo after=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "trap") (word "'false; echo $LINENO err'") (word "ERR"))
(command (word "trap") (word "'false; echo $LINENO debug'") (word "DEBUG"))
(command (word "false"))
(command (word "echo") (word "after=$?"))
---

=== trap can use original $LINENO
trap 'echo line=$LINENO' ERR

false
false
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(command (word "false"))
(command (word "false"))
(command (word "echo") (word "ok"))
---

=== trap ERR and set -o errexit
trap 'echo line=$LINENO' ERR

false
echo a

set -o errexit

echo b
false   # trap executed, and executation also halts
echo c  # doesn't get here
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(command (word "false"))
(command (word "echo") (word "a"))
(command (word "set") (word "-o") (word "errexit"))
(command (word "echo") (word "b"))
(command (word "false"))
(command (word "echo") (word "c"))
---

=== trap ERR and errexit disabled context
trap 'echo line=$LINENO' ERR

false
echo a

set -o errexit

echo b
if false; then
  echo xx
fi
echo c  # doesn't get here
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(command (word "false"))
(command (word "echo") (word "a"))
(command (word "set") (word "-o") (word "errexit"))
(command (word "echo") (word "b"))
(if (command (word "false")) (command (word "echo") (word "xx")))
(command (word "echo") (word "c"))
---

=== trap ERR and if statement
if test -f /nope; then echo file exists; fi

trap 'echo err' ERR
#trap 'echo line=$LINENO' ERR

if test -f /nope; then echo file exists; fi
---
(if (command (word "test") (word "-f") (word "/nope")) (command (word "echo") (word "file") (word "exists")))
(command (word "trap") (word "'echo err'") (word "ERR"))
(if (command (word "test") (word "-f") (word "/nope")) (command (word "echo") (word "file") (word "exists")))
---

=== trap ERR and || conditional
trap 'echo line=$LINENO' ERR

false || false || false
echo ok

false && false
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(or (or (command (word "false")) (command (word "false"))) (command (word "false")))
(command (word "echo") (word "ok"))
(and (command (word "false")) (command (word "false")))
(command (word "echo") (word "ok"))
---

=== trap ERR and pipeline
# mksh and bash have different line numbers in this case
#trap 'echo line=$LINENO' ERR
trap 'echo line=$LINENO' ERR

# it's run for the last 'false'
false | false | false

{ echo pipeline; false; } | false | false

# it's never run here
! true
! false
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(pipe (command (word "false")) (pipe (command (word "false")) (command (word "false"))))
(pipe (brace-group (semi (command (word "echo") (word "pipeline")) (command (word "false")))) (pipe (command (word "false")) (command (word "false"))))
(negation (command (word "true")))
(negation (command (word "false")))
---

=== trap ERR pipelines without simple commands
trap 'echo assign' ERR
a=$(false) | a=$(false) | a=$(false)

trap 'echo dparen' ERR
(( 0 )) | (( 0 )) | (( 0 ))

trap 'echo dbracket' ERR
[[ a = b ]] | [[ a = b ]] | [[ a = b ]]

# bash anomaly - it gets printed twice?
trap 'echo subshell' ERR
(false) | (false) | (false) | (false)

# same bug
trap 'echo subshell2' ERR 
(false) | (false) | (false) | (false; false)

trap 'echo group' ERR
{ false; } | { false; } | { false; }

echo ok
---
(command (word "trap") (word "'echo assign'") (word "ERR"))
(pipe (command (word "a=$(false)")) (pipe (command (word "a=$(false)")) (command (word "a=$(false)"))))
(command (word "trap") (word "'echo dparen'") (word "ERR"))
(pipe (arith (word " 0 ")) (pipe (arith (word " 0 ")) (arith (word " 0 "))))
(command (word "trap") (word "'echo dbracket'") (word "ERR"))
(pipe (cond (cond-binary "=" (cond-term "a") (cond-term "b"))) (pipe (cond (cond-binary "=" (cond-term "a") (cond-term "b"))) (cond (cond-binary "=" (cond-term "a") (cond-term "b")))))
(command (word "trap") (word "'echo subshell'") (word "ERR"))
(pipe (subshell (command (word "false"))) (pipe (subshell (command (word "false"))) (pipe (subshell (command (word "false"))) (subshell (command (word "false"))))))
(command (word "trap") (word "'echo subshell2'") (word "ERR"))
(pipe (subshell (command (word "false"))) (pipe (subshell (command (word "false"))) (pipe (subshell (command (word "false"))) (subshell (semi (command (word "false")) (command (word "false")))))))
(command (word "trap") (word "'echo group'") (word "ERR"))
(pipe (brace-group (command (word "false"))) (pipe (brace-group (command (word "false"))) (brace-group (command (word "false")))))
(command (word "echo") (word "ok"))
---

=== Pipeline group quirk
# Oh this is because it's run for the PIPELINE, not for the last thing!  Hmmm

trap 'echo group2' ERR
{ false; } | { false; } | { false; false; }

echo ok
---
(command (word "trap") (word "'echo group2'") (word "ERR"))
(pipe (brace-group (command (word "false"))) (pipe (brace-group (command (word "false"))) (brace-group (semi (command (word "false")) (command (word "false"))))))
(command (word "echo") (word "ok"))
---

=== trap ERR does not run in errexit situations
trap 'echo line=$LINENO' ERR

if false; then
  echo if
fi

while false; do
  echo while
done

until false; do
  echo until
  break
done

false || false || false

false && false && false

false; false; false

echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(if (command (word "false")) (command (word "echo") (word "if")))
(while (command (word "false")) (command (word "echo") (word "while")))
(until (command (word "false")) (semi (command (word "echo") (word "until")) (command (word "break"))))
(or (or (command (word "false")) (command (word "false"))) (command (word "false")))
(and (and (command (word "false")) (command (word "false"))) (command (word "false")))
(semi (semi (command (word "false")) (command (word "false"))) (command (word "false")))
(command (word "echo") (word "ok"))
---

=== trap ERR doesn't run in subprograms - subshell, command sub, async
trap 'echo line=$LINENO' ERR

( false; echo subshell )

x=$( false; echo command sub )

false & wait

{ false; echo async; } & wait

false
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(subshell (semi (command (word "false")) (command (word "echo") (word "subshell"))))
(command (word "x=$(false; echo command sub)"))
(background (command (word "false")) (command (word "wait")))
(background (brace-group (semi (command (word "false")) (command (word "echo") (word "async")))) (command (word "wait")))
(command (word "false"))
(command (word "echo") (word "ok"))
---

=== set -o errtrace: trap ERR runs in subprograms
case $SH in mksh) exit ;; esac

set -o errtrace
trap 'echo line=$LINENO' ERR

( false; echo subshell )

x=$( false; echo command sub )

false
echo ok
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "set") (word "-o") (word "errtrace"))
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(subshell (semi (command (word "false")) (command (word "echo") (word "subshell"))))
(command (word "x=$(false; echo command sub)"))
(command (word "false"))
(command (word "echo") (word "ok"))
---

=== trap ERR doesn't run with &
trap 'echo line=$LINENO' ERR

false & wait

{ false; echo async; } & wait
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(background (command (word "false")) (command (word "wait")))
(background (brace-group (semi (command (word "false")) (command (word "echo") (word "async")))) (command (word "wait")))
---

=== set -o errtrace: trap ERR with &
case $SH in mksh) exit ;; esac

set -o errtrace
trap 'echo line=$LINENO' ERR

false & wait

{ false; echo async; } & wait
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "set") (word "-o") (word "errtrace"))
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(background (command (word "false")) (command (word "wait")))
(background (brace-group (semi (command (word "false")) (command (word "echo") (word "async")))) (command (word "wait")))
---

=== trap ERR not active in shell functions in (bash behavior)
trap 'echo line=$LINENO' ERR

f() {
  false 
  true
}

f
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(function "f" (brace-group (semi (command (word "false")) (command (word "true")))))
(command (word "f"))
---

=== set -o errtrace - trap ERR runs in shell functions
trap 'echo err' ERR

passing() {
  false  # line 4
  true
}

failing() {
  true
  false
}

passing
failing

set -o errtrace

echo 'now with errtrace'
passing
failing

echo ok
---
(command (word "trap") (word "'echo err'") (word "ERR"))
(function "passing" (brace-group (semi (command (word "false")) (command (word "true")))))
(function "failing" (brace-group (semi (command (word "true")) (command (word "false")))))
(command (word "passing"))
(command (word "failing"))
(command (word "set") (word "-o") (word "errtrace"))
(command (word "echo") (word "'now with errtrace'"))
(command (word "passing"))
(command (word "failing"))
(command (word "echo") (word "ok"))
---

=== set -o errtrace - trap ERR runs in shell functions (LINENO)
trap 'echo line=$LINENO' ERR

passing() {
  false  # line 4
  true
}

failing() {
  true
  false
}

passing
failing

set -o errtrace

echo 'now with errtrace'
passing
failing

echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(function "passing" (brace-group (semi (command (word "false")) (command (word "true")))))
(function "failing" (brace-group (semi (command (word "true")) (command (word "false")))))
(command (word "passing"))
(command (word "failing"))
(command (word "set") (word "-o") (word "errtrace"))
(command (word "echo") (word "'now with errtrace'"))
(command (word "passing"))
(command (word "failing"))
(command (word "echo") (word "ok"))
---

=== trap ERR with "atoms": assignment (( [[
trap 'echo line=$LINENO' ERR

x=$(false)

[[ a == b ]]

(( 0 ))
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(command (word "x=$(false)"))
(cond (cond-binary "==" (cond-term "a") (cond-term "b")))
(arith (word " 0 "))
(command (word "echo") (word "ok"))
---

=== trap ERR with for,  case, { }
trap 'echo line=$LINENO' ERR

for y in 1 2; do
  false
done

case x in
  x) false ;;
  *) false ;;
esac

{ false; false; false; }
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(for (word "y") (in (word "1") (word "2")) (command (word "false")))
(case (word "x") (pattern ((word "x")) (command (word "false"))) (pattern ((word "*")) (command (word "false"))))
(brace-group (semi (semi (command (word "false")) (command (word "false"))) (command (word "false"))))
(command (word "echo") (word "ok"))
---

=== trap ERR with redirect
trap 'echo line=$LINENO' ERR

false

{ false 
  true
} > /zz  # error
echo ok
---
(command (word "trap") (word "'echo line=$LINENO'") (word "ERR"))
(command (word "false"))
(brace-group (semi (command (word "false")) (command (word "true")))) (redirect ">" "/zz")
(command (word "echo") (word "ok"))
---

=== trap ERR
err() {
  echo "err [$@] $?"
}
trap 'err x y' ERR 

echo A

false
echo B

( exit 42 )
echo C

trap - ERR  # disable trap

false
echo D

trap 'echo after errexit $?' ERR 

set -o errexit

( exit 99 )
echo E
---
(function "err" (brace-group (command (word "echo") (word "\"err [$@] $?\""))))
(command (word "trap") (word "'err x y'") (word "ERR"))
(command (word "echo") (word "A"))
(command (word "false"))
(command (word "echo") (word "B"))
(subshell (command (word "exit") (word "42")))
(command (word "echo") (word "C"))
(command (word "trap") (word "-") (word "ERR"))
(command (word "false"))
(command (word "echo") (word "D"))
(command (word "trap") (word "'echo after errexit $?'") (word "ERR"))
(command (word "set") (word "-o") (word "errexit"))
(subshell (command (word "exit") (word "99")))
(command (word "echo") (word "E"))
---

=== trap ERR and pipelines - PIPESTATUS difference
case $SH in ash) exit ;; esac

err() {
  echo "err [$@] status=$? [${PIPESTATUS[@]}]"
}
trap 'err' ERR 

echo A

false

# succeeds
echo B | grep B

# fails
echo C | grep zzz

echo D | grep zzz | cat

set -o pipefail
echo E | grep zzz | cat

trap - ERR  # disable trap

echo F | grep zz
echo ok
---
(case (word "$SH") (pattern ((word "ash")) (command (word "exit"))))
(function "err" (brace-group (command (word "echo") (word "\"err [$@] status=$? [${PIPESTATUS[@]}]\""))))
(command (word "trap") (word "'err'") (word "ERR"))
(command (word "echo") (word "A"))
(command (word "false"))
(pipe (command (word "echo") (word "B")) (command (word "grep") (word "B")))
(pipe (command (word "echo") (word "C")) (command (word "grep") (word "zzz")))
(pipe (command (word "echo") (word "D")) (pipe (command (word "grep") (word "zzz")) (command (word "cat"))))
(command (word "set") (word "-o") (word "pipefail"))
(pipe (command (word "echo") (word "E")) (pipe (command (word "grep") (word "zzz")) (command (word "cat"))))
(command (word "trap") (word "-") (word "ERR"))
(pipe (command (word "echo") (word "F")) (command (word "grep") (word "zz")))
(command (word "echo") (word "ok"))
---

=== error in trap ERR (recursive)
case $SH in dash) exit ;; esac

err() {
  echo err status $?
  false
  ( exit 2 )  # not recursively triggered
  echo err 2
}
trap 'err' ERR 

echo A
false
echo B

# Try it with errexit
set -e
false
echo C
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "err" (brace-group (semi (semi (semi (command (word "echo") (word "err") (word "status") (word "$?")) (command (word "false"))) (subshell (command (word "exit") (word "2")))) (command (word "echo") (word "err") (word "2")))))
(command (word "trap") (word "'err'") (word "ERR"))
(command (word "echo") (word "A"))
(command (word "false"))
(command (word "echo") (word "B"))
(command (word "set") (word "-e"))
(command (word "false"))
(command (word "echo") (word "C"))
---

=== traps are not active inside subshells $() ()  trap | cat
# TODO: should we change this?  We're not compatible with bash or busybox ash

trap 'echo bye' EXIT

# NOT a subshell
trap > traps.txt
wc -l traps.txt

echo '( )'
( trap )

echo '$(trap)'
echo $(trap)

echo 'trap | cat'
trap | cat
---
(command (word "trap") (word "'echo bye'") (word "EXIT"))
(command (word "trap") (redirect ">" "traps.txt"))
(command (word "wc") (word "-l") (word "traps.txt"))
(command (word "echo") (word "'( )'"))
(subshell (command (word "trap")))
(command (word "echo") (word "'$(trap)'"))
(command (word "echo") (word "$(trap)"))
(command (word "echo") (word "'trap | cat'"))
(pipe (command (word "trap")) (command (word "cat")))
---

=== trap accepts/ignores --
trap -- 'echo hi' EXIT
echo ok
---
(command (word "trap") (word "--") (word "'echo hi'") (word "EXIT"))
(command (word "echo") (word "ok"))
---

=== Register invalid trap, remove invalid trap
trap 'foo' SIGINVALID
if test $? -ne 0; then
  echo ok
fi

trap - SIGINVALID
if test $? -ne 0; then
  echo ok
fi
---
(command (word "trap") (word "'foo'") (word "SIGINVALID"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
(command (word "trap") (word "-") (word "SIGINVALID"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
---

=== trap foo gives non-zero error
trap 'foo'
if test $? -ne 0; then
  echo ok
fi
---
(command (word "trap") (word "'foo'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
---

=== SIGINT and INT are aliases
trap - SIGINT
echo $?
trap - INT
echo $?
---
(command (word "trap") (word "-") (word "SIGINT"))
(command (word "echo") (word "$?"))
(command (word "trap") (word "-") (word "INT"))
(command (word "echo") (word "$?"))
---

=== trap without args prints traps
trap 'echo exit' EXIT
echo status=$?

trap
echo status=$?
---
(command (word "trap") (word "'echo exit'") (word "EXIT"))
(command (word "echo") (word "status=$?"))
(command (word "trap"))
(command (word "echo") (word "status=$?"))
---

=== print trap handler with multiple lines
trap 'echo 1
echo 2
echo 3' INT

trap
---
(command (word "trap") (word "'echo 1\necho 2\necho 3'") (word "INT"))
(command (word "trap"))
---

=== trap -p is like trap: it prints the handlers and full signal names
case $SH in dash) exit ;; esac
trap "echo INT" INT
trap "echo EXIT" EXIT
trap -p
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "trap") (word "\"echo INT\"") (word "INT"))
(command (word "trap") (word "\"echo EXIT\"") (word "EXIT"))
(command (word "trap") (word "-p"))
---

=== Register the same handler for multiple signals
trap 'echo test' TERM 2 EXIT
trap
---
(command (word "trap") (word "'echo test'") (word "TERM") (word "2") (word "EXIT"))
(command (word "trap"))
---

=== Remove multiple handlers with trap -
trap "echo int" INT
trap "echo e" EXIT
trap - int 0 3
trap

echo ---
trap "echo int" INT
trap "echo e" EXIT
trap - int 0 -99
if test $? -ne 0; then
  echo ok
fi
---
(command (word "trap") (word "\"echo int\"") (word "INT"))
(command (word "trap") (word "\"echo e\"") (word "EXIT"))
(command (word "trap") (word "-") (word "int") (word "0") (word "3"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "\"echo int\"") (word "INT"))
(command (word "trap") (word "\"echo e\"") (word "EXIT"))
(command (word "trap") (word "-") (word "int") (word "0") (word "-99"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
---

=== trap EXIT clears the EXIT trap
trap "echo INT" INT
trap "echo EXIT" EXIT
trap
echo ---
trap EXIT
trap
echo ---
trap INT
trap
---
(command (word "trap") (word "\"echo INT\"") (word "INT"))
(command (word "trap") (word "\"echo EXIT\"") (word "EXIT"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "EXIT"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "INT"))
(command (word "trap"))
---

=== trap 0 is equivalent to trap EXIT
trap "echo INT" INT
trap "echo EXIT" 0  # EXIT
trap
echo ---
trap 0
trap
---
(command (word "trap") (word "\"echo INT\"") (word "INT"))
(command (word "trap") (word "\"echo EXIT\"") (word "0"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "0"))
(command (word "trap"))
---

=== trap 1 is equivalent to SIGHUP; HUP is equivalent to SIGHUP
trap 'echo HUP' SIGHUP
echo status=$?
trap 'echo HUP' HUP
echo status=$?
trap 'echo HUP' 1
echo status=$?
trap - HUP
echo status=$?
---
(command (word "trap") (word "'echo HUP'") (word "SIGHUP"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "'echo HUP'") (word "HUP"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "'echo HUP'") (word "1"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "-") (word "HUP"))
(command (word "echo") (word "status=$?"))
---

=== trap 0 2 resets EXIT AND SIGINT
trap "echo EXIT" EXIT
echo ---
trap
echo ---
trap 0 2
trap
echo ---
trap "echo INT" INT
trap "echo EXIT" EXIT
trap 2 EXIT
trap
---
(command (word "trap") (word "\"echo EXIT\"") (word "EXIT"))
(command (word "echo") (word "---"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "0") (word "2"))
(command (word "trap"))
(command (word "echo") (word "---"))
(command (word "trap") (word "\"echo INT\"") (word "INT"))
(command (word "trap") (word "\"echo EXIT\"") (word "EXIT"))
(command (word "trap") (word "2") (word "EXIT"))
(command (word "trap"))
---

=== trap '' EXIT - printing state
trap 'echo exit' EXIT
trap
echo

trap '' EXIT
trap
echo

trap '# comment' EXIT
trap
---
(command (word "trap") (word "'echo exit'") (word "EXIT"))
(command (word "trap"))
(command (word "echo"))
(command (word "trap") (word "''") (word "EXIT"))
(command (word "trap"))
(command (word "echo"))
(command (word "trap") (word "'# comment'") (word "EXIT"))
(command (word "trap"))
---

=== trap 'echo hi' KILL (regression test, caught by smoosh suite)
trap 'echo hi' 9
echo status=$?

trap 'echo hi' KILL
echo status=$?

trap 'echo hi' STOP
echo status=$?

trap 'echo hi' TERM
echo status=$?
---
(command (word "trap") (word "'echo hi'") (word "9"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "'echo hi'") (word "KILL"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "'echo hi'") (word "STOP"))
(command (word "echo") (word "status=$?"))
(command (word "trap") (word "'echo hi'") (word "TERM"))
(command (word "echo") (word "status=$?"))
---

=== exit 1 when trap code string is invalid
# All shells spew warnings to stderr, but don't actually exit!  Bad!
trap 'echo <' EXIT
echo status=$?
---
(command (word "trap") (word "'echo <'") (word "EXIT"))
(command (word "echo") (word "status=$?"))
---

=== trap EXIT calling exit
cleanup() {
  echo "cleanup [$@]"
  exit 42
}
trap 'cleanup x y z' EXIT
---
(function "cleanup" (brace-group (semi (command (word "echo") (word "\"cleanup [$@]\"")) (command (word "exit") (word "42")))))
(command (word "trap") (word "'cleanup x y z'") (word "EXIT"))
---

=== trap EXIT return status ignored
cleanup() {
  echo "cleanup [$@]"
  return 42
}
trap 'cleanup x y z' EXIT
---
(function "cleanup" (brace-group (semi (command (word "echo") (word "\"cleanup [$@]\"")) (command (word "return") (word "42")))))
(command (word "trap") (word "'cleanup x y z'") (word "EXIT"))
---

=== trap EXIT with explicit exit
trap 'echo IN TRAP; echo $stdout' EXIT 
stdout=FOO
exit 42
---
(command (word "trap") (word "'echo IN TRAP; echo $stdout'") (word "EXIT"))
(command (word "stdout=FOO"))
(command (word "exit") (word "42"))
---

=== trap EXIT with command sub / subshell / pipeline
trap 'echo EXIT TRAP' EXIT 

echo $(echo command sub)

( echo subshell )

echo pipeline | cat
---
(command (word "trap") (word "'echo EXIT TRAP'") (word "EXIT"))
(command (word "echo") (word "$(echo command sub)"))
(subshell (command (word "echo") (word "subshell")))
(pipe (command (word "echo") (word "pipeline")) (command (word "cat")))
---

=== eval in the exit trap (regression for issue #293)
trap 'eval "echo hi"' 0
---
(command (word "trap") (word "'eval \"echo hi\"'") (word "0"))
---

=== exit codes for traps are isolated
trap 'echo USR1 trap status=$?; ( exit 42 )' USR1

echo before=$?

# Equivalent to 'kill -USR1 $$' except OSH doesn't have "kill" yet.
# /bin/kill doesn't exist on Debian unless 'procps' is installed.
sh -c "kill -USR1 $$"
echo after=$?
---
(command (word "trap") (word "'echo USR1 trap status=$?; ( exit 42 )'") (word "USR1"))
(command (word "echo") (word "before=$?"))
(command (word "sh") (word "-c") (word "\"kill -USR1 $$\""))
(command (word "echo") (word "after=$?"))
---

=== traps are cleared in subshell (started with &)
# Test with SIGURG because the default handler is SIG_IGN
#
# If we use SIGUSR1, I think the shell reverts to killing the process

# https://man7.org/linux/man-pages/man7/signal.7.html

trap 'echo SIGURG' URG

kill -URG $$

# Hm trap doesn't happen here
{ echo begin child; sleep 0.1; echo end child; } &
kill -URG $!
wait
echo "wait status $?"

# In the CI, mksh sometimes gives:
#
# USR1
# begin child
# done
# 
# leaving off 'end child'.  This seems like a BUG to me?
---
(command (word "trap") (word "'echo SIGURG'") (word "URG"))
(command (word "kill") (word "-URG") (word "$$"))
(background (brace-group (semi (semi (command (word "echo") (word "begin") (word "child")) (command (word "sleep") (word "0.1"))) (command (word "echo") (word "end") (word "child")))))
(command (word "kill") (word "-URG") (word "$!"))
(command (word "wait"))
(command (word "echo") (word "\"wait status $?\""))
---

=== trap USR1, sleep, SIGINT: non-interactively
$REPO_ROOT/spec/testdata/builtin-trap-usr1.sh
---
(command (word "$REPO_ROOT/spec/testdata/builtin-trap-usr1.sh"))
---

=== trap INT, sleep, SIGINT: non-interactively
# mksh behaves differently in CI -- maybe when it's not connected to a
# terminal?
case $SH in mksh) echo mksh; exit ;; esac

$REPO_ROOT/spec/testdata/builtin-trap-int.sh
---
(case (word "$SH") (pattern ((word "mksh")) (semi (command (word "echo") (word "mksh")) (command (word "exit")))))
(command (word "$REPO_ROOT/spec/testdata/builtin-trap-int.sh"))
---

=== trap EXIT, sleep, SIGINT: non-interactively
$REPO_ROOT/spec/testdata/builtin-trap-exit.sh
---
(command (word "$REPO_ROOT/spec/testdata/builtin-trap-exit.sh"))
---

=== Remove trap with an unsigned integer
$SH -e -c '
trap "echo noprint" EXIT
trap 0 EXIT
echo ok0
'
echo

$SH -e -c '
trap "echo noprint" EXIT
trap " 42 " EXIT
echo ok42space
'
echo

# corner case: sometimes 07 is treated as octal, but not here
$SH -e -c '
trap "echo noprint" EXIT
trap 07 EXIT
echo ok07
'
echo

$SH -e -c '
trap "echo trap-exit" EXIT
trap -1 EXIT
echo bad
'
if test $? -ne 0; then
  echo failure
fi
---
(command (word "$SH") (word "-e") (word "-c") (word "'\ntrap \"echo noprint\" EXIT\ntrap 0 EXIT\necho ok0\n'"))
(command (word "echo"))
(command (word "$SH") (word "-e") (word "-c") (word "'\ntrap \"echo noprint\" EXIT\ntrap \" 42 \" EXIT\necho ok42space\n'"))
(command (word "echo"))
(command (word "$SH") (word "-e") (word "-c") (word "'\ntrap \"echo noprint\" EXIT\ntrap 07 EXIT\necho ok07\n'"))
(command (word "echo"))
(command (word "$SH") (word "-e") (word "-c") (word "'\ntrap \"echo trap-exit\" EXIT\ntrap -1 EXIT\necho bad\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "failure")))
---

=== trap '' sets handler to empty string (SIG_IGN)
# Note: this doesn't actually test that it's SIG_IGN

trap '' USR1
trap
---
(command (word "trap") (word "''") (word "USR1"))
(command (word "trap"))
---

=== trap '' with multiple signals
trap '' USR1 USR2
trap
---
(command (word "trap") (word "''") (word "USR1") (word "USR2"))
(command (word "trap"))
---

=== trap with command.NoOp - check internal invariant
$SH -c 'trap "> zz" EXIT'
wc -l zz  # should exist
---
(command (word "$SH") (word "-c") (word "'trap \"> zz\" EXIT'"))
(command (word "wc") (word "-l") (word "zz"))
---

=== type -t -> function
f() { echo hi; }
type -t f
---
(function "f" (brace-group (command (word "echo") (word "hi"))))
(command (word "type") (word "-t") (word "f"))
---

=== type -t -> alias
shopt -s expand_aliases
alias foo=bar
type -t foo
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "foo=bar"))
(command (word "type") (word "-t") (word "foo"))
---

=== type -t -> builtin
type -t echo read : [ declare local
---
(command (word "type") (word "-t") (word "echo") (word "read") (word ":") (word "[") (word "declare") (word "local"))
---

=== type -t -> keyword
type -t for time ! fi do {
---
(command (word "type") (word "-t") (word "for") (word "time") (word "!") (word "fi") (word "do") (word "{"))
---

=== type -t control flow
type -t break continue return exit
---
(command (word "type") (word "-t") (word "break") (word "continue") (word "return") (word "exit"))
---

=== type -t -> file
type -t find xargs
---
(command (word "type") (word "-t") (word "find") (word "xargs"))
---

=== type -t doesn't find non-executable (like command -v)
PATH="$TMP:$PATH"
touch $TMP/non-executable
type -t non-executable
---
(command (word "PATH=\"$TMP:$PATH\""))
(command (word "touch") (word "$TMP/non-executable"))
(command (word "type") (word "-t") (word "non-executable"))
---

=== type -t -> not found
type -t echo ZZZ find ==
echo status=$?
---
(command (word "type") (word "-t") (word "echo") (word "ZZZ") (word "find") (word "=="))
(command (word "echo") (word "status=$?"))
---

=== type -p and -P builtin -> file
touch /tmp/{mv,tar,grep}
chmod +x /tmp/{mv,tar,grep}
PATH=/tmp:$PATH

type -p mv tar grep
echo --
type -P mv tar grep
---
(command (word "touch") (word "/tmp/{mv,tar,grep}"))
(command (word "chmod") (word "+x") (word "/tmp/{mv,tar,grep}"))
(command (word "PATH=/tmp:$PATH"))
(command (word "type") (word "-p") (word "mv") (word "tar") (word "grep"))
(command (word "echo") (word "--"))
(command (word "type") (word "-P") (word "mv") (word "tar") (word "grep"))
---

=== type -a -P gives multiple files
touch _tmp/pwd
chmod +x _tmp/pwd
PATH="_tmp:/bin"

type -a -P pwd
---
(command (word "touch") (word "_tmp/pwd"))
(command (word "chmod") (word "+x") (word "_tmp/pwd"))
(command (word "PATH=\"_tmp:/bin\""))
(command (word "type") (word "-a") (word "-P") (word "pwd"))
---

=== type -p builtin -> not found
type -p FOO BAR NOT_FOUND
---
(command (word "type") (word "-p") (word "FOO") (word "BAR") (word "NOT_FOUND"))
---

=== type -p builtin -> not a file
type -p cd type builtin command
---
(command (word "type") (word "-p") (word "cd") (word "type") (word "builtin") (word "command"))
---

=== type -P builtin -> not found
type -P FOO BAR NOT_FOUND
---
(command (word "type") (word "-P") (word "FOO") (word "BAR") (word "NOT_FOUND"))
---

=== type -P builtin -> not a file
type -P cd type builtin command
---
(command (word "type") (word "-P") (word "cd") (word "type") (word "builtin") (word "command"))
---

=== type -P builtin -> not a file but file found
touch _tmp/{mv,tar,grep}
chmod +x _tmp/{mv,tar,grep}
PATH=_tmp:$PATH

mv () { ls; }
tar () { ls; }
grep () { ls; }
type -P mv tar grep cd builtin command type
---
(command (word "touch") (word "_tmp/{mv,tar,grep}"))
(command (word "chmod") (word "+x") (word "_tmp/{mv,tar,grep}"))
(command (word "PATH=_tmp:$PATH"))
(function "mv" (brace-group (command (word "ls"))))
(function "tar" (brace-group (command (word "ls"))))
(function "grep" (brace-group (command (word "ls"))))
(command (word "type") (word "-P") (word "mv") (word "tar") (word "grep") (word "cd") (word "builtin") (word "command") (word "type"))
---

=== type -f builtin -> not found
type -f FOO BAR NOT FOUND
---
(command (word "type") (word "-f") (word "FOO") (word "BAR") (word "NOT") (word "FOUND"))
---

=== type -f builtin -> function and file exists
touch /tmp/{mv,tar,grep}
chmod +x /tmp/{mv,tar,grep}
PATH=/tmp:$PATH

mv () { ls; }
tar () { ls; }
grep () { ls; }
type -f mv tar grep
---
(command (word "touch") (word "/tmp/{mv,tar,grep}"))
(command (word "chmod") (word "+x") (word "/tmp/{mv,tar,grep}"))
(command (word "PATH=/tmp:$PATH"))
(function "mv" (brace-group (command (word "ls"))))
(function "tar" (brace-group (command (word "ls"))))
(function "grep" (brace-group (command (word "ls"))))
(command (word "type") (word "-f") (word "mv") (word "tar") (word "grep"))
---

=== type prints function source code
f () { echo; }
type -a f
echo

type f
---
(function "f" (brace-group (command (word "echo"))))
(command (word "type") (word "-a") (word "f"))
(command (word "echo"))
(command (word "type") (word "f"))
---

=== type -ap -> function
f () { :; }
type -ap f
---
(function "f" (brace-group (command (word ":"))))
(command (word "type") (word "-ap") (word "f"))
---

=== type -a -> alias; prints alias definition
shopt -s expand_aliases
alias ll="ls -lha"
type -a ll
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "ll=\"ls -lha\""))
(command (word "type") (word "-a") (word "ll"))
---

=== type -ap -> alias
shopt -s expand_aliases
alias ll="ls -lha"
type -ap ll
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "ll=\"ls -lha\""))
(command (word "type") (word "-ap") (word "ll"))
---

=== type -a -> builtin
type -a cd
---
(command (word "type") (word "-a") (word "cd"))
---

=== type -ap -> builtin
type -ap cd
---
(command (word "type") (word "-ap") (word "cd"))
---

=== type -a -> keyword
type -a while
---
(command (word "type") (word "-a") (word "while"))
---

=== type -a -> file
touch _tmp/date
chmod +x _tmp/date
PATH=/bin:_tmp  # control output

type -a date
---
(command (word "touch") (word "_tmp/date"))
(command (word "chmod") (word "+x") (word "_tmp/date"))
(command (word "PATH=/bin:_tmp"))
(command (word "type") (word "-a") (word "date"))
---

=== type -ap -> file; abbreviated
touch _tmp/date
chmod +x _tmp/date
PATH=/bin:_tmp  # control output

type -ap date
---
(command (word "touch") (word "_tmp/date"))
(command (word "chmod") (word "+x") (word "_tmp/date"))
(command (word "PATH=/bin:_tmp"))
(command (word "type") (word "-ap") (word "date"))
---

=== type -a -> builtin and file
touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

type -a pwd
---
(command (word "touch") (word "_tmp/pwd"))
(command (word "chmod") (word "+x") (word "_tmp/pwd"))
(command (word "PATH=/bin:_tmp"))
(command (word "type") (word "-a") (word "pwd"))
---

=== type -a -> builtin and file and shell function
touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

type -a pwd
echo ---

pwd () 
{ 
    echo function-too
}

osh-normalize() {
  sed 's/shell function/function/'
}

type -a pwd | osh-normalize
echo ---

type -a -f pwd | osh-normalize
---
(command (word "touch") (word "_tmp/pwd"))
(command (word "chmod") (word "+x") (word "_tmp/pwd"))
(command (word "PATH=/bin:_tmp"))
(command (word "type") (word "-a") (word "pwd"))
(command (word "echo") (word "---"))
(function "pwd" (brace-group (command (word "echo") (word "function-too"))))
(function "osh-normalize" (brace-group (command (word "sed") (word "'s/shell function/function/'"))))
(pipe (command (word "type") (word "-a") (word "pwd")) (command (word "osh-normalize")))
(command (word "echo") (word "---"))
(pipe (command (word "type") (word "-a") (word "-f") (word "pwd")) (command (word "osh-normalize")))
---

=== type -ap -> builtin and file; doesn't print builtin or function
touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

# Function is also ignored
pwd() { echo function-too; }

type -ap pwd
echo ---

type -p pwd
---
(command (word "touch") (word "_tmp/pwd"))
(command (word "chmod") (word "+x") (word "_tmp/pwd"))
(command (word "PATH=/bin:_tmp"))
(function "pwd" (brace-group (command (word "echo") (word "function-too"))))
(command (word "type") (word "-ap") (word "pwd"))
(command (word "echo") (word "---"))
(command (word "type") (word "-p") (word "pwd"))
---

=== type -a -> executable not in PATH
touch _tmp/executable
chmod +x _tmp/executable
type -a executable
---
(command (word "touch") (word "_tmp/executable"))
(command (word "chmod") (word "+x") (word "_tmp/executable"))
(command (word "type") (word "-a") (word "executable"))
---

=== type -P does not find directories (regression)
mkdir -p _tmp
PATH="_tmp:$PATH"
mkdir _tmp/cat

type -P _tmp/cat
echo status=$?
type -P cat
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "PATH=\"_tmp:$PATH\""))
(command (word "mkdir") (word "_tmp/cat"))
(command (word "type") (word "-P") (word "_tmp/cat"))
(command (word "echo") (word "status=$?"))
(command (word "type") (word "-P") (word "cat"))
(command (word "echo") (word "status=$?"))
---

=== type -> keyword builtin
type while cd
---
(command (word "type") (word "while") (word "cd"))
---

=== type -> alias external
mkdir -p _tmp
shopt -s expand_aliases || true  # bash

alias ll='ls -l'

touch _tmp/date
chmod +x _tmp/date
PATH=_tmp:/bin

normalize() {
  # ignore quotes and backticks
  # bash prints a left backtick
  quotes='"`'\'
  sed \
    -e "s/[$quotes]//g" \
    -e 's/shell function/function/' \
    -e 's/is aliased to/is an alias for/'
}

type ll date | normalize

# Note: both procs and funcs go in var namespace?  So they don't respond to
# 'type'?
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(or (command (word "shopt") (word "-s") (word "expand_aliases")) (command (word "true")))
(command (word "alias") (word "ll='ls -l'"))
(command (word "touch") (word "_tmp/date"))
(command (word "chmod") (word "+x") (word "_tmp/date"))
(command (word "PATH=_tmp:/bin"))
(function "normalize" (brace-group (semi (command (word "quotes='\"`'\\'")) (command (word "sed") (word "-e") (word "\"s/[$quotes]//g\"") (word "-e") (word "'s/shell function/function/'") (word "-e") (word "'s/is aliased to/is an alias for/'")))))
(pipe (command (word "type") (word "ll") (word "date")) (command (word "normalize")))
---

=== type of relative path
mkdir -p _tmp
touch _tmp/file _tmp/ex
chmod +x _tmp/ex

type _tmp/file _tmp/ex

# dash and ash don't care if it's executable
# mksh
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "touch") (word "_tmp/file") (word "_tmp/ex"))
(command (word "chmod") (word "+x") (word "_tmp/ex"))
(command (word "type") (word "_tmp/file") (word "_tmp/ex"))
---

=== type -> not found
type zz 2>err.txt
echo status=$?

# for bash and OSH: print to stderr
fgrep -o 'zz: not found' err.txt || true

# zsh and mksh behave the same - status 1
# dash and ash behave the same - status 127
---
(command (word "type") (word "zz") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(or (command (word "fgrep") (word "-o") (word "'zz: not found'") (word "err.txt")) (command (word "true")))
---

=== special builtins are called out
type cd
type eval
type :
type true

echo
type export
---
(command (word "type") (word "cd"))
(command (word "type") (word "eval"))
(command (word "type") (word ":"))
(command (word "type") (word "true"))
(command (word "echo"))
(command (word "type") (word "export"))
---

=== more special builtins
case $SH in bash|zsh|dash) exit ;; esac

type .
type source

# no agreement here!
# type local
# type typeset
---
(case (word "$SH") (pattern ((word "bash") (word "zsh") (word "dash")) (command (word "exit"))))
(command (word "type") (word "."))
(command (word "type") (word "source"))
---

=== Export sets a global variable
# Even after you do export -n, it still exists.
f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL
---
(function "f" (brace-group (command (word "export") (word "GLOBAL=X"))))
(command (word "f"))
(command (word "echo") (word "$GLOBAL"))
(command (word "printenv.py") (word "GLOBAL"))
---

=== Export sets a global variable that persists after export -n
f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL
export -n GLOBAL
echo $GLOBAL
printenv.py GLOBAL
---
(function "f" (brace-group (command (word "export") (word "GLOBAL=X"))))
(command (word "f"))
(command (word "echo") (word "$GLOBAL"))
(command (word "printenv.py") (word "GLOBAL"))
(command (word "export") (word "-n") (word "GLOBAL"))
(command (word "echo") (word "$GLOBAL"))
(command (word "printenv.py") (word "GLOBAL"))
---

=== export -n undefined is ignored
set -o errexit
export -n undef
echo status=$?
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "export") (word "-n") (word "undef"))
(command (word "echo") (word "status=$?"))
---

=== export -n foo=bar not allowed
foo=old
export -n foo=new
echo status=$?
echo $foo
---
(command (word "foo=old"))
(command (word "export") (word "-n") (word "foo=new"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "$foo"))
---

=== Export a global variable and unset it
f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL
unset GLOBAL
echo g=$GLOBAL
printenv.py GLOBAL
---
(function "f" (brace-group (command (word "export") (word "GLOBAL=X"))))
(command (word "f"))
(command (word "echo") (word "$GLOBAL"))
(command (word "printenv.py") (word "GLOBAL"))
(command (word "unset") (word "GLOBAL"))
(command (word "echo") (word "g=$GLOBAL"))
(command (word "printenv.py") (word "GLOBAL"))
---

=== Export existing global variables
G1=g1
G2=g2
export G1 G2
printenv.py G1 G2
---
(command (word "G1=g1"))
(command (word "G2=g2"))
(command (word "export") (word "G1") (word "G2"))
(command (word "printenv.py") (word "G1") (word "G2"))
---

=== Export existing local variable
f() {
  local L1=local1
  export L1
  printenv.py L1
}
f
printenv.py L1
---
(function "f" (brace-group (semi (semi (command (word "local") (word "L1=local1")) (command (word "export") (word "L1"))) (command (word "printenv.py") (word "L1")))))
(command (word "f"))
(command (word "printenv.py") (word "L1"))
---

=== Export a local that shadows a global
V=global
f() {
  local V=local1
  export V
  printenv.py V
}
f
printenv.py V  # exported local out of scope; global isn't exported yet
export V
printenv.py V  # now it's exported
---
(command (word "V=global"))
(function "f" (brace-group (semi (semi (command (word "local") (word "V=local1")) (command (word "export") (word "V"))) (command (word "printenv.py") (word "V")))))
(command (word "f"))
(command (word "printenv.py") (word "V"))
(command (word "export") (word "V"))
(command (word "printenv.py") (word "V"))
---

=== Export a variable before defining it
export U
U=u
printenv.py U
---
(command (word "export") (word "U"))
(command (word "U=u"))
(command (word "printenv.py") (word "U"))
---

=== Unset exported variable, then define it again.  It's NOT still exported.
export U
U=u
printenv.py U
unset U
printenv.py U
U=newvalue
echo $U
printenv.py U
---
(command (word "export") (word "U"))
(command (word "U=u"))
(command (word "printenv.py") (word "U"))
(command (word "unset") (word "U"))
(command (word "printenv.py") (word "U"))
(command (word "U=newvalue"))
(command (word "echo") (word "$U"))
(command (word "printenv.py") (word "U"))
---

=== Exporting a parent func variable (dynamic scope)
# The algorithm is to walk up the stack and export that one.
inner() {
  export outer_var
  echo "inner: $outer_var"
  printenv.py outer_var
}
outer() {
  local outer_var=X
  echo "before inner"
  printenv.py outer_var
  inner
  echo "after inner"
  printenv.py outer_var
}
outer
---
(function "inner" (brace-group (semi (semi (command (word "export") (word "outer_var")) (command (word "echo") (word "\"inner: $outer_var\""))) (command (word "printenv.py") (word "outer_var")))))
(function "outer" (brace-group (semi (semi (semi (semi (semi (command (word "local") (word "outer_var=X")) (command (word "echo") (word "\"before inner\""))) (command (word "printenv.py") (word "outer_var"))) (command (word "inner"))) (command (word "echo") (word "\"after inner\""))) (command (word "printenv.py") (word "outer_var")))))
(command (word "outer"))
---

=== Dependent export setting
# FOO is not respected here either.
export FOO=foo v=$(printenv.py FOO)
echo "v=$v"
---
(command (word "export") (word "FOO=foo") (word "v=$(printenv.py FOO)"))
(command (word "echo") (word "\"v=$v\""))
---

=== Exporting a variable doesn't change it
old=$PATH
export PATH
new=$PATH
test "$old" = "$new" && echo "not changed"
---
(command (word "old=$PATH"))
(command (word "export") (word "PATH"))
(command (word "new=$PATH"))
(and (command (word "test") (word "\"$old\"") (word "=") (word "\"$new\"")) (command (word "echo") (word "\"not changed\"")))
---

=== can't export array (strict_array)
shopt -s strict_array

typeset -a a
a=(1 2 3)

export a
printenv.py a
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "typeset") (word "-a") (word "a"))
(command (word "a=(1 2 3)"))
(command (word "export") (word "a"))
(command (word "printenv.py") (word "a"))
---

=== can't export associative array (strict_array)
shopt -s strict_array

typeset -A a
a["foo"]=bar

export a
printenv.py a
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "typeset") (word "-A") (word "a"))
(command (word "a[\"foo\"]=bar"))
(command (word "export") (word "a"))
(command (word "printenv.py") (word "a"))
---

=== assign to readonly variable
# bash doesn't abort unless errexit!
readonly foo=bar
foo=eggs
echo "status=$?"  # nothing happens
---
(command (word "readonly") (word "foo=bar"))
(command (word "foo=eggs"))
(command (word "echo") (word "\"status=$?\""))
---

=== Make an existing local variable readonly
f() {
	local x=local
	readonly x
	echo $x
	eval 'x=bar'  # Wrap in eval so it's not fatal
	echo status=$?
}
x=global
f
echo $x
---
(function "f" (brace-group (semi (semi (semi (semi (command (word "local") (word "x=local")) (command (word "readonly") (word "x"))) (command (word "echo") (word "$x"))) (command (word "eval") (word "'x=bar'"))) (command (word "echo") (word "status=$?")))))
(command (word "x=global"))
(command (word "f"))
(command (word "echo") (word "$x"))
---

=== assign to readonly variable - errexit
set -o errexit
readonly foo=bar
foo=eggs
echo "status=$?"  # nothing happens
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "readonly") (word "foo=bar"))
(command (word "foo=eggs"))
(command (word "echo") (word "\"status=$?\""))
---

=== Unset a variable
foo=bar
echo foo=$foo
unset foo
echo foo=$foo
---
(command (word "foo=bar"))
(command (word "echo") (word "foo=$foo"))
(command (word "unset") (word "foo"))
(command (word "echo") (word "foo=$foo"))
---

=== Unset exit status
V=123
unset V
echo status=$?
---
(command (word "V=123"))
(command (word "unset") (word "V"))
(command (word "echo") (word "status=$?"))
---

=== Unset nonexistent variable
unset ZZZ
echo status=$?
---
(command (word "unset") (word "ZZZ"))
(command (word "echo") (word "status=$?"))
---

=== Unset readonly variable
# dash and zsh abort the whole program.   OSH doesn't?
readonly R=foo
unset R
echo status=$?
---
(command (word "readonly") (word "R=foo"))
(command (word "unset") (word "R"))
(command (word "echo") (word "status=$?"))
---

=== Unset a function without -f
f() {
  echo foo
}
f
unset f
f
---
(function "f" (brace-group (command (word "echo") (word "foo"))))
(command (word "f"))
(command (word "unset") (word "f"))
(command (word "f"))
---

=== Unset has dynamic scope
f() {
  unset foo
}
foo=bar
echo foo=$foo
f
echo foo=$foo
---
(function "f" (brace-group (command (word "unset") (word "foo"))))
(command (word "foo=bar"))
(command (word "echo") (word "foo=$foo"))
(command (word "f"))
(command (word "echo") (word "foo=$foo"))
---

=== Unset and scope (bug #653)
unlocal() { unset "$@"; }

level2() {
  local hello=yy

  echo level2=$hello
  unlocal hello
  echo level2=$hello
}

level1() {
  local hello=xx

  level2

  echo level1=$hello
  unlocal hello
  echo level1=$hello

  level2
}

hello=global
level1

# bash, mksh, yash agree here.
---
(function "unlocal" (brace-group (command (word "unset") (word "\"$@\""))))
(function "level2" (brace-group (semi (semi (semi (command (word "local") (word "hello=yy")) (command (word "echo") (word "level2=$hello"))) (command (word "unlocal") (word "hello"))) (command (word "echo") (word "level2=$hello")))))
(function "level1" (brace-group (semi (semi (semi (semi (semi (command (word "local") (word "hello=xx")) (command (word "level2"))) (command (word "echo") (word "level1=$hello"))) (command (word "unlocal") (word "hello"))) (command (word "echo") (word "level1=$hello"))) (command (word "level2")))))
(command (word "hello=global"))
(command (word "level1"))
---

=== unset of local reveals variable in higher scope
# OSH has a RARE behavior here (matching yash and mksh), but at least it's
# consistent.

x=global
f() {
  local x=foo
  echo x=$x
  unset x
  echo x=$x
}
f
---
(command (word "x=global"))
(function "f" (brace-group (semi (semi (semi (command (word "local") (word "x=foo")) (command (word "echo") (word "x=$x"))) (command (word "unset") (word "x"))) (command (word "echo") (word "x=$x")))))
(command (word "f"))
---

=== Unset invalid variable name
unset %
echo status=$?
---
(command (word "unset") (word "%"))
(command (word "echo") (word "status=$?"))
---

=== Unset nonexistent variable
unset _nonexistent__
echo status=$?
---
(command (word "unset") (word "_nonexistent__"))
(command (word "echo") (word "status=$?"))
---

=== Unset -v
foo() {
  echo "function foo"
}
foo=bar
unset -v foo
echo foo=$foo
foo
---
(function "foo" (brace-group (command (word "echo") (word "\"function foo\""))))
(command (word "foo=bar"))
(command (word "unset") (word "-v") (word "foo"))
(command (word "echo") (word "foo=$foo"))
(command (word "foo"))
---

=== Unset -f
foo() {
  echo "function foo"
}
foo=bar
unset -f foo
echo foo=$foo
foo
echo status=$?
---
(function "foo" (brace-group (command (word "echo") (word "\"function foo\""))))
(command (word "foo=bar"))
(command (word "unset") (word "-f") (word "foo"))
(command (word "echo") (word "foo=$foo"))
(command (word "foo"))
(command (word "echo") (word "status=$?"))
---

=== Unset array member
a=(x y z)
unset 'a[1]'
echo status=$?
echo "${a[@]}" len="${#a[@]}"
---
(command (word "a=(x y z)"))
(command (word "unset") (word "'a[1]'"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "\"${a[@]}\"") (word "len=\"${#a[@]}\""))
---

=== Unset errors
unset undef
echo status=$?

a=(x y z)
unset 'a[99]'  # out of range
echo status=$?

unset 'not_array[99]'  # not an array
echo status=$?
---
(command (word "unset") (word "undef"))
(command (word "echo") (word "status=$?"))
(command (word "a=(x y z)"))
(command (word "unset") (word "'a[99]'"))
(command (word "echo") (word "status=$?"))
(command (word "unset") (word "'not_array[99]'"))
(command (word "echo") (word "status=$?"))
---

=== Unset wrong type
case $SH in mksh) exit ;; esac

declare undef
unset -v 'undef[1]'
echo undef $?
unset -v 'undef["key"]'
echo undef $?

declare a=(one two)
unset -v 'a[1]'
echo array $?

#shopt -s strict_arith || true
# In OSH, the string 'key' is converted to an integer, which is 0, unless
# strict_arith is on, when it fails.
unset -v 'a["key"]'
echo array $?

declare -A A=(['key']=val)
unset -v 'A[1]'
echo assoc $?
unset -v 'A["key"]'
echo assoc $?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "declare") (word "undef"))
(command (word "unset") (word "-v") (word "'undef[1]'"))
(command (word "echo") (word "undef") (word "$?"))
(command (word "unset") (word "-v") (word "'undef[\"key\"]'"))
(command (word "echo") (word "undef") (word "$?"))
(command (word "declare") (word "a=(one two)"))
(command (word "unset") (word "-v") (word "'a[1]'"))
(command (word "echo") (word "array") (word "$?"))
(command (word "unset") (word "-v") (word "'a[\"key\"]'"))
(command (word "echo") (word "array") (word "$?"))
(command (word "declare") (word "-A") (word "A=(['key']=val)"))
(command (word "unset") (word "-v") (word "'A[1]'"))
(command (word "echo") (word "assoc") (word "$?"))
(command (word "unset") (word "-v") (word "'A[\"key\"]'"))
(command (word "echo") (word "assoc") (word "$?"))
---

=== unset -v assoc (related to issue #661)
case $SH in dash|mksh|zsh) return ;; esac

declare -A dict=()
key=1],a[1
dict["$key"]=foo
echo ${#dict[@]}
echo keys=${!dict[@]}
echo vals=${dict[@]}

unset -v 'dict["$key"]'
echo ${#dict[@]}
echo keys=${!dict[@]}
echo vals=${dict[@]}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "return"))))
(command (word "declare") (word "-A") (word "dict=()"))
(command (word "key=1],a[1"))
(command (word "dict[\"$key\"]=foo"))
(command (word "echo") (word "${#dict[@]}"))
(command (word "echo") (word "keys=${!dict[@]}"))
(command (word "echo") (word "vals=${dict[@]}"))
(command (word "unset") (word "-v") (word "'dict[\"$key\"]'"))
(command (word "echo") (word "${#dict[@]}"))
(command (word "echo") (word "keys=${!dict[@]}"))
(command (word "echo") (word "vals=${dict[@]}"))
---

=== unset assoc errors
case $SH in dash|mksh) return ;; esac

declare -A assoc=(['key']=value)
unset 'assoc["nonexistent"]'
echo status=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "return"))))
(command (word "declare") (word "-A") (word "assoc=(['key']=value)"))
(command (word "unset") (word "'assoc[\"nonexistent\"]'"))
(command (word "echo") (word "status=$?"))
---

=== Unset array member with dynamic parsing
i=1
a=(w x y z)
unset 'a[ i - 1 ]' a[i+1]  # note: can't have space between a and [
echo status=$?
echo "${a[@]}" len="${#a[@]}"
---
(command (word "i=1"))
(command (word "a=(w x y z)"))
(command (word "unset") (word "'a[ i - 1 ]'") (word "a[i+1]"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "\"${a[@]}\"") (word "len=\"${#a[@]}\""))
---

=== Use local twice
f() {
  local foo=bar
  local foo
  echo $foo
}
f
---
(function "f" (brace-group (semi (semi (command (word "local") (word "foo=bar")) (command (word "local") (word "foo"))) (command (word "echo") (word "$foo")))))
(command (word "f"))
---

=== Local without variable is still unset!
set -o nounset
f() {
  local foo
  echo "[$foo]"
}
f
---
(command (word "set") (word "-o") (word "nounset"))
(function "f" (brace-group (semi (command (word "local") (word "foo")) (command (word "echo") (word "\"[$foo]\"")))))
(command (word "f"))
---

=== local after readonly
f() { 
  readonly y
  local x=1 y=$(( x ))
  echo y=$y
}
f
echo y=$y
---
(function "f" (brace-group (semi (semi (command (word "readonly") (word "y")) (command (word "local") (word "x=1") (word "y=$(( x ))"))) (command (word "echo") (word "y=$y")))))
(command (word "f"))
(command (word "echo") (word "y=$y"))
---

=== unset a[-1] (bf.bash regression)
case $SH in dash|zsh) exit ;; esac

a=(1 2 3)
unset a[-1]
echo len=${#a[@]}

echo last=${a[-1]}
(( last = a[-1] ))
echo last=$last

(( a[-1] = 42 ))
echo "${a[@]}"
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "a=(1 2 3)"))
(command (word "unset") (word "a[-1]"))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "echo") (word "last=${a[-1]}"))
(arith (word " last = a[-1] "))
(command (word "echo") (word "last=$last"))
(arith (word " a[-1] = 42 "))
(command (word "echo") (word "\"${a[@]}\""))
---

=== unset a[-1] in sparse array (bf.bash regression)
case $SH in dash|zsh) exit ;; esac

a=(0 1 2 3 4)
unset a[1]
unset a[4]
echo len=${#a[@]} a=${a[@]}
echo last=${a[-1]} second=${a[-2]} third=${a[-3]}

echo ---
unset a[3]
echo len=${#a[@]} a=${a[@]}
echo last=${a[-1]} second=${a[-2]} third=${a[-3]}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "a=(0 1 2 3 4)"))
(command (word "unset") (word "a[1]"))
(command (word "unset") (word "a[4]"))
(command (word "echo") (word "len=${#a[@]}") (word "a=${a[@]}"))
(command (word "echo") (word "last=${a[-1]}") (word "second=${a[-2]}") (word "third=${a[-3]}"))
(command (word "echo") (word "---"))
(command (word "unset") (word "a[3]"))
(command (word "echo") (word "len=${#a[@]}") (word "a=${a[@]}"))
(command (word "echo") (word "last=${a[-1]}") (word "second=${a[-2]}") (word "third=${a[-3]}"))
---
