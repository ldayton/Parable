================================================================================
builtin-bash.test.sh: help
================================================================================

help
echo status=$? >&2
help help
echo status=$? >&2
help -- help
echo status=$? >&2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: bad help topic
================================================================================

help ZZZ 2>$TMP/err.txt
echo "help=$?"
cat $TMP/err.txt | grep -i 'no help topics' >/dev/null
echo "grep=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile
  echo "n=${#MAPFILE[@]}"
  printf '[%s]\n' "${MAPFILE[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: readarray (synonym for mapfile)
================================================================================

type readarray >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  readarray
  echo "n=${#MAPFILE[@]}"
  printf '[%s]\n' "${MAPFILE[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (array name): arr
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (delimiter): -d delim
================================================================================

# Note: Bash-4.4+
type mapfile >/dev/null 2>&1 || exit 0
printf '%s:' {1..5..2} | {
  mapfile -d : arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (delimiter): -d '' (null-separated)
================================================================================

# Note: Bash-4.4+
type mapfile >/dev/null 2>&1 || exit 0
printf '%s\0' {1..5..2} | {
  mapfile -d '' arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (truncate delim): -t
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' {1..5..2} | {
  mapfile -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile -t doesn't remove \r
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\r\n' {1..5..2} | {
  mapfile -t arr
  argv.py "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile -t bugs (ble.sh)
================================================================================


# empty line
mapfile -t lines <<< $'hello\n\nworld'
echo len=${#lines[@]}
#declare -p lines

# initial newline
mapfile -t lines <<< $'\nhello'
echo len=${#lines[@]}
#declare -p lines

# trailing newline
mapfile -t lines <<< $'hello\n'
echo len=${#lines[@]}
#declare -p lines

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (store position): -O start
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' a{0..2} | {
  arr=(x y z)
  mapfile -O 2 -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile (input range): -s start -n count
================================================================================

type mapfile >/dev/null 2>&1 || exit 0
printf '%s\n' a{0..10} | {
  mapfile -s 5 -n 3 -t arr
  echo "n=${#arr[@]}"
  printf '[%s]\n' "${arr[@]}"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bash.test.sh: mapfile / readarray stdin  TODO: Fix me.
================================================================================

shopt -s lastpipe  # for bash

seq 2 | mapfile m
seq 3 | readarray r
echo ${#m[@]}
echo ${#r[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -l should report readline functions
================================================================================


# This test depends on the exact version
# bind -l | sort > _tmp/this-shell-bind-l.txt
# comm -23 $REPO_ROOT/spec/testdata/bind/bind_l_function_list.txt _tmp/this-shell-bind-l.txt

# More relaxed test
bind -l | grep accept-line

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -p -P to print function names and key bindings
================================================================================


# silly workaround for spec test format - change # comment to %
bind -p | grep vi-subst | sed 's/^#/%/'
echo

bind -P | grep vi-subst

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -s -S accepted
================================================================================


# TODO: add non-trivial tests here

bind -s
bind -S

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -v -V accepted
================================================================================


bind -v | grep blink-matching-paren
echo

# transform silly quote so we don't mess up syntax highlighting
bind -V | grep blink-matching-paren | sed "s/\`/'/g"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -q
================================================================================


bind -q zz-bad
echo status=$?

# bash prints message to stdout

bind -q vi-subst
echo status=$?

bind -q yank
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -X
================================================================================

bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -x '"\C-o\C-s\C-h": echo foo'
bind -X | grep -oF '\C-o\C-s\C-h'
bind -X | grep -oF 'echo foo'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -m with bind -x/-X
================================================================================

bind -X | grep -oF 'emacs|vi'
echo status=$?

bind -m emacs -x '"\C-o\C-s\C-h": echo emacs'
bind -m emacs -X | grep -oF 'emacs'
echo status=$?

bind -m vi -x '"\C-o\C-s\C-h": echo vi'
bind -m vi -X | grep -oF 'vi'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -r
================================================================================

bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind '"\C-o\C-s\C-h": yank'
bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -r "\C-o\C-s\C-h"
bind -q yank | grep -oF '\C-o\C-s\C-h'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bind.test.sh: bind -r of bind -x commands
================================================================================

bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -x '"\C-o\C-s\C-h": echo foo'
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

bind -r "\C-o\C-s\C-h"
bind -X | grep -oF '\C-o\C-s\C-h'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: zero args: [ ]
================================================================================

[ ] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: one arg: [ x ] where x is one of '=' '!' '(' ']'
================================================================================

[ = ]
echo status=$?
[ ] ]
echo status=$?
[ '!' ]
echo status=$?
[ '(' ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: one arg: empty string is false.  Equivalent to -n.
================================================================================

test 'a'  && echo true
test ''   || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -a as unary operator (alias of -e)
================================================================================

# NOT IMPLEMENTED FOR OSH, but could be later.  See comment in core/id_kind.py.
[ -a / ]
echo status=$?
[ -a /nonexistent ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: two args: -z with = ! ( ]
================================================================================

[ -z = ]
echo status=$?
[ -z ] ]
echo status=$?
[ -z '!' ]
echo status=$?
[ -z '(' ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: three args
================================================================================

[ foo = '' ]
echo status=$?
[ foo -a '' ]
echo status=$?
[ foo -o '' ]
echo status=$?
[ ! -z foo ]
echo status=$?
[ \( foo \) ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: four args
================================================================================

[ ! foo = foo ]
echo status=$?
[ \( -z foo \) ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test with extra args is syntax error
================================================================================

test -n x ]
echo status=$?
test -n x y
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: ] syntax errors
================================================================================

[
echo status=$?
test  # not a syntax error
echo status=$?
[ -n x  # missing ]
echo status=$?
[ -n x ] y  # extra arg after ]
echo status=$?
[ -n x y  # extra arg
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -n
================================================================================

test -n 'a'  && echo true
test -n ''   || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: ! -a
================================================================================

[ -z '' -a ! -z x ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -o
================================================================================

[ -z x -o ! -z x ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: ( )
================================================================================

[ -z '' -a '(' ! -z x ')' ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: ( ) ! -a -o with system version of [
================================================================================

command [ --version
command [ -z '' -a '(' ! -z x ')' ] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: == is alias for =
================================================================================

[ a = a ] && echo true
[ a == a ] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: == and = does not do glob
================================================================================

[ abc = 'a*' ]
echo status=$?
[ abc == 'a*' ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ with op variable
================================================================================

# OK -- parsed AFTER evaluation of vars
op='='
[ a $op a ] && echo true
[ a $op b ] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ with unquoted empty var
================================================================================

empty=''
[ $empty = '' ] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ compare with literal -f
================================================================================

# Hm this is the same
var=-f
[ $var = -f ] && echo true
[ '-f' = $var ] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ '(' foo ] is runtime syntax error
================================================================================

[ '(' foo ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -z '>' implies two token lookahead
================================================================================

[ -z ] && echo true  # -z is operand
[ -z '>' ] || echo false  # -z is operator
[ -z '>' -- ] && echo true  # -z is operand

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: operator/operand ambiguity with ]
================================================================================

# bash parses this as '-z' AND ']', which is true.  It's a syntax error in
# dash/mksh.
[ -z -a ] ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: operator/operand ambiguity with -a
================================================================================

# bash parses it as '-z' AND '-a'.  It's a syntax error in mksh but somehow a
# runtime error in dash.
[ -z -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -d
================================================================================

test -d $TMP
echo status=$?
test -d $TMP/__nonexistent_Z_Z__
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -x
================================================================================

rm -f $TMP/x
echo 'echo hi' > $TMP/x
test -x $TMP/x || echo 'no'
chmod +x $TMP/x
test -x $TMP/x && echo 'yes'
test -x $TMP/__nonexistent__ || echo 'bad'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -r
================================================================================

echo '1' > $TMP/testr_yes
echo '2' > $TMP/testr_no
chmod -r $TMP/testr_no  # remove read permission
test -r $TMP/testr_yes && echo 'yes'
test -r $TMP/testr_no || echo 'no'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -w
================================================================================

rm -f $TMP/testw_*
echo '1' > $TMP/testw_yes
echo '2' > $TMP/testw_no
chmod -w $TMP/testw_no  # remove write permission
test -w $TMP/testw_yes && echo 'yes'
test -w $TMP/testw_no || echo 'no'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -k for sticky bit
================================================================================

# not isolated: /tmp usually has sticky bit on
# https://en.wikipedia.org/wiki/Sticky_bit

test -k /tmp
echo status=$?

test -k /bin
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -h and -L test for symlink
================================================================================

tmp=$TMP/builtin-test-1
mkdir -p $tmp
touch $tmp/zz
ln -s -f $tmp/zz $tmp/symlink
ln -s -f $tmp/__nonexistent_ZZ__ $tmp/dangling
test -L $tmp/zz || echo no
test -h $tmp/zz || echo no
test -f $tmp/symlink && echo is-file
test -L $tmp/symlink && echo symlink
test -h $tmp/symlink && echo symlink
test -L $tmp/dangling && echo dangling
test -h $tmp/dangling  && echo dangling
test -f $tmp/dangling  || echo 'dangling is not file'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -t 1 for stdout
================================================================================

# There is no way to get a terminal in the test environment?
[ -t 1 ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ -t invalid ]
================================================================================

[ -t invalid ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -ot and -nt
================================================================================

touch -d 2017/12/31 $TMP/x
touch -d 2018/01/01 > $TMP/y
test $TMP/x -ot $TMP/y && echo 'older'
test $TMP/x -nt $TMP/y || echo 'not newer'
test $TMP/x -ot $TMP/x || echo 'not older than itself'
test $TMP/x -nt $TMP/x || echo 'not newer than itself'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: [ a -eq b ]
================================================================================

[ a -eq a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -s
================================================================================

test -s __nonexistent
echo status=$?
touch $TMP/empty
test -s $TMP/empty
echo status=$?
echo nonempty > $TMP/nonempty
test -s $TMP/nonempty
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -b -c -S (block, character, socket)
================================================================================

# NOTE: we do not have the "true" case

echo -b
test -b nonexistent
echo status=$?
test -b testdata
echo status=$?
test -b /
echo status=$?

echo -c
test -c nonexistent
echo status=$?
test -c testdata
echo status=$?

echo -S
test -S nonexistent
echo status=$?
test -S testdata
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -p named pipe
================================================================================

mkfifo $TMP/fifo
test -p $TMP/fifo
echo status=$?

test -p testdata
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -G and -O for effective user ID and group ID
================================================================================


mkdir -p $TMP/bin

test -O $TMP/bin
echo status=$?
test -O __nonexistent__
echo status=$?

test -G $TMP/bin
echo status=$?
test -G __nonexistent__
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -u for setuid, -g too
================================================================================


touch $TMP/setuid $TMP/setgid
chmod u+s $TMP/setuid
chmod g+s $TMP/setgid

test -u $TMP/setuid
echo status=$?

test -u $TMP/setgid
echo status=$?

test -g $TMP/setuid
echo status=$?

test -g $TMP/setgid
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -v to test variable (bash)
================================================================================

test -v nonexistent
echo global=$?

g=1
test -v g
echo global=$?

f() {
  local f_var=0
  g
}

g() {
  test -v f_var
  echo dynamic=$?
  test -v g
  echo dynamic=$?
  test -v nonexistent
  echo dynamic=$?
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -o for options
================================================================================

# note: it's lame that the 'false' case is confused with the 'typo' case.
# but checking for error code 2 is unlikely anyway.
test -o nounset
echo status=$?

set -o nounset
test -o nounset
echo status=$?

test -o _bad_name_
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -nt -ot
================================================================================

[ present -nt absent ] || exit 1
[ absent -ot present ] || exit 2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: -ef
================================================================================

left=$TMP/left
right=$TMP/right
touch $left $right

ln -f $TMP/left $TMP/hardlink

test $left -ef $left && echo same
test $left -ef $TMP/hardlink && echo same
test $left -ef $right || echo different

test $TMP/__nonexistent -ef $right || echo different

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: Overflow error
================================================================================

test -t 12345678910
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: Bug regression
================================================================================

test "$ipv6" = "yes" -a "$ipv6lib" != "none"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -c
================================================================================

test -c /dev/zero
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: test -S
================================================================================

test -S /dev/zero
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: bug from pnut: negative number $((-1))
================================================================================


# https://lobste.rs/s/lplim1/design_self_compiling_c_transpiler#c_km2ywc

[ $((-42)) -le 0 ]
echo status=$?

[ $((-1)) -le 0 ]
echo status=$?

echo

[ -1 -le 0 ]
echo status=$?

[ -42 -le 0 ]
echo status=$?

echo

test -1 -le 0
echo status=$?

test -42 -le 0
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: negative octal numbers, etc.
================================================================================


# zero
[ -0 -eq 0 ]
echo zero=$?

# octal numbers can be negative
[ -0123 -eq -83 ]
echo octal=$?

# hex doesn't have negative numbers?
[ -0xff -eq -255 ]
echo hex=$?

# base N doesn't either
[ -64#a -eq -10 ]
echo baseN=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: More negative numbers
================================================================================

case $SH in dash) exit ;; esac

[[ -1 -le 0 ]]
echo status=$?

[[ $((-1)) -le 0 ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: No octal, hex, base N conversion - leading 0 is a regular decimal
================================================================================


# arithmetic has octal conversion
echo $(( 073 ))
echo $(( -073 ))

echo

# Bracket does NOT have octal conversion!  That is annoying.
[ 073 -eq 73 ]
echo status=$?

[ -073 -eq -73 ]
echo status=$?

echo

[ 0xff -eq 255 ]
echo hex=$?
[ 64#a -eq 10 ]
echo baseN=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: Looks like octal, but digit is too big
================================================================================


# arithmetic has octal conversion
echo $(( 083 ))
echo status=$?

echo $(( -083 ))
echo status=$?

echo

# Bracket does NOT have octal conversion!  That is annoying.
[ 083 -eq 83 ]
echo status=$?

[ -083 -eq -83 ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-bracket.test.sh: no recursive arith [ 1+2 -eq 3 ]
================================================================================


[ 1+2 -eq 3 ]
echo status=$?

s='1+2'
[ "$s" -eq 3 ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd and $PWD
================================================================================

cd /
echo $PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd BAD/..
================================================================================


# Odd divergence in shells: dash and mksh normalize the path and don't check
# this error.
# TODO: I would like OSH to behave like bash and zsh, but separating chdir_arg
# and pwd_arg breaks case 17.

cd nonexistent_ZZ/..
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd with 2 or more args - with strict_arg_parse
================================================================================


shopt -s strict_arg_parse

mkdir -p foo
cd foo
echo status=$?
cd ..
echo status=$?


cd foo bar
st=$?
if test $st -ne 0; then
  echo 'failed with multiple args'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd with 2 or more args is allowed (strict_arg_parse disabled)
================================================================================


mkdir -p foo
cd foo bar

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd - without OLDPWD
================================================================================


cd - > /dev/null  # silence dash output
echo status=$?
#pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: $OLDPWD
================================================================================

cd /
cd $TMP
echo "old: $OLDPWD"
env | grep OLDPWD  # It's EXPORTED too!
cd -

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: pwd
================================================================================

cd /
pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: pwd after cd ..
================================================================================

dir=$TMP/dir-one/dir-two
mkdir -p $dir
cd $dir
echo $(basename $(pwd))
cd ..
echo $(basename $(pwd))

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: pwd with symlink and -P
================================================================================

tmp=$TMP/builtins-pwd-1
mkdir -p $tmp/target
ln -s -f $tmp/target $tmp/symlink

cd $tmp/symlink

echo pwd:
basename $(pwd)

echo pwd -P:
basename $(pwd -P)

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: setting $PWD doesn't affect the value of 'pwd' builtin
================================================================================

dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir

PWD=foo
echo before $PWD
pwd
echo after $PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: unset PWD; then pwd
================================================================================

dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir

unset PWD
echo PWD=$PWD
pwd
echo PWD=$PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: 'unset PWD; pwd' before any cd (tickles a rare corner case)
================================================================================

dir=/tmp/oil-spec-test/pwd-2
mkdir -p $dir
cd $dir

# ensure clean shell process state
$SH -c 'unset PWD; pwd'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: lie about PWD; pwd before any cd
================================================================================

dir=/tmp/oil-spec-test/pwd-3
mkdir -p $dir
cd $dir

# ensure clean shell process state
$SH -c 'PWD=foo; pwd'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: remove pwd dir
================================================================================

dir=/tmp/oil-spec-test/pwd
mkdir -p $dir
cd $dir
pwd
rmdir $dir
echo status=$?
pwd
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: pwd in symlinked dir on shell initialization
================================================================================

tmp=$TMP/builtins-pwd-2
mkdir -p $tmp
mkdir -p $tmp/target
ln -s -f $tmp/target $tmp/symlink

cd $tmp/symlink
$SH -c 'basename $(pwd)'
unset PWD
$SH -c 'basename $(pwd)'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: Test the current directory after 'cd ..' involving symlinks
================================================================================

dir=$TMP/symlinktest
mkdir -p $dir
cd $dir
mkdir -p a/b/c
mkdir -p a/b/d
ln -s -f a/b/c c > /dev/null
cd c
cd ..
# Expecting a c/ (since we are in symlinktest) but osh gives c d (thinks we are
# in b/)
ls

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd with no arguments
================================================================================

HOME=$TMP/home
mkdir -p $HOME
cd
test $(pwd) = "$HOME" && echo OK

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd to nonexistent dir
================================================================================

cd /nonexistent/dir
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd away from dir that was deleted
================================================================================

dir=$TMP/cd-nonexistent
mkdir -p $dir
cd $dir
rmdir $dir
cd $TMP
echo $(basename $OLDPWD)
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd permits double bare dash
================================================================================

cd -- /
echo $PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd to symlink with -L and -P
================================================================================

targ=$TMP/cd-symtarget
lnk=$TMP/cd-symlink
mkdir -p $targ
ln -s $targ $lnk

# -L behavior is the default
cd $lnk
test $PWD = "$TMP/cd-symlink" && echo OK

cd -L $lnk
test $PWD = "$TMP/cd-symlink" && echo OK

cd -P $lnk
test $PWD = "$TMP/cd-symtarget" && echo OK || echo $PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: cd to relative path with -L and -P
================================================================================

die() { echo "$@"; exit 1; }

targ=$TMP/cd-symtarget/subdir
lnk=$TMP/cd-symlink
mkdir -p $targ
ln -s $TMP/cd-symtarget $lnk

# -L behavior is the default
cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd ..
test $PWD = "$TMP/cd-symlink" && echo OK

cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd -L ..
test $PWD = "$TMP/cd-symlink" && echo OK

cd $lnk/subdir
test $PWD = "$TMP/cd-symlink/subdir" || die "failed"
cd -P ..
test $PWD = "$TMP/cd-symtarget" && echo OK || echo $PWD

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: unset PWD; cd /tmp is allowed (regression)
================================================================================


unset PWD; cd /tmp
pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: CDPATH is respected
================================================================================


mkdir -p /tmp/spam/foo /tmp/eggs/foo

CDPATH='/tmp/spam:/tmp/eggs'

cd foo
echo status=$?
pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: Change directory in non-shell parent process (make or Python)
================================================================================


# inspired by Perl package bug

old_dir=$(pwd)

mkdir -p cpan/Encode/Byte

# Simulate make changing the dir
wrapped_chdir() {
  #set -- $SH -c 'echo BEFORE; pwd; echo CD; cd Byte; echo AFTER; pwd'

  set -- $SH -c 'cd Byte; pwd'
  # strace comes out the same - one getcwd() and one chdir()
  #set -- strace -e 'getcwd,chdir' "$@"

  python2 -c '
from __future__ import print_function
import os, sys, subprocess

argv = sys.argv[1:]
print("Python PWD = %r" % os.getenv("PWD"), file=sys.stderr)
print("Python argv = %r" % argv, file=sys.stderr)

os.chdir("cpan/Encode")
subprocess.check_call(argv)
' "$@"
}

#wrapped_chdir
new_dir=$(wrapped_chdir)

#echo $old_dir

# Make the test insensitive to absolute paths
echo "${new_dir##$old_dir}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: What happens when inherited $PWD and current dir disagree?
================================================================================


DIR=/tmp/osh-spec-cd
mkdir -p $DIR
cd $DIR

old_dir=$(pwd)

mkdir -p cpan/Encode/Byte

# Simulate make changing the dir
wrapped_chdir() {
  #set -- $SH -c 'echo BEFORE; pwd; echo CD; cd Byte; echo AFTER; pwd'

  # disagreement before we gert here
  set -- $SH -c '
echo "PWD = $PWD"; pwd
cd Byte; echo cd=$?
echo "PWD = $PWD"; pwd
'

  # strace comes out the same - one getcwd() and one chdir()
  #set -- strace -e 'getcwd,chdir' "$@"

  python2 -c '
from __future__ import print_function
import os, sys, subprocess

argv = sys.argv[1:]
print("Python argv = %r" % argv, file=sys.stderr)

os.chdir("cpan/Encode")
print("Python PWD = %r" % os.getenv("PWD"), file=sys.stdout)
sys.stdout.flush()

subprocess.check_call(argv)
' "$@"
}

#unset PWD
wrapped_chdir

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: Survey of getcwd() syscall
================================================================================


# This is not that important -- see core/sh_init.py
# Instead of verifying that stat('.') == stat(PWD), which is two sycalls,
# OSH just calls getcwd() unconditionally.

# so C++ leak sanitizer  doesn't print to stderr
export ASAN_OPTIONS='detect_leaks=0'

strace -e getcwd -- $SH -c 'echo hi; pwd; echo $PWD' 1> /dev/null 2> err.txt

wc -l err.txt
#cat err.txt

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: chdir is a synonym for cd - busybox ash
================================================================================


chdir /tmp

if test $? -ne 0; then
  echo fail
  exit
fi

pwd

# It's the same with no args, but mksh fails because of $HOME
#chdir
#echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: arguments to pwd
================================================================================

pwd /

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-cd.test.sh: pwd errors out on args with strict_arg_parse
================================================================================

shopt -s strict_arg_parse || true
pwd / >/dev/null || echo 'too many args!'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete with no args and complete -p both print completion spec
================================================================================


set -e

complete

complete -W 'foo bar' mycommand

complete -p

complete -F myfunc other

complete

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete -F f is usage error
================================================================================


#complete -F f cmd

# Alias for complete -p
complete > /dev/null  # ignore OSH output for now
echo status=$?

# But this is an error
complete -F f
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete with nonexistent function
================================================================================

complete -F invalidZZ -D
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete with no action
================================================================================

complete foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: -A function prints functions
================================================================================

add () { expr 4 + 4; }
div () { expr 6 / 2; }
ek () { echo hello; }
__ec () { echo hi; }
_ab () { expr 10 % 3; }
compgen -A function
echo --
compgen -A function _

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: Invalid syntax
================================================================================

compgen -A foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: how compgen calls completion functions
================================================================================

foo_complete() {
  # first, cur, prev
  argv.py argv "$@"
  argv.py COMP_WORDS "${COMP_WORDS[@]}"
  argv.py COMP_CWORD "${COMP_CWORD}"
  argv.py COMP_LINE "${COMP_LINE}"
  argv.py COMP_POINT "${COMP_POINT}"
  #return 124
  COMPREPLY=(one two three)
}
compgen -F foo_complete foo a b c

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete -o -F (git)
================================================================================

foo() { echo foo; }
wrapper=foo
complete -o default -o nospace -F $wrapper git

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compopt with invalid syntax
================================================================================

compopt -o invalid
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compopt fails when not in completion function
================================================================================

# NOTE: Have to be executing a completion function
compopt -o filenames +o nospace

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -f on invalid  dir
================================================================================

compgen -f /non-existing-dir/

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -f
================================================================================

mkdir -p $TMP/compgen
touch $TMP/compgen/{one,two,three}
cd $TMP/compgen
compgen -f | sort
echo --
compgen -f t | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -v with local vars
================================================================================

v1_global=0
f() {
  local v2_local=0	 
  compgen -v v
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -v on unknown var
================================================================================

compgen -v __nonexistent__

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -v P
================================================================================

cd > /dev/null  # for some reason in bash, this makes PIPESTATUS appear!
compgen -v P | grep -E '^PATH|PWD' | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -e with global/local exported vars
================================================================================

export v1_global=0
f() {
  local v2_local=0
  export v2_local
  compgen -e v
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -e on known, but unexported, var
================================================================================

unexported=0
compgen -e unexported

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -e on unknown var
================================================================================

compgen -e __nonexistent__

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -e P
================================================================================

cd > /dev/null  # for some reason in bash, this makes PIPESTATUS appear!
compgen -e P | grep -E '^PATH|PWD' | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen with actions: function / variable / file
================================================================================

mkdir -p $TMP/compgen2
touch $TMP/compgen2/{PA,Q}_FILE
cd $TMP/compgen2  # depends on previous test above!
PA_FUNC() { echo P; }
Q_FUNC() { echo Q; }
compgen -A function -A variable -A file PA

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen with actions: alias, setopt
================================================================================

alias v_alias='ls'
alias v_alias2='ls'
alias a1='ls'
compgen -A alias -A setopt v

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen with actions: shopt
================================================================================

compgen -A shopt -P [ -S ] nu

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen with action and suffix: helptopic
================================================================================

compgen -A helptopic -S ___ fal

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A directory
================================================================================

cd $REPO_ROOT
compgen -A directory c | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A file
================================================================================

cd $REPO_ROOT
compgen -A file o | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A user
================================================================================

# no assertion because this isn't hermetic
compgen -A user

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A command completes external commands
================================================================================

# NOTE: this test isn't hermetic
compgen -A command xarg | uniq
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A command completes functions and aliases
================================================================================

our_func() { echo ; }
our_func2() { echo ; }
alias our_alias=foo

compgen -A command our_
echo status=$?

# Introduce another function.  Note that we're missing test coverage for
# 'complete', i.e. bug #1064.
our_func3() { echo ; }

compgen -A command our_
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A command completes builtins and keywords
================================================================================

compgen -A command eva
echo status=$?
compgen -A command whil
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -k shows the same keywords as bash
================================================================================


# bash adds ]] and } and coproc

# Use bash as an oracle
bash -c 'compgen -k' | sort > bash.txt

# osh vs. bash, or bash vs. bash
$SH -c 'compgen -k' | sort > this-shell.txt

#comm bash.txt this-shell.txt

# show lines in both files
comm -12 bash.txt this-shell.txt | egrep -v 'coproc|select'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -k shows Oils keywords too
================================================================================


# YSH has a superset of keywords:
# const var
# setvar setglobal
# proc func typed
# call =   # hm = is not here

compgen -k | sort | egrep '^(const|var|setvar|setglobal|proc|func|typed|call|=)$'
echo --

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -k completes reserved shell keywords
================================================================================

compgen -k do | sort
echo status=$?
compgen -k el | sort
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: -o filenames and -o nospace have no effect with compgen
================================================================================

# they are POSTPROCESSING.
compgen -o filenames -o nospace -W 'bin build'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: -o plusdirs and -o dirnames with compgen
================================================================================

cd $REPO_ROOT
compgen -o plusdirs -W 'a b1 b2' b | sort
echo ---
compgen -o dirnames b | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -o default completes files and dirs
================================================================================

cd $REPO_ROOT
compgen -o default spec/t | sort

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen doesn't respect -X for user-defined functions
================================================================================

# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
    $SH --rcfile /dev/null -i -c '
shopt -s extglob
fun() {
  COMPREPLY=(one two three bin)
}
compgen -X "@(two|bin)" -F fun
echo --
compgen -X "!@(two|bin)" -F fun
'
esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -W words -X filter
================================================================================

# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
      $SH --rcfile /dev/null -i -c 'shopt -s extglob; compgen -X "@(two|bin)" -W "one two three bin"'
esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -f -X filter -- $cur
================================================================================

cd $TMP
touch spam.py spam.sh
compgen -f -- sp | sort
echo --
# WORKAROUND: wrap in bash -i -c because non-interactive bash behaves
# differently!
case $SH in
  *bash|*osh)
      $SH --rcfile /dev/null -i -c 'shopt -s extglob; compgen -f -X "!*.@(py)" -- sp'
esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen doesn't need shell quoting
================================================================================

# There is an obsolete comment in bash_completion that claims the opposite.
cd $TMP
touch 'foo bar'
touch "foo'bar"
compgen -f "foo b"
compgen -f "foo'"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -W 'one two three'
================================================================================

cd $REPO_ROOT
compgen -W 'one two three'
echo --
compgen -W 'v1 v2 three' -A directory v
echo --
compgen -A directory -W 'v1 v2 three' v  # order doesn't matter

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -W evaluates code in $()
================================================================================

IFS=':%'
compgen -W '$(echo "spam:eggs%ham cheese")'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -W uses IFS, and delimiters are escaped with \
================================================================================

IFS=':%'
compgen -W 'spam:eggs%ham cheese\:colon'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: Parse errors for compgen -W and complete -W
================================================================================

# bash doesn't detect as many errors because it lacks static parsing.
compgen -W '${'
echo status=$?
complete -W '${' foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: Runtime errors for compgen -W
================================================================================

compgen -W 'foo $(( 1 / 0 )) bar'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: Runtime errors for compgen -F func
================================================================================

_foo() {
  COMPREPLY=( foo bar )
  COMPREPLY+=( $(( 1 / 0 )) )  # FATAL, but we still have candidates
}
compgen -F _foo foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -W '' cmd is not a usage error
================================================================================

# Bug fix due to '' being falsey in Python
compgen -W '' -- foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -A builtin
================================================================================

compgen -A builtin g

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: complete -C vs. compgen -C
================================================================================


f() { echo foo; echo bar; }

# Bash prints warnings: -C option may not work as you expect
#                       -F option may not work as you expect
#
# https://unix.stackexchange.com/questions/117987/compgen-warning-c-option-not-working-as-i-expected
#
# compexport fixes this problem, because it invokves ShellFuncAction, whcih
# sets COMP_ARGV, COMP_WORDS, etc.
#
# Should we print a warning?

compgen -C f b
echo compgen=$?

complete -C f b
echo complete=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compadjust with empty COMP_ARGV
================================================================================

case $SH in bash) exit ;; esac

COMP_ARGV=()
compadjust words
argv.py "${words[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compadjust with sparse COMP_ARGV
================================================================================

case $SH in bash) exit ;; esac

COMP_ARGV=({0..9})
unset -v 'COMP_ARGV['{1,3,4,6,7,8}']'
compadjust words
argv.py "${words[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-completion.test.sh: compgen -F with scalar COMPREPLY
================================================================================


_comp_cmd_test() {
  unset -v COMPREPLY
  COMPREPLY=hello
}
compgen -F _comp_cmd_test

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: pushd/popd
================================================================================

set -o errexit
cd /
pushd /tmp
echo -n pwd=; pwd
popd
echo -n pwd=; pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: pushd usage
================================================================================

pushd -z
echo status=$?
pushd /tmp >/dev/null
echo status=$?
pushd -- /tmp >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: popd usage error
================================================================================

pushd / >/dev/null
popd zzz
echo status=$?

popd -- >/dev/null
echo status=$?

popd -z
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: popd returns error on empty directory stack
================================================================================

message=$(popd 2>&1)
echo $?
echo "$message" | grep -o "directory stack"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: cd replaces the lowest entry on the directory stack!
================================================================================


# stable temp dir
dir=/tmp/oils-spec/builtin-dirs

mkdir -p $dir
cd $dir

pushd /tmp >/dev/null
echo pushd=$?

dirs

cd /
echo cd=$?

dirs

popd >/dev/null
echo popd=$?

popd >/dev/null
echo popd=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs builtin
================================================================================

cd /
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs -c to clear the stack
================================================================================

set -o errexit
cd /
pushd /tmp >/dev/null  # zsh pushd doesn't print anything, but bash does
echo --
dirs
dirs -c
echo --
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs -v to print numbered stack, one entry per line
================================================================================

set -o errexit
cd /
pushd /tmp >/dev/null
echo --
dirs -v
pushd /dev >/dev/null
echo --
dirs -v

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs -p to print one entry per line
================================================================================

set -o errexit
cd /
pushd /tmp >/dev/null
echo --
dirs -p
pushd /dev >/dev/null
echo --
dirs -p

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs -l to print in long format, no tilde prefix
================================================================================

# Can't use the OSH test harness for this because
# /home/<username> may be included in a path.
cd /
HOME=/tmp
mkdir -p $HOME/oil_test
pushd $HOME/oil_test >/dev/null
dirs
dirs -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs to print using tilde-prefix format
================================================================================

cd /
HOME=/tmp
mkdir -p $HOME/oil_test
pushd $HOME/oil_test >/dev/null
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs test converting true home directory to tilde
================================================================================

cd /
HOME=/tmp
mkdir -p $HOME/oil_test/$HOME
pushd $HOME/oil_test/$HOME >/dev/null
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs don't convert to tilde when $HOME is substring
================================================================================

cd /
mkdir -p /tmp/oil_test
mkdir -p /tmp/oil_tests
HOME=/tmp/oil_test
pushd /tmp/oil_tests
dirs

#### dirs tilde test when $HOME is exactly $PWD
cd /
mkdir -p /tmp/oil_test
HOME=/tmp/oil_test
pushd $HOME
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs test of path alias `..`
================================================================================

cd /tmp
pushd .. >/dev/null
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs test of path alias `.`
================================================================================

cd /tmp
pushd . >/dev/null
dirs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: pushd does not take more than one argument
================================================================================

pushd . . >/dev/null || echo too many args!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-dirs.test.sh: dirs does not take arguments
================================================================================

dirs a || echo failed
dirs -l a || echo failed

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo dashes
================================================================================

echo -
echo --
echo ---

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo backslashes
================================================================================

echo \\
echo '\'
echo '\\'
echo "\\"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e backslashes
================================================================================

echo -e \\
echo -e '\'
echo -e '\\'
echo -e "\\"
echo

# backslash at end of line
echo -e '\
line2'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -en
================================================================================

echo -en 'abc\ndef\n'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -ez (invalid flag)
================================================================================

# bash differs from the other three shells, but its behavior is possibly more
# sensible, if you're going to ignore the error.  It doesn't make sense for
# the 'e' to mean 2 different things simultaneously: flag and literal to be
# printed.
echo -ez 'abc\n'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with embedded newline
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'foo
bar'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e line continuation
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'foo\
bar'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with C escapes
================================================================================

# https://www.gnu.org/software/bash/manual/bashref.html#Bourne-Shell-Builtins
# not sure why \c is like NUL?
# zsh doesn't allow \E for some reason.
echo -e '\a\b\d\e\f'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with whitespace C escapes
================================================================================

echo -e '\n\r\t\v'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \0
================================================================================

echo -e 'ab\0cd'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \c stops processing input
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags xy  'ab\cde'  'zzz'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with hex escape
================================================================================

echo -e 'abcd\x65f'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with octal escape
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\044e'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with 4 digit unicode escape
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\u0065f'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo -e with 8 digit unicode escape
================================================================================

flags='-e'
case $SH in dash) flags='' ;; esac

echo $flags 'abcd\U00000065f'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \0377 is the highest octal byte
================================================================================

echo -en '\03777' | od -A n -t x1 | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \0400 is one more than the highest octal byte
================================================================================

# It is 256 % 256 which gets interpreted as a NUL byte.
echo -en '\04000' | od -A n -t x1 | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \0777 is out of range
================================================================================

flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\0777' | od -A n -t x1 | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: incomplete hex escape
================================================================================

echo -en 'abcd\x6' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \x
================================================================================

# I consider mksh and zsh a bug because \x is not an escape
echo -e '\x' '\xg' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: incomplete octal escape
================================================================================

flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags 'abcd\04' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: incomplete unicode escape
================================================================================

echo -en 'abcd\u006' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \u6
================================================================================

flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\u6' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: \0 \1 \8
================================================================================

# \0 is special, but \1 isn't in bash
# \1 is special in dash!  geez
flags='-en'
case $SH in dash) flags='-n' ;; esac

echo $flags '\0' '\1' '\8' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-echo.test.sh: echo to redirected directory is an error
================================================================================

mkdir -p dir

echo foo > ./dir
echo status=$?
printf foo > ./dir
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Eval
================================================================================

eval "a=3"
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: eval accepts/ignores --
================================================================================

eval -- echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: eval usage
================================================================================

eval -
echo $?
eval -z
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: eval string with 'break continue return error'
================================================================================


set -e

sh_func_that_evals() {
  local code_str=$1
  for i in 1 2; do
    echo $i
    eval "$code_str"
  done
  echo 'end func'
}

for code_str in break continue return false; do
  echo "--- $code_str"
  sh_func_that_evals "$code_str"
done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: exit within eval (regression)
================================================================================

eval 'exit 42'
echo 'should not get here'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: exit within source (regression)
================================================================================

cd $TMP
echo 'exit 42' > lib.sh
. ./lib.sh
echo 'should not get here'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source
================================================================================

lib=$TMP/spec-test-lib.sh
echo 'LIBVAR=libvar' > $lib
. $lib  # dash doesn't have source
echo $LIBVAR

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source accepts/ignores --
================================================================================

echo 'echo foo' > $TMP/foo.sh
source -- $TMP/foo.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source nonexistent
================================================================================

source /nonexistent/path
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source with no arguments
================================================================================

source
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source with arguments
================================================================================

. $REPO_ROOT/spec/testdata/show-argv.sh foo bar  # dash doesn't have source

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source from a function, mutating argv and defining a local var
================================================================================

f() {
  . $REPO_ROOT/spec/testdata/source-argv.sh              # no argv
  . $REPO_ROOT/spec/testdata/source-argv.sh args to src  # new argv
  echo $@
  echo foo=$foo  # defined in source-argv.sh
}
f args to func
echo foo=$foo  # not defined

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Source with syntax error
================================================================================

# TODO: We should probably use dash behavior of a fatal error.
# Although set-o errexit handles this.  We don't want to break the invariant
# that a builtin like 'source' behaves like an external program.  An external
# program can't halt the shell!
echo 'echo >' > $TMP/syntax-error.sh
. $TMP/syntax-error.sh
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Eval with syntax error
================================================================================

eval 'echo >'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Eval in does tilde expansion
================================================================================


x="~"
eval y="$x"  # scalar
test "$x" = "$y" || echo FALSE
[[ $x == /* ]] || echo FALSE  # doesn't start with /
[[ $y == /* ]] && echo TRUE

#argv "$x" "$y"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: Eval in bash does tilde expansion in array
================================================================================


# the "make" plugin in bash-completion relies on this?  wtf?
x="~"

# UPSTREAM CODE

#eval array=( "$x" )

# FIXED CODE -- proper quoting.

eval 'array=(' "$x" ')'  # array

test "$x" = "${array[0]}" || echo FALSE
[[ $x == /* ]] || echo FALSE  # doesn't start with /
[[ "${array[0]}" == /* ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source works for files in current directory (bash only)
================================================================================

cd $TMP
echo "echo current dir" > cmd
. cmd
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source looks in PATH for files
================================================================================

mkdir -p dir
echo "echo hi" > dir/cmd
PATH="dir:$PATH"
. cmd
rm dir/cmd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source finds files in PATH before current dir
================================================================================

cd $TMP
mkdir -p dir
echo "echo path" > dir/cmd
echo "echo current dir" > cmd
PATH="dir:$PATH"
. cmd
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source works for files in subdirectory
================================================================================

mkdir -p dir
echo "echo path" > dir/cmd
. dir/cmd
rm dir/cmd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: source doesn't crash when targeting a directory
================================================================================

cd $TMP
mkdir -p dir
. ./dir/
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-eval-source.test.sh: sourcing along PATH should ignore directories
================================================================================


mkdir -p _tmp/shell
mkdir -p _tmp/dir/hello.sh
printf 'echo hi' >_tmp/shell/hello.sh

DIR=$PWD/_tmp/dir
SHELL=$PWD/_tmp/shell

# Should find the file hello.sh right away and source it
PATH="$SHELL:$PATH" . hello.sh
echo status=$?

# Should fail because hello.sh cannot be found
PATH="$DIR:$SHELL:$PATH" . hello.sh
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l lists history commands
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -ln lists history commands without numbers
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -ln
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -lr lists history commands in reverse order
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lr
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -lnr lists history commands without numbers in reverse order
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lnr
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l lists history commands with default page size
================================================================================

printf "echo %s\n" {1..16} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l [first] where first is an index
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l [first] where first is an offset from current command
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l -3
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l [first] [last] where first and last are indexes
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 2 3
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l [first] [last] where first and last are offsets from current command
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l -3 -2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l [first] [last] where first and last are reversed indexes
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -l 3 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -lr [first] [last] where first and last are reversed indexes does not undo reverse
================================================================================

printf "echo %s\n" {1..3} > tmp

echo '
HISTFILE=tmp
history -c
history -r

fc -lr 3 2
' | $SH --norc -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc ignores too many args
================================================================================

fc -l 0 1 2 || echo too many args!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc errors out on too many args with strict_arg_parse
================================================================================

shopt -s strict_arg_parse || true
fc -l 0 1 2 || echo too many args!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-fc.test.sh: fc -l when no history is present
================================================================================

fc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts empty
================================================================================

set -- 
getopts 'a:' opt
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts sees unknown arg
================================================================================

set -- -Z
getopts 'a:' opt
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts three invocations
================================================================================

set -- -h -c foo
getopts 'hc:' opt
echo status=$? opt=$opt
getopts 'hc:' opt
echo status=$? opt=$opt
getopts 'hc:' opt
echo status=$? opt=$opt

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts resets OPTARG
================================================================================

set -- -c foo -h
getopts 'hc:' opt
echo status=$? opt=$opt OPTARG=$OPTARG
getopts 'hc:' opt
echo status=$? opt=$opt OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTARG is empty (not unset) after parsing a flag doesn't take an arg
================================================================================


set -u
getopts 'ab' name '-a'
echo name=$name
echo OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: Basic getopts invocation
================================================================================

set -- -h -c foo x y z
FLAG_h=0
FLAG_c=''
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
shift $(( OPTIND - 1 ))
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts with invalid variable name
================================================================================

set -- -c foo -h
getopts 'hc:' opt-
echo status=$? opt=$opt OPTARG=$OPTARG OPTIND=$OPTIND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts with invalid flag
================================================================================

set -- -h -x
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts with with -
================================================================================

set -- -h -
echo "$@"
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts missing required argument
================================================================================

set -- -h -c
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
    '?') echo ERROR $OPTIND; exit 2; ;;
  esac
done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts doesn't look for flags after args
================================================================================

set -- x -h -c y
FLAG_h=0
FLAG_c=''
while getopts "hc:" opt; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
shift $(( OPTIND - 1 ))
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts with explicit args
================================================================================

# NOTE: Alpine doesn't appear to use this, but bash-completion does.
FLAG_h=0
FLAG_c=''
arg=''
set -- A B C
while getopts "hc:" opt -h -c foo x y z; do
  case $opt in
    h) FLAG_h=1 ;;
    c) FLAG_c="$OPTARG" ;;
  esac
done
echo h=$FLAG_h c=$FLAG_c optind=$OPTIND argv=$@

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTIND
================================================================================

echo $OPTIND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTIND after multiple getopts with same spec
================================================================================

while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set -- -h -c foo x y z
while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set --
while getopts "hc:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTIND after multiple getopts with different spec
================================================================================

# Wow this is poorly specified!  A fundamental design problem with the global
# variable OPTIND.
set -- -a
while getopts "ab:" opt; do
  echo '.'
done
echo OPTIND=$OPTIND

set -- -c -d -e foo
while getopts "cde:" opt; do
  echo '-'
done
echo OPTIND=$OPTIND

set -- -f
while getopts "f:" opt; do
  echo '_'
done
echo OPTIND=$OPTIND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTIND narrowed down
================================================================================

FLAG_a=
FLAG_b=
FLAG_c=
FLAG_d=
FLAG_e=
set -- -a
while getopts "ab:" opt; do
  case $opt in
    a) FLAG_a=1 ;;
    b) FLAG_b="$OPTARG" ;;
  esac
done
# Bash doesn't reset OPTIND!  It skips over c!  mksh at least warns about this!
# You have to reset OPTIND yourself.

set -- -c -d -e E
while getopts "cde:" opt; do
  case $opt in
    c) FLAG_c=1 ;;
    d) FLAG_d=1 ;;
    e) FLAG_e="$OPTARG" ;;
  esac
done

echo a=$FLAG_a b=$FLAG_b c=$FLAG_c d=$FLAG_d e=$FLAG_e

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: Getopts parses the function's arguments
================================================================================

FLAG_h=0
FLAG_c=''
myfunc() {
  while getopts "hc:" opt; do
    case $opt in
      h) FLAG_h=1 ;;
      c) FLAG_c="$OPTARG" ;;
    esac
  done
}
set -- -h -c foo x y z
myfunc -c bar
echo h=$FLAG_h c=$FLAG_c opt=$opt optind=$OPTIND argv=$@

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: Local OPTIND
================================================================================

# minimal test case extracted from bash-completion
min() {
  local OPTIND=1

  while getopts "n:e:o:i:s" flag "$@"; do
    echo "loop $OPTIND";
  done
}
min -s

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: two flags: -ab
================================================================================

getopts "ab" opt -ab
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab" opt -ab
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: flag and arg: -c10
================================================================================

getopts "c:" opt -c10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "c:" opt -c10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: More Smooshing 1
================================================================================

getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "ab:c:" opt -ab hi -c hello
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: More Smooshing 2
================================================================================

getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG
getopts "abc:" opt -abc10
echo OPTIND=$OPTIND opt=$opt OPTARG=$OPTARG

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: OPTIND should be >= 1 (regression)
================================================================================

OPTIND=-1
getopts a: foo
echo status=$?

OPTIND=0
getopts a: foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts bug #1523
================================================================================


$SH $REPO_ROOT/spec/testdata/getopts-1523.sh -abcdef -abcde

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: More regression for #1523
================================================================================


$SH $REPO_ROOT/spec/testdata/getopts-1523.sh -abcdef -xyz

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts silent error reporting - invalid option
================================================================================

# Leading : in optspec enables silent mode: OPTARG=option char, no error msg
set -- -Z
getopts ':a:' opt 2>&1
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts silent error reporting - missing required argument
================================================================================

# Silent mode returns ':' and sets OPTARG to option char
set -- -a
getopts ':a:' opt 2>&1
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts normal mode - invalid option (compare with silent)
================================================================================

# Normal mode: OPTARG is empty, prints error message
set -- -Z
getopts 'a:' opt 2>/dev/null
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts normal mode - missing required argument (compare with silent)
================================================================================

# Normal mode returns '?', OPTARG is empty
set -- -a
getopts 'a:' opt 2>/dev/null
echo "status=$? opt=$opt OPTARG=$OPTARG"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts handles '--' #2579
================================================================================

set -- "-a" "--"
while getopts "a" name; do
        case "$name" in
                a)
                        echo "a"
                        ;;
                ?)
                        echo "?"
                        ;;
        esac
done
echo "name=$name"
echo "$OPTIND"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-getopts.test.sh: getopts leaves all args after '--' as operands #2579
================================================================================

set -- "-a" "--" "-c" "operand"
while getopts "a" name; do
    case "$name" in
        a)
            echo "a"
            ;;
        c)
            echo "c"
            ;;
        ?)
            echo "?"
            ;;
    esac
done
shift $((OPTIND - 1))
echo "$#"
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -a
================================================================================

rm -f tmp

echo '
history -c

HISTFILE=tmp
echo 1
history -a
cat tmp

echo 2

cat tmp
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -w writes out the in-memory history to the history file
================================================================================


cd $TMP

# Populate a history file with a command to be overwritten
echo 'cmd old' > tmp
HISTFILE=tmp
history -c
echo 'cmd new' > /dev/null
history -w # Overwrite history file

# Verify that old command is gone
grep 'old' tmp > /dev/null
echo "found=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -r reads from the history file, and appends it to the current history
================================================================================


cd $TMP
printf "cmd orig%s\n" {1..10} > tmp
HISTFILE=tmp

history -c

history -r
history -r

history | grep orig | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -n reads *new* commands from the history file, and appends them to the current history
================================================================================

# NB: Based on line ranges, not contents

cd $TMP

printf "cmd orig%s\n" {1..10} > tmp1
cp tmp1 tmp2
printf "cmd new%s\n" {1..10} >> tmp2

history -c
HISTFILE=tmp1 history -r
HISTFILE=tmp2 history -n

history | grep orig | wc -l
history | grep new | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -c clears in-memory history
================================================================================


$SH --norc -i <<'EOF'
echo 'foo' > /dev/null
echo 'bar' > /dev/null
history -c 
history | wc -l
EOF

case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -d to delete 1 item
================================================================================


cd $TMP
HISTFILE=tmp
printf "cmd orig%s\n" {1..3} > tmp
history -c
history -r
history -d 1
history | grep orig1 > /dev/null
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history -d to delete history from end
================================================================================

# bash 4 doesn't support negative indices or ranges

rm -f myhist
export HISTFILE=myhist

$SH --norc -i <<'EOF'

echo 42
echo 43
echo 44

history -a

history -d 1
echo status=$?

# Invalid integers
history -d -1
echo status=$?
history -d -2
echo status=$?
history -d 99
echo status=$?

case $SH in bash*) echo '^D' ;; esac

EOF

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTFILE is defined initially
================================================================================

echo '
if test -n $HISTFILE; then echo exists; fi
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTFILE must point to a file
================================================================================


rm -f _tmp/does-not-exist

echo '
HISTFILE=_tmp/does-not-exist
history -r
echo status=$?
' | $SH -i

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTFILE set to array
================================================================================


echo '
HISTFILE=(a b c)
history -a
echo status=$?
' | $SH -i

case $SH in bash) echo '^D' ;; esac

# note that bash actually writes the file 'a', since that's ${HISTFILE[0]} 

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTFILE unset
================================================================================


echo '
unset HISTFILE
history -a
echo status=$?
' | $SH -i

case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: history usage
================================================================================


history not-a-number
echo status=$?

history 3 too-many
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTSIZE shrinks the in-memory history when changed
================================================================================


cd $TMP
printf "cmd %s\n" {1..10} > tmp
HISTFILE=tmp
history -c
history -r
history | wc -l
HISTSIZE=5
history | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: HISTFILESIZE shrinks the history file when changed
================================================================================


cd $TMP
printf "cmd %s\n" {1..10} > tmp
HISTFILE=tmp
HISTFILESIZE=5
cat tmp | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: recording history can be toggled with set -o/+o history
================================================================================


cd $TMP
printf "echo %s\n" {1..3} > tmp
HISTFILE=tmp $SH -i <<'EOF'
set +o history
echo "not recorded" >> /dev/null
set -o history
echo "recorded" >> /dev/null
EOF

case $SH in bash) echo '^D' ;; esac

grep "not recorded" tmp >> /dev/null
echo status=$?
grep "recorded" tmp >> /dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: shopt histappend toggle check
================================================================================


shopt -s histappend
echo status=$?
shopt -p histappend
shopt -u histappend
echo status=$?
shopt -p histappend

# match osh's behaviour of echoing ^D for EOF
case $SH in bash) echo '^D' ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-history.test.sh: shopt histappend - osh ignores shopt and appends, bash sometimes overwrites
================================================================================

# When set, bash always appends when exiting, no matter what. 
# When unset, bash will append anyway as long the # of new commands < the hist length
# Either way, the file is truncated to HISTFILESIZE afterwards.
# osh always appends

cd $TMP 

export HISTSIZE=10
export HISTFILESIZE=1000
export HISTFILE=tmp

histappend_test() {
  local histopt
  if [[ "$1" == true ]]; then
    histopt='shopt -s histappend'
  else
    histopt='shopt -u histappend'
  fi

  printf "cmd orig%s\n" {1..10} > tmp

  $SH --norc -i <<EOF
  HISTSIZE=2 # Stifle the history down to 2 commands
  $histopt
  # Now run >2 commands to trigger bash's overwrite behavior
  echo cmd new1 > /dev/null
  echo cmd new2 > /dev/null
  echo cmd new3 > /dev/null
EOF

  case $SH in bash) echo '^D' ;; esac
}

# If we force histappend, bash won't overwrite the history file
histappend_test true
grep "orig" tmp > /dev/null
echo status=$?

# If we don't force histappend, bash will overwrite the history file when the number of cmds exceeds HISTSIZE
histappend_test false
grep "orig" tmp > /dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -15 kills the process with SIGTERM
================================================================================

case $SH in mksh) exit ;; esac  # mksh is flaky

sleep 0.1 &
pid=$!
kill -15 $pid
echo kill=$?

wait $pid
echo wait=$?  # 143 is 128 + SIGTERM

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -KILL kills the process with SIGKILL
================================================================================

sleep 0.1 & 
pid=$!
kill -KILL $pid 
echo kill=$?

wait $pid
echo wait=$?  # 137 is 128 + SIGKILL

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -n 9 specifies the signal number
================================================================================

#case $SH in mksh|dash) exit ;; esac

sleep 0.1 &
pid=$!
kill -n 9 $pid
echo kill=$?

wait $pid
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -s TERM specifies the signal name
================================================================================

sleep 0.1 &
pid=$!
kill -s TERM $pid
echo kill=$?

wait $pid
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -terM -SigterM isn't case sensitive
================================================================================

case $SH in mksh|dash|zsh) exit ;; esac

sleep 0.1 &
pid=$!
kill -SigterM $pid
echo kill=$?
wait $pid
echo wait=$?

sleep 0.1 &
pid=$!
kill -terM $pid
echo kill=$?
wait $pid
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill HUP pid gives the correct error
================================================================================

case $SH in dash) exit ;; esac
sleep 0.1 &
builtin kill HUP $pid
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l shows signals
================================================================================

case $SH in dash) exit ;; esac

# Check if at least the HUP flag is reported.  The output format of all shells
# is different and the available signals may depend on your environment

builtin kill -l | grep HUP > /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -L also shows signals
================================================================================

case $SH in mksh|dash|zsh) exit ;; esac

builtin kill -L | grep HUP > /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l 10 TERM translates between names and numbers
================================================================================

case $SH in mksh|dash) exit ;; esac

builtin kill -l 10 11 12
echo status=$?
echo

builtin kill -l SIGUSR1 SIGSEGV USR2
echo status=$?
echo

# mixed kind
builtin kill -l 10 SIGSEGV 12
echo status=$?
echo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -L checks for invalid input
================================================================================

case $SH in mksh|dash) exit ;; esac

builtin kill -L 10 BAD 12
echo status=$?
echo

builtin kill -L USR1 9999 USR2
echo status=$?
echo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l with exit code
================================================================================

kill -l 134 # 128 + 6 (ABRT)

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l with 128 is invalid
================================================================================

kill -l 128
if [ $? -ne 0 ]; then
    echo "invalid"
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l 0 returns EXIT
================================================================================

kill -l 0

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -l 0 INT lists both signals
================================================================================

kill -l 0 INT

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -9999 is an invalid signal
================================================================================

case $SH in dash)  exit ;; esac
sleep 0.1 &
pid=$!
kill -9999 $pid > /dev/null
echo kill=$?

wait $pid
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -15 %% kills current job
================================================================================

#case $SH in mksh|dash) exit ;; esac

sleep 0.5 &
pid=$!
kill -15 %%
echo kill=$?

wait %%
echo wait=$?

# no such job
wait %%
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill -15 %- kills previous job
================================================================================

#case $SH in mksh|dash) exit ;; esac

sleep 0.1 &  # previous job
sleep 0.2 &  # current job

kill -15 %-
echo kill=$?

wait %-
echo wait=$?

# what does bash define here as the previous job?  May be a bug
#wait %-
#echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill multiple pids at once
================================================================================

sleep 0.1 &
pid1=$!
sleep 0.1 &
pid2=$!
sleep 0.1 &
pid3=$!

kill $pid1 $pid2 $pid3
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: kill pid and job at once
================================================================================

sleep 0.1 &
pid=$!
sleep 0.1 &
kill %2 $pid
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-kill.test.sh: Numeric signal out of range - OSH may send it anyway
================================================================================


sleep 0.1 &

# OSH doesn't validate this, but that could be useful for non-portable signals,
# which we don't have a name for.

kill -s 9999 %%
echo kill=$?

wait
echo wait=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: builtin declare a=(x y) is allowed
================================================================================

case $SH in dash|zsh|mksh|ash) exit ;; esac

$SH -c 'declare a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi

$SH -c 'builtin declare a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi

$SH -c 'builtin declare -a a=(x y); declare -p a'
if test $? -ne 0; then
  echo 'fail'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: command export,readonly
================================================================================

case $SH in zsh) exit ;; esac

# dash doesn't have declare typeset

command export c=export
echo c=$c

command readonly c=readonly
echo c=$c

echo --

command command export cc=export
echo cc=$cc

command command readonly cc=readonly
echo cc=$cc

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: command local
================================================================================


f() {
  command local s=local
  echo s=$s
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: export, builtin export
================================================================================


x='a b'

export y=$x
echo $y

builtin export z=$x
echo $z

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: \builtin declare - ble.sh relies on it
================================================================================

case $SH in dash|mksh|ash) exit ;; esac

x='a b'

builtin declare c=$x
echo $c

\builtin declare d=$x
echo $d

'builtin' declare e=$x
echo $e

b=builtin
$b declare f=$x
echo $f

b=b
${b}uiltin declare g=$x
echo $g

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: \command readonly - similar issue
================================================================================

case $SH in zsh) exit ;; esac

# \command readonly is equivalent to \builtin declare
# except dash implements it

x='a b'

readonly b=$x
echo $b

command readonly c=$x
echo $c

\command readonly d=$x
echo $d

'command' readonly e=$x
echo $e

# The issue here is that we have a heuristic in EvalWordSequence2:
# fs len(part_vals) == 1

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: Dynamic $c readonly - bash and dash change behavior, mksh bug
================================================================================

case $SH in zsh) exit ;; esac

x='a b'

z=command
$z readonly c=$x
echo $c

z=c
${z}ommand readonly d=$x
echo $d

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: static builtin command ASSIGN, command builtin ASSIGN
================================================================================

case $SH in dash|ash|zsh) exit ;; esac

# dash doesn't have declare typeset

builtin command export bc=export
echo bc=$bc

builtin command readonly bc=readonly
echo bc=$bc

echo --

command builtin export cb=export
echo cb=$cb

command builtin readonly cb=readonly
echo cb=$cb

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: dynamic builtin command ASSIGN, command builtin ASSIGN
================================================================================

case $SH in dash|ash|zsh) exit ;; esac

b=builtin
c=command
e=export
r=readonly

$b $c export bc=export
echo bc=$bc

$b $c readonly bc=readonly
echo bc=$bc

echo --

$c $b export cb=export
echo cb=$cb

$c $b readonly cb=readonly
echo cb=$cb

echo --

$b $c $e bce=export
echo bce=$bce

$b $c $r bcr=readonly
echo bcr=$bcr

echo --

$c $b $e cbe=export
echo cbe=$cbe

$c $b $r cbr=readonly
echo cbr=$cbr

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: builtin typeset, export,readonly
================================================================================

case $SH in dash|ash) exit ;; esac

builtin typeset s=typeset
echo s=$s

builtin export s=export
echo s=$s

builtin readonly s=readonly
echo s=$s

echo --

builtin builtin typeset s2=typeset
echo s2=$s2

builtin builtin export s2=export
echo s2=$s2

builtin builtin readonly s2=readonly
echo s2=$s2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta-assign.test.sh: builtin declare,local
================================================================================

case $SH in dash|ash|mksh) exit ;; esac

builtin declare s=declare
echo s=$s

f() {
  builtin local s=local
  echo s=$s
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -v
================================================================================

myfunc() { echo x; }
command -v echo
echo $?

command -v myfunc
echo $?

command -v nonexistent  # doesn't print anything
echo nonexistent=$?

command -v ''  # BUG FIX, shouldn't succeed
echo empty=$?

command -v for
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -v executable, builtin
================================================================================


#command -v grep ls

command -v grep | egrep -o '/[^/]+$'
command -v ls | egrep -o '/[^/]+$'
echo

command -v true
command -v eval

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -v with multiple names
================================================================================

# ALL FOUR SHELLS behave differently here!
#
# bash chooses to swallow the error!  We agree with zsh if ANY word lookup
# fails, then the whole thing fails.

myfunc() { echo x; }
command -v echo myfunc ZZZ for
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -v doesn't find non-executable file
================================================================================

# PATH resolution is different

mkdir -p _tmp
PATH="_tmp:$PATH"
touch _tmp/non-executable _tmp/executable
chmod +x _tmp/executable

command -v _tmp/non-executable
echo status=$?

command -v _tmp/executable
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -v doesn't find executable dir
================================================================================


mkdir -p _tmp
PATH="_tmp:$PATH"
mkdir _tmp/cat

command -v _tmp/cat
echo status=$?
command -v cat
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -V
================================================================================

myfunc() { echo x; }

shopt -s expand_aliases
alias ll='ls -l'

backtick=\`
command -V ll | sed "s/$backtick/'/g"
echo status=$?

command -V echo
echo status=$?

# Paper over insignificant difference
command -V myfunc | sed 's/shell function/function/'
echo status=$?

command -V nonexistent  # doesn't print anything
echo status=$?

command -V for
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -V nonexistent
================================================================================

command -V nonexistent 2>err.txt
echo status=$?
fgrep -o 'nonexistent: not found' err.txt || true

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command skips function lookup
================================================================================

seq() {
  echo "$@"
}
command  # no-op
seq 3
command seq 3
# subshell shouldn't fork another process (but we don't have a good way of
# testing it)
( command seq 3 )

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command command seq 3
================================================================================

command command seq 3

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command command -v seq
================================================================================

seq() {
  echo 3
}
command command -v seq

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -p (override existing program)
================================================================================

# Tests whether command -p overrides the path
# tr chosen because we need a simple non-builtin
mkdir -p $TMP/bin
echo "echo wrong" > $TMP/bin/tr
chmod +x $TMP/bin/tr
PATH="$TMP/bin:$PATH"
echo aaa | tr "a" "b"
echo aaa | command -p tr "a" "b"
rm $TMP/bin/tr

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -p (hide tool in custom path)
================================================================================

mkdir -p $TMP/bin
echo "echo hello" > $TMP/bin/hello
chmod +x $TMP/bin/hello
export PATH=$TMP/bin
command -p hello

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: command -p (find hidden tool in default path)
================================================================================

export PATH=''
command -p ls

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: $(command type ls)
================================================================================

type() { echo FUNCTION; }
type
s=$(command type echo)
echo $s | grep builtin > /dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: builtin
================================================================================

cd () { echo "hi"; }
cd
builtin cd / && pwd
unset -f cd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: builtin ls not found
================================================================================

builtin ls

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: builtin usage
================================================================================

 
builtin
echo status=$?

builtin --
echo status=$?

builtin -- false
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-meta.test.sh: builtin command echo hi
================================================================================

builtin command echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: history builtin usage
================================================================================

history
echo status=$?
history +5  # hm bash considers this valid
echo status=$?
history -5  # invalid flag
echo status=$?
history f 
echo status=$?
history too many args
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: Print shell strings with weird chars: set and printf %q and ${x@Q}
================================================================================


# bash declare -p will print binary data, which makes this invalid UTF-8!
foo=$(/bin/echo -e 'a\nb\xffc'\'d)

# let's test the easier \x01, which doesn't give bash problems
foo=$(/bin/echo -e 'a\nb\x01c'\'d)

# dash:
#   only supports 'set'; prints it on multiple lines with binary data
#   switches to "'" for single quotes, not \'
# zsh:
#   print binary data all the time, except for printf %q
#   does print $'' strings
# mksh:
#   prints binary data for @Q
#   prints $'' strings

# All are very inconsistent.

case $SH in dash|mksh|zsh) return ;; esac


set | grep -A1 foo

# Will print multi-line and binary data literally!
#declare -p foo

printf 'pf  %q\n' "$foo"

echo '@Q ' ${foo@Q}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: Print shell strings with normal chars: set and printf %q and ${x@Q}
================================================================================


# There are variations on whether quotes are printed

case $SH in dash|zsh) return ;; esac

foo=spam

set | grep -A1 foo

# Will print multi-line and binary data literally!
typeset -p foo

printf 'pf  %q\n' "$foo"

echo '@Q ' ${foo@Q}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: time pipeline
================================================================================

time echo hi | wc -c

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: shift
================================================================================

set -- 1 2 3 4
shift
echo "$@"
shift 2
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: Shifting too far
================================================================================

set -- 1
shift 2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-misc.test.sh: Invalid shift argument
================================================================================

shift ZZZ

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf with no args
================================================================================

printf

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf -v %s
================================================================================

var=foo
printf -v $var %s 'hello there'
argv.py "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf -v %q
================================================================================

val='"quoted" with spaces and \'

# quote 'val' and store it in foo
printf -v foo %q "$val"
# then round trip back to eval
eval "bar=$foo"

# debugging:
#echo foo="$foo"
#echo bar="$bar"
#echo val="$val"

test "$bar" = "$val" && echo OK

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf -v a[1]
================================================================================

a=(a b c)
printf -v 'a[1]' %s 'foo'
echo status=$?
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf -v syntax error
================================================================================

printf -v 'a[' %s 'foo'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: dynamic declare instead of %s
================================================================================

var=foo
declare $var='hello there'
argv.py "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: dynamic declare instead of %q
================================================================================

var=foo
val='"quoted" with spaces and \'
# I think this is bash 4.4 only.
declare $var="${val@Q}"
echo "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf -v dynamic scope
================================================================================

case $SH in mksh|zsh|dash|ash) echo not implemented; exit ;; esac
# OK so printf is like assigning to a var.
# printf -v foo %q "$bar" is like
# foo=${bar@Q}
dollar='dollar'
f() {
  local mylocal=foo
  printf -v dollar %q '$'  # assign foo to a quoted dollar
  printf -v mylocal %q 'mylocal'
  echo dollar=$dollar
  echo mylocal=$mylocal
}
echo dollar=$dollar
echo --
f
echo --
echo dollar=$dollar
echo mylocal=$mylocal

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf with too few arguments
================================================================================

printf -- '-%s-%s-%s-\n' 'a b' 'x y'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf with too many arguments
================================================================================

printf -- '-%s-%s-\n' a b c d e

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf width strings
================================================================================

printf '[%5s]\n' abc
printf '[%-5s]\n' abc

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf integer
================================================================================

printf '%d\n' 42
printf '%i\n' 42  # synonym
printf '%d\n' \'a # if first character is a quote, use character code
printf '%d\n' \"a # double quotes work too
printf '[%5d]\n' 42
printf '[%-5d]\n' 42
printf '[%05d]\n' 42
#printf '[%-05d]\n' 42  # the leading 0 is meaningless
#[42   ]

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6.4d -- "precision" does padding for integers
================================================================================

printf '[%6.4d]\n' 42
printf '[%.4d]\n' 42
printf '[%6.d]\n' 42
echo --
printf '[%6.4d]\n' -42
printf '[%.4d]\n' -42
printf '[%6.d]\n' -42

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6.4x X o
================================================================================

printf '[%6.4x]\n' 42
printf '[%.4x]\n' 42
printf '[%6.x]\n' 42
echo --
printf '[%6.4X]\n' 42
printf '[%.4X]\n' 42
printf '[%6.X]\n' 42
echo --
printf '[%6.4o]\n' 42
printf '[%.4o]\n' 42
printf '[%6.o]\n' 42

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %06d zero padding vs. %6.6d
================================================================================

printf '[%06d]\n' 42
printf '[%06d]\n' -42  # 6 TOTAL
echo --
printf '[%6.6d]\n' 42
printf '[%6.6d]\n' -42  # 6 + 1 for the - sign!!!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %06x %06X %06o
================================================================================

printf '[%06x]\n' 42
printf '[%06X]\n' 42
printf '[%06o]\n' 42

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %06s is no-op
================================================================================

printf '(%6s)\n' 42
printf '(%6s)\n' -42
printf '(%06s)\n' 42
printf '(%06s)\n' -42
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6.4s does both truncation and padding
================================================================================

printf '[%6s]\n' foo
printf '[%6.4s]\n' foo
printf '[%-6.4s]\n' foo
printf '[%6s]\n' spam-eggs
printf '[%6.4s]\n' spam-eggs
printf '[%-6.4s]\n' spam-eggs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6.0s and %0.0s
================================================================================

printf '[%6.0s]\n' foo
printf '[%0.0s]\n' foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6.s and %0.s
================================================================================

printf '[%6.s]\n' foo
printf '[%0.s]\n' foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %*.*s (width/precision from args)
================================================================================

printf '[%*s]\n' 9 hello
printf '[%.*s]\n' 3 hello
printf '[%*.3s]\n' 9 hello
printf '[%9.*s]\n' 3 hello
printf '[%*.*s]\n' 9 3 hello

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: unsigned / octal / hex
================================================================================

printf '[%u]\n' 42
printf '[%o]\n' 42
printf '[%x]\n' 42
printf '[%X]\n' 42
echo

printf '[%X]\n' \'a  # if first character is a quote, use character code
printf '[%X]\n' \'ab # extra chars ignored

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: unsigned / octal / hex big
================================================================================


for big in $(( 1 << 32 )) $(( (1 << 63) - 1 )); do
  printf '[%u]\n' $big
  printf '[%o]\n' $big
  printf '[%x]\n' $big
  printf '[%X]\n' $big
  echo
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: empty string (osh is more strict)
================================================================================

printf '%d\n' ''

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: No char after ' => zero code point
================================================================================


# most shells use 0 here
printf '%d\n' \'
printf '%d\n' \"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Unicode char with '
================================================================================

case $SH in mksh) echo 'weird bug'; exit ;; esac

# the mu character is U+03BC

printf '%x\n' \'
printf '%u\n' \'
printf '%o\n' \'
echo

u3=
# u4=

printf '%x\n' \'$u3
printf '%u\n' \'$u3
printf '%o\n' \'$u3
echo

# mksh DOES respect unicode on the new Debian bookworm.
# but even building the SAME SOURCE from scratch, somehow it doesn't on Ubuntu 8.
# TBH I should probably just upgrade the mksh version.
#
# $ ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# 
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ cat /etc/os-release
# NAME="Ubuntu"
# VERSION="18.04.5 LTS (Bionic Beaver)"
# ID=ubuntu
# ID_LIKE=debian
# PRETTY_NAME="Ubuntu 18.04.5 LTS"
# VERSION_ID="18.04"
# HOME_URL="https://www.ubuntu.com/"
# SUPPORT_URL="https://help.ubuntu.com/"
# BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
# PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
# VERSION_CODENAME=bionic
# UBUNTU_CODENAME=bionic
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ env|egrep 'LC|LANG'
# LANG=en_US.UTF-8
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_CTYPE=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LANG=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=C.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=en_US.UTF-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206
# andy@lenny:~/wedge/oils-for-unix.org/pkg/mksh/R52c$ LC_ALL=en_US.utf-8 ./mksh -c 'printf "%u\n" \"$1' dummy $'\u03bc'
# printf: warning: : character(s) following character constant have been ignored
# 206

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Invalid UTF-8
================================================================================


echo bytes1
not_utf8=$(python2 -c 'print("\xce\xce")')

printf '%x\n' \'$not_utf8
printf '%u\n' \'$not_utf8
printf '%o\n' \'$not_utf8
echo

echo bytes2
not_utf8=$(python2 -c 'print("\xbc\xbc")')
printf '%x\n' \'$not_utf8
printf '%u\n' \'$not_utf8
printf '%o\n' \'$not_utf8
echo

# Copied from data_lang/utf8_test.cc

echo overlong2
overlong2=$(python2 -c 'print("\xC1\x81")')
printf '%x\n' \'$overlong2
printf '%u\n' \'$overlong2
printf '%o\n' \'$overlong2
echo

echo overlong3
overlong3=$(python2 -c 'print("\xE0\x81\x81")')
printf '%x\n' \'$overlong3
printf '%u\n' \'$overlong3
printf '%o\n' \'$overlong3
echo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Too large
================================================================================

case $SH in mksh) echo 'weird bug'; exit ;; esac

echo too large
too_large=$(python2 -c 'print("\xF4\x91\x84\x91")')
printf '%x\n' \'$too_large
printf '%u\n' \'$too_large
printf '%o\n' \'$too_large
echo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: negative numbers with unsigned / octal / hex
================================================================================

printf '[%u]\n' -42
echo status=$?

printf '[%o]\n' -42
echo status=$?

printf '[%x]\n' -42
echo status=$?

printf '[%X]\n' -42
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf floating point (not required, but they all implement it)
================================================================================

printf '[%f]\n' 3.14159
printf '[%.2f]\n' 3.14159
printf '[%8.2f]\n' 3.14159
printf '[%-8.2f]\n' 3.14159
printf '[%-f]\n' 3.14159
printf '[%-f]\n' 3.14

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf floating point with - and 0
================================================================================

printf '[%8.4f]\n' 3.14
printf '[%08.4f]\n' 3.14
printf '[%8.04f]\n' 3.14  # meaning less 0
printf '[%08.04f]\n' 3.14
echo ---
# these all boil down to the same thing.  The -, 8, and 4 are respected, but
# none of the 0 are.
printf '[%-8.4f]\n' 3.14
printf '[%-08.4f]\n' 3.14
printf '[%-8.04f]\n' 3.14
printf '[%-08.04f]\n' 3.14

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf eE fF gG
================================================================================

printf '[%e]\n' 3.14
printf '[%E]\n' 3.14
printf '[%f]\n' 3.14
# bash is the only one that implements %F?  Is it a synonym?
#printf '[%F]\n' 3.14
printf '[%g]\n' 3.14
printf '[%G]\n' 3.14

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf backslash escapes
================================================================================

argv.py "$(printf 'a\tb')"
argv.py "$(printf '\xE2\x98\xA0')"
argv.py "$(printf '\044e')"
argv.py "$(printf '\0377')"  # out of range

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf octal backslash escapes
================================================================================

argv.py "$(printf '\0377')"
argv.py "$(printf '\377')"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf unicode backslash escapes
================================================================================

argv.py "$(printf '\u2620')"
argv.py "$(printf '\U0000065f')"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf invalid backslash escape (is ignored)
================================================================================

printf '[\Z]\n'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf % escapes
================================================================================

printf '[%%]\n'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %c ASCII
================================================================================


printf '%c\n' a
printf '%c\n' ABC
printf '%cZ\n' ABC

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %c unicode - prints the first BYTE of a string - it does not respect UTF-8
================================================================================


# TODO: in YSH, this should be deprecated
case $SH in dash|ash) exit ;; esac

show_bytes() {
  od -A n -t x1
}
twomu=$'\u03bc\u03bc'
printf '[%s]\n' "$twomu"

# Hm this cuts off a UTF-8 character?
printf '%c' "$twomu" | show_bytes

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf invalid format
================================================================================

printf '%z' 42
echo status=$?
printf '%-z' 42
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %q
================================================================================

x='a b'
printf '[%q]\n' "$x"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %6q (width)
================================================================================

# NOTE: coreutils /usr/bin/printf does NOT implement this %6q !!!
x='a b'
printf '[%6q]\n' "$x"
printf '[%1q]\n' "$x"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf negative numbers
================================================================================

printf '[%d] ' -42
echo status=$?
printf '[%i] ' -42
echo status=$?

# extra LEADING space too
printf '[%d] ' ' -42'
echo status=$?
printf '[%i] ' ' -42'
echo status=$?

# extra TRAILING space too
printf '[%d] ' ' -42 '
echo status=$?
printf '[%i] ' ' -42 '
echo status=$?

# extra TRAILING chars
printf '[%d] ' ' -42z'
echo status=$?
printf '[%i] ' ' -42z'
echo status=$?

exit 0  # ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf + and space flags
================================================================================

# I didn't know these existed -- I only knew about - and 0 !
printf '[%+d]\n' 42
printf '[%+d]\n' -42
printf '[% d]\n' 42
printf '[% d]\n' -42

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf # flag
================================================================================

# I didn't know these existed -- I only knew about - and 0 !
# Note: '#' flag for integers outputs a prefix ONLY WHEN the value is non-zero
printf '[%#o][%#o]\n' 0 42
printf '[%#x][%#x]\n' 0 42
printf '[%#X][%#X]\n' 0 42
echo ---
# Note: '#' flag for %f, %g always outputs the decimal point.
printf '[%.0f][%#.0f]\n' 3 3
# Note: In addition, '#' flag for %g does not omit zeroes in fraction
printf '[%g][%#g]\n' 3 3

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Runtime error for invalid integer
================================================================================

x=3abc
printf '%d\n' $x
echo status=$?
printf '%d\n' xyz
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %(strftime format)T
================================================================================

# The result depends on timezone
export TZ=Asia/Tokyo
printf '%(%Y-%m-%d)T\n' 1557978599
export TZ=US/Eastern
printf '%(%Y-%m-%d)T\n' 1557978599
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %(strftime format)T doesn't respect TZ if not exported
================================================================================


# note: this test leaks!  It assumes that /etc/localtime is NOT Portugal.

TZ=Portugal  # NOT exported
localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

# TZ is respected
export TZ=Portugal
tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

#echo $localtime
#echo $tz

if ! test "$localtime" = "$tz"; then
  echo 'not equal'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %(strftime format)T TZ in environ but not in shell's memory
================================================================================


# note: this test leaks!  It assumes that /etc/localtime is NOT Portugal.

# TZ is respected
export TZ=Portugal
tz=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

unset TZ  # unset in the shell, but still in the environment

localtime=$(printf '%(%Y-%m-%d %H:%M:%S)T\n' 1557978599)

if ! test "$localtime" = "$tz"; then
  echo 'not equal'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: %10.5(strftime format)T
================================================================================

# The result depends on timezone
export TZ=Asia/Tokyo
printf '[%10.5(%Y-%m-%d)T]\n' 1557978599
export TZ=US/Eastern
printf '[%10.5(%Y-%m-%d)T]\n' 1557978599
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Regression for 'printf x y'
================================================================================

printf x y
printf '%s\n' z

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: bash truncates long strftime string at 128
================================================================================


case $SH in ash|dash|mksh|zsh) exit ;; esac

strftime-format() {
  local n=$1

  # Prints increasingly long format strings:
  # %(%Y)T %(%Y)T %(%Y%Y)T ...

  echo -n '%('
  for i in $(seq $n); do
    echo -n '%Y'
  done
  echo -n ')T'
}

printf $(strftime-format 1) | wc --bytes
printf $(strftime-format 10) | wc --bytes
printf $(strftime-format 30) | wc --bytes
printf $(strftime-format 31) | wc --bytes
printf $(strftime-format 32) | wc --bytes

case $SH in
  (*/_bin/cxx-dbg/*)    
    # Ensure that oils-for-unix detects the truncation of a fixed buffer.
    # bash has a buffer of 128.

    set +o errexit
    (
      printf $(strftime-format 1000)
    )
    status=$?
    if test $status -ne 1; then
      echo FAIL
    fi
    ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf positive integer overflow
================================================================================


# %i seems like a synonym for %d

for fmt in '%u\n' '%d\n'; do
  # bash considers this in range for %u
  # same with mksh
  # zsh cuts everything off after 19 digits
  # ash truncates everything
  printf "$fmt" '18446744073709551615'
  echo status=$?
  printf "$fmt" '18446744073709551616'
  echo status=$?
  echo
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf negative integer overflow
================================================================================


# %i seems like a synonym for %d

for fmt in '%u\n' '%d\n'; do

  printf "$fmt" '-18446744073709551615'
  echo status=$?
  printf "$fmt" '-18446744073709551616'
  echo status=$?
  echo
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %b does backslash escaping
================================================================================


printf '[%s]\n' '\044'  # escapes not evaluated
printf '[%b]\n' '\044'  # YES, escapes evaluated
echo

printf '[%s]\n' '\x7e'  # escapes not evaluated
printf '[%b]\n' '\x7e'  # YES, escapes evaluated
echo

# not a valid escape
printf '[%s]\n' '\A'
printf '[%b]\n' '\A'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %b unicode escapes
================================================================================


printf '[%s]\n' '\u03bc'  # escapes not evaluated
printf '[%b]\n' '\u03bc'  # YES, escapes evaluated

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %b respects \c early return
================================================================================

printf '[%b]\n' 'ab\ncd\cxy'
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %b supports octal escapes, both \141 and \0141
================================================================================


printf 'three %b\n' '\141'  # di
printf 'four  %b\n' '\0141'
echo

# trailing 9
printf '%b\n' '\1419'
printf '%b\n' '\01419'

# Notes:
#
# - echo -e: 
#   - NO  3 digit octal  - echo -e '\141' does not work
#   - YES 4 digit octal
# - printf %b
#   - YES 3 digit octal
#   - YES 4 digit octal
# - printf string (outer)
#   - YES 3 digit octal
#   - NO  4 digit octal
# - $'' and $PS1
#   - YES 3 digit octal
#   - NO  4 digit octal

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %b with truncated octal escapes
================================================================================


# 8 is not a valid octal digit

printf '%b\n' '\558'
printf '%b\n' '\0558'
echo

show_bytes() {
  od -A n -t x1
}
printf '%b' '\7' | show_bytes
printf '%b' '\07' | show_bytes
printf '%b' '\007' | show_bytes
printf '%b' '\0007' | show_bytes

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %d %X support hex 0x5 and octal 055
================================================================================


echo hex
printf '%d\n' 0x55
printf '%X\n' 0x55

echo hex CAPS
printf '%d\n' 0X55
printf '%X\n' 0X55

echo octal 3
printf '%d\n' 055
printf '%X\n' 055

echo octal 4
printf '%d\n' 0055
printf '%X\n' 0055

echo octal 5
printf '%d\n' 00055
printf '%X\n' 00055

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: printf %d with + prefix (positive sign)
================================================================================


echo decimal
printf '%d\n' +42

echo octal
printf '%d\n' +077

echo hex lowercase
printf '%d\n' +0xab

echo hex uppercase
printf '%d\n' +0XAB

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: leading spaces are accepted in value given to %d %X, but not trailing spaces
================================================================================


case $SH in zsh) exit ;; esac

# leading space is allowed
printf '%d\n' ' -123'
echo status=$?
printf '%d\n' ' -123 '
echo status=$?

echo ---

printf '%d\n' ' +077'
echo status=$?

printf '%d\n' ' +0xff'
echo status=$?

printf '%X\n' ' +0xff'
echo status=$?

printf '%x\n' ' +0xff'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-printf.test.sh: Arbitrary base 64#a is rejected (unlike in shell arithmetic)
================================================================================


printf '%d\n' '64#a'
echo status=$?

# bash, dash, and mksh print 64 and return status 1
# zsh and ash print 0 and return status 1
# OSH rejects it completely (prints nothing) and returns status 1

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: exec builtin
================================================================================

exec echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: exec builtin with redirects
================================================================================

exec 1>&2
echo 'to stderr'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: exec builtin with here doc
================================================================================

# This has in a separate file because both code and data can be read from
# stdin.
$SH $REPO_ROOT/spec/bin/builtins-exec-here-doc-helper.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: exec builtin accepts --
================================================================================

exec -- echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: exec -- 2>&1
================================================================================

exec -- 3>&1
echo stdout 1>&3

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: Exit out of function
================================================================================

f() { exit 3; }
f
exit 4

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: Exit builtin with invalid arg
================================================================================

exit invalid
# Rationale: runtime errors are 1

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: Exit builtin with too many args
================================================================================

# This is a parse error in OSH.
exit 7 8 9
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: time with brace group argument
================================================================================


err=time-$(basename $SH).txt
{
  time {
    sleep 0.01
    sleep 0.02
  }
} 2> $err

grep --only-matching user $err
echo result=$?

# Regression: check fractional seconds
gawk '
BEGIN { ok = 0 }
match( $0, /\.([0-9]+)/, m) {
  if (m[1] > 0) {  # check fractional seconds
    ok = 1
  }
}
END { if (ok) { print "non-zero" } }
' $err

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: get umask
================================================================================

umask | grep '[0-9]\+'  # check for digits

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: set umask in octal
================================================================================

rm -f $TMP/umask-one $TMP/umask-two
umask 0002
echo one > $TMP/umask-one
umask 0022
echo two > $TMP/umask-two
stat -c '%a' $TMP/umask-one $TMP/umask-two

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: set umask symbolically
================================================================================

umask 0002  # begin in a known state for the test
rm -f $TMP/umask-one $TMP/umask-two
echo one > $TMP/umask-one
umask g-w,o-w
echo two > $TMP/umask-two
stat -c '%a' $TMP/umask-one $TMP/umask-two

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit with no flags is like -f
================================================================================


ulimit > no-flags.txt
echo status=$?

ulimit -f > f.txt
echo status=$?

diff -u no-flags.txt f.txt
echo diff=$?

# Print everything
# ulimit -a

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit too many args
================================================================================


ulimit 1 2
if test $? -ne 0; then
  echo pass
else
  echo fail
fi

#ulimit -f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit negative flag
================================================================================


ulimit -f

# interpreted as a flag
ulimit -f -42
if test $? -ne 0; then
  echo pass
else
  echo fail
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit negative arg
================================================================================


ulimit -f

# an arg
ulimit -f -- -42
if test $? -ne 0; then
  echo pass
else
  echo fail
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit -a doesn't take arg
================================================================================

case $SH in bash) exit ;; esac

ulimit -a 42
if test $? -ne 0; then
  echo 'failure that was expected'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit doesn't accept multiple flags - reduce confusion between shells
================================================================================


# - bash, zsh, busybox ash accept multiple "commands", which requires custom
#   flag parsing, like

#   ulimit -f 999 -n
#   ulimit -f 999 -n 888
#
# - dash and mksh accept a single ARG
#
# we want to make it clear we're like the latter

# can't print all and -f
ulimit -f -a >/dev/null
echo status=$?

ulimit -f -n >/dev/null
echo status=$?

ulimit -f -n 999 >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: YSH readability: ulimit --all the same as ulimit -a
================================================================================


case $SH in bash|dash|mksh|zsh) exit ;; esac

ulimit -a > short.txt
ulimit --all > long.txt

wc -l short.txt long.txt

diff -u short.txt long.txt
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit accepts 'unlimited'
================================================================================


for arg in zz unlimited; do
  echo "  arg $arg"
  ulimit -f
  echo status=$?
  ulimit -f $arg
  if test $? -ne 0; then
    echo 'FAILED'
  fi
  echo
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit of 2**32, 2**31 (int overflow)
================================================================================


echo -n 'one '; ulimit -f


ulimit -f $(( 1 << 32 ))

echo -n 'two '; ulimit -f


# mksh fails because it overflows signed int, turning into negative number
ulimit -f $(( 1 << 31 ))

echo -n 'three '; ulimit -f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit that is 64 bits
================================================================================


# no 64-bit integers
case $SH in mksh) exit ;; esac

echo -n 'before '; ulimit -f

# 1 << 63 overflows signed int

# 512 is 1 << 9, so make it 62-9 = 53 bits

lim=$(( 1 << 53 ))
#echo $lim

# bash says this is out of range
ulimit -f $lim

echo -n 'after '; ulimit -f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: arg that would overflow 64 bits is detected
================================================================================


# no 64-bit integers
case $SH in mksh) exit ;; esac

echo -n 'before '; ulimit -f

# 1 << 63 overflows signed int

lim=$(( (1 << 62) + 1 ))
#echo lim=$lim

# bash detects that this is out of range
# so does osh-cpp, but not osh-cpython

ulimit -f $lim
echo -n 'after '; ulimit -f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit -f 1 prevents files larger 512 bytes
================================================================================

trap - XFSZ  # don't handle this

rm -f err.txt
touch err.txt

bytes() {
  local n=$1
  local st=0
  for i in $(seq $n); do
    echo -n x
    st=$?
    if test $st -ne 0; then
      echo "ERROR: echo failed with status $st" >> err.txt
    fi
  done
}

ulimit -f 1

bytes 512 > ok.txt
echo 512 status=$?

bytes 513 > too-big.txt
echo 513 status=$?
echo

wc --bytes ok.txt too-big.txt
echo

cat err.txt

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: write big file with ulimit
================================================================================


# I think this will test write() errors, rather than the final flush() error
# (which is currently skipped by C++

{ echo 'ulimit -f 1'
  # More than 8 KiB may cause a flush()
  python2 -c 'print("echo " + "X"*9000 + " >out.txt")'
  echo 'echo inner=$?'
} > big.sh

$SH big.sh
echo outer=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit -S for soft limit (default), -H for hard limit
================================================================================

case $SH in dash|zsh) exit ;; esac

# Note: ulimit -n -S 1111 is OK in osh/dash/mksh, but not bash/zsh
# Mus be ulimit -S -n 1111

show_state() {
  local msg=$1
  echo "$msg"
  echo -n '  '; ulimit -S -t
  echo -n '  '; ulimit -H -t
  echo
}

show_state 'init'

ulimit -S -t 123456
show_state '-S'

ulimit -H -t 123457
show_state '-H'

ulimit -t 123455
show_state 'no flag'

echo 'GET'

ulimit -S -t 123454
echo -n '  '; ulimit -t
echo -n '  '; ulimit -S -t
echo -n '  '; ulimit -H -t

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: Changing resource limit is denied
================================================================================


# Not sure why these don't work
case $SH in dash|mksh) exit ;; esac


flag=-t

ulimit -S -H $flag 100
echo both=$?

ulimit -S $flag 90
echo soft=$?

ulimit -S $flag 95
echo soft=$?

ulimit -S $flag 105
if test $? -ne 0; then
  echo soft OK
else
  echo soft fail
fi

ulimit -H $flag 200
if test $? -ne 0; then
  echo hard OK
else
  echo hard fail
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-process.test.sh: ulimit -n limits file descriptors
================================================================================


# OSH bug
# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/alpine.20build.20failures.20-.20make.20-.20ulimit.20-n.2064/with/519691301

$SH -c 'ulimit -n 64; echo hi >out'
echo status=$?

$SH -c 'ulimit -n 0; echo hi >out'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read line from here doc
================================================================================


# NOTE: there are TABS below
read x <<EOF
A		B C D E
FG
EOF
echo "[$x]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read from empty file
================================================================================

echo -n '' > $TMP/empty.txt
read x < $TMP/empty.txt
argv.py "status=$?" "$x"

# No variable name, behaves the same
read < $TMP/empty.txt
argv.py "status=$?" "$REPLY"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read /dev/null
================================================================================

read -n 1 </dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read with zero args
================================================================================

echo | read
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read builtin with no newline returns status 1
================================================================================


# This is odd because the variable is populated successfully.  OSH/YSH might
# need a separate put reading feature that doesn't use IFS.

echo -n ZZZ | { read x; echo status=$?; echo $x; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read builtin splits value across multiple vars
================================================================================

# NOTE: there are TABS below
read x y z <<EOF
A		B C D E 
FG
EOF
echo "[$x/$y/$z]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read builtin with too few variables
================================================================================

set -o errexit
set -o nounset  # hm this doesn't change it
read x y z <<EOF
A B
EOF
echo /$x/$y/$z/

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n (with $REPLY)
================================================================================

echo 12345 > $TMP/readn.txt
read -n 4 x < $TMP/readn.txt
read -n 2 < $TMP/readn.txt  # Do it again with no variable
argv.py $x $REPLY

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS= read -n (OSH regression: value saved in tempenv)
================================================================================

echo XYZ > "$TMP/readn.txt"
IFS= TMOUT= read -n 1 char < "$TMP/readn.txt"
argv.py "$char"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n doesn't strip whitespace (bug fix)
================================================================================

case $SH in dash|zsh) exit ;; esac

echo '  a b  ' | (read -n 4; echo "[$REPLY]")
echo '  a b  ' | (read -n 5; echo "[$REPLY]")
echo '  a b  ' | (read -n 6; echo "[$REPLY]")
echo

echo 'one var strips whitespace'
echo '  a b  ' | (read -n 4 myvar; echo "[$myvar]")
echo '  a b  ' | (read -n 5 myvar; echo "[$myvar]")
echo '  a b  ' | (read -n 6 myvar; echo "[$myvar]")
echo

echo 'three vars'
echo '  a b  ' | (read -n 4 x y z; echo "[$x] [$y] [$z]")
echo '  a b  ' | (read -n 5 x y z; echo "[$x] [$y] [$z]")
echo '  a b  ' | (read -n 6 x y z; echo "[$x] [$y] [$z]")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -d -n - respects delimiter and splits
================================================================================


case $SH in dash|zsh|ash) exit ;; esac

echo 'delim c'
echo '  a b c ' | (read -d 'c' -n 3; echo "[$REPLY]")
echo '  a b c ' | (read -d 'c' -n 4; echo "[$REPLY]")
echo '  a b c ' | (read -d 'c' -n 5; echo "[$REPLY]")
echo

echo 'one var'
echo '  a b c ' | (read -d 'c' -n 3 myvar; echo "[$myvar]")
echo '  a b c ' | (read -d 'c' -n 4 myvar; echo "[$myvar]")
echo '  a b c ' | (read -d 'c' -n 5 myvar; echo "[$myvar]")
echo

echo 'three vars'
echo '  a b c ' | (read -d 'c' -n 3 x y z; echo "[$x] [$y] [$z]")
echo '  a b c ' | (read -d 'c' -n 4 x y z; echo "[$x] [$y] [$z]")
echo '  a b c ' | (read -d 'c' -n 5 x y z; echo "[$x] [$y] [$z]")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n with invalid arg
================================================================================

read -n not_a_number
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n from pipe
================================================================================

case $SH in dash|ash|zsh) exit ;; esac

echo abcxyz | { read -n 3; echo reply=$REPLY; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read without args uses $REPLY, no splitting occurs (without -n)
================================================================================


# mksh and zsh implement splitting with $REPLY, bash/ash don't

echo '  a b  ' | (read; echo "[$REPLY]")
echo '  a b  ' | (read myvar; echo "[$myvar]")

echo '  a b  \
  line2' | (read; echo "[$REPLY]")
echo '  a b  \
  line2' | (read myvar; echo "[$myvar]")

# Now test with -r
echo '  a b  \
  line2' | (read -r; echo "[$REPLY]")
echo '  a b  \
  line2' | (read -r myvar; echo "[$myvar]")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n vs. -N
================================================================================

# dash, ash and zsh do not implement read -N
# mksh treats -N exactly the same as -n
case $SH in dash|ash|zsh) exit ;; esac

# bash docs: https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html

echo 'a b c' > $TMP/readn.txt

echo 'read -n'
read -n 5 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
read -n 4 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
echo

echo 'read -N'
read -N 5 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"
read -N 4 A B C < $TMP/readn.txt; echo "'$A' '$B' '$C'"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -N ignores delimiters
================================================================================

case $SH in dash|ash|zsh) exit ;; esac

echo $'a\nb\nc' > $TMP/read-lines.txt

read -N 3 out < $TMP/read-lines.txt
echo "$out"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read will unset extranous vars
================================================================================


echo 'a b' > $TMP/read-few.txt

c='some value'
read a b c < $TMP/read-few.txt
echo "'$a' '$b' '$c'"

case $SH in dash) exit ;; esac # dash does not implement -n

c='some value'
read -n 3 a b c < $TMP/read-few.txt
echo "'$a' '$b' '$c'"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -r ignores backslashes
================================================================================

echo 'one\ two' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -r with other backslash escapes
================================================================================

echo 'one\ two\x65three' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"
# mksh respects the hex escapes here, but other shells don't!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read with line continuation reads multiple physical lines
================================================================================

# NOTE: osh failing because of file descriptor issue.  stdin has to be closed!
tmp=$TMP/$(basename $SH)-readr.txt
echo -e 'one\\\ntwo\n' > $tmp
read escaped < $tmp
read -r raw < $tmp
argv.py "$escaped" "$raw"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read multiple vars spanning many lines
================================================================================

read x y << 'EOF'
one-\
two three-\
four five-\
six
EOF
argv.py "$x" "$y" "$z"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -r with \n
================================================================================

echo '\nline' > $TMP/readr.txt
read escaped < $TMP/readr.txt
read -r raw < $TMP/readr.txt
argv.py "$escaped" "$raw"
# dash/mksh/zsh are bugs because at least the raw mode should let you read a
# literal \n.

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -s from pipe, not a terminal
================================================================================

case $SH in dash|zsh) exit ;; esac

# It's hard to really test this because it requires a terminal.  We hit a
# different code path when reading through a pipe.  There can be bugs there
# too!

echo foo | { read -s; echo $REPLY; }
echo bar | { read -n 2 -s; echo $REPLY; }

# Hm no exit 1 here?  Weird
echo b | { read -n 2 -s; echo $?; echo $REPLY; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read with IFS=$'\n'
================================================================================

# The leading spaces are stripped if they appear in IFS.
IFS=$(echo -e '\n')
read var <<EOF
  a b c
  d e f
EOF
echo "[$var]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read multiple lines with IFS=:
================================================================================

# The leading spaces are stripped if they appear in IFS.
# IFS chars are escaped with :.
tmp=$TMP/$(basename $SH)-read-ifs.txt
IFS=:
cat >$tmp <<'EOF'
  \\a :b\: c:d\
  e
EOF
read a b c d < $tmp
# Use printf because echo in dash/mksh interprets escapes, while it doesn't in
# bash.
printf "%s\n" "[$a|$b|$c|$d]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read with IFS=''
================================================================================

IFS=''
read x y <<EOF
  a b c d
EOF
echo "[$x|$y]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read does not respect C backslash escapes
================================================================================


# bash doesn't respect these, but other shells do.  Gah!  I think bash
# behavior makes more sense.  It only escapes IFS.
echo '\a \b \c \d \e \f \g \h \x65 \145 \i' > $TMP/read-c.txt
read line < $TMP/read-c.txt
echo $line

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: dynamic scope used to set vars
================================================================================

f() {
  read head << EOF
ref: refs/heads/dev/andy
EOF
}
f
echo $head

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -a reads into array
================================================================================


# read -a is used in bash-completion
# none of these shells implement it
case $SH in
  *mksh|*dash|*zsh|*/ash)
    exit 2;
    ;;
esac

read -a myarray <<'EOF'
a b c\ d
EOF
argv.py "${myarray[@]}"

# arguments are ignored here
read -r -a array2 extra arguments <<'EOF'
a b c\ d
EOF
argv.py "${array2[@]}"
argv.py "${extra[@]}"
argv.py "${arguments[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -d : (colon-separated records)
================================================================================

printf a,b,c:d,e,f:g,h,i | {
  IFS=,
  read -d : v1
  echo "v1=$v1"
  read -d : v1 v2
  echo "v1=$v1 v2=$v2"
  read -d : v1 v2 v3
  echo "v1=$v1 v2=$v2 v3=$v3"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -d '' (null-separated records)
================================================================================

printf 'a,b,c\0d,e,f\0g,h,i' | {
  IFS=,
  read -d '' v1
  echo "v1=$v1"
  read -d '' v1 v2
  echo "v1=$v1 v2=$v2"
  read -d '' v1 v2 v3
  echo "v1=$v1 v2=$v2 v3=$v3"
}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -rd
================================================================================

read -rd '' var <<EOF
foo
bar
EOF
echo "$var"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -d when there's no delimiter
================================================================================

{ read -d : part
  echo $part $?
  read -d : part
  echo $part $?
} <<EOF
foo:bar
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -t 0 tests if input is available
================================================================================

case $SH in dash|zsh|mksh) exit ;; esac

# is there input available?
read -t 0 < /dev/null
echo $?

# floating point
read -t 0.0 < /dev/null
echo $?

# floating point
echo foo | { read -t 0; echo reply=$REPLY; }
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -t 0.5
================================================================================

case $SH in dash) exit ;; esac

read -t 0.5 < /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -t -0.5 is invalid
================================================================================

# bash appears to just take the absolute value?

read -t -0.5 < /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -u
================================================================================

case $SH in dash|mksh) exit ;; esac

# file descriptor
read -u 3 3<<EOF
hi
EOF
echo reply=$REPLY

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -u syntax error
================================================================================

read -u -3
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -u -s
================================================================================

case $SH in dash|mksh) exit ;; esac

# file descriptor
read -s -u 3 3<<EOF
hi
EOF
echo reply=$REPLY

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -u 3 -d 5
================================================================================

case $SH in dash|mksh) exit ;; esac

# file descriptor
read -u 3 -d 5 3<<EOF
123456789
EOF
echo reply=$REPLY

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -u 3 -d b -N 6
================================================================================

case $SH in ash|zsh) exit ;; esac

# file descriptor
read -u 3 -d b -N 4 3<<EOF
ababababa
EOF
echo reply=$REPLY
# test end on EOF
read -u 3 -d b -N 6 3<<EOF
ab
EOF
echo reply=$REPLY

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -N doesn't respect delimiter, while read -n does
================================================================================

case $SH in dash|zsh|ash) exit ;; esac

echo foobar | { read -n 5 -d b; echo $REPLY; }
echo foobar | { read -N 5 -d b; echo $REPLY; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -p (not fully tested)
================================================================================


# hm DISABLED if we're not going to the terminal
# so we're only testing that it accepts the flag here

case $SH in dash|mksh|zsh) exit ;; esac

echo hi | { read -p 'P'; echo $REPLY; }
echo hi | { read -p 'P' -n 1; echo $REPLY; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read usage
================================================================================

read -n -1
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read with smooshed args
================================================================================

echo hi | { read -rn1 var; echo var=$var; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -r -d '' for NUL strings, e.g. find -print0
================================================================================



case $SH in dash|zsh|mksh) exit ;; esac  # NOT IMPLEMENTED

mkdir -p read0
cd read0
rm -f *

touch a\\b\\c\\d  # -r is necessary!

find . -type f -a -print0 | { read -r -d ''; echo "[$REPLY]"; }

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read from redirected directory is non-fatal error
================================================================================


# This tickles an infinite loop bug in our version of mksh!  TODO: upgrade the
# version and enable this
case $SH in mksh) return ;; esac

cd $TMP
mkdir -p dir
read x < ./dir
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n from directory
================================================================================


case $SH in dash|ash) return ;; esac  # not implemented

# same hanging bug
case $SH in mksh) return ;; esac

mkdir -p dir
read -n 3 x < ./dir
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: mapfile from directory (bash doesn't handle errors)
================================================================================

case $SH in dash|ash|mksh|zsh) return ;; esac  # not implemented

mkdir -p dir
mapfile $x < ./dir
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n 0
================================================================================

case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'a\b\c\d\e\f' | (read -n 0; argv.py "$REPLY")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n and backslash escape
================================================================================

case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'a\b\c\d\e\f' | (read -n 5; argv.py "$REPLY")
echo 'a\ \ \ \ \ ' | (read -n 5; argv.py "$REPLY")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n 4 with incomplete backslash
================================================================================

case $SH in zsh) exit 99;; esac  # read -n not implemented

echo 'abc\def\ghijklmn' | (read -n 4; argv.py "$REPLY")
echo '   \xxx\xxxxxxxx' | (read -n 4; argv.py "$REPLY")

# bash implements "-n NUM" as number of characters

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read -n 4 with backslash + delim
================================================================================

case $SH in zsh) exit 99;; esac  # read -n not implemented

echo $'abc\\\ndefg' | (read -n 4; argv.py "$REPLY")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: "backslash + newline" should be swallowed regardless of "-d <delim>"
================================================================================


printf '%s\n' 'a b\' 'c d' | (read; argv.py "$REPLY")
printf '%s\n' 'a b\,c d'   | (read; argv.py "$REPLY")
printf '%s\n' 'a b\' 'c d' | (read -d ,; argv.py "$REPLY")
printf '%s\n' 'a b\,c d'   | (read -d ,; argv.py "$REPLY")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: empty input and splitting
================================================================================

case $SH in mksh|ash|dash|zsh) exit 99; esac
echo '' | (read -a a; argv.py "${a[@]}")
IFS=x
echo '' | (read -a a; argv.py "${a[@]}")
IFS=
echo '' | (read -a a; argv.py "${a[@]}")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS='x ' read -a: trailing spaces (unlimited split)
================================================================================

case $SH in mksh|ash|dash|zsh) exit 99; esac
IFS='x '
echo 'a b'     | (read -a a; argv.py "${a[@]}")
echo 'a b '    | (read -a a; argv.py "${a[@]}")
echo 'a bx'    | (read -a a; argv.py "${a[@]}")
echo 'a bx '   | (read -a a; argv.py "${a[@]}")
echo 'a b x'   | (read -a a; argv.py "${a[@]}")
echo 'a b x '  | (read -a a; argv.py "${a[@]}")
echo 'a b x x' | (read -a a; argv.py "${a[@]}")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS='x ' read a b: trailing spaces (with max_split)
================================================================================

echo 'hello world  test   ' | (read a b; argv.py "$a" "$b")
echo '-- IFS=x --'
IFS='x '
echo 'a ax  x  '     | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x'    | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x  '  | (read a b; argv.py "$a" "$b")
echo 'a ax  x  x  a' | (read a b; argv.py "$a" "$b")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS='x ' read -a: intermediate spaces (unlimited split)
================================================================================

case $SH in mksh|ash|dash|zsh) exit 99; esac
IFS='x '
echo 'a x b'   | (read -a a; argv.py "${a[@]}")
echo 'a xx b'  | (read -a a; argv.py "${a[@]}")
echo 'a xxx b' | (read -a a; argv.py "${a[@]}")
echo 'a x xb'  | (read -a a; argv.py "${a[@]}")
echo 'a x x b' | (read -a a; argv.py "${a[@]}")
echo 'ax b'    | (read -a a; argv.py "${a[@]}")
echo 'ax xb'   | (read -a a; argv.py "${a[@]}")
echo 'ax  xb'  | (read -a a; argv.py "${a[@]}")
echo 'ax x xb' | (read -a a; argv.py "${a[@]}")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS='x ' incomplete backslash
================================================================================

echo ' a b \' | (read a; argv.py "$a")
echo ' a b \' | (read a b; argv.py "$a" "$b")
IFS='x '
echo $'a ax  x    \\\nhello' | (read a b; argv.py "$a" "$b")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS='\ ' and backslash escaping
================================================================================

IFS='\ '
echo "hello\ world  test" | (read a b; argv.py "$a" "$b")
IFS='\'
echo "hello\ world  test" | (read a b; argv.py "$a" "$b")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: max_split and backslash escaping
================================================================================

echo 'Aa b \ a\ b' | (read a b; argv.py "$a" "$b")
echo 'Aa b \ a\ b' | (read a b c; argv.py "$a" "$b" "$c")
echo 'Aa b \ a\ b' | (read a b c d; argv.py "$a" "$b" "$c" "$d")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: IFS=x read a b <<< xxxxxx
================================================================================

IFS='x '
echo x     | (read a b; argv.py "$a" "$b")
echo xx    | (read a b; argv.py "$a" "$b")
echo xxx   | (read a b; argv.py "$a" "$b")
echo xxxx  | (read a b; argv.py "$a" "$b")
echo xxxxx | (read a b; argv.py "$a" "$b")
echo '-- spaces --'
echo 'x    ' | (read a b; argv.py "$a" "$b")
echo 'xx   ' | (read a b; argv.py "$a" "$b")
echo 'xxx  ' | (read a b; argv.py "$a" "$b")
echo 'xxxx ' | (read a b; argv.py "$a" "$b")
echo 'xxxxx' | (read a b; argv.py "$a" "$b")
echo '-- with char --'
echo 'xa    ' | (read a b; argv.py "$a" "$b")
echo 'xax   ' | (read a b; argv.py "$a" "$b")
echo 'xaxx  ' | (read a b; argv.py "$a" "$b")
echo 'xaxxx ' | (read a b; argv.py "$a" "$b")
echo 'xaxxxx' | (read a b; argv.py "$a" "$b")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read and "\ "
================================================================================


IFS='x '
check() { echo "$1" | (read a b; argv.py "$a" "$b"); }

echo '-- xs... --'
check 'x '
check 'x \ '
check 'x \ \ '
check 'x \ \ \ '
echo '-- xe... --'
check 'x\ '
check 'x\ \ '
check 'x\ \ \ '
check 'x\  '
check 'x\  '
check 'x\    '

# check 'xx\ '
# check 'xx\ '

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-read.test.sh: read bash bug
================================================================================

IFS='x '
echo 'x\  \ ' | (read a b; argv.py "$a" "$b")

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: can continue after unknown option
================================================================================

#
# TODO: this is the posix special builtin logic?
# dash and mksh make this a fatal error no matter what.

set -o errexit
set -o STRICT || true # unknown option
echo hello

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set with both options and argv
================================================================================

set -o errexit a b c
echo "$@"
false
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: nounset with "$@"
================================================================================

set a b c
set -u  # shouldn't touch argv
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -u -- clears argv
================================================================================

set a b c
set -u -- # shouldn't touch argv
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -u -- x y z
================================================================================

set a b c
set -u -- x y z
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -u with undefined variable exits the interpreter
================================================================================


# non-interactive
$SH -c 'set -u; echo before; echo $x; echo after'
if test $? -ne 0; then
  echo OK
fi

# interactive
$SH -i -c 'set -u; echo before; echo $x; echo after'
if test $? -ne 0; then
  echo OK
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -u with undefined var in interactive shell does NOT exit the interpreter
================================================================================


# In bash, it aborts the LINE only.  The next line is executed!

# non-interactive
$SH -c 'set -u; echo before; echo $x; echo after
echo line2
'
if test $? -ne 0; then
  echo OK
fi

# interactive
$SH -i -c 'set -u; echo before; echo $x; echo after
echo line2
'
if test $? -ne 0; then
  echo OK
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -u error can break out of nested evals
================================================================================

$SH -c '
set -u
test_function_2() {
  x=$blarg
}
test_function() {
  eval "test_function_2"
}

echo before
eval test_function
echo after
'
# status must be non-zero: bash uses 1, ash/dash exit 2
if test $? -ne 0; then
  echo OK
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: reset option with long flag
================================================================================

set -o errexit
set +o errexit
echo "[$unset]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: reset option with short flag
================================================================================

set -u 
set +u
echo "[$unset]"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -eu (flag parsing)
================================================================================

set -eu 
echo "[$unset]"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -o lists options
================================================================================

# NOTE: osh doesn't use the same format yet.
set -o | grep -o noexec

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: 'set' and 'eval' round trip
================================================================================


# NOTE: not testing arrays and associative arrays!
_space='[ ]'
_whitespace=$'[\t\r\n]'
_sq="'single quotes'"
_backslash_dq="\\ \""
_unicode=$'[\u03bc]'

# Save the variables
varfile=$TMP/vars-$(basename $SH).txt

set | grep '^_' > "$varfile"

# Unset variables
unset _space _whitespace _sq _backslash_dq _unicode
echo [ $_space $_whitespace $_sq $_backslash_dq $_unicode ]

# Restore them

. $varfile
echo "Code saved to $varfile" 1>&2  # for debugging

test "$_space" = '[ ]' && echo OK
test "$_whitespace" = $'[\t\r\n]' && echo OK
test "$_sq" = "'single quotes'" && echo OK
test "$_backslash_dq" = "\\ \"" && echo OK
test "$_unicode" = $'[\u03bc]' && echo OK

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set - - and so forth
================================================================================

set a b
echo "$@"

set - a b
echo "$@"

set -- a b
echo "$@"

set - -
echo "$@"

set -- --
echo "$@"

# note: zsh is different, and yash is totally different

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set - leading single dash is ignored, turns off xtrace verbose (#2364)
================================================================================


show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set -x -v
show_options
echo

set - a b c
echo "$@"
show_options
echo

# dash that's not leading is not special
set x - y z
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set - stops option processing like set --
================================================================================

case $SH in zsh) exit ;; esac

show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set -x - -v

show_options
echo argv "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: A single + is an ignored flag; not an argument
================================================================================

case $SH in zsh) exit ;; esac

show_options() {
  case $- in
    *v*) echo verbose-on ;;
  esac
  case $- in
    *x*) echo xtrace-on ;;
  esac
}

set +
echo plus "$@"

set -x + -v x y
show_options
echo plus "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set - + and + -
================================================================================

set - +
echo "$@"

set + -
echo "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -a exports variables
================================================================================

set -a
FOO=bar
BAZ=qux
printenv.py FOO BAZ

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set +a stops exporting
================================================================================

set -a
FOO=exported
set +a
BAR=not_exported
printenv.py FOO BAR

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -o allexport (long form)
================================================================================

set -o allexport
VAR1=value1
set +o allexport
VAR2=value2
printenv.py VAR1 VAR2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: variables set before set -a are not exported
================================================================================

BEFORE=before_value
set -a
AFTER=after_value
printenv.py BEFORE AFTER

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -a exports local variables
================================================================================

set -a
f() {
  local ZZZ=zzz
  printenv.py ZZZ
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-set.test.sh: set -a exports declare variables
================================================================================

set -a
declare ZZZ=zzz
printenv.py ZZZ

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: true is not special; prefix assignments don't persist, it can be redefined
================================================================================

foo=bar true
echo foo=$foo

true() {
  echo true func
}
foo=bar true
echo foo=$foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Prefix assignments persist after special builtins, like : (set -o posix)
================================================================================

case $SH in
  bash) set -o posix ;;
esac

foo=bar :
echo foo=$foo

# Not true when you use 'builtin'
z=Z builtin :
echo z=$Z

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Prefix assignments persist after readonly, but NOT exported (set -o posix)
================================================================================


# Bash only implements it behind the posix option
case $SH in
  bash) set -o posix ;;
esac
foo=bar readonly spam=eggs
echo foo=$foo
echo spam=$spam

# should NOT be exported
printenv.py foo
printenv.py spam

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Prefix binding for exec is a special case (versus e.g. readonly)
================================================================================


pre1=pre1 readonly x=x
pre2=pre2 exec sh -c 'echo pre1=$pre1 x=$x pre2=$pre2'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: exec without args is a special case of the special case in some shells
================================================================================


FOO=bar exec >& 2
echo FOO=$FOO
#declare -p | grep FOO

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Which shells allow special builtins to be redefined?
================================================================================

eval() {
  echo 'eval func' "$@"
}
eval 'echo hi'

# we allow redefinition, but the definition is NOT used!

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Special builtins can't be redefined as shell functions (set -o posix)
================================================================================

case $SH in
  bash) set -o posix ;;
esac

eval 'echo hi'

eval() {
  echo 'sh func' "$@"
}

eval 'echo hi'

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Non-special builtins CAN be redefined as functions
================================================================================

test -n "$BASH_VERSION" && set -o posix
true() {
  echo 'true func'
}
true hi
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: Shift is special and fails whole script
================================================================================


# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14
#
# 2.8.1 - Consequences of shell errors
#
# Special built-ins should exit a non-interactive shell
# bash and busybox dont't implement this even with set -o posix, so it seems risky
# dash and mksh do it; so does AT&T ksh

$SH -c '
if test -n "$BASH_VERSION"; then
  set -o posix
fi
set -- a b
shift 3
echo status=$?
'
if test "$?" != 0; then
  echo 'non-zero status'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: set is special and fails whole script, even if using || true
================================================================================

$SH -c '
if test -n "$BASH_VERSION"; then
  set -o posix
fi

shopt -s invalid_ || true
echo ok
set -o invalid_ || true
echo should not get here
'
if test "$?" != 0; then
  echo 'non-zero status'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: bash 'type' gets confused - says 'function', but runs builtin
================================================================================

case $SH in dash|mksh|zsh|ash|yash) exit ;; esac

echo TRUE
type -t true  # builtin
true() { echo true func; }
type -t true  # now a function
echo ---

echo EVAL

type -t eval  # builtin
# define function before set -o posix
eval() { echo "shell function: $1"; }
# bash runs the FUNCTION, but OSH finds the special builtin
# OSH doesn't need set -o posix
eval 'echo before posix'

if test -n "$BASH_VERSION"; then
  # this makes the eval definition invisible!
  set -o posix
fi

eval 'echo after posix'  # this is the builtin eval
# bash claims it's a function, but it's a builtin
type -t eval

# it finds the function and the special builtin
#type -a eval

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-special.test.sh: command, builtin - both can be redefined, not special (regression)
================================================================================

case $SH in dash|ash|yash) exit ;; esac

builtin echo b
command echo c

builtin() {
  echo builtin-redef "$@"
}

command() {
  echo command-redef "$@"
}

builtin echo b
command echo c

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-times.test.sh: times shows two formatted lines
================================================================================

output=$(times)
echo "$output" | while read line
do
	echo "$line" | egrep -q '[0-9]+m[0-9]+.[0-9]+s [0-9]+m[0-9]+.[0-9]+s' && echo "pass"
done

echo "$output" | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap -l
================================================================================

trap -l | grep INT >/dev/null

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap -p
================================================================================


trap 'echo exit' EXIT

trap -p > parent.txt

grep EXIT parent.txt >/dev/null
if test $? -eq 0; then
  echo shown
else
  echo not shown
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap -p in child is BUGGY in bash
================================================================================


# It shows the trap even though it doesn't execute it!

trap 'echo exit' EXIT

trap -p | cat > child.txt

grep EXIT child.txt >/dev/null
if test $? -eq 0; then
  echo shown
else
  echo not shown
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG ignores $?
================================================================================

debuglog() {
  echo "  [$@]"
  return 42     # IGNORED FAILURE
}

trap 'debuglog $LINENO' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: but trap DEBUG respects errexit
================================================================================

set -o errexit

debuglog() {
  echo "  [$@]"
  return 42
}

trap 'debuglog $LINENO' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG with 'return'
================================================================================


debuglog() {
  echo "  [$@]"
}

trap 'debuglog $LINENO; return 42' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG with 'exit'
================================================================================

debuglog() {
  echo "  [$@]"
}

trap 'debuglog $LINENO; exit 42' DEBUG

echo status=$?
echo A
echo status=$?
echo B
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG with non-compound commands
================================================================================

case $SH in dash|mksh) exit ;; esac

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

echo a
echo b; echo c

echo d && echo e
echo f || echo g

(( h = 42 ))
[[ j == j ]]

var=value

readonly r=value

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG and control flow
================================================================================


debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

while true; do
  echo hello
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG and command sub / subshell
================================================================================

case $SH in dash|mksh) exit ;; esac

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

echo "result = $(echo command sub; echo two)"
( echo subshell
  echo two
)
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG not run in forked interpreter for first pipeline part
================================================================================


debuglog() {
  #echo "  PID=$$ BASHPID=$BASHPID LINENO=$1"
  echo "  LINENO=$1"
}
trap 'debuglog $LINENO' DEBUG

{ echo pipe1;
  echo pipe2; } \
  | cat
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: One 'echo' in first pipeline part - why does bash behave differently from case above?
================================================================================


# TODO: bash runs the trap 3 times, and osh only twice.  I don't see why.  Is
# it because Process::Run() does trap_state.ClearForSubProgram()?  Probably
#echo top PID=$$ BASHPID=$BASHPID
#shopt -s lastpipe

debuglog() {
  #echo "  PID=$$ BASHPID=$BASHPID LINENO=$1"
  #echo "  LINENO=$1 $BASH_COMMAND"
  # LINENO=6 echo pipeline
  # LINENO=7 cat
  echo "  LINENO=$1"
}
trap 'debuglog $LINENO' DEBUG

echo pipeline \
  | cat
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG and pipeline (lastpipe difference)
================================================================================

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

# gets run for each one of these
{ echo a; echo b; }

# only run for the last one, maybe I guess because traps aren't inherited?
{ echo x; echo y; } | wc -l

# bash runs for all of these, but OSH doesn't because we have SubProgramThunk
# Hm.
date | cat | wc -l

date |
  cat |
  wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG function call
================================================================================

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

f() {
  local mylocal=1
  for i in "$@"; do
    echo i=$i
  done
}

f A B  # executes ONCE here, but does NOT go into the function call

echo next

f X Y

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG case
================================================================================

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

name=foo.py

case $name in 
  *.py)
    echo python
    ;;
  *.sh)
    echo shell
    ;;
esac
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG for each
================================================================================


debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

for x in 1 2; do
  echo x=$x
done

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG for expr
================================================================================

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

for (( i =3 ; i < 5; ++i )); do
  echo i=$i
done

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap DEBUG if while
================================================================================

debuglog() {
  echo "  [$@]"
}
trap 'debuglog $LINENO' DEBUG

if test x = x; then
  echo if
fi 

while test x != x; do
  echo while
done

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: trap RETURN
================================================================================

profile() {
  echo "profile [$@]"
}
g() {
  echo --
  echo g
  echo --
  return
}
f() {
  echo --
  echo f
  echo --
  g
}
# RETURN trap doesn't fire when a function returns, only when a script returns?
# That's not what the manual says.
trap 'profile x y' RETURN
f
. $REPO_ROOT/spec/testdata/return-helper.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: Compare trap DEBUG vs. trap ERR
================================================================================


# Pipelines and AndOr are problematic

# THREE each
trap 'echo dbg $LINENO' DEBUG

false | false | false

false || false || false

! true

trap - DEBUG


# ONE EACH
trap 'echo err $LINENO' ERR

false | false | false

false || false || false

! true  # not run

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: Combine DEBUG trap and USR1 trap
================================================================================


case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO usr1' USR1
trap 'false; echo $LINENO dbg' DEBUG

sh -c "kill -USR1 $$"
echo after=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: Combine ERR trap and USR1 trap
================================================================================


case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO usr1' USR1
trap 'false; echo $LINENO err' ERR

sh -c "kill -USR1 $$"
echo after=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-bash.test.sh: Combine DEBUG trap and ERR trap
================================================================================


case $SH in dash|mksh|ash) exit ;; esac

trap 'false; echo $LINENO err' ERR
trap 'false; echo $LINENO debug' DEBUG

false
echo after=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap can use original $LINENO
================================================================================


trap 'echo line=$LINENO' ERR

false
false
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and set -o errexit
================================================================================


trap 'echo line=$LINENO' ERR

false
echo a

set -o errexit

echo b
false   # trap executed, and executation also halts
echo c  # doesn't get here

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and errexit disabled context
================================================================================


trap 'echo line=$LINENO' ERR

false
echo a

set -o errexit

echo b
if false; then
  echo xx
fi
echo c  # doesn't get here

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and if statement
================================================================================


if test -f /nope; then echo file exists; fi

trap 'echo err' ERR
#trap 'echo line=$LINENO' ERR

if test -f /nope; then echo file exists; fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and || conditional
================================================================================


trap 'echo line=$LINENO' ERR

false || false || false
echo ok

false && false
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and pipeline
================================================================================


# mksh and bash have different line numbers in this case
#trap 'echo line=$LINENO' ERR
trap 'echo line=$LINENO' ERR

# it's run for the last 'false'
false | false | false

{ echo pipeline; false; } | false | false

# it's never run here
! true
! false

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR pipelines without simple commands
================================================================================


trap 'echo assign' ERR
a=$(false) | a=$(false) | a=$(false)

trap 'echo dparen' ERR
(( 0 )) | (( 0 )) | (( 0 ))

trap 'echo dbracket' ERR
[[ a = b ]] | [[ a = b ]] | [[ a = b ]]

# bash anomaly - it gets printed twice?
trap 'echo subshell' ERR
(false) | (false) | (false) | (false)

# same bug
trap 'echo subshell2' ERR 
(false) | (false) | (false) | (false; false)

trap 'echo group' ERR
{ false; } | { false; } | { false; }

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: Pipeline group quirk
================================================================================


# Oh this is because it's run for the PIPELINE, not for the last thing!  Hmmm

trap 'echo group2' ERR
{ false; } | { false; } | { false; false; }

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR does not run in errexit situations
================================================================================


trap 'echo line=$LINENO' ERR

if false; then
  echo if
fi

while false; do
  echo while
done

until false; do
  echo until
  break
done

false || false || false

false && false && false

false; false; false

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR doesn't run in subprograms - subshell, command sub, async
================================================================================


trap 'echo line=$LINENO' ERR

( false; echo subshell )

x=$( false; echo command sub )

false & wait

{ false; echo async; } & wait

false
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: set -o errtrace: trap ERR runs in subprograms
================================================================================

case $SH in mksh) exit ;; esac

set -o errtrace
trap 'echo line=$LINENO' ERR

( false; echo subshell )

x=$( false; echo command sub )

false
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR doesn't run with &
================================================================================


trap 'echo line=$LINENO' ERR

false & wait

{ false; echo async; } & wait

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: set -o errtrace: trap ERR with &
================================================================================

case $SH in mksh) exit ;; esac

set -o errtrace
trap 'echo line=$LINENO' ERR

false & wait

{ false; echo async; } & wait

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR not active in shell functions in (bash behavior)
================================================================================


trap 'echo line=$LINENO' ERR

f() {
  false 
  true
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: set -o errtrace - trap ERR runs in shell functions
================================================================================


trap 'echo err' ERR

passing() {
  false  # line 4
  true
}

failing() {
  true
  false
}

passing
failing

set -o errtrace

echo 'now with errtrace'
passing
failing

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: set -o errtrace - trap ERR runs in shell functions (LINENO)
================================================================================


trap 'echo line=$LINENO' ERR

passing() {
  false  # line 4
  true
}

failing() {
  true
  false
}

passing
failing

set -o errtrace

echo 'now with errtrace'
passing
failing

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR with "atoms": assignment (( [[
================================================================================


trap 'echo line=$LINENO' ERR

x=$(false)

[[ a == b ]]

(( 0 ))
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR with for,  case, { }
================================================================================


trap 'echo line=$LINENO' ERR

for y in 1 2; do
  false
done

case x in
  x) false ;;
  *) false ;;
esac

{ false; false; false; }
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR with redirect
================================================================================


trap 'echo line=$LINENO' ERR

false

{ false 
  true
} > /zz  # error
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR
================================================================================

err() {
  echo "err [$@] $?"
}
trap 'err x y' ERR 

echo A

false
echo B

( exit 42 )
echo C

trap - ERR  # disable trap

false
echo D

trap 'echo after errexit $?' ERR 

set -o errexit

( exit 99 )
echo E

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: trap ERR and pipelines - PIPESTATUS difference
================================================================================

case $SH in ash) exit ;; esac

err() {
  echo "err [$@] status=$? [${PIPESTATUS[@]}]"
}
trap 'err' ERR 

echo A

false

# succeeds
echo B | grep B

# fails
echo C | grep zzz

echo D | grep zzz | cat

set -o pipefail
echo E | grep zzz | cat

trap - ERR  # disable trap

echo F | grep zz
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap-err.test.sh: error in trap ERR (recursive)
================================================================================

case $SH in dash) exit ;; esac

err() {
  echo err status $?
  false
  ( exit 2 )  # not recursively triggered
  echo err 2
}
trap 'err' ERR 

echo A
false
echo B

# Try it with errexit
set -e
false
echo C

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: traps are not active inside subshells $() ()  trap | cat
================================================================================


# TODO: should we change this?  We're not compatible with bash or busybox ash

trap 'echo bye' EXIT

# NOT a subshell
trap > traps.txt
wc -l traps.txt

echo '( )'
( trap )

echo '$(trap)'
echo $(trap)

echo 'trap | cat'
trap | cat

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap accepts/ignores --
================================================================================

trap -- 'echo hi' EXIT
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: Register invalid trap, remove invalid trap
================================================================================

trap 'foo' SIGINVALID
if test $? -ne 0; then
  echo ok
fi

trap - SIGINVALID
if test $? -ne 0; then
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap foo gives non-zero error
================================================================================

trap 'foo'
if test $? -ne 0; then
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: SIGINT and INT are aliases
================================================================================

trap - SIGINT
echo $?
trap - INT
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap without args prints traps
================================================================================

trap 'echo exit' EXIT
echo status=$?

trap
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: print trap handler with multiple lines
================================================================================

trap 'echo 1
echo 2
echo 3' INT

trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap -p is like trap: it prints the handlers and full signal names
================================================================================

case $SH in dash) exit ;; esac
trap "echo INT" INT
trap "echo EXIT" EXIT
trap -p

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: Register the same handler for multiple signals
================================================================================

trap 'echo test' TERM 2 EXIT
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: Remove multiple handlers with trap -
================================================================================

trap "echo int" INT
trap "echo e" EXIT
trap - int 0 3
trap

echo ---
trap "echo int" INT
trap "echo e" EXIT
trap - int 0 -99
if test $? -ne 0; then
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT clears the EXIT trap
================================================================================

trap "echo INT" INT
trap "echo EXIT" EXIT
trap
echo ---
trap EXIT
trap
echo ---
trap INT
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap 0 is equivalent to trap EXIT
================================================================================

trap "echo INT" INT
trap "echo EXIT" 0  # EXIT
trap
echo ---
trap 0
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap 1 is equivalent to SIGHUP; HUP is equivalent to SIGHUP
================================================================================

trap 'echo HUP' SIGHUP
echo status=$?
trap 'echo HUP' HUP
echo status=$?
trap 'echo HUP' 1
echo status=$?
trap - HUP
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap 0 2 resets EXIT AND SIGINT
================================================================================


trap "echo EXIT" EXIT
echo ---
trap
echo ---
trap 0 2
trap
echo ---
trap "echo INT" INT
trap "echo EXIT" EXIT
trap 2 EXIT
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap '' EXIT - printing state
================================================================================


trap 'echo exit' EXIT
trap
echo

trap '' EXIT
trap
echo

trap '# comment' EXIT
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap 'echo hi' KILL (regression test, caught by smoosh suite)
================================================================================

trap 'echo hi' 9
echo status=$?

trap 'echo hi' KILL
echo status=$?

trap 'echo hi' STOP
echo status=$?

trap 'echo hi' TERM
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: exit 1 when trap code string is invalid
================================================================================

# All shells spew warnings to stderr, but don't actually exit!  Bad!
trap 'echo <' EXIT
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT calling exit
================================================================================

cleanup() {
  echo "cleanup [$@]"
  exit 42
}
trap 'cleanup x y z' EXIT

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT return status ignored
================================================================================

cleanup() {
  echo "cleanup [$@]"
  return 42
}
trap 'cleanup x y z' EXIT

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT with explicit exit
================================================================================

trap 'echo IN TRAP; echo $stdout' EXIT 
stdout=FOO
exit 42

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT with command sub / subshell / pipeline
================================================================================

trap 'echo EXIT TRAP' EXIT 

echo $(echo command sub)

( echo subshell )

echo pipeline | cat

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: eval in the exit trap (regression for issue #293)
================================================================================

trap 'eval "echo hi"' 0

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: exit codes for traps are isolated
================================================================================


trap 'echo USR1 trap status=$?; ( exit 42 )' USR1

echo before=$?

# Equivalent to 'kill -USR1 $$' except OSH doesn't have "kill" yet.
# /bin/kill doesn't exist on Debian unless 'procps' is installed.
sh -c "kill -USR1 $$"
echo after=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: traps are cleared in subshell (started with &)
================================================================================


# Test with SIGURG because the default handler is SIG_IGN
#
# If we use SIGUSR1, I think the shell reverts to killing the process

# https://man7.org/linux/man-pages/man7/signal.7.html

trap 'echo SIGURG' URG

kill -URG $$

# Hm trap doesn't happen here
{ echo begin child; sleep 0.1; echo end child; } &
kill -URG $!
wait
echo "wait status $?"

# In the CI, mksh sometimes gives:
#
# USR1
# begin child
# done
# 
# leaving off 'end child'.  This seems like a BUG to me?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap USR1, sleep, SIGINT: non-interactively
================================================================================


$REPO_ROOT/spec/testdata/builtin-trap-usr1.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap INT, sleep, SIGINT: non-interactively
================================================================================


# mksh behaves differently in CI -- maybe when it's not connected to a
# terminal?
case $SH in mksh) echo mksh; exit ;; esac

$REPO_ROOT/spec/testdata/builtin-trap-int.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap EXIT, sleep, SIGINT: non-interactively
================================================================================


$REPO_ROOT/spec/testdata/builtin-trap-exit.sh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: Remove trap with an unsigned integer
================================================================================


$SH -e -c '
trap "echo noprint" EXIT
trap 0 EXIT
echo ok0
'
echo

$SH -e -c '
trap "echo noprint" EXIT
trap " 42 " EXIT
echo ok42space
'
echo

# corner case: sometimes 07 is treated as octal, but not here
$SH -e -c '
trap "echo noprint" EXIT
trap 07 EXIT
echo ok07
'
echo

$SH -e -c '
trap "echo trap-exit" EXIT
trap -1 EXIT
echo bad
'
if test $? -ne 0; then
  echo failure
fi

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap '' sets handler to empty string (SIG_IGN)
================================================================================


# Note: this doesn't actually test that it's SIG_IGN

trap '' USR1
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap '' with multiple signals
================================================================================


trap '' USR1 USR2
trap

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-trap.test.sh: trap with command.NoOp - check internal invariant
================================================================================


$SH -c 'trap "> zz" EXIT'
wc -l zz  # should exist

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> function
================================================================================

f() { echo hi; }
type -t f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> alias
================================================================================

shopt -s expand_aliases
alias foo=bar
type -t foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> builtin
================================================================================

type -t echo read : [ declare local

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> keyword
================================================================================

type -t for time ! fi do {

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t control flow
================================================================================

type -t break continue return exit

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> file
================================================================================

type -t find xargs

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t doesn't find non-executable (like command -v)
================================================================================

PATH="$TMP:$PATH"
touch $TMP/non-executable
type -t non-executable

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -t -> not found
================================================================================

type -t echo ZZZ find ==
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -p and -P builtin -> file
================================================================================

touch /tmp/{mv,tar,grep}
chmod +x /tmp/{mv,tar,grep}
PATH=/tmp:$PATH

type -p mv tar grep
echo --
type -P mv tar grep

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -P gives multiple files
================================================================================


touch _tmp/pwd
chmod +x _tmp/pwd
PATH="_tmp:/bin"

type -a -P pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -p builtin -> not found
================================================================================

type -p FOO BAR NOT_FOUND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -p builtin -> not a file
================================================================================

type -p cd type builtin command

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -P builtin -> not found
================================================================================

type -P FOO BAR NOT_FOUND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -P builtin -> not a file
================================================================================

type -P cd type builtin command

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -P builtin -> not a file but file found
================================================================================

touch _tmp/{mv,tar,grep}
chmod +x _tmp/{mv,tar,grep}
PATH=_tmp:$PATH

mv () { ls; }
tar () { ls; }
grep () { ls; }
type -P mv tar grep cd builtin command type

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -f builtin -> not found
================================================================================

type -f FOO BAR NOT FOUND

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -f builtin -> function and file exists
================================================================================

touch /tmp/{mv,tar,grep}
chmod +x /tmp/{mv,tar,grep}
PATH=/tmp:$PATH

mv () { ls; }
tar () { ls; }
grep () { ls; }
type -f mv tar grep

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type prints function source code
================================================================================

f () { echo; }
type -a f
echo

type f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -ap -> function
================================================================================

f () { :; }
type -ap f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> alias; prints alias definition
================================================================================

shopt -s expand_aliases
alias ll="ls -lha"
type -a ll

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -ap -> alias
================================================================================

shopt -s expand_aliases
alias ll="ls -lha"
type -ap ll

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> builtin
================================================================================

type -a cd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -ap -> builtin
================================================================================

type -ap cd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> keyword
================================================================================

type -a while

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> file
================================================================================

touch _tmp/date
chmod +x _tmp/date
PATH=/bin:_tmp  # control output

type -a date

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -ap -> file; abbreviated
================================================================================

touch _tmp/date
chmod +x _tmp/date
PATH=/bin:_tmp  # control output

type -ap date

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> builtin and file
================================================================================

touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

type -a pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> builtin and file and shell function
================================================================================

touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

type -a pwd
echo ---

pwd () 
{ 
    echo function-too
}

osh-normalize() {
  sed 's/shell function/function/'
}

type -a pwd | osh-normalize
echo ---

type -a -f pwd | osh-normalize

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -ap -> builtin and file; doesn't print builtin or function
================================================================================

touch _tmp/pwd
chmod +x _tmp/pwd
PATH=/bin:_tmp  # control output

# Function is also ignored
pwd() { echo function-too; }

type -ap pwd
echo ---

type -p pwd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -a -> executable not in PATH
================================================================================

touch _tmp/executable
chmod +x _tmp/executable
type -a executable

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type-bash.test.sh: type -P does not find directories (regression)
================================================================================


mkdir -p _tmp
PATH="_tmp:$PATH"
mkdir _tmp/cat

type -P _tmp/cat
echo status=$?
type -P cat
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: type -> keyword builtin
================================================================================


type while cd

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: type -> alias external
================================================================================


mkdir -p _tmp
shopt -s expand_aliases || true  # bash

alias ll='ls -l'

touch _tmp/date
chmod +x _tmp/date
PATH=_tmp:/bin

normalize() {
  # ignore quotes and backticks
  # bash prints a left backtick
  quotes='"`'\'
  sed \
    -e "s/[$quotes]//g" \
    -e 's/shell function/function/' \
    -e 's/is aliased to/is an alias for/'
}

type ll date | normalize

# Note: both procs and funcs go in var namespace?  So they don't respond to
# 'type'?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: type of relative path
================================================================================


mkdir -p _tmp
touch _tmp/file _tmp/ex
chmod +x _tmp/ex

type _tmp/file _tmp/ex

# dash and ash don't care if it's executable
# mksh

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: type -> not found
================================================================================


type zz 2>err.txt
echo status=$?

# for bash and OSH: print to stderr
fgrep -o 'zz: not found' err.txt || true

# zsh and mksh behave the same - status 1
# dash and ash behave the same - status 127

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: special builtins are called out
================================================================================

type cd
type eval
type :
type true

echo
type export

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-type.test.sh: more special builtins
================================================================================

case $SH in bash|zsh|dash) exit ;; esac

type .
type source

# no agreement here!
# type local
# type typeset

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export sets a global variable
================================================================================

# Even after you do export -n, it still exists.
f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export sets a global variable that persists after export -n
================================================================================

f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL
export -n GLOBAL
echo $GLOBAL
printenv.py GLOBAL

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: export -n undefined is ignored
================================================================================

set -o errexit
export -n undef
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: export -n foo=bar not allowed
================================================================================

foo=old
export -n foo=new
echo status=$?
echo $foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export a global variable and unset it
================================================================================

f() { export GLOBAL=X; }
f
echo $GLOBAL
printenv.py GLOBAL
unset GLOBAL
echo g=$GLOBAL
printenv.py GLOBAL

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export existing global variables
================================================================================

G1=g1
G2=g2
export G1 G2
printenv.py G1 G2

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export existing local variable
================================================================================

f() {
  local L1=local1
  export L1
  printenv.py L1
}
f
printenv.py L1

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export a local that shadows a global
================================================================================

V=global
f() {
  local V=local1
  export V
  printenv.py V
}
f
printenv.py V  # exported local out of scope; global isn't exported yet
export V
printenv.py V  # now it's exported

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Export a variable before defining it
================================================================================

export U
U=u
printenv.py U

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset exported variable, then define it again.  It's NOT still exported.
================================================================================

export U
U=u
printenv.py U
unset U
printenv.py U
U=newvalue
echo $U
printenv.py U

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Exporting a parent func variable (dynamic scope)
================================================================================

# The algorithm is to walk up the stack and export that one.
inner() {
  export outer_var
  echo "inner: $outer_var"
  printenv.py outer_var
}
outer() {
  local outer_var=X
  echo "before inner"
  printenv.py outer_var
  inner
  echo "after inner"
  printenv.py outer_var
}
outer

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Dependent export setting
================================================================================

# FOO is not respected here either.
export FOO=foo v=$(printenv.py FOO)
echo "v=$v"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Exporting a variable doesn't change it
================================================================================

old=$PATH
export PATH
new=$PATH
test "$old" = "$new" && echo "not changed"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: can't export array (strict_array)
================================================================================

shopt -s strict_array

typeset -a a
a=(1 2 3)

export a
printenv.py a

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: can't export associative array (strict_array)
================================================================================

shopt -s strict_array

typeset -A a
a["foo"]=bar

export a
printenv.py a

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: assign to readonly variable
================================================================================

# bash doesn't abort unless errexit!
readonly foo=bar
foo=eggs
echo "status=$?"  # nothing happens

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Make an existing local variable readonly
================================================================================

f() {
	local x=local
	readonly x
	echo $x
	eval 'x=bar'  # Wrap in eval so it's not fatal
	echo status=$?
}
x=global
f
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: assign to readonly variable - errexit
================================================================================

set -o errexit
readonly foo=bar
foo=eggs
echo "status=$?"  # nothing happens

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset a variable
================================================================================

foo=bar
echo foo=$foo
unset foo
echo foo=$foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset exit status
================================================================================

V=123
unset V
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset nonexistent variable
================================================================================

unset ZZZ
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset readonly variable
================================================================================

# dash and zsh abort the whole program.   OSH doesn't?
readonly R=foo
unset R
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset a function without -f
================================================================================

f() {
  echo foo
}
f
unset f
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset has dynamic scope
================================================================================

f() {
  unset foo
}
foo=bar
echo foo=$foo
f
echo foo=$foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset and scope (bug #653)
================================================================================

unlocal() { unset "$@"; }

level2() {
  local hello=yy

  echo level2=$hello
  unlocal hello
  echo level2=$hello
}

level1() {
  local hello=xx

  level2

  echo level1=$hello
  unlocal hello
  echo level1=$hello

  level2
}

hello=global
level1

# bash, mksh, yash agree here.

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: unset of local reveals variable in higher scope
================================================================================


# OSH has a RARE behavior here (matching yash and mksh), but at least it's
# consistent.

x=global
f() {
  local x=foo
  echo x=$x
  unset x
  echo x=$x
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset invalid variable name
================================================================================

unset %
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset nonexistent variable
================================================================================

unset _nonexistent__
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset -v
================================================================================

foo() {
  echo "function foo"
}
foo=bar
unset -v foo
echo foo=$foo
foo

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset -f
================================================================================

foo() {
  echo "function foo"
}
foo=bar
unset -f foo
echo foo=$foo
foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset array member
================================================================================

a=(x y z)
unset 'a[1]'
echo status=$?
echo "${a[@]}" len="${#a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset errors
================================================================================

unset undef
echo status=$?

a=(x y z)
unset 'a[99]'  # out of range
echo status=$?

unset 'not_array[99]'  # not an array
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset wrong type
================================================================================

case $SH in mksh) exit ;; esac

declare undef
unset -v 'undef[1]'
echo undef $?
unset -v 'undef["key"]'
echo undef $?

declare a=(one two)
unset -v 'a[1]'
echo array $?

#shopt -s strict_arith || true
# In OSH, the string 'key' is converted to an integer, which is 0, unless
# strict_arith is on, when it fails.
unset -v 'a["key"]'
echo array $?

declare -A A=(['key']=val)
unset -v 'A[1]'
echo assoc $?
unset -v 'A["key"]'
echo assoc $?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: unset -v assoc (related to issue #661)
================================================================================


case $SH in dash|mksh|zsh) return ;; esac

declare -A dict=()
key=1],a[1
dict["$key"]=foo
echo ${#dict[@]}
echo keys=${!dict[@]}
echo vals=${dict[@]}

unset -v 'dict["$key"]'
echo ${#dict[@]}
echo keys=${!dict[@]}
echo vals=${dict[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: unset assoc errors
================================================================================


case $SH in dash|mksh) return ;; esac

declare -A assoc=(['key']=value)
unset 'assoc["nonexistent"]'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Unset array member with dynamic parsing
================================================================================


i=1
a=(w x y z)
unset 'a[ i - 1 ]' a[i+1]  # note: can't have space between a and [
echo status=$?
echo "${a[@]}" len="${#a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Use local twice
================================================================================

f() {
  local foo=bar
  local foo
  echo $foo
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: Local without variable is still unset!
================================================================================

set -o nounset
f() {
  local foo
  echo "[$foo]"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: local after readonly
================================================================================

f() { 
  readonly y
  local x=1 y=$(( x ))
  echo y=$y
}
f
echo y=$y

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: unset a[-1] (bf.bash regression)
================================================================================

case $SH in dash|zsh) exit ;; esac

a=(1 2 3)
unset a[-1]
echo len=${#a[@]}

echo last=${a[-1]}
(( last = a[-1] ))
echo last=$last

(( a[-1] = 42 ))
echo "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
builtin-vars.test.sh: unset a[-1] in sparse array (bf.bash regression)
================================================================================

case $SH in dash|zsh) exit ;; esac

a=(0 1 2 3 4)
unset a[1]
unset a[4]
echo len=${#a[@]} a=${a[@]}
echo last=${a[-1]} second=${a[-2]} third=${a[-3]}

echo ---
unset a[3]
echo len=${#a[@]} a=${a[@]}
echo last=${a[-1]} second=${a[-2]} third=${a[-3]}

--------------------------------------------------------------------------------

(program)
