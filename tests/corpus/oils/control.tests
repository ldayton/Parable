# Converted from Oils corpus: control.txt

=== Case statement
case a in
  a) echo A ;;
  *) echo star ;;
esac

for x in a b; do
  case $x in
    # the pattern is DYNAMIC and evaluated on every iteration
    $x) echo loop ;;
    *) echo star ;;
  esac
done
---
(case (word "a") (pattern ((word "a")) (command (word "echo") (word "A"))) (pattern ((word "*")) (command (word "echo") (word "star"))))
(for (word "x") (in (word "a") (word "b")) (case (word "$x") (pattern ((word "$x")) (command (word "echo") (word "loop"))) (pattern ((word "*")) (command (word "echo") (word "star")))))
---

=== Case statement with ;;&
# ;;& keeps testing conditions
# NOTE: ;& and ;;& are bash 4 only, not on Mac
case a in
  a) echo A ;;&
  *) echo star ;;&
  *) echo star2 ;;
esac
---
(case (word "a") (pattern ((word "a")) (command (word "echo") (word "A"))) (pattern ((word "*")) (command (word "echo") (word "star"))) (pattern ((word "*")) (command (word "echo") (word "star2"))))
---

=== Case statement with ;&
# ;& ignores the next condition.  Why would that be useful?

for x in aa bb cc dd zz; do
  case $x in
    aa) echo aa ;&
    bb) echo bb ;&
    cc) echo cc ;;
    dd) echo dd ;;
  esac
  echo --
done
---
(for (word "x") (in (word "aa") (word "bb") (word "cc") (word "dd") (word "zz")) (semi (case (word "$x") (pattern ((word "aa")) (command (word "echo") (word "aa"))) (pattern ((word "bb")) (command (word "echo") (word "bb"))) (pattern ((word "cc")) (command (word "echo") (word "cc"))) (pattern ((word "dd")) (command (word "echo") (word "dd")))) (command (word "echo") (word "--"))))
---

=== Case with empty condition
case $empty in
  ''|foo) echo match ;;
  *) echo no ;;
esac
---
(case (word "$empty") (pattern ((word "''") (word "foo")) (command (word "echo") (word "match"))) (pattern ((word "*")) (command (word "echo") (word "no"))))
---

=== Match a literal with a glob character
x='*.py'
case "$x" in
  '*.py') echo match ;;
esac
---
(command (word "x='*.py'"))
(case (word "\"$x\"") (pattern ((word "'*.py'")) (command (word "echo") (word "match"))))
---

=== Match a literal with a glob character with a dynamic pattern
x='b.py'
pat='[ab].py'
case "$x" in
  $pat) echo match ;;
esac
---
(command (word "x='b.py'"))
(command (word "pat='[ab].py'"))
(case (word "\"$x\"") (pattern ((word "$pat")) (command (word "echo") (word "match"))))
---

=== Quoted literal in glob pattern
x='[ab].py'
pat='[ab].py'
case "$x" in
  "$pat") echo match ;;
esac
---
(command (word "x='[ab].py'"))
(command (word "pat='[ab].py'"))
(case (word "\"$x\"") (pattern ((word "\"$pat\"")) (command (word "echo") (word "match"))))
---

=== Multiple Patterns Match
x=foo
result='-'
case "$x" in
  f*|*o) result="$result X"
esac
echo $result
---
(command (word "x=foo"))
(command (word "result='-'"))
(case (word "\"$x\"") (pattern ((word "f*") (word "*o")) (command (word "result=\"$result X\""))))
(command (word "echo") (word "$result"))
---

=== Pattern ? matches 1 code point (many bytes), but not multiple code points
# These two code points form a single character.
two_code_points="__$(echo $'\u0061\u0300')__"

# U+0061 is A, and U+0300 is an accent.  
#
# (Example taken from # https://blog.golang.org/strings)
#
# However ? in bash/zsh only counts CODE POINTS.  They do NOT take into account
# this case.

for s in '__a__' '__μ__' "$two_code_points"; do
  case $s in
    __?__)
      echo yes
      ;;
    *)
      echo no
  esac
done
---
(command (word "two_code_points=\"__$(echo 'à')__\""))
(for (word "s") (in (word "'__a__'") (word "'__μ__'") (word "\"$two_code_points\"")) (case (word "$s") (pattern ((word "__?__")) (command (word "echo") (word "yes"))) (pattern ((word "*")) (command (word "echo") (word "no")))))
---

=== matching the byte 0xff against empty string - DISABLED - CI only bug?
case $SH in *osh) echo soil-ci-buster-slim-bug; exit ;; esac

# This doesn't make a difference on my local machine?
# Is the underlying issue how libc fnmatch() respects Unicode?

#LC_ALL=C
#LC_ALL=C.UTF-8

c=$(printf \\377)

# OSH prints -1 here
#echo "${#c}"

case $c in
  '')   echo a ;;
  "$c") echo b ;;
esac

case "$c" in
  '')   echo a ;;
  "$c") echo b ;;
esac
---
(case (word "$SH") (pattern ((word "*osh")) (semi (command (word "echo") (word "soil-ci-buster-slim-bug")) (command (word "exit")))))
(command (word "c=$(printf \\\\377)"))
(case (word "$c") (pattern ((word "''")) (command (word "echo") (word "a"))) (pattern ((word "\"$c\"")) (command (word "echo") (word "b"))))
(case (word "\"$c\"") (pattern ((word "''")) (command (word "echo") (word "a"))) (pattern ((word "\"$c\"")) (command (word "echo") (word "b"))))
---

=== matching every byte against itself
# Why does OSH on the CI machine behave differently?  Probably a libc bug fix
# I'd guess?

sum=0

# note: NUL byte crashes OSH!
for i in $(seq 1 255); do
  hex=$(printf '%x' "$i")
  c="$(printf "\\x$hex")"  # command sub quirk: \n or \x0a turns into empty string

  #echo -n $c | od -A n -t x1
  #echo ${#c}

  case "$c" in
    # Newline matches empty string somehow.  All shells agree.  I guess
    # fnmatch() ignores trailing newline?
    #'')   echo "[empty i=$i hex=$hex c=$c]" ;;
    "$c") sum=$(( sum + 1 )) ;;
    *)   echo "[bug i=$i hex=$hex c=$c]" ;;
  esac
done

echo sum=$sum
---
(command (word "sum=0"))
(for (word "i") (in (word "$(seq 1 255)")) (semi (semi (command (word "hex=$(printf '%x' \"$i\")")) (command (word "c=\"$(printf \"\\\\x$hex\")\""))) (case (word "\"$c\"") (pattern ((word "\"$c\"")) (command (word "sum=$(( sum + 1 ))"))) (pattern ((word "*")) (command (word "echo") (word "\"[bug i=$i hex=$hex c=$c]\""))))))
(command (word "echo") (word "sum=$sum"))
---

=== \(\) in pattern (regression)
s='foo()'

case $s in
  *\(\)) echo 'match'
esac

case $SH in dash) exit ;; esac  # not implemented

shopt -s extglob

case $s in
  *(foo|bar)'()') echo 'extglob'
esac
---
(command (word "s='foo()'"))
(case (word "$s") (pattern ((word "*\\(\\)")) (command (word "echo") (word "'match'"))))
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "extglob"))
(case (word "$s") (pattern ((word "*(foo|bar)'()'")) (command (word "echo") (word "'extglob'"))))
---

=== Prefix env on assignment
f() {
  # NOTE: local treated like a special builtin!
  E=env local v=var
  echo $E $v
}
f
---
(function "f" (brace-group (semi (command (word "E=env") (word "local") (word "v=var")) (command (word "echo") (word "$E") (word "$v")))))
(command (word "f"))
---

=== Redirect on assignment (enabled 7/2019)
f() {
  # NOTE: local treated like a special builtin!
  local E=env > _tmp/r.txt
}
rm -f _tmp/r.txt
f
test -f _tmp/r.txt && echo REDIRECTED
---
(function "f" (brace-group (command (word "local") (word "E=env") (redirect ">" "_tmp/r.txt"))))
(command (word "rm") (word "-f") (word "_tmp/r.txt"))
(command (word "f"))
(and (command (word "test") (word "-f") (word "_tmp/r.txt")) (command (word "echo") (word "REDIRECTED")))
---

=== Prefix env on control flow
for x in a b c; do
  echo $x
  E=env break
done
---
(for (word "x") (in (word "a") (word "b") (word "c")) (semi (command (word "echo") (word "$x")) (command (word "E=env") (word "break"))))
---

=== Redirect on control flow (ignored in OSH)
rm -f _tmp/r.txt
for x in a b c; do
  break > _tmp/r.txt
done
if test -f _tmp/r.txt; then
  echo REDIRECTED
else
  echo NO
fi
---
(command (word "rm") (word "-f") (word "_tmp/r.txt"))
(for (word "x") (in (word "a") (word "b") (word "c")) (command (word "break") (redirect ">" "_tmp/r.txt")))
(if (command (word "test") (word "-f") (word "_tmp/r.txt")) (command (word "echo") (word "REDIRECTED")) (command (word "echo") (word "NO")))
---

=== Redirect on control flow with ysh:all (no_parse_ignored)
shopt -s ysh:all
rm -f _tmp/r.txt
for x in a b c; do
  break > _tmp/r.txt
done
test -f _tmp/r.txt && echo REDIRECTED
---
(command (word "shopt") (word "-s") (word "ysh:all"))
(command (word "rm") (word "-f") (word "_tmp/r.txt"))
(for (word "x") (in (word "a") (word "b") (word "c")) (command (word "break") (redirect ">" "_tmp/r.txt")))
(and (command (word "test") (word "-f") (word "_tmp/r.txt")) (command (word "echo") (word "REDIRECTED")))
---

=== C-style for loop
n=10
for ((a=1; a <= n ; a++))  # Double parentheses, and naked 'n'
do
  if test $a = 3; then
    continue
  fi
  if test $a = 6; then
    break
  fi
  echo $a
done
---
(command (word "n=10"))
(arith-for (init (word "a=1")) (test (word "a <= n ")) (step (word "a++")) (semi (semi (if (command (word "test") (word "$a") (word "=") (word "3")) (command (word "continue"))) (if (command (word "test") (word "$a") (word "=") (word "6")) (command (word "break")))) (command (word "echo") (word "$a"))))
---

=== For loop with and without semicolon
for ((a=1; a <= 3; a++)); do
  echo $a
done
for ((a=1; a <= 3; a++)) do
  echo $a
done
---
(arith-for (init (word "a=1")) (test (word "a <= 3")) (step (word "a++")) (command (word "echo") (word "$a")))
(arith-for (init (word "a=1")) (test (word "a <= 3")) (step (word "a++")) (command (word "echo") (word "$a")))
---

=== Accepts { } syntax too
for ((a=1; a <= 3; a++)) {
  echo $a
}
---
(arith-for (init (word "a=1")) (test (word "a <= 3")) (step (word "a++")) (command (word "echo") (word "$a")))
---

=== Empty init
i=1
for ((  ;i < 4;  i++ )); do
  echo $i
done
---
(command (word "i=1"))
(arith-for (init (word "1")) (test (word "i < 4")) (step (word "i++ ")) (command (word "echo") (word "$i")))
---

=== Empty init and cond
i=1
for ((  ; ;  i++ )); do
  if test $i = 4; then
    break
  fi
  echo $i
done
---
(command (word "i=1"))
(arith-for (init (word "1")) (test (word "1")) (step (word "i++ ")) (semi (if (command (word "test") (word "$i") (word "=") (word "4")) (command (word "break"))) (command (word "echo") (word "$i"))))
---

=== Infinite loop with ((;;))
a=1
for ((  ;  ;  )); do
  if test $a = 4; then
    break
  fi
  echo $((a++))
done
---
(command (word "a=1"))
(arith-for (init (word "1")) (test (word "1")) (step (word "1")) (semi (if (command (word "test") (word "$a") (word "=") (word "4")) (command (word "break"))) (command (word "echo") (word "$((a++))"))))
---

=== Arith lexer mode
# bash is lenient; zsh disagrees

for ((i = '3';  i < '5';  ++i)); do echo $i; done
for ((i = "3";  i < "5";  ++i)); do echo $i; done
for ((i = $'3'; i < $'5'; ++i)); do echo $i; done
for ((i = $"3"; i < $"5"; ++i)); do echo $i; done
---
(arith-for (init (word "i = '3'")) (test (word "i < '5'")) (step (word "++i")) (command (word "echo") (word "$i")))
(arith-for (init (word "i = \"3\"")) (test (word "i < \"5\"")) (step (word "++i")) (command (word "echo") (word "$i")))
(arith-for (init (word "i = '3'")) (test (word "i < '5'")) (step (word "++i")) (command (word "echo") (word "$i")))
(arith-for (init (word "i = \"3\"")) (test (word "i < \"5\"")) (step (word "++i")) (command (word "echo") (word "$i")))
---

=== Integers near 31, 32, 62 bits
# Hm this was never a bug, but it's worth testing.
# The bug was EvalToInt() in the condition.

for base in 31 32 62; do

  start=$(( (1 << $base) - 2))
  end=$(( (1 << $base) + 2))

  for ((i = start; i < end; ++i)); do
    echo $i
  done
  echo ---
done
---
(for (word "base") (in (word "31") (word "32") (word "62")) (semi (semi (semi (command (word "start=$(( (1 << $base) - 2))")) (command (word "end=$(( (1 << $base) + 2))"))) (arith-for (init (word "i = start")) (test (word "i < end")) (step (word "++i")) (command (word "echo") (word "$i")))) (command (word "echo") (word "---"))))
---

=== Condition that's greater than 32 bits
iters=0

for ((i = 1 << 32; i; ++i)); do
  echo $i
  iters=$(( iters + 1 ))
  if test $iters -eq 5; then
    break
  fi
done
---
(command (word "iters=0"))
(arith-for (init (word "i = 1 << 32")) (test (word "i")) (step (word "++i")) (semi (semi (command (word "echo") (word "$i")) (command (word "iters=$(( iters + 1 ))"))) (if (command (word "test") (word "$iters") (word "-eq") (word "5")) (command (word "break")))))
---

=== If
if true; then
  echo if
fi
---
(if (command (word "true")) (command (word "echo") (word "if")))
---

=== else
if false; then
  echo if
else
  echo else
fi
---
(if (command (word "false")) (command (word "echo") (word "if")) (command (word "echo") (word "else")))
---

=== elif
if (( 0 )); then
  echo if
elif true; then
  echo elif
else
  echo else
fi
---
(if (arith (word " 0 ")) (command (word "echo") (word "if")) (if (command (word "true")) (command (word "echo") (word "elif")) (command (word "echo") (word "else"))))
---

=== Long style
if [[ 0 -eq 1 ]]
then
  echo if
  echo if
elif true
then
  echo elif
else
  echo else
  echo else
fi
---
(if (cond (cond-binary "-eq" (cond-term "0") (cond-term "1"))) (semi (command (word "echo") (word "if")) (command (word "echo") (word "if"))) (if (command (word "true")) (command (word "echo") (word "elif")) (semi (command (word "echo") (word "else")) (command (word "echo") (word "else")))))
---

=== if break corner case
# This is analogous to the 'while' case in spec/loop
f() {
  if break; then
    echo hi
  fi
}
f
---
(function "f" (brace-group (if (command (word "break")) (command (word "echo") (word "hi")))))
(command (word "f"))
---

=== `set` output format - ifupdown-ng
export FOO=bar
set | grep bar | head -n 1
---
(command (word "export") (word "FOO=bar"))
(pipe (command (word "set")) (pipe (command (word "grep") (word "bar")) (command (word "head") (word "-n") (word "1"))))
---

=== implicit for loop
# This is like "for i in $@".
fun() {
  for i; do
    echo $i
  done
  echo "finished=$i"
}
fun 1 2 3
---
(function "fun" (brace-group (semi (for (word "i") (in (word "\"$@\"")) (command (word "echo") (word "$i"))) (command (word "echo") (word "\"finished=$i\"")))))
(command (word "fun") (word "1") (word "2") (word "3"))
---

=== empty for loop (has "in")
set -- 1 2 3
for i in ; do
  echo $i
done
---
(command (word "set") (word "--") (word "1") (word "2") (word "3"))
(for (word "i") (in) (command (word "echo") (word "$i")))
---

=== for loop with invalid identifier
# should be compile time error, but runtime error is OK too
for - in a b c; do
  echo hi
done
---
(for (word "-") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "hi")))
---

=== the word 'in' can be the loop variable
for in in a b c; do
  echo $in
done
echo finished=$in
---
(for (word "in") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$in")))
(command (word "echo") (word "finished=$in"))
---

=== Tilde expansion within for loop
HOME=/home/bob
for name in ~/src ~/git; do
  echo $name
done
---
(command (word "HOME=/home/bob"))
(for (word "name") (in (word "~/src") (word "~/git")) (command (word "echo") (word "$name")))
---

=== Brace Expansion within Array
for i in -{a,b} {c,d}-; do
  echo $i
  done
---
(for (word "i") (in (word "-{a,b}") (word "{c,d}-")) (command (word "echo") (word "$i")))
---

=== using loop var outside loop
fun() {
  for i in a b c; do
    echo $i
  done
  echo $i
}
fun
---
(function "fun" (brace-group (semi (for (word "i") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$i"))) (command (word "echo") (word "$i")))))
(command (word "fun"))
---

=== continue
for i in a b c; do
  echo $i
  if test $i = b; then
    continue
  fi
  echo $i
done
---
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (semi (command (word "echo") (word "$i")) (if (command (word "test") (word "$i") (word "=") (word "b")) (command (word "continue")))) (command (word "echo") (word "$i"))))
---

=== break
for i in a b c; do
  echo $i
  if test $i = b; then
    break
  fi
done
---
(for (word "i") (in (word "a") (word "b") (word "c")) (semi (command (word "echo") (word "$i")) (if (command (word "test") (word "$i") (word "=") (word "b")) (command (word "break")))))
---

=== while in while condition
# This is a consequence of the grammar
while while true; do echo cond; break; done
do
  echo body
  break
done
---
(while (while (command (word "true")) (semi (command (word "echo") (word "cond")) (command (word "break")))) (semi (command (word "echo") (word "body")) (command (word "break"))))
---

=== while in pipe
x=$(find spec/ | wc -l)
y=$(find spec/ | while read path; do
  echo $path
done | wc -l
)
test $x -eq $y
echo status=$?
---
(command (word "x=$(find spec/ | wc -l)"))
(command (word "y=$(find spec/ | while read path; do\n    echo $path;\ndone | wc -l)"))
(command (word "test") (word "$x") (word "-eq") (word "$y"))
(command (word "echo") (word "status=$?"))
---

=== while in pipe with subshell
i=0
seq 3 | ( while read foo; do
  i=$((i+1))
  #echo $i
done
echo $i )
---
(command (word "i=0"))
(pipe (command (word "seq") (word "3")) (subshell (semi (while (command (word "read") (word "foo")) (command (word "i=$((i+1))"))) (command (word "echo") (word "$i")))))
---

=== until loop
# This is just the opposite of while?  while ! cond?
until false; do
  echo hi
  break
done
---
(until (command (word "false")) (semi (command (word "echo") (word "hi")) (command (word "break"))))
---

=== continue at top level
if true; then
  echo one
  continue
  echo two
fi
---
(if (command (word "true")) (semi (semi (command (word "echo") (word "one")) (command (word "continue"))) (command (word "echo") (word "two"))))
---

=== continue in subshell
for i in $(seq 2); do
  echo "> $i"
  ( if true; then continue; fi; echo "Should not print" )
  echo subshell status=$?
  echo ". $i"
done
---
(for (word "i") (in (word "$(seq 2)")) (semi (semi (semi (command (word "echo") (word "\"> $i\"")) (subshell (semi (if (command (word "true")) (command (word "continue"))) (command (word "echo") (word "\"Should not print\""))))) (command (word "echo") (word "subshell") (word "status=$?"))) (command (word "echo") (word "\". $i\""))))
---

=== continue in subshell aborts with errexit
# The other shells don't let you recover from this programming error!
set -o errexit
for i in $(seq 2); do
  echo "> $i"
  ( if true; then continue; fi; echo "Should not print" )
  echo 'should fail after subshell'
  echo ". $i"
done
---
(command (word "set") (word "-o") (word "errexit"))
(for (word "i") (in (word "$(seq 2)")) (semi (semi (semi (command (word "echo") (word "\"> $i\"")) (subshell (semi (if (command (word "true")) (command (word "continue"))) (command (word "echo") (word "\"Should not print\""))))) (command (word "echo") (word "'should fail after subshell'"))) (command (word "echo") (word "\". $i\""))))
---

=== bad arg to break
x=oops
while true; do 
  echo hi
  break $x
  sleep 0.1
done
---
(command (word "x=oops"))
(while (command (word "true")) (semi (semi (command (word "echo") (word "hi")) (command (word "break") (word "$x"))) (command (word "sleep") (word "0.1"))))
---

=== too many args to continue
# OSH treats this as a parse error
for x in a b c; do
  echo $x
  # bash breaks rather than continue or fatal error!!!
  continue 1 2 3
done
echo --
---
(for (word "x") (in (word "a") (word "b") (word "c")) (semi (command (word "echo") (word "$x")) (command (word "continue") (word "1") (word "2") (word "3"))))
(command (word "echo") (word "--"))
---

=== break in condition of loop
while break; do
  echo x
done
echo done
---
(while (command (word "break")) (command (word "echo") (word "x")))
(command (word "echo") (word "done"))
---

=== break in condition of nested loop
for i in 1 2 3; do
  echo i=$i
  while break; do
    echo x
  done
done
echo done
---
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "i=$i")) (while (command (word "break")) (command (word "echo") (word "x")))))
(command (word "echo") (word "done"))
---

=== return within eval
f() {
  echo one
  eval 'return'
  echo two
}
f
---
(function "f" (brace-group (semi (semi (command (word "echo") (word "one")) (command (word "eval") (word "'return'"))) (command (word "echo") (word "two")))))
(command (word "f"))
---

=== break/continue within eval
# NOTE: This changes things
# set -e
f() {
  for i in $(seq 5); do 
    if test $i = 2; then
      eval continue
    fi
    if test $i = 4; then
      eval break
    fi
    echo $i
  done

  eval 'return'
  echo 'done'
}
f
---
(function "f" (brace-group (semi (semi (for (word "i") (in (word "$(seq 5)")) (semi (semi (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "eval") (word "continue"))) (if (command (word "test") (word "$i") (word "=") (word "4")) (command (word "eval") (word "break")))) (command (word "echo") (word "$i")))) (command (word "eval") (word "'return'"))) (command (word "echo") (word "'done'")))))
(command (word "f"))
---

=== break/continue within source
# NOTE: This changes things
# set -e

cd $REPO_ROOT
f() {
  for i in $(seq 5); do 
    if test $i = 2; then
      . spec/testdata/continue.sh
    fi
    if test $i = 4; then
      . spec/testdata/break.sh
    fi
    echo $i
  done

  # Return is different!
  . spec/testdata/return.sh
  echo done
}
f
---
(command (word "cd") (word "$REPO_ROOT"))
(function "f" (brace-group (semi (semi (for (word "i") (in (word "$(seq 5)")) (semi (semi (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word ".") (word "spec/testdata/continue.sh"))) (if (command (word "test") (word "$i") (word "=") (word "4")) (command (word ".") (word "spec/testdata/break.sh")))) (command (word "echo") (word "$i")))) (command (word ".") (word "spec/testdata/return.sh"))) (command (word "echo") (word "done")))))
(command (word "f"))
---

=== top-level break/continue/return (without strict_control_flow)
$SH -c 'break; echo break=$?'
$SH -c 'continue; echo continue=$?'
$SH -c 'return; echo return=$?'
---
(command (word "$SH") (word "-c") (word "'break; echo break=$?'"))
(command (word "$SH") (word "-c") (word "'continue; echo continue=$?'"))
(command (word "$SH") (word "-c") (word "'return; echo return=$?'"))
---

=== multi-level break with argument
# reported in issue #1459

counterA=100
counterB=100

while test "$counterA" -gt 0
do
    counterA=$((counterA - 1))
    while test "$counterB" -gt 0
    do
        counterB=$((counterB - 1))
        if test "$counterB" = 50
        then
            break 2
        fi
    done
done

echo "$counterA"
echo "$counterB"
---
(command (word "counterA=100"))
(command (word "counterB=100"))
(while (command (word "test") (word "\"$counterA\"") (word "-gt") (word "0")) (semi (command (word "counterA=$((counterA - 1))")) (while (command (word "test") (word "\"$counterB\"") (word "-gt") (word "0")) (semi (command (word "counterB=$((counterB - 1))")) (if (command (word "test") (word "\"$counterB\"") (word "=") (word "50")) (command (word "break") (word "2")))))))
(command (word "echo") (word "\"$counterA\""))
(command (word "echo") (word "\"$counterB\""))
---

=== multi-level continue
for i in 1 2; do
  for j in a b c; do
    if test $j = b; then
      continue
    fi
    echo $i $j
  done
done

echo ---

for i in 1 2; do
  for j in a b c; do
    if test $j = b; then
      continue 2   # MULTI-LEVEL
    fi
    echo $i $j
  done
done
---
(for (word "i") (in (word "1") (word "2")) (for (word "j") (in (word "a") (word "b") (word "c")) (semi (if (command (word "test") (word "$j") (word "=") (word "b")) (command (word "continue"))) (command (word "echo") (word "$i") (word "$j")))))
(command (word "echo") (word "---"))
(for (word "i") (in (word "1") (word "2")) (for (word "j") (in (word "a") (word "b") (word "c")) (semi (if (command (word "test") (word "$j") (word "=") (word "b")) (command (word "continue") (word "2"))) (command (word "echo") (word "$i") (word "$j")))))
---

=== $b break, $c continue, $r return, $e exit
# hm would it be saner to make FATAL builtins called break/continue/etc.?
# On the other hand, this spits out errors loudly.

echo '- break'
b=break
for i in 1 2 3; do
  echo $i
  $b
done

echo '- continue'
c='continue'
for i in 1 2 3; do
  if test $i = 2; then
    $c
  fi
  echo $i
done

r='return'
f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      $r 99
    fi
  done
}
f
echo status=$?

echo '- exit'
e='exit'
$e 5
echo 'not executed'
---
(command (word "echo") (word "'- break'"))
(command (word "b=break"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (command (word "$b"))))
(command (word "echo") (word "'- continue'"))
(command (word "c='continue'"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "$c"))) (command (word "echo") (word "$i"))))
(command (word "r='return'"))
(function "f" (brace-group (semi (command (word "echo") (word "'- return'")) (for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "$r") (word "99"))))))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "'- exit'"))
(command (word "e='exit'"))
(command (word "$e") (word "5"))
(command (word "echo") (word "'not executed'"))
---

=== \break \continue \return \exit
echo '- break'
for i in 1 2 3; do
  echo $i
  \break
done

echo '- continue'
for i in 1 2 3; do
  if test $i = 2; then
    \continue
  fi
  echo $i
done

f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      \return 99
    fi
  done
}
f
echo status=$?

echo '- exit'
\exit 5
echo 'not executed'
---
(command (word "echo") (word "'- break'"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (command (word "\\break"))))
(command (word "echo") (word "'- continue'"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "\\continue"))) (command (word "echo") (word "$i"))))
(function "f" (brace-group (semi (command (word "echo") (word "'- return'")) (for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "\\return") (word "99"))))))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "'- exit'"))
(command (word "\\exit") (word "5"))
(command (word "echo") (word "'not executed'"))
---

=== builtin,command break,continue,return,exit
case $SH in dash|zsh) exit ;; esac

echo '- break'
for i in 1 2 3; do
  echo $i
  builtin break
done

echo '- continue'
for i in 1 2 3; do
  if test $i = 2; then
    command continue
  fi
  echo $i
done

f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      builtin command return 99
    fi
  done
}
f
echo status=$?

echo '- exit'
command builtin exit 5
echo 'not executed'
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "echo") (word "'- break'"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (command (word "builtin") (word "break"))))
(command (word "echo") (word "'- continue'"))
(for (word "i") (in (word "1") (word "2") (word "3")) (semi (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "command") (word "continue"))) (command (word "echo") (word "$i"))))
(function "f" (brace-group (semi (command (word "echo") (word "'- return'")) (for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (if (command (word "test") (word "$i") (word "=") (word "2")) (command (word "builtin") (word "command") (word "return") (word "99"))))))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "'- exit'"))
(command (word "command") (word "builtin") (word "exit") (word "5"))
(command (word "echo") (word "'not executed'"))
---

=== [[ equality matching
shopt -s nocasematch
[[ a == A ]]; echo $?
[[ A == a ]]; echo $?
[[ A == [a] ]]; echo $?
[[ a == [A] ]]; echo $?
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(semi (cond (cond-binary "==" (cond-term "a") (cond-term "A"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "==" (cond-term "A") (cond-term "a"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "==" (cond-term "A") (cond-term "[a]"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "==" (cond-term "a") (cond-term "[A]"))) (command (word "echo") (word "$?")))
---

=== [[ regex matching
shopt -s nocasematch
[[ a =~ A ]]; echo $?
[[ A =~ a ]]; echo $?
[[ a =~ [A] ]]; echo $?
[[ A =~ [a] ]]; echo $?
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(semi (cond (cond-binary "=~" (cond-term "a") (cond-term "A"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "=~" (cond-term "A") (cond-term "a"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "=~" (cond-term "a") (cond-term "[A]"))) (command (word "echo") (word "$?")))
(semi (cond (cond-binary "=~" (cond-term "A") (cond-term "[a]"))) (command (word "echo") (word "$?")))
---

=== [ matching
shopt -s nocasematch
[ a = A ]; echo $?
[ A = a ]; echo $?
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(semi (command (word "[") (word "a") (word "=") (word "A") (word "]")) (command (word "echo") (word "$?")))
(semi (command (word "[") (word "A") (word "=") (word "a") (word "]")) (command (word "echo") (word "$?")))
---

=== case matching
shopt -s nocasematch
case a in A) echo 0 ;; *) echo 1 ;; esac
case A in a) echo 0 ;; *) echo 1 ;; esac
case a in [A]) echo 0 ;; *) echo 1 ;; esac
case A in [a]) echo 0 ;; *) echo 1 ;; esac
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(case (word "a") (pattern ((word "A")) (command (word "echo") (word "0"))) (pattern ((word "*")) (command (word "echo") (word "1"))))
(case (word "A") (pattern ((word "a")) (command (word "echo") (word "0"))) (pattern ((word "*")) (command (word "echo") (word "1"))))
(case (word "a") (pattern ((word "[A]")) (command (word "echo") (word "0"))) (pattern ((word "*")) (command (word "echo") (word "1"))))
(case (word "A") (pattern ((word "[a]")) (command (word "echo") (word "0"))) (pattern ((word "*")) (command (word "echo") (word "1"))))
---

=== file matching
shopt -s nocasematch
touch a B
echo [A] [b]
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(command (word "touch") (word "a") (word "B"))
(command (word "echo") (word "[A]") (word "[b]"))
---

=== parameter expansion matching
shopt -s nocasematch
foo=a
bar=A
echo "${foo#A}" "${foo#[A]}"
echo "${bar#a}" "${bar#[a]}"
---
(command (word "shopt") (word "-s") (word "nocasematch"))
(command (word "foo=a"))
(command (word "bar=A"))
(command (word "echo") (word "\"${foo#A}\"") (word "\"${foo#[A]}\""))
(command (word "echo") (word "\"${bar#a}\"") (word "\"${bar#[a]}\""))
---
