================================================================================
case_.test.sh: Case statement
================================================================================

case a in
  a) echo A ;;
  *) echo star ;;
esac

for x in a b; do
  case $x in
    # the pattern is DYNAMIC and evaluated on every iteration
    $x) echo loop ;;
    *) echo star ;;
  esac
done

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Case statement with ;;&
================================================================================

# ;;& keeps testing conditions
# NOTE: ;& and ;;& are bash 4 only, not on Mac
case a in
  a) echo A ;;&
  *) echo star ;;&
  *) echo star2 ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Case statement with ;&
================================================================================

# ;& ignores the next condition.  Why would that be useful?

for x in aa bb cc dd zz; do
  case $x in
    aa) echo aa ;&
    bb) echo bb ;&
    cc) echo cc ;;
    dd) echo dd ;;
  esac
  echo --
done

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Case with empty condition
================================================================================

case $empty in
  ''|foo) echo match ;;
  *) echo no ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Match a literal with a glob character
================================================================================

x='*.py'
case "$x" in
  '*.py') echo match ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Match a literal with a glob character with a dynamic pattern
================================================================================

x='b.py'
pat='[ab].py'
case "$x" in
  $pat) echo match ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Quoted literal in glob pattern
================================================================================

x='[ab].py'
pat='[ab].py'
case "$x" in
  "$pat") echo match ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Multiple Patterns Match
================================================================================

x=foo
result='-'
case "$x" in
  f*|*o) result="$result X"
esac
echo $result

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: Pattern ? matches 1 code point (many bytes), but not multiple code points
================================================================================


# These two code points form a single character.
two_code_points="__$(echo $'\u0061\u0300')__"

# U+0061 is A, and U+0300 is an accent.  
#
# (Example taken from # https://blog.golang.org/strings)
#
# However ? in bash/zsh only counts CODE POINTS.  They do NOT take into account
# this case.

for s in '__a__' '__Î¼__' "$two_code_points"; do
  case $s in
    __?__)
      echo yes
      ;;
    *)
      echo no
  esac
done

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: matching the byte 0xff against empty string - DISABLED - CI only bug?
================================================================================


case $SH in *osh) echo soil-ci-buster-slim-bug; exit ;; esac

# This doesn't make a difference on my local machine?
# Is the underlying issue how libc fnmatch() respects Unicode?

#LC_ALL=C
#LC_ALL=C.UTF-8

c=$(printf \\377)

# OSH prints -1 here
#echo "${#c}"

case $c in
  '')   echo a ;;
  "$c") echo b ;;
esac

case "$c" in
  '')   echo a ;;
  "$c") echo b ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: matching every byte against itself
================================================================================


# Why does OSH on the CI machine behave differently?  Probably a libc bug fix
# I'd guess?

sum=0

# note: NUL byte crashes OSH!
for i in $(seq 1 255); do
  hex=$(printf '%x' "$i")
  c="$(printf "\\x$hex")"  # command sub quirk: \n or \x0a turns into empty string

  #echo -n $c | od -A n -t x1
  #echo ${#c}

  case "$c" in
    # Newline matches empty string somehow.  All shells agree.  I guess
    # fnmatch() ignores trailing newline?
    #'')   echo "[empty i=$i hex=$hex c=$c]" ;;
    "$c") sum=$(( sum + 1 )) ;;
    *)   echo "[bug i=$i hex=$hex c=$c]" ;;
  esac
done

echo sum=$sum

--------------------------------------------------------------------------------

(program)

================================================================================
case_.test.sh: \(\) in pattern (regression)
================================================================================

s='foo()'

case $s in
  *\(\)) echo 'match'
esac

case $SH in dash) exit ;; esac  # not implemented

shopt -s extglob

case $s in
  *(foo|bar)'()') echo 'extglob'
esac

--------------------------------------------------------------------------------

(program)

================================================================================
command-parsing.test.sh: Prefix env on assignment
================================================================================

f() {
  # NOTE: local treated like a special builtin!
  E=env local v=var
  echo $E $v
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
command-parsing.test.sh: Redirect on assignment (enabled 7/2019)
================================================================================

f() {
  # NOTE: local treated like a special builtin!
  local E=env > _tmp/r.txt
}
rm -f _tmp/r.txt
f
test -f _tmp/r.txt && echo REDIRECTED

--------------------------------------------------------------------------------

(program)

================================================================================
command-parsing.test.sh: Prefix env on control flow
================================================================================

for x in a b c; do
  echo $x
  E=env break
done

--------------------------------------------------------------------------------

(program)

================================================================================
command-parsing.test.sh: Redirect on control flow (ignored in OSH)
================================================================================

rm -f _tmp/r.txt
for x in a b c; do
  break > _tmp/r.txt
done
if test -f _tmp/r.txt; then
  echo REDIRECTED
else
  echo NO
fi

--------------------------------------------------------------------------------

(program)

================================================================================
command-parsing.test.sh: Redirect on control flow with ysh:all (no_parse_ignored)
================================================================================

shopt -s ysh:all
rm -f _tmp/r.txt
for x in a b c; do
  break > _tmp/r.txt
done
test -f _tmp/r.txt && echo REDIRECTED

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: C-style for loop
================================================================================

n=10
for ((a=1; a <= n ; a++))  # Double parentheses, and naked 'n'
do
  if test $a = 3; then
    continue
  fi
  if test $a = 6; then
    break
  fi
  echo $a
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: For loop with and without semicolon
================================================================================

for ((a=1; a <= 3; a++)); do
  echo $a
done
for ((a=1; a <= 3; a++)) do
  echo $a
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Accepts { } syntax too
================================================================================

for ((a=1; a <= 3; a++)) {
  echo $a
}

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Empty init
================================================================================

i=1
for ((  ;i < 4;  i++ )); do
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Empty init and cond
================================================================================

i=1
for ((  ; ;  i++ )); do
  if test $i = 4; then
    break
  fi
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Infinite loop with ((;;))
================================================================================

a=1
for ((  ;  ;  )); do
  if test $a = 4; then
    break
  fi
  echo $((a++))
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Arith lexer mode
================================================================================


# bash is lenient; zsh disagrees

for ((i = '3';  i < '5';  ++i)); do echo $i; done
for ((i = "3";  i < "5";  ++i)); do echo $i; done
for ((i = $'3'; i < $'5'; ++i)); do echo $i; done
for ((i = $"3"; i < $"5"; ++i)); do echo $i; done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Integers near 31, 32, 62 bits
================================================================================


# Hm this was never a bug, but it's worth testing.
# The bug was EvalToInt() in the condition.

for base in 31 32 62; do

  start=$(( (1 << $base) - 2))
  end=$(( (1 << $base) + 2))

  for ((i = start; i < end; ++i)); do
    echo $i
  done
  echo ---
done

--------------------------------------------------------------------------------

(program)

================================================================================
for-expr.test.sh: Condition that's greater than 32 bits
================================================================================


iters=0

for ((i = 1 << 32; i; ++i)); do
  echo $i
  iters=$(( iters + 1 ))
  if test $iters -eq 5; then
    break
  fi
done

--------------------------------------------------------------------------------

(program)

================================================================================
if_.test.sh: If
================================================================================

if true; then
  echo if
fi

--------------------------------------------------------------------------------

(program)

================================================================================
if_.test.sh: else
================================================================================

if false; then
  echo if
else
  echo else
fi

--------------------------------------------------------------------------------

(program)

================================================================================
if_.test.sh: elif
================================================================================

if (( 0 )); then
  echo if
elif true; then
  echo elif
else
  echo else
fi

--------------------------------------------------------------------------------

(program)

================================================================================
if_.test.sh: Long style
================================================================================

if [[ 0 -eq 1 ]]
then
  echo if
  echo if
elif true
then
  echo elif
else
  echo else
  echo else
fi

--------------------------------------------------------------------------------

(program)

================================================================================
if_.test.sh: if break corner case
================================================================================


# This is analogous to the 'while' case in spec/loop
f() {
  if break; then
    echo hi
  fi
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
known-differences.test.sh: `set` output format - ifupdown-ng
================================================================================

export FOO=bar
set | grep bar | head -n 1

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: implicit for loop
================================================================================

# This is like "for i in $@".
fun() {
  for i; do
    echo $i
  done
  echo "finished=$i"
}
fun 1 2 3

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: empty for loop (has "in")
================================================================================

set -- 1 2 3
for i in ; do
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: for loop with invalid identifier
================================================================================

# should be compile time error, but runtime error is OK too
for - in a b c; do
  echo hi
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: the word 'in' can be the loop variable
================================================================================


for in in a b c; do
  echo $in
done
echo finished=$in

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: Tilde expansion within for loop
================================================================================

HOME=/home/bob
for name in ~/src ~/git; do
  echo $name
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: Brace Expansion within Array
================================================================================

for i in -{a,b} {c,d}-; do
  echo $i
  done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: using loop var outside loop
================================================================================

fun() {
  for i in a b c; do
    echo $i
  done
  echo $i
}
fun

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: continue
================================================================================

for i in a b c; do
  echo $i
  if test $i = b; then
    continue
  fi
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: break
================================================================================

for i in a b c; do
  echo $i
  if test $i = b; then
    break
  fi
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: while in while condition
================================================================================

# This is a consequence of the grammar
while while true; do echo cond; break; done
do
  echo body
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: while in pipe
================================================================================

x=$(find spec/ | wc -l)
y=$(find spec/ | while read path; do
  echo $path
done | wc -l
)
test $x -eq $y
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: while in pipe with subshell
================================================================================

i=0
seq 3 | ( while read foo; do
  i=$((i+1))
  #echo $i
done
echo $i )

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: until loop
================================================================================

# This is just the opposite of while?  while ! cond?
until false; do
  echo hi
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: continue at top level
================================================================================

if true; then
  echo one
  continue
  echo two
fi

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: continue in subshell
================================================================================

for i in $(seq 2); do
  echo "> $i"
  ( if true; then continue; fi; echo "Should not print" )
  echo subshell status=$?
  echo ". $i"
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: continue in subshell aborts with errexit
================================================================================

# The other shells don't let you recover from this programming error!
set -o errexit
for i in $(seq 2); do
  echo "> $i"
  ( if true; then continue; fi; echo "Should not print" )
  echo 'should fail after subshell'
  echo ". $i"
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: bad arg to break
================================================================================

x=oops
while true; do 
  echo hi
  break $x
  sleep 0.1
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: too many args to continue
================================================================================

# OSH treats this as a parse error
for x in a b c; do
  echo $x
  # bash breaks rather than continue or fatal error!!!
  continue 1 2 3
done
echo --

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: break in condition of loop
================================================================================

while break; do
  echo x
done
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: break in condition of nested loop
================================================================================

for i in 1 2 3; do
  echo i=$i
  while break; do
    echo x
  done
done
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: return within eval
================================================================================

f() {
  echo one
  eval 'return'
  echo two
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: break/continue within eval
================================================================================

# NOTE: This changes things
# set -e
f() {
  for i in $(seq 5); do 
    if test $i = 2; then
      eval continue
    fi
    if test $i = 4; then
      eval break
    fi
    echo $i
  done

  eval 'return'
  echo 'done'
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: break/continue within source
================================================================================

# NOTE: This changes things
# set -e

cd $REPO_ROOT
f() {
  for i in $(seq 5); do 
    if test $i = 2; then
      . spec/testdata/continue.sh
    fi
    if test $i = 4; then
      . spec/testdata/break.sh
    fi
    echo $i
  done

  # Return is different!
  . spec/testdata/return.sh
  echo done
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: top-level break/continue/return (without strict_control_flow)
================================================================================

$SH -c 'break; echo break=$?'
$SH -c 'continue; echo continue=$?'
$SH -c 'return; echo return=$?'

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: multi-level break with argument
================================================================================


# reported in issue #1459

counterA=100
counterB=100

while test "$counterA" -gt 0
do
    counterA=$((counterA - 1))
    while test "$counterB" -gt 0
    do
        counterB=$((counterB - 1))
        if test "$counterB" = 50
        then
            break 2
        fi
    done
done

echo "$counterA"
echo "$counterB"

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: multi-level continue
================================================================================


for i in 1 2; do
  for j in a b c; do
    if test $j = b; then
      continue
    fi
    echo $i $j
  done
done

echo ---

for i in 1 2; do
  for j in a b c; do
    if test $j = b; then
      continue 2   # MULTI-LEVEL
    fi
    echo $i $j
  done
done

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: $b break, $c continue, $r return, $e exit
================================================================================


# hm would it be saner to make FATAL builtins called break/continue/etc.?
# On the other hand, this spits out errors loudly.

echo '- break'
b=break
for i in 1 2 3; do
  echo $i
  $b
done

echo '- continue'
c='continue'
for i in 1 2 3; do
  if test $i = 2; then
    $c
  fi
  echo $i
done

r='return'
f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      $r 99
    fi
  done
}
f
echo status=$?

echo '- exit'
e='exit'
$e 5
echo 'not executed'

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: \break \continue \return \exit
================================================================================


echo '- break'
for i in 1 2 3; do
  echo $i
  \break
done

echo '- continue'
for i in 1 2 3; do
  if test $i = 2; then
    \continue
  fi
  echo $i
done

f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      \return 99
    fi
  done
}
f
echo status=$?

echo '- exit'
\exit 5
echo 'not executed'

--------------------------------------------------------------------------------

(program)

================================================================================
loop.test.sh: builtin,command break,continue,return,exit
================================================================================

case $SH in dash|zsh) exit ;; esac

echo '- break'
for i in 1 2 3; do
  echo $i
  builtin break
done

echo '- continue'
for i in 1 2 3; do
  if test $i = 2; then
    command continue
  fi
  echo $i
done

f() {
  echo '- return'
  for i in 1 2 3; do
    echo $i
    if test $i = 2; then
      builtin command return 99
    fi
  done
}
f
echo status=$?

echo '- exit'
command builtin exit 5
echo 'not executed'

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: [[ equality matching
================================================================================

shopt -s nocasematch
[[ a == A ]]; echo $?
[[ A == a ]]; echo $?
[[ A == [a] ]]; echo $?
[[ a == [A] ]]; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: [[ regex matching
================================================================================

shopt -s nocasematch
[[ a =~ A ]]; echo $?
[[ A =~ a ]]; echo $?
[[ a =~ [A] ]]; echo $?
[[ A =~ [a] ]]; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: [ matching
================================================================================

shopt -s nocasematch
[ a = A ]; echo $?
[ A = a ]; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: case matching
================================================================================

shopt -s nocasematch
case a in A) echo 0 ;; *) echo 1 ;; esac
case A in a) echo 0 ;; *) echo 1 ;; esac
case a in [A]) echo 0 ;; *) echo 1 ;; esac
case A in [a]) echo 0 ;; *) echo 1 ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: file matching
================================================================================

shopt -s nocasematch
touch a B
echo [A] [b]

--------------------------------------------------------------------------------

(program)

================================================================================
nocasematch-match.test.sh: parameter expansion matching
================================================================================

shopt -s nocasematch
foo=a
bar=A
echo "${foo#A}" "${foo#[A]}"
echo "${bar#a}" "${bar#[a]}"

--------------------------------------------------------------------------------

(program)
