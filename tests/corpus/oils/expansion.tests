# Converted from Oils corpus: expansion.txt

=== no expansion
echo {foo}
---
(command (word "echo") (word "{foo}"))
---

=== incomplete trailing expansion
echo {a,b}_{
---
(command (word "echo") (word "{a,b}_{"))
---

=== partial leading expansion
echo }_{a,b}
---
(command (word "echo") (word "}_{a,b}"))
---

=== partial leading expansion 2
echo {x}_{a,b}
---
(command (word "echo") (word "{x}_{a,b}"))
---

=== } in expansion
# hm they treat this the SAME.  Leftmost { is matched by first }, and then
# there is another } as the postfix.
echo {a,b}}
---
(command (word "echo") (word "{a,b}}"))
---

=== single expansion
echo {foo,bar}
---
(command (word "echo") (word "{foo,bar}"))
---

=== double expansion
echo {a,b}_{c,d}
---
(command (word "echo") (word "{a,b}_{c,d}"))
---

=== triple expansion
echo {0,1}{0,1}{0,1}
---
(command (word "echo") (word "{0,1}{0,1}{0,1}"))
---

=== double expansion with single and double quotes
echo {'a',b}_{c,"d"}
---
(command (word "echo") (word "{'a',b}_{c,\"d\"}"))
---

=== expansion with mixed quotes
echo -{\X"b",'cd'}-
---
(command (word "echo") (word "-{\\X\"b\",'cd'}-"))
---

=== expansion with simple var
a=A
echo -{$a,b}-
---
(command (word "a=A"))
(command (word "echo") (word "-{$a,b}-"))
---

=== double expansion with simple var -- bash bug
# bash is inconsistent with the above
a=A
echo {$a,b}_{c,d}
---
(command (word "a=A"))
(command (word "echo") (word "{$a,b}_{c,d}"))
---

=== double expansion with braced variable
# This fixes it
a=A
echo {${a},b}_{c,d}
---
(command (word "a=A"))
(command (word "echo") (word "{${a},b}_{c,d}"))
---

=== double expansion with literal and simple var
a=A
echo {_$a,b}_{c,d}
---
(command (word "a=A"))
(command (word "echo") (word "{_$a,b}_{c,d}"))
---

=== expansion with command sub
a=A
echo -{$(echo a),b}-
---
(command (word "a=A"))
(command (word "echo") (word "-{$(echo a),b}-"))
---

=== expansion with arith sub
a=A
echo -{$((1 + 2)),b}-
---
(command (word "a=A"))
(command (word "echo") (word "-{$((1 + 2)),b}-"))
---

=== double expansion with escaped literals
a=A
echo -{\$,\[,\]}-
---
(command (word "a=A"))
(command (word "echo") (word "-{\\$,\\[,\\]}-"))
---

=== { in expansion
# bash and mksh treat this differently.  bash treats the
# first { is a prefix.  I think it's harder to read, and \{{a,b} should be
# required.
echo {{a,b}
---
(command (word "echo") (word "{{a,b}"))
---

=== quoted { in expansion
echo \{{a,b}
---
(command (word "echo") (word "\\{{a,b}"))
---

=== Empty expansion
echo a{X,,Y}b
---
(command (word "echo") (word "a{X,,Y}b"))
---

=== Empty alternative
# zsh and mksh don't do word elision, probably because they do brace expansion
# AFTER variable substitution.
argv.py {X,,Y,}
---
(command (word "argv.py") (word "{X,,Y,}"))
---

=== Empty alternative with empty string suffix
# zsh and mksh don't do word elision, probably because they do brace expansion
# AFTER variable substitution.
argv.py {X,,Y,}''
---
(command (word "argv.py") (word "{X,,Y,}''"))
---

=== nested brace expansion
echo -{A,={a,b}=,B}-
---
(command (word "echo") (word "-{A,={a,b}=,B}-"))
---

=== triple nested brace expansion
echo -{A,={a,.{x,y}.,b}=,B}-
---
(command (word "echo") (word "-{A,={a,.{x,y}.,b}=,B}-"))
---

=== nested and double brace expansion
echo -{A,={a,b}{c,d}=,B}-
---
(command (word "echo") (word "-{A,={a,b}{c,d}=,B}-"))
---

=== expansion on RHS of assignment
# I think bash's behavior is more consistent.  No splitting either.
v={X,Y}
echo $v
---
(command (word "v={X,Y}"))
(command (word "echo") (word "$v"))
---

=== no expansion with RHS assignment
{v,x}=X
---
(command (word "{v,x}=X"))
---

=== Tilde expansion
HOME=/home/foo
echo ~
HOME=/home/bar
echo ~
---
(command (word "HOME=/home/foo"))
(command (word "echo") (word "~"))
(command (word "HOME=/home/bar"))
(command (word "echo") (word "~"))
---

=== Tilde expansion with brace expansion
# The brace expansion happens FIRST.  After that, the second token has tilde
# FIRST, so it gets expanded.  The first token has an unexpanded tilde, because
# it's not in the leading position.

HOME=/home/bob

# Command

echo {foo~,~}/bar

# Loop

for x in {foo~,~}/bar; do
  echo -- $x
done

# Array

a=({foo~,~}/bar)

for y in "${a[@]}"; do
  echo "== $y"
done
---
(command (word "HOME=/home/bob"))
(command (word "echo") (word "{foo~,~}/bar"))
(for (word "x") (in (word "{foo~,~}/bar")) (command (word "echo") (word "--") (word "$x")))
(command (word "a=({foo~,~}/bar)"))
(for (word "y") (in (word "\"${a[@]}\"")) (command (word "echo") (word "\"== $y\"")))
---

=== Two kinds of tilde expansion
HOME=/home/bob

# Command
echo ~{/src,root}

# Loop

for x in ~{/src,root}; do
  echo -- $x
done

# Array

a=(~{/src,root})

for y in "${a[@]}"; do
  echo "== $y"
done
---
(command (word "HOME=/home/bob"))
(command (word "echo") (word "~{/src,root}"))
(for (word "x") (in (word "~{/src,root}")) (command (word "echo") (word "--") (word "$x")))
(command (word "a=(~{/src,root})"))
(for (word "y") (in (word "\"${a[@]}\"")) (command (word "echo") (word "\"== $y\"")))
---

=== Tilde expansion come before var expansion
HOME=/home/bob
foo=~
echo $foo
foo='~'
echo $foo
# In the second instance, we expand into a literal ~, and since var expansion
# comes after tilde expansion, it is NOT tried again.
---
(command (word "HOME=/home/bob"))
(command (word "foo=~"))
(command (word "echo") (word "$foo"))
(command (word "foo='~'"))
(command (word "echo") (word "$foo"))
---

=== Number range expansion
echo -{1..8..3}-
echo -{1..10..3}-
---
(command (word "echo") (word "-{1..8..3}-"))
(command (word "echo") (word "-{1..10..3}-"))
---

=== Ascending number range expansion with negative step is invalid
echo -{1..8..-3}-
---
(command (word "echo") (word "-{1..8..-3}-"))
---

=== regression: -1 step disallowed
echo -{1..4..-1}-
---
(command (word "echo") (word "-{1..4..-1}-"))
---

=== regression: 0 step disallowed
echo -{1..4..0}-
---
(command (word "echo") (word "-{1..4..0}-"))
---

=== Descending number range expansion with positive step is invalid
echo -{8..1..3}-
---
(command (word "echo") (word "-{8..1..3}-"))
---

=== Descending number range expansion with negative step
echo -{8..1..-3}-
---
(command (word "echo") (word "-{8..1..-3}-"))
---

=== Singleton ranges
echo {1..1}-
echo {-9..-9}-
echo {-9..-9..3}-
echo {-9..-9..-3}-
echo {a..a}-
---
(command (word "echo") (word "{1..1}-"))
(command (word "echo") (word "{-9..-9}-"))
(command (word "echo") (word "{-9..-9..3}-"))
(command (word "echo") (word "{-9..-9..-3}-"))
(command (word "echo") (word "{a..a}-"))
---

=== Singleton char ranges with steps
echo {a..a..2}-
echo {a..a..-2}-
---
(command (word "echo") (word "{a..a..2}-"))
(command (word "echo") (word "{a..a..-2}-"))
---

=== Char range expansion
echo -{a..e}-
---
(command (word "echo") (word "-{a..e}-"))
---

=== Char range expansion with step
echo -{a..e..2}-
---
(command (word "echo") (word "-{a..e..2}-"))
---

=== Char ranges with steps of the wrong sign
echo -{a..e..-2}-
echo -{e..a..2}-
---
(command (word "echo") (word "-{a..e..-2}-"))
(command (word "echo") (word "-{e..a..2}-"))
---

=== Mixed case char expansion is invalid
case $SH in *zsh) echo BUG; exit ;; esac
echo -{z..A}-
echo -{z..A..2}-
---
(case (word "$SH") (pattern ((word "*zsh")) (semi (command (word "echo") (word "BUG")) (command (word "exit")))))
(command (word "echo") (word "-{z..A}-"))
(command (word "echo") (word "-{z..A..2}-"))
---

=== Descending char range expansion
echo -{e..a..-2}-
---
(command (word "echo") (word "-{e..a..-2}-"))
---

=== Fixed width number range expansion
echo -{01..03}-
echo -{09..12}-  # doesn't become -012-, fixed width
echo -{12..07}-
---
(command (word "echo") (word "-{01..03}-"))
(command (word "echo") (word "-{09..12}-"))
(command (word "echo") (word "-{12..07}-"))
---

=== Inconsistent fixed width number range expansion
# zsh uses the first one, bash uses the max width?
echo -{01..003}-
---
(command (word "echo") (word "-{01..003}-"))
---

=== Inconsistent fixed width number range expansion
# zsh uses the first width, bash uses the max width?
echo -{01..3}-
---
(command (word "echo") (word "-{01..3}-"))
---

=== Adjacent comma and range works
echo -{a,b}{1..3}-
---
(command (word "echo") (word "-{a,b}{1..3}-"))
---

=== Range inside comma works
echo -{a,_{1..3}_,b}-
---
(command (word "echo") (word "-{a,_{1..3}_,b}-"))
---

=== Mixed comma and range doesn't work
echo -{a,b,1..3}-
---
(command (word "echo") (word "-{a,b,1..3}-"))
---

=== comma and invalid range (adjacent and nested)
echo -{a,b}{1...3}-
echo -{a,{1...3}}-
echo {a,b}{}
---
(command (word "echo") (word "-{a,b}{1...3}-"))
(command (word "echo") (word "-{a,{1...3}}-"))
(command (word "echo") (word "{a,b}{}"))
---

=== OSH provides an alternative to invalid syntax
echo -{a,b}\{1...3\}-
echo -{a,\{1...3\}}-
echo {a,b}\{\}
---
(command (word "echo") (word "-{a,b}\\{1...3\\}-"))
(command (word "echo") (word "-{a,\\{1...3\\}}-"))
(command (word "echo") (word "{a,b}\\{\\}"))
---

=== Side effect in expansion
# bash is the only one that does it first.  I guess since this is
# non-POSIX anyway, follow bash?
i=0
echo {a,b,c}-$((i++))
---
(command (word "i=0"))
(command (word "echo") (word "{a,b,c}-$((i++))"))
---

=== Invalid brace expansions don't expand
echo {1.3}
echo {1...3}
echo {1__3}
---
(command (word "echo") (word "{1.3}"))
(command (word "echo") (word "{1...3}"))
(command (word "echo") (word "{1__3}"))
---

=== Invalid brace expansions mixing characters and numbers
# zsh does something crazy like : ; < = > that I'm not writing
case $SH in *zsh) echo BUG; exit ;; esac
echo {1..a}
echo {z..3}
---
(case (word "$SH") (pattern ((word "*zsh")) (semi (command (word "echo") (word "BUG")) (command (word "exit")))))
(command (word "echo") (word "{1..a}"))
(command (word "echo") (word "{z..3}"))
---

=== @() matches exactly one of the patterns
# @extglob
shopt -s extglob
mkdir -p 0
cd 0
touch {foo,bar}.cc {foo,bar,baz}.h
echo @(*.cc|*.h)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "0"))
(command (word "cd") (word "0"))
(command (word "touch") (word "{foo,bar}.cc") (word "{foo,bar,baz}.h"))
(command (word "echo") (word "@(*.cc|*.h)"))
---

=== ?() matches 0 or 1
# @extglob
shopt -s extglob
mkdir -p 1
cd 1
touch {foo,bar}.cc {foo,bar,baz}.h foo. foo.hh
ext=cc
echo foo.?($ext|h)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "1"))
(command (word "cd") (word "1"))
(command (word "touch") (word "{foo,bar}.cc") (word "{foo,bar,baz}.h") (word "foo.") (word "foo.hh"))
(command (word "ext=cc"))
(command (word "echo") (word "foo.?($ext|h)"))
---

=== *() matches 0 or more
# @extglob
shopt -s extglob
mkdir -p eg1
touch eg1/_ eg1/_One eg1/_OneOne eg1/_TwoTwo eg1/_OneTwo
echo eg1/_*(One|Two)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg1"))
(command (word "touch") (word "eg1/_") (word "eg1/_One") (word "eg1/_OneOne") (word "eg1/_TwoTwo") (word "eg1/_OneTwo"))
(command (word "echo") (word "eg1/_*(One|Two)"))
---

=== +() matches 1 or more
# @extglob
shopt -s extglob
mkdir -p eg2
touch eg2/_ eg2/_One eg2/_OneOne eg2/_TwoTwo eg2/_OneTwo
echo eg2/_+(One|$(echo Two))
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg2"))
(command (word "touch") (word "eg2/_") (word "eg2/_One") (word "eg2/_OneOne") (word "eg2/_TwoTwo") (word "eg2/_OneTwo"))
(command (word "echo") (word "eg2/_+(One|$(echo Two))"))
---

=== !(*.h|*.cc) to match everything except C++
# @extglob
shopt -s extglob
mkdir -p extglob2
touch extglob2/{foo,bar}.cc extglob2/{foo,bar,baz}.h \
      extglob2/{foo,bar,baz}.py
echo extglob2/!(*.h|*.cc)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "extglob2"))
(command (word "touch") (word "extglob2/{foo,bar}.cc") (word "extglob2/{foo,bar,baz}.h") (word "extglob2/{foo,bar,baz}.py"))
(command (word "echo") (word "extglob2/!(*.h|*.cc)"))
---

=== Two adjacent alternations
# @extglob
shopt -s extglob
mkdir -p 2
touch 2/{aa,ab,ac,ba,bb,bc,ca,cb,cc}
echo 2/!(b)@(b|c)
echo 2/!(b)?@(b|c)  # wildcard in between
echo 2/!(b)a@(b|c)  # constant in between
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "2"))
(command (word "touch") (word "2/{aa,ab,ac,ba,bb,bc,ca,cb,cc}"))
(command (word "echo") (word "2/!(b)@(b|c)"))
(command (word "echo") (word "2/!(b)?@(b|c)"))
(command (word "echo") (word "2/!(b)a@(b|c)"))
---

=== Nested extended glob pattern
# @extglob
shopt -s extglob
mkdir -p eg6
touch eg6/{ab,ac,ad,az,bc,bd}
echo eg6/a@(!(c|d))
echo eg6/a!(@(ab|b*))
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg6"))
(command (word "touch") (word "eg6/{ab,ac,ad,az,bc,bd}"))
(command (word "echo") (word "eg6/a@(!(c|d))"))
(command (word "echo") (word "eg6/a!(@(ab|b*))"))
---

=== Extended glob patterns with spaces
# @extglob
shopt -s extglob
mkdir -p eg4
touch eg4/a 'eg4/a b' eg4/foo
argv.py eg4/@(a b|foo)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg4"))
(command (word "touch") (word "eg4/a") (word "'eg4/a b'") (word "eg4/foo"))
(command (word "argv.py") (word "eg4/@(a b|foo)"))
---

=== Filenames with spaces
# @extglob
shopt -s extglob
mkdir -p eg5
touch eg5/'a b'{cd,de,ef}
argv.py eg5/'a '@(bcd|bde|zzz)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg5"))
(command (word "touch") (word "eg5/'a b'{cd,de,ef}"))
(command (word "argv.py") (word "eg5/'a '@(bcd|bde|zzz)"))
---

=== nullglob with extended glob
# @extglob
shopt -s extglob
mkdir eg6
argv.py eg6/@(no|matches)  # no matches
shopt -s nullglob  # test this too
argv.py eg6/@(no|matches)  # no matches
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "eg6"))
(command (word "argv.py") (word "eg6/@(no|matches)"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "argv.py") (word "eg6/@(no|matches)"))
---

=== Glob other punctuation chars (lexer mode)
# @extglob
shopt -s extglob
mkdir -p eg5
cd eg5
touch __{aa,'<>','{}','#','&&'}
argv.py @(__aa|'__<>'|__{}|__#|__&&|)

# mksh sorts them differently
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg5"))
(command (word "cd") (word "eg5"))
(command (word "touch") (word "__{aa,'<>','{}','#','&&'}"))
(command (word "argv.py") (word "@(__aa|'__<>'|__{}|__#|__&&|)"))
---

=== More glob escaping
# @extglob
shopt -s extglob
mkdir -p eg7
cd eg7
touch '_[:]' '_*' '_?'
argv.py @('_[:]'|'_*'|'_?')
argv.py @(nested|'_?'|@('_[:]'|'_*'))

# mksh sorts them differently
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg7"))
(command (word "cd") (word "eg7"))
(command (word "touch") (word "'_[:]'") (word "'_*'") (word "'_?'"))
(command (word "argv.py") (word "@('_[:]'|'_*'|'_?')"))
(command (word "argv.py") (word "@(nested|'_?'|@('_[:]'|'_*'))"))
---

=== Escaping of pipe (glibc bug, see demo/glibc_fnmatch.c)
# @extglob
shopt -s extglob

mkdir -p extpipe
cd extpipe

touch '__|' foo
argv.py @('foo'|__\||bar)
argv.py @('foo'|'__|'|bar)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "extpipe"))
(command (word "cd") (word "extpipe"))
(command (word "touch") (word "'__|'") (word "foo"))
(command (word "argv.py") (word "@('foo'|__\\||bar)"))
(command (word "argv.py") (word "@('foo'|'__|'|bar)"))
---

=== Extended glob as argument to ${undef:-} (dynamic globbing)
# This case popped into my mind after inspecting osh/word_eval.py for calls to
# _EvalWordToParts()

shopt -s extglob

mkdir -p eg8
cd eg8
touch {foo,bar,spam}.py

# regular glob
echo ${undef:-*.py}

# extended glob
echo ${undef:-@(foo|bar).py}
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg8"))
(command (word "cd") (word "eg8"))
(command (word "touch") (word "{foo,bar,spam}.py"))
(command (word "echo") (word "${undef:-*.py}"))
(command (word "echo") (word "${undef:-@(foo|bar).py}"))
---

=== Extended glob in assignment builtin
# @extglob
# Another invocation of _EvalWordToParts() that OSH should handle

shopt -s extglob
mkdir -p eg9
cd eg9
touch {foo,bar}.py
typeset -@(*.py) myvar
echo status=$?
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg9"))
(command (word "cd") (word "eg9"))
(command (word "touch") (word "{foo,bar}.py"))
(command (word "typeset") (word "-@(*.py)") (word "myvar"))
(command (word "echo") (word "status=$?"))
---

=== Extended glob in same word as array
# @extglob
shopt -s extglob
mkdir -p eg10
cd eg10

touch {'a b c',bee,cee}.{py,cc}
set -- 'a b' 'c'

argv.py "$@"

# This works!
argv.py star glob "$*"*.py
argv.py star extglob "$*"*@(.py|cc)

# Hm this actually still works!  the first two parts are literal.  And then
# there's something like the simple_word_eval algorithm on the rest.  Gah.
argv.py at extglob "$@"*@(.py|cc)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg10"))
(command (word "cd") (word "eg10"))
(command (word "touch") (word "{'a b c',bee,cee}.{py,cc}"))
(command (word "set") (word "--") (word "'a b'") (word "'c'"))
(command (word "argv.py") (word "\"$@\""))
(command (word "argv.py") (word "star") (word "glob") (word "\"$*\"*.py"))
(command (word "argv.py") (word "star") (word "extglob") (word "\"$*\"*@(.py|cc)"))
(command (word "argv.py") (word "at") (word "extglob") (word "\"$@\"*@(.py|cc)"))
---

=== Extended glob with word splitting
# @extglob
shopt -s extglob
mkdir -p 3
cd 3

x='a b'
touch bar.{cc,h}

# OSH may disallow splitting when there's an extended glob
argv.py $x*.@(cc|h)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "3"))
(command (word "cd") (word "3"))
(command (word "x='a b'"))
(command (word "touch") (word "bar.{cc,h}"))
(command (word "argv.py") (word "$x*.@(cc|h)"))
---

=== In Array Literal and for loop
# @extglob
shopt -s extglob
mkdir -p eg11
cd eg11
touch {foo,bar,spam}.py
for x in @(fo*|bar).py; do
  echo $x
done

echo ---
declare -a A
A=(zzz @(fo*|bar).py)
echo "${A[@]}"
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg11"))
(command (word "cd") (word "eg11"))
(command (word "touch") (word "{foo,bar,spam}.py"))
(for (word "x") (in (word "@(fo*|bar).py")) (command (word "echo") (word "$x")))
(command (word "echo") (word "---"))
(command (word "declare") (word "-a") (word "A"))
(command (word "A=(zzz @(fo*|bar).py)"))
(command (word "echo") (word "\"${A[@]}\""))
---

=== No extended glob with simple_word_eval (YSH evaluation)
# @extglob
shopt -s ysh:all
shopt -s extglob
mkdir -p eg12
cd eg12
touch {foo,bar,spam}.py
builtin write -- x@(fo*|bar).py
builtin write -- @(fo*|bar).py
---
(command (word "shopt") (word "-s") (word "ysh:all"))
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "eg12"))
(command (word "cd") (word "eg12"))
(command (word "touch") (word "{foo,bar,spam}.py"))
(command (word "builtin") (word "write") (word "--") (word "x@(fo*|bar).py"))
(command (word "builtin") (word "write") (word "--") (word "@(fo*|bar).py"))
---

=== no_dash_glob
# @extglob
shopt -s extglob
mkdir -p opts
cd opts

touch -- foo bar -dash
echo @(*)

shopt --set no_dash_glob
echo @(*)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "opts"))
(command (word "cd") (word "opts"))
(command (word "touch") (word "--") (word "foo") (word "bar") (word "-dash"))
(command (word "echo") (word "@(*)"))
(command (word "shopt") (word "--set") (word "no_dash_glob"))
(command (word "echo") (word "@(*)"))
---

=== noglob
# @extglob
shopt -s extglob
mkdir -p _noglob
cd _noglob

set -o noglob
echo @(*)
echo @(__nope__*|__nope__?|'*'|'?'|'[:alpha:]'|'|')
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "mkdir") (word "-p") (word "_noglob"))
(command (word "cd") (word "_noglob"))
(command (word "set") (word "-o") (word "noglob"))
(command (word "echo") (word "@(*)"))
(command (word "echo") (word "@(__nope__*|__nope__?|'*'|'?'|'[:alpha:]'|'|')"))
---

=== failglob
# @extglob
shopt -s extglob

rm -f _failglob/*
mkdir -p _failglob
cd _failglob

shopt -s failglob
echo @(*)
echo status=$?

touch foo
echo @(*)
echo status=$?
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "rm") (word "-f") (word "_failglob/*"))
(command (word "mkdir") (word "-p") (word "_failglob"))
(command (word "cd") (word "_failglob"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "echo") (word "@(*)"))
(command (word "echo") (word "status=$?"))
(command (word "touch") (word "foo"))
(command (word "echo") (word "@(*)"))
(command (word "echo") (word "status=$?"))
---

=== @ matches exactly one
# @extglob
[[ --verbose == --@(help|verbose) ]] && echo TRUE
[[ --oops == --@(help|verbose) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--verbose") (cond-term "--@(help|verbose)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "--@(help|verbose)"))) (command (word "echo") (word "FALSE")))
---

=== @() with variable arms
# @extglob
choice1='help'
choice2='verbose'
[[ --verbose == --@($choice1|$choice2) ]] && echo TRUE
[[ --oops == --@($choice1|$choice2) ]] || echo FALSE
---
(command (word "choice1='help'"))
(command (word "choice2='verbose'"))
(and (cond (cond-binary "==" (cond-term "--verbose") (cond-term "--@($choice1|$choice2)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "--@($choice1|$choice2)"))) (command (word "echo") (word "FALSE")))
---

=== extglob in variable
# @extglob
shopt -s extglob

# this syntax requires extglob in bash!!
# OSH never allows it
g=--@(help|verbose)

quoted='--@(help|verbose)'

[[ --help == $g ]] && echo TRUE
[[ --verbose == $g ]] && echo TRUE
[[ -- == $g ]] || echo FALSE
[[ --help == $q ]] || echo FALSE
[[ -- == $q ]] || echo FALSE
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "g=--@(help|verbose)"))
(command (word "quoted='--@(help|verbose)'"))
(and (cond (cond-binary "==" (cond-term "--help") (cond-term "$g"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "--verbose") (cond-term "$g"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--") (cond-term "$g"))) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "--help") (cond-term "$q"))) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "--") (cond-term "$q"))) (command (word "echo") (word "FALSE")))
---

=== Matching literal '@(cc)'
# @extglob
# extglob is OFF.  Doesn't affect bash or mksh!
[[ cc == @(cc) ]] 
echo status=$?
[[ cc == '@(cc)' ]]
echo status=$?

shopt -s extglob

[[ cc == @(cc) ]]
echo status=$?
[[ cc == '@(cc)' ]]
echo status=$?
---
(cond (cond-binary "==" (cond-term "cc") (cond-term "@(cc)")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "==" (cond-term "cc") (cond-term "'@(cc)'")))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-s") (word "extglob"))
(cond (cond-binary "==" (cond-term "cc") (cond-term "@(cc)")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "==" (cond-term "cc") (cond-term "'@(cc)'")))
(command (word "echo") (word "status=$?"))
---

=== nested @()
shopt -s extglob
pat='--@(help|verbose|no-@(long|short)-option)'
[[ --no-long-option == $pat ]] && echo TRUE
[[ --no-short-option == $pat ]] && echo TRUE
[[ --help == $pat ]] && echo TRUE
[[ --oops == $pat ]] || echo FALSE
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "pat='--@(help|verbose|no-@(long|short)-option)'"))
(and (cond (cond-binary "==" (cond-term "--no-long-option") (cond-term "$pat"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "--no-short-option") (cond-term "$pat"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "--help") (cond-term "$pat"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "$pat"))) (command (word "echo") (word "FALSE")))
---

=== nested @() with quotes and vars
# @extglob
shopt -s extglob
prefix=no
[[ --no-long-option == --@(help|verbose|$prefix-@(long|short)-'option') ]] &&
  echo TRUE
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "prefix=no"))
(and (cond (cond-binary "==" (cond-term "--no-long-option") (cond-term "--@(help|verbose|$prefix-@(long|short)-'option')"))) (command (word "echo") (word "TRUE")))
---

=== ? matches 0 or 1
# @extglob
[[ -- == --?(help|verbose) ]] && echo TRUE
[[ --oops == --?(help|verbose) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--") (cond-term "--?(help|verbose)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "--?(help|verbose)"))) (command (word "echo") (word "FALSE")))
---

=== + matches 1 or more
# @extglob
[[ --helphelp == --+(help|verbose) ]] && echo TRUE
[[ -- == --+(help|verbose) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--helphelp") (cond-term "--+(help|verbose)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--") (cond-term "--+(help|verbose)"))) (command (word "echo") (word "FALSE")))
---

=== * matches 0 or more
# @extglob
[[ -- == --*(help|verbose) ]] && echo TRUE
[[ --oops == --*(help|verbose) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--") (cond-term "--*(help|verbose)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "--*(help|verbose)"))) (command (word "echo") (word "FALSE")))
---

=== simple repetition with *(foo) and +(Foo)
# @extglob
[[ foofoo == *(foo) ]] && echo TRUE
[[ foofoo == +(foo) ]] && echo TRUE
---
(and (cond (cond-binary "==" (cond-term "foofoo") (cond-term "*(foo)"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "foofoo") (cond-term "+(foo)"))) (command (word "echo") (word "TRUE")))
---

=== ! matches none
# @extglob
[[ --oops == --!(help|verbose) ]] && echo TRUE
[[ --help == --!(help|verbose) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--oops") (cond-term "--!(help|verbose)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--help") (cond-term "--!(help|verbose)"))) (command (word "echo") (word "FALSE")))
---

=== match is anchored
# @extglob
[[ foo_ == @(foo) ]] || echo FALSE
[[ _foo == @(foo) ]] || echo FALSE
[[ foo == @(foo) ]] && echo TRUE
---
(or (cond (cond-binary "==" (cond-term "foo_") (cond-term "@(foo)"))) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "_foo") (cond-term "@(foo)"))) (command (word "echo") (word "FALSE")))
(and (cond (cond-binary "==" (cond-term "foo") (cond-term "@(foo)"))) (command (word "echo") (word "TRUE")))
---

=== repeated match is anchored
# @extglob
[[ foofoo_ == +(foo) ]] || echo FALSE
[[ _foofoo == +(foo) ]] || echo FALSE
[[ foofoo == +(foo) ]] && echo TRUE
---
(or (cond (cond-binary "==" (cond-term "foofoo_") (cond-term "+(foo)"))) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "_foofoo") (cond-term "+(foo)"))) (command (word "echo") (word "FALSE")))
(and (cond (cond-binary "==" (cond-term "foofoo") (cond-term "+(foo)"))) (command (word "echo") (word "TRUE")))
---

=== repetition with glob
# @extglob
# NOTE that * means two different things here
[[ foofoo_foo__foo___ == *(foo*) ]] && echo TRUE
[[ Xoofoo_foo__foo___ == *(foo*) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "foofoo_foo__foo___") (cond-term "*(foo*)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "Xoofoo_foo__foo___") (cond-term "*(foo*)"))) (command (word "echo") (word "FALSE")))
---

=== No brace expansion in ==
# @extglob
[[ --X{a,b}X == --@(help|X{a,b}X) ]] && echo TRUE
[[ --oops == --@(help|X{a,b}X) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--X{a,b}X") (cond-term "--@(help|X{a,b}X)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--oops") (cond-term "--@(help|X{a,b}X)"))) (command (word "echo") (word "FALSE")))
---

=== adjacent extglob
# @extglob
[[ --help == @(--|++)@(help|verbose) ]] && echo TRUE
[[ ++verbose == @(--|++)@(help|verbose) ]] && echo TRUE
---
(and (cond (cond-binary "==" (cond-term "--help") (cond-term "@(--|++)@(help|verbose)"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "++verbose") (cond-term "@(--|++)@(help|verbose)"))) (command (word "echo") (word "TRUE")))
---

=== nested extglob
# @extglob
[[ --help == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose=1 == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose=2 == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose == --@(help|verbose=@(1|2)) ]] || echo FALSE
---
(and (cond (cond-binary "==" (cond-term "--help") (cond-term "--@(help|verbose=@(1|2))"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "--verbose=1") (cond-term "--@(help|verbose=@(1|2))"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "--verbose=2") (cond-term "--@(help|verbose=@(1|2))"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "--verbose") (cond-term "--@(help|verbose=@(1|2))"))) (command (word "echo") (word "FALSE")))
---

=== extglob empty string
# @extglob
shopt -s extglob
[[ '' == @(foo|bar) ]] || echo FALSE
[[ '' == @(foo||bar) ]] && echo TRUE
---
(command (word "shopt") (word "-s") (word "extglob"))
(or (cond (cond-binary "==" (cond-term "''") (cond-term "@(foo|bar)"))) (command (word "echo") (word "FALSE")))
(and (cond (cond-binary "==" (cond-term "''") (cond-term "@(foo||bar)"))) (command (word "echo") (word "TRUE")))
---

=== extglob empty pattern
# @extglob
shopt -s extglob
[[ '' == @() ]] && echo TRUE
[[ '' == @(||) ]] && echo TRUE
[[ X == @() ]] || echo FALSE
[[ '|' == @(||) ]] || echo FALSE
---
(command (word "shopt") (word "-s") (word "extglob"))
(and (cond (cond-binary "==" (cond-term "''") (cond-term "@()"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-binary "==" (cond-term "''") (cond-term "@(||)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "X") (cond-term "@()"))) (command (word "echo") (word "FALSE")))
(or (cond (cond-binary "==" (cond-term "'|'") (cond-term "@(||)"))) (command (word "echo") (word "FALSE")))
---

=== case with extglob
# @extglob
shopt -s extglob
for word in --help --verbose --unmatched -- -zxzx -; do
  case $word in
    --@(help|verbose) )
      echo A
      continue
      ;;
    ( --?(b|c) )
      echo B
      continue
      ;;
    ( -+(x|z) )
      echo C
      continue
      ;;
    ( -*(x|z) )
      echo D
      continue
      ;;
    *)
      echo U
      continue
      ;;
  esac
done
---
(command (word "shopt") (word "-s") (word "extglob"))
(for (word "word") (in (word "--help") (word "--verbose") (word "--unmatched") (word "--") (word "-zxzx") (word "-")) (case (word "$word") (pattern ((word "--@(help|verbose)")) (semi (command (word "echo") (word "A")) (command (word "continue")))) (pattern ((word "--?(b|c)")) (semi (command (word "echo") (word "B")) (command (word "continue")))) (pattern ((word "-+(x|z)")) (semi (command (word "echo") (word "C")) (command (word "continue")))) (pattern ((word "-*(x|z)")) (semi (command (word "echo") (word "D")) (command (word "continue")))) (pattern ((word "*")) (semi (command (word "echo") (word "U")) (command (word "continue"))))))
---

=== [[ $x == !($str) ]]
# @extglob
shopt -s extglob
empty=''
str='x'
[[ $empty == !($str) ]] && echo TRUE  # test glob match
[[ $str == !($str) ]]   || echo FALSE
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "empty=''"))
(command (word "str='x'"))
(and (cond (cond-binary "==" (cond-term "$empty") (cond-term "!($str)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-binary "==" (cond-term "$str") (cond-term "!($str)"))) (command (word "echo") (word "FALSE")))
---

=== Turning extglob on changes the meaning of [[ !(str) ]] in bash
# @extglob
empty=''
str='x'
[[ !($empty) ]]  && echo TRUE   # test if $empty is empty
[[ !($str) ]]    || echo FALSE  # test if $str is empty
shopt -s extglob  # mksh doesn't have this
[[ !($empty) ]]  && echo TRUE   # negated glob
[[ !($str) ]]    && echo TRUE   # negated glob
---
(command (word "empty=''"))
(command (word "str='x'"))
(and (cond (cond-unary "-n" (cond-term "!($empty)"))) (command (word "echo") (word "TRUE")))
(or (cond (cond-unary "-n" (cond-term "!($str)"))) (command (word "echo") (word "FALSE")))
(command (word "shopt") (word "-s") (word "extglob"))
(and (cond (cond-unary "-n" (cond-term "!($empty)"))) (command (word "echo") (word "TRUE")))
(and (cond (cond-unary "-n" (cond-term "!($str)"))) (command (word "echo") (word "TRUE")))
---

=== With extglob on, !($str) on the left or right of == has different meanings
# @extglob
shopt -s extglob
str='x'
[[ 1 == !($str) ]]  && echo TRUE   # glob match
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "str='x'"))
(and (cond (cond-binary "==" (cond-term "1") (cond-term "!($str)"))) (command (word "echo") (word "TRUE")))
---

=== extglob inside arg word
# @extglob
shopt -s extglob
[[ foo == @(foo|bar) ]] && echo rhs
[[ foo == ${unset:-@(foo|bar)} ]] && echo 'rhs arg'
[[ fo == ${unset:-@(foo|bar)} ]] || echo nope
---
(command (word "shopt") (word "-s") (word "extglob"))
(and (cond (cond-binary "==" (cond-term "foo") (cond-term "@(foo|bar)"))) (command (word "echo") (word "rhs")))
(and (cond (cond-binary "==" (cond-term "foo") (cond-term "${unset:-@(foo|bar)}"))) (command (word "echo") (word "'rhs arg'")))
(or (cond (cond-binary "==" (cond-term "fo") (cond-term "${unset:-@(foo|bar)}"))) (command (word "echo") (word "nope")))
---

=== extglob is not detected in regex!
shopt -s extglob
[[ foo =~ ^@(foo|bar)$ ]] || echo FALSE
---
(command (word "shopt") (word "-s") (word "extglob"))
(or (cond (cond-binary "=~" (cond-term "foo") (cond-term "^@(foo|bar)$"))) (command (word "echo") (word "FALSE")))
---

=== regular glob of single unicode char
shopt -s extglob
[[ __a__ == __?__ ]]
echo $?
[[ __μ__ == __?__ ]]
echo $?
---
(command (word "shopt") (word "-s") (word "extglob"))
(cond (cond-binary "==" (cond-term "__a__") (cond-term "__?__")))
(command (word "echo") (word "$?"))
(cond (cond-binary "==" (cond-term "__μ__") (cond-term "__?__")))
(command (word "echo") (word "$?"))
---

=== extended glob of single unicode char
# @extglob
shopt -s extglob
[[ __a__ == @(__?__) ]]
echo $?
[[ __μ__ == @(__?__) ]]
echo $?
---
(command (word "shopt") (word "-s") (word "extglob"))
(cond (cond-binary "==" (cond-term "__a__") (cond-term "@(__?__)")))
(command (word "echo") (word "$?"))
(cond (cond-binary "==" (cond-term "__μ__") (cond-term "@(__?__)")))
(command (word "echo") (word "$?"))
---

=== Extended glob in ${x//pat/replace}
# not supported in OSH due to GlobToERE() strategy for positional info

shopt -s extglob
x=foo.py
echo ${x//@(?.py)/Z}
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "x=foo.py"))
(command (word "echo") (word "${x//@(?.py)/Z}"))
---

=== Extended glob in ${x%PATTERN}
shopt -s extglob
x=foo.py
echo 'strip % ' ${x%.@(py|cc)}
echo 'strip %%' ${x%%.@(py|cc)}
echo 'strip # ' ${x#@(foo)}
echo 'strip ##' ${x##@(foo)}
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "x=foo.py"))
(command (word "echo") (word "'strip % '") (word "${x%.@(py|cc)}"))
(command (word "echo") (word "'strip %%'") (word "${x%%.@(py|cc)}"))
(command (word "echo") (word "'strip # '") (word "${x#@(foo)}"))
(command (word "echo") (word "'strip ##'") (word "${x##@(foo)}"))
---

=== shopt -s nullglob
argv.py _tmp/spec-tmp/*.nonexistent
shopt -s nullglob
argv.py _tmp/spec-tmp/*.nonexistent
---
(command (word "argv.py") (word "_tmp/spec-tmp/*.nonexistent"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "argv.py") (word "_tmp/spec-tmp/*.nonexistent"))
---

=== shopt -s failglob in command context
argv.py *.ZZ
shopt -s failglob
argv.py *.ZZ  # nothing is printed, not []
echo status=$?
---
(command (word "argv.py") (word "*.ZZ"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "argv.py") (word "*.ZZ"))
(command (word "echo") (word "status=$?"))
---

=== shopt -s failglob in loop context
for x in *.ZZ; do echo $x; done
echo status=$?
shopt -s failglob
for x in *.ZZ; do echo $x; done
echo status=$?
---
(for (word "x") (in (word "*.ZZ")) (command (word "echo") (word "$x")))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-s") (word "failglob"))
(for (word "x") (in (word "*.ZZ")) (command (word "echo") (word "$x")))
(command (word "echo") (word "status=$?"))
---

=== shopt -s failglob in array literal context
myarr=(*.ZZ)
echo "${myarr[@]}"
shopt -s failglob
myarr=(*.ZZ)
echo status=$?
---
(command (word "myarr=(*.ZZ)"))
(command (word "echo") (word "\"${myarr[@]}\""))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "myarr=(*.ZZ)"))
(command (word "echo") (word "status=$?"))
---

=== shopt -s failglob exits properly in command context with set -e
set -e
argv.py *.ZZ
shopt -s failglob
argv.py *.ZZ
echo status=$?
---
(command (word "set") (word "-e"))
(command (word "argv.py") (word "*.ZZ"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "argv.py") (word "*.ZZ"))
(command (word "echo") (word "status=$?"))
---

=== shopt -s failglob exits properly in loop context with set -e
set -e
for x in *.ZZ; do echo $x; done
echo status=$?

shopt -s failglob
for x in *.ZZ; do echo $x; done
echo status=$?
---
(command (word "set") (word "-e"))
(for (word "x") (in (word "*.ZZ")) (command (word "echo") (word "$x")))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-s") (word "failglob"))
(for (word "x") (in (word "*.ZZ")) (command (word "echo") (word "$x")))
(command (word "echo") (word "status=$?"))
---

=== shopt -s failglob behavior on single line with semicolon
# bash behaves differently when commands are separated by a semicolon than when
# separated by a newline. This behavior doesn't make sense or seem to be
# intentional, so osh does not mimic it.

shopt -s failglob
echo *.ZZ; echo status=$? # bash doesn't execute the second part!
echo *.ZZ
echo status=$? # bash executes this
---
(command (word "shopt") (word "-s") (word "failglob"))
(semi (command (word "echo") (word "*.ZZ")) (command (word "echo") (word "status=$?")))
(command (word "echo") (word "*.ZZ"))
(command (word "echo") (word "status=$?"))
---

=== dotglob (bash option that no_dash_glob is roughly consistent with)
mkdir -p $TMP/dotglob
cd $TMP/dotglob
touch .foorc other

echo *
shopt -s dotglob
echo * | sort
---
(command (word "mkdir") (word "-p") (word "$TMP/dotglob"))
(command (word "cd") (word "$TMP/dotglob"))
(command (word "touch") (word ".foorc") (word "other"))
(command (word "echo") (word "*"))
(command (word "shopt") (word "-s") (word "dotglob"))
(pipe (command (word "echo") (word "*")) (command (word "sort")))
---

=== glob double quote escape
echo "*.sh"
---
(command (word "echo") (word "\"*.sh\""))
---

=== glob single quote escape
echo "*.sh"
---
(command (word "echo") (word "\"*.sh\""))
---

=== glob backslash escape
echo \*.sh
---
(command (word "echo") (word "\\*.sh"))
---

=== 1 char glob
cd $REPO_ROOT
echo [b]in
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "echo") (word "[b]in"))
---

=== 0 char glob -- does NOT work
echo []bin
---
(command (word "echo") (word "[]bin"))
---

=== looks like glob at the start, but isn't
echo [bin
---
(command (word "echo") (word "[bin"))
---

=== looks like glob plus negation at the start, but isn't
echo [!bin
---
(command (word "echo") (word "[!bin"))
---

=== glob can expand to command and arg
cd $REPO_ROOT
spec/testdata/echo.s[hz]
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "spec/testdata/echo.s[hz]"))
---

=== glob after var expansion
touch _tmp/a.A _tmp/aa.A _tmp/b.B
f="_tmp/*.A"
g="$f _tmp/*.B"
echo $g
---
(command (word "touch") (word "_tmp/a.A") (word "_tmp/aa.A") (word "_tmp/b.B"))
(command (word "f=\"_tmp/*.A\""))
(command (word "g=\"$f _tmp/*.B\""))
(command (word "echo") (word "$g"))
---

=== quoted var expansion with glob meta characters
touch _tmp/a.A _tmp/aa.A _tmp/b.B
f="_tmp/*.A"
echo "[ $f ]"
---
(command (word "touch") (word "_tmp/a.A") (word "_tmp/aa.A") (word "_tmp/b.B"))
(command (word "f=\"_tmp/*.A\""))
(command (word "echo") (word "\"[ $f ]\""))
---

=== glob after "$@" expansion
fun() {
  echo "$@"
}
fun '_tmp/*.B'
---
(function "fun" (brace-group (command (word "echo") (word "\"$@\""))))
(command (word "fun") (word "'_tmp/*.B'"))
---

=== glob after $@ expansion
touch _tmp/b.B
fun() {
  echo $@
}
fun '_tmp/*.B'
---
(command (word "touch") (word "_tmp/b.B"))
(function "fun" (brace-group (command (word "echo") (word "$@"))))
(command (word "fun") (word "'_tmp/*.B'"))
---

=== no glob after ~ expansion
HOME=*
echo ~/*.py
---
(command (word "HOME=*"))
(command (word "echo") (word "~/*.py"))
---

=== store literal globs in array then expand
touch _tmp/a.A _tmp/aa.A _tmp/b.B
g=("_tmp/*.A" "_tmp/*.B")
echo ${g[@]}
---
(command (word "touch") (word "_tmp/a.A") (word "_tmp/aa.A") (word "_tmp/b.B"))
(command (word "g=(\"_tmp/*.A\" \"_tmp/*.B\")"))
(command (word "echo") (word "${g[@]}"))
---

=== glob inside array
touch _tmp/a.A _tmp/aa.A _tmp/b.B
g=(_tmp/*.A _tmp/*.B)
echo "${g[@]}"
---
(command (word "touch") (word "_tmp/a.A") (word "_tmp/aa.A") (word "_tmp/b.B"))
(command (word "g=(_tmp/*.A _tmp/*.B)"))
(command (word "echo") (word "\"${g[@]}\""))
---

=== glob with escaped - in char class
touch _tmp/foo.-
touch _tmp/c.C
echo _tmp/*.[C-D] _tmp/*.[C\-D]
---
(command (word "touch") (word "_tmp/foo.-"))
(command (word "touch") (word "_tmp/c.C"))
(command (word "echo") (word "_tmp/*.[C-D]") (word "_tmp/*.[C\\-D]"))
---

=== glob with char class expression
# note: mksh doesn't support [[:punct:]] ?
touch _tmp/e.E _tmp/foo.-
echo _tmp/*.[[:punct:]E]
---
(command (word "touch") (word "_tmp/e.E") (word "_tmp/foo.-"))
(command (word "echo") (word "_tmp/*.[[:punct:]E]"))
---

=== glob double quotes
# note: mksh doesn't support [[:punct:]] ?
touch _tmp/\"quoted.py\"
echo _tmp/\"*.py\"
---
(command (word "touch") (word "_tmp/\\\"quoted.py\\\""))
(command (word "echo") (word "_tmp/\\\"*.py\\\""))
---

=== glob escaped
# - mksh doesn't support [[:punct:]] ?
# - python shell fails because \[ not supported!
touch _tmp/\[abc\] _tmp/\?
echo _tmp/\[???\] _tmp/\?
---
(command (word "touch") (word "_tmp/\\[abc\\]") (word "_tmp/\\?"))
(command (word "echo") (word "_tmp/\\[???\\]") (word "_tmp/\\?"))
---

=== : escaped
touch _tmp/foo.-
echo _tmp/*.[[:punct:]] _tmp/*.[[:punct\:]]
---
(command (word "touch") (word "_tmp/foo.-"))
(command (word "echo") (word "_tmp/*.[[:punct:]]") (word "_tmp/*.[[:punct\\:]]"))
---

=== Glob after var manipulation
touch _tmp/foo.zzz _tmp/bar.zzz
g='_tmp/*.zzzZ'
echo $g ${g%Z}
---
(command (word "touch") (word "_tmp/foo.zzz") (word "_tmp/bar.zzz"))
(command (word "g='_tmp/*.zzzZ'"))
(command (word "echo") (word "$g") (word "${g%Z}"))
---

=== Glob after part joining
touch _tmp/foo.yyy _tmp/bar.yyy
g='_tmp/*.yy'
echo $g ${g}y
---
(command (word "touch") (word "_tmp/foo.yyy") (word "_tmp/bar.yyy"))
(command (word "g='_tmp/*.yy'"))
(command (word "echo") (word "$g") (word "${g}y"))
---

=== Glob flags on file system
touch _tmp/-n _tmp/zzzzz
cd _tmp
echo -* hello zzzz?
---
(command (word "touch") (word "_tmp/-n") (word "_tmp/zzzzz"))
(command (word "cd") (word "_tmp"))
(command (word "echo") (word "-*") (word "hello") (word "zzzz?"))
---

=== set -o noglob
cd $REPO_ROOT
touch _tmp/spec-tmp/a.zz _tmp/spec-tmp/b.zz
echo _tmp/spec-tmp/*.zz
set -o noglob
echo _tmp/spec-tmp/*.zz
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "touch") (word "_tmp/spec-tmp/a.zz") (word "_tmp/spec-tmp/b.zz"))
(command (word "echo") (word "_tmp/spec-tmp/*.zz"))
(command (word "set") (word "-o") (word "noglob"))
(command (word "echo") (word "_tmp/spec-tmp/*.zz"))
---

=== set -o noglob (bug #698)
var='\z'
set -f
echo $var
---
(command (word "var='\\z'"))
(command (word "set") (word "-f"))
(command (word "echo") (word "$var"))
---

=== Splitting/Globbing doesn't happen on local assignment
cd $REPO_ROOT

f() {
  # Dash splits words and globs before handing it to the 'local' builtin.  But
  # ash doesn't!
  local foo=$1
  echo "$foo"
}
f 'void *'
---
(command (word "cd") (word "$REPO_ROOT"))
(function "f" (brace-group (semi (command (word "local") (word "foo=$1")) (command (word "echo") (word "\"$foo\"")))))
(command (word "f") (word "'void *'"))
---

=== Glob of unescaped [[] and []]
touch $TMP/[ $TMP/]
cd $TMP
echo [\[z] [\]z]  # the right way to do it
echo [[z] []z]    # also accepted
---
(command (word "touch") (word "$TMP/[") (word "$TMP/]"))
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "[\\[z]") (word "[\\]z]"))
(command (word "echo") (word "[[z]") (word "[]z]"))
---

=== Glob of negated unescaped [[] and []]
# osh does this "correctly" because it defers to libc!
touch $TMP/_G
cd $TMP
echo _[^\[z] _[^\]z]  # the right way to do it
echo _[^[z] _[^]z]    # also accepted
---
(command (word "touch") (word "$TMP/_G"))
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "_[^\\[z]") (word "_[^\\]z]"))
(command (word "echo") (word "_[^[z]") (word "_[^]z]"))
---

=== PatSub of unescaped [[] and []]
x='[foo]'
echo ${x//[\[z]/<}  # the right way to do it
echo ${x//[\]z]/>}
echo ${x//[[z]/<}  # also accepted
echo ${x//[]z]/>}
---
(command (word "x='[foo]'"))
(command (word "echo") (word "${x//[\\[z]/<}"))
(command (word "echo") (word "${x//[\\]z]/>}"))
(command (word "echo") (word "${x//[[z]/<}"))
(command (word "echo") (word "${x//[]z]/>}"))
---

=== PatSub of negated unescaped [[] and []]
x='[foo]'
echo ${x//[^\[z]/<}  # the right way to do it
echo ${x//[^\]z]/>}
echo ${x//[^[z]/<}  # also accepted
#echo ${x//[^]z]/>}  # only busybox ash interprets as ^\]
---
(command (word "x='[foo]'"))
(command (word "echo") (word "${x//[^\\[z]/<}"))
(command (word "echo") (word "${x//[^\\]z]/>}"))
(command (word "echo") (word "${x//[^[z]/<}"))
---

=== Glob unicode char
touch $TMP/__a__
touch $TMP/__μ__
cd $TMP

echo __?__
---
(command (word "touch") (word "$TMP/__a__"))
(command (word "touch") (word "$TMP/__μ__"))
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "__?__"))
---

=== Glob ordering respects LC_COLLATE (zsh respects this too)
# test/spec-common.sh sets LC_ALL=C.UTF_8
unset LC_ALL

touch hello hello.py hello_preamble.sh hello-test.sh
echo h*

# bash - hello_preamble.h comes first
# But ord('_') == 95 
#     ord('-') == 45

# https://serverfault.com/questions/122737/in-bash-are-wildcard-expansions-guaranteed-to-be-in-order

#LC_COLLATE=C.UTF-8
LC_COLLATE=en_US.UTF-8  # en_US is necessary
echo h*

LC_COLLATE=en_US.UTF-8 $SH -c 'echo h*'
---
(command (word "unset") (word "LC_ALL"))
(command (word "touch") (word "hello") (word "hello.py") (word "hello_preamble.sh") (word "hello-test.sh"))
(command (word "echo") (word "h*"))
(command (word "LC_COLLATE=en_US.UTF-8"))
(command (word "echo") (word "h*"))
(command (word "LC_COLLATE=en_US.UTF-8") (word "$SH") (word "-c") (word "'echo h*'"))
---

=== \ in unquoted substitutions does not match a backslash
mkdir x
touch \
  x/test.ifs.\\.txt \
  x/test.ifs.\'.txt \
  x/test.ifs.a.txt \
  x/test.ifs.\\b.txt

v="*\\*.txt"
argv.py x/$v

v="*\'.txt"
argv.py x/$v

v='*\a.txt'
argv.py x/$v

v='*\b.txt'
argv.py x/$v
---
(command (word "mkdir") (word "x"))
(command (word "touch") (word "x/test.ifs.\\\\.txt") (word "x/test.ifs.\\'.txt") (word "x/test.ifs.a.txt") (word "x/test.ifs.\\\\b.txt"))
(command (word "v=\"*\\\\*.txt\""))
(command (word "argv.py") (word "x/$v"))
(command (word "v=\"*\\'.txt\""))
(command (word "argv.py") (word "x/$v"))
(command (word "v='*\\a.txt'"))
(command (word "argv.py") (word "x/$v"))
(command (word "v='*\\b.txt'"))
(command (word "argv.py") (word "x/$v"))
---

=== \ in unquoted substitutions is preserved
v='\*\*.txt'
echo $v
echo "$v"
---
(command (word "v='\\*\\*.txt'"))
(command (word "echo") (word "$v"))
(command (word "echo") (word "\"$v\""))
---

=== \ in unquoted substitutions is preserved with set -o noglob
set -f
v='*\*.txt'
echo $v
---
(command (word "set") (word "-f"))
(command (word "v='*\\*.txt'"))
(command (word "echo") (word "$v"))
---

=== \ in unquoted substitutions is preserved without glob matching
mkdir x
touch \
  'x/test.ifs.\.txt' \
  'x/test.ifs.*.txt'
v='*\*.txt'
argv.py x/unmatching.$v
---
(command (word "mkdir") (word "x"))
(command (word "touch") (word "'x/test.ifs.\\.txt'") (word "'x/test.ifs.*.txt'"))
(command (word "v='*\\*.txt'"))
(command (word "argv.py") (word "x/unmatching.$v"))
---

=== \ in unquoted substitutions escapes globchars
mkdir x
touch \
  'x/test.ifs.\.txt' \
  'x/test.ifs.*.txt'

v='*\*.txt'
argv.py x/$v

v="\\" u='*.txt'
argv.py x/*$v$u

v="\\" u="*.txt"
argv.py x/*$v*.txt
---
(command (word "mkdir") (word "x"))
(command (word "touch") (word "'x/test.ifs.\\.txt'") (word "'x/test.ifs.*.txt'"))
(command (word "v='*\\*.txt'"))
(command (word "argv.py") (word "x/$v"))
(command (word "v=\"\\\\\"") (word "u='*.txt'"))
(command (word "argv.py") (word "x/*$v$u"))
(command (word "v=\"\\\\\"") (word "u=\"*.txt\""))
(command (word "argv.py") (word "x/*$v*.txt"))
---

=== pattern starting with . does not return . and ..
echo hi .*
---
(command (word "echo") (word "hi") (word ".*"))
---

=== shopt -u globskipdots shows . and ..
case $SH in dash|ash|mksh) exit ;; esac

shopt -u globskipdots
echo hi .*
---
(case (word "$SH") (pattern ((word "dash") (word "ash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-u") (word "globskipdots"))
(command (word "echo") (word "hi") (word ".*"))
---

=== Don't glob flags on file system with GLOBIGNORE
touch _tmp/-n _tmp/zzzzz
cd _tmp
GLOBIGNORE=-*:zzzzz  # colon-separated pattern list
echo -* hello zzzz?
---
(command (word "touch") (word "_tmp/-n") (word "_tmp/zzzzz"))
(command (word "cd") (word "_tmp"))
(command (word "GLOBIGNORE=-*:zzzzz"))
(command (word "echo") (word "-*") (word "hello") (word "zzzz?"))
---

=== Ignore *.txt
touch one.md one.txt
mkdir -p foo
touch foo/{two.md,two.txt}
GLOBIGNORE=*.txt
echo *.* foo/*.*
---
(command (word "touch") (word "one.md") (word "one.txt"))
(command (word "mkdir") (word "-p") (word "foo"))
(command (word "touch") (word "foo/{two.md,two.txt}"))
(command (word "GLOBIGNORE=*.txt"))
(command (word "echo") (word "*.*") (word "foo/*.*"))
---

=== Ignore ?.txt
touch {1,10}.txt
mkdir -p foo
touch foo/{2,20}.txt
GLOBIGNORE=?.txt
echo *.* foo/*.*
---
(command (word "touch") (word "{1,10}.txt"))
(command (word "mkdir") (word "-p") (word "foo"))
(command (word "touch") (word "foo/{2,20}.txt"))
(command (word "GLOBIGNORE=?.txt"))
(command (word "echo") (word "*.*") (word "foo/*.*"))
---

=== Ignore *.o:*.h
touch {hello.c,hello.h,hello.o,hello}
GLOBIGNORE=*.o:*.h
echo hello*
---
(command (word "touch") (word "{hello.c,hello.h,hello.o,hello}"))
(command (word "GLOBIGNORE=*.o:*.h"))
(command (word "echo") (word "hello*"))
---

=== Ignore single file src/__main__.py
mkdir src
touch src/{__init__.py,__main__.py}
GLOBIGNORE='src/__init__.py'
echo src/*
---
(command (word "mkdir") (word "src"))
(command (word "touch") (word "src/{__init__.py,__main__.py}"))
(command (word "GLOBIGNORE='src/__init__.py'"))
(command (word "echo") (word "src/*"))
---

=== Ignore dirs dist/*:node_modules/*
mkdir {src,compose,dist,node_modules}
touch src/{a.js,b.js}
touch compose/{base.compose.yaml,dev.compose.yaml}
touch dist/index.js
touch node_modules/package.js
GLOBIGNORE=dist/*:node_modules/*
echo */*
---
(command (word "mkdir") (word "{src,compose,dist,node_modules}"))
(command (word "touch") (word "src/{a.js,b.js}"))
(command (word "touch") (word "compose/{base.compose.yaml,dev.compose.yaml}"))
(command (word "touch") (word "dist/index.js"))
(command (word "touch") (word "node_modules/package.js"))
(command (word "GLOBIGNORE=dist/*:node_modules/*"))
(command (word "echo") (word "*/*"))
---

=== find files in subdirectory but not the ignored pattern
mkdir {dir1,dir2}
touch dir1/{a.txt,ignore.txt}
touch dir2/{a.txt,ignore.txt}
GLOBIGNORE=*/ignore*
echo */*
---
(command (word "mkdir") (word "{dir1,dir2}"))
(command (word "touch") (word "dir1/{a.txt,ignore.txt}"))
(command (word "touch") (word "dir2/{a.txt,ignore.txt}"))
(command (word "GLOBIGNORE=*/ignore*"))
(command (word "echo") (word "*/*"))
---

=== Ignore globs with char patterns like [!ab]
rm -rf _tmp
touch {a,b,c,d,A,B,C,D}
GLOBIGNORE=*[ab]*
echo *
GLOBIGNORE=*[ABC]*
echo *
GLOBIGNORE=*[!ab]*
echo *
---
(command (word "rm") (word "-rf") (word "_tmp"))
(command (word "touch") (word "{a,b,c,d,A,B,C,D}"))
(command (word "GLOBIGNORE=*[ab]*"))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE=*[ABC]*"))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE=*[!ab]*"))
(command (word "echo") (word "*"))
---

=== Ignore globs with char classes like [[:alnum:]]
touch {_testing.py,pyproject.toml,20231114.log,.env}
touch 'has space.docx'
GLOBIGNORE=[[:alnum:]]*
echo *.*
GLOBIGNORE=[![:alnum:]]*
echo *.*
GLOBIGNORE=*[[:space:]]*
echo *.*
GLOBIGNORE=[[:digit:]_.]*
echo *.*
---
(command (word "touch") (word "{_testing.py,pyproject.toml,20231114.log,.env}"))
(command (word "touch") (word "'has space.docx'"))
(command (word "GLOBIGNORE=[[:alnum:]]*"))
(command (word "echo") (word "*.*"))
(command (word "GLOBIGNORE=[![:alnum:]]*"))
(command (word "echo") (word "*.*"))
(command (word "GLOBIGNORE=*[[:space:]]*"))
(command (word "echo") (word "*.*"))
(command (word "GLOBIGNORE=[[:digit:]_.]*"))
(command (word "echo") (word "*.*"))
---

=== Ignore *
# This pattern appears in public repositories
touch {1.txt,2.log,3.md}
GLOBIGNORE=*
echo *
---
(command (word "touch") (word "{1.txt,2.log,3.md}"))
(command (word "GLOBIGNORE=*"))
(command (word "echo") (word "*"))
---

=== treat escaped patterns literally
touch {escape-10.txt,escape*.txt}
GLOBIGNORE="escape\*.txt"
echo *.*
---
(command (word "touch") (word "{escape-10.txt,escape*.txt}"))
(command (word "GLOBIGNORE=\"escape\\*.txt\""))
(command (word "echo") (word "*.*"))
---

=== resetting globignore reverts to default behaviour
touch reset.txt
GLOBIGNORE=*.txt
echo *.*
GLOBIGNORE=
echo *.*
---
(command (word "touch") (word "reset.txt"))
(command (word "GLOBIGNORE=*.txt"))
(command (word "echo") (word "*.*"))
(command (word "GLOBIGNORE="))
(command (word "echo") (word "*.*"))
---

=== Ignore .:..
# globskipdots is enabled by default in bash >=5.2
# for bash <5.2 this pattern is a common way to match dotfiles but not . or ..
shopt -u globskipdots
touch .env
GLOBIGNORE=.:..
echo .*
GLOBIGNORE=
echo .* | sort
---
(command (word "shopt") (word "-u") (word "globskipdots"))
(command (word "touch") (word ".env"))
(command (word "GLOBIGNORE=.:.."))
(command (word "echo") (word ".*"))
(command (word "GLOBIGNORE="))
(pipe (command (word "echo") (word ".*")) (command (word "sort")))
---

=== Quoting GLOBIGNORE
# each style of "ignore everything" spotted in a public repo
touch image.jpeg
GLOBIGNORE=*
echo *
GLOBIGNORE='*'
echo *
GLOBIGNORE="*"
echo *
GLOBIGNORE=\*
echo *
---
(command (word "touch") (word "image.jpeg"))
(command (word "GLOBIGNORE=*"))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE='*'"))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE=\"*\""))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE=\\*"))
(command (word "echo") (word "*"))
---

=== . and .. always filtered when GLOBIGNORE is set
# When GLOBIGNORE is set to any non-null value, . and .. are always filtered
touch .hidden
GLOBIGNORE=*.txt

echo .*
shopt -u globskipdots
echo .*
---
(command (word "touch") (word ".hidden"))
(command (word "GLOBIGNORE=*.txt"))
(command (word "echo") (word ".*"))
(command (word "shopt") (word "-u") (word "globskipdots"))
(command (word "echo") (word ".*"))
---

=== When GLOBIGNORE is set, glob may become empty (nullglob too)
touch -- foo.txt -foo.txt

echo *t

GLOBIGNORE=*.txt
echo *t

shopt -s nullglob
echo nullglob *t
---
(command (word "touch") (word "--") (word "foo.txt") (word "-foo.txt"))
(command (word "echo") (word "*t"))
(command (word "GLOBIGNORE=*.txt"))
(command (word "echo") (word "*t"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "echo") (word "nullglob") (word "*t"))
---

=== When GLOBIGNORE is set, no_dash_glob isn't respected
case $SH in bash) exit ;; esac

touch -- foo.txt -foo.txt

shopt -s no_dash_glob  # YSH option

echo *  # expansion does NOT include -foo.txt

GLOBIGNORE=f*.txt
echo *  # expansion includes -foo.txt, because it doesn't match GLOBIGNORE
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "touch") (word "--") (word "foo.txt") (word "-foo.txt"))
(command (word "shopt") (word "-s") (word "no_dash_glob"))
(command (word "echo") (word "*"))
(command (word "GLOBIGNORE=f*.txt"))
(command (word "echo") (word "*"))
---

=== Extended glob expansion combined with GLOBIGNORE
# @extglob
shopt -s extglob

touch foo.cc foo.h bar.cc bar.h 
echo @(*.cc|*.h)
GLOBIGNORE=foo.*
echo @(*.cc|*.h)
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "touch") (word "foo.cc") (word "foo.h") (word "bar.cc") (word "bar.h"))
(command (word "echo") (word "@(*.cc|*.h)"))
(command (word "GLOBIGNORE=foo.*"))
(command (word "echo") (word "@(*.cc|*.h)"))
---

=== globstar is off -> ** is treated like *
case $SH in zsh) exit ;; esac

shopt -u globstar

mkdir -p c/subdir
touch {leaf.md,c/leaf.md,c/subdir/leaf.md}

echo **/*.* | sort
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "shopt") (word "-u") (word "globstar"))
(command (word "mkdir") (word "-p") (word "c/subdir"))
(command (word "touch") (word "{leaf.md,c/leaf.md,c/subdir/leaf.md}"))
(pipe (command (word "echo") (word "**/*.*")) (command (word "sort")))
---

=== each occurrence of ** recurses through all depths
shopt -s globstar

mkdir -p c/subdir
touch {leaf.md,c/leaf.md,c/subdir/leaf.md}

echo **/*.* | tr ' ' '\n' | sort
echo
echo **/**/*.* | tr ' ' '\n' | sort
---
(command (word "shopt") (word "-s") (word "globstar"))
(command (word "mkdir") (word "-p") (word "c/subdir"))
(command (word "touch") (word "{leaf.md,c/leaf.md,c/subdir/leaf.md}"))
(pipe (command (word "echo") (word "**/*.*")) (pipe (command (word "tr") (word "' '") (word "'\\n'")) (command (word "sort"))))
(command (word "echo"))
(pipe (command (word "echo") (word "**/**/*.*")) (pipe (command (word "tr") (word "' '") (word "'\\n'")) (command (word "sort"))))
---

=== within braces, globstar works when there is a comma
shopt -s globstar

mkdir -p c/subdir
touch c/subdir/leaf.md

echo {**/*.*,} | sort | sed 's/[[:space:]]*$//'
---
(command (word "shopt") (word "-s") (word "globstar"))
(command (word "mkdir") (word "-p") (word "c/subdir"))
(command (word "touch") (word "c/subdir/leaf.md"))
(pipe (command (word "echo") (word "{**/*.*,}")) (pipe (command (word "sort")) (command (word "sed") (word "'s/[[:space:]]*$//'"))))
---

=== ** behaves like * if adjacent to anything other than /
shopt -s globstar

mkdir directory
touch leaf.md
touch directory/leaf.md

echo **/*.* | sort
echo directory/**/*.md | sort
echo d**/*.md | sort
echo **y/*.md | sort
echo d**y/*.md | sort
---
(command (word "shopt") (word "-s") (word "globstar"))
(command (word "mkdir") (word "directory"))
(command (word "touch") (word "leaf.md"))
(command (word "touch") (word "directory/leaf.md"))
(pipe (command (word "echo") (word "**/*.*")) (command (word "sort")))
(pipe (command (word "echo") (word "directory/**/*.md")) (command (word "sort")))
(pipe (command (word "echo") (word "d**/*.md")) (command (word "sort")))
(pipe (command (word "echo") (word "**y/*.md")) (command (word "sort")))
(pipe (command (word "echo") (word "d**y/*.md")) (command (word "sort")))
---

=== in zsh, ***/ follows symlinked directories, while **/ does not
case $SH in bash) exit ;; esac

mkdir directory-1
mkdir directory-2
touch directory-2/leaf-2.md
ln -s -T ../directory-2 directory-1/symlink

echo **/*.* | sort
echo ***/*.* | sort
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "mkdir") (word "directory-1"))
(command (word "mkdir") (word "directory-2"))
(command (word "touch") (word "directory-2/leaf-2.md"))
(command (word "ln") (word "-s") (word "-T") (word "../directory-2") (word "directory-1/symlink"))
(pipe (command (word "echo") (word "**/*.*")) (command (word "sort")))
(pipe (command (word "echo") (word "***/*.*")) (command (word "sort")))
---

=== ~ expansion in assignment
HOME=/home/bob
a=~/src
echo $a
---
(command (word "HOME=/home/bob"))
(command (word "a=~/src"))
(command (word "echo") (word "$a"))
---

=== ~ expansion in readonly assignment
# dash fails here!
# http://stackoverflow.com/questions/8441473/tilde-expansion-doesnt-work-when-i-logged-into-gui
HOME=/home/bob
readonly const=~/src
echo $const
---
(command (word "HOME=/home/bob"))
(command (word "readonly") (word "const=~/src"))
(command (word "echo") (word "$const"))
---

=== No ~ expansion in dynamic assignment
HOME=/home/bob
binding='const=~/src'
readonly "$binding"
echo $const
---
(command (word "HOME=/home/bob"))
(command (word "binding='const=~/src'"))
(command (word "readonly") (word "\"$binding\""))
(command (word "echo") (word "$const"))
---

=== No tilde expansion in word that looks like assignment but isn't
# bash and mksh mistakenly expand here!
# bash fixes this in POSIX mode (gah).
# http://lists.gnu.org/archive/html/bug-bash/2016-06/msg00001.html
HOME=/home/bob
echo x=~
---
(command (word "HOME=/home/bob"))
(command (word "echo") (word "x=~"))
---

=== tilde expansion of word after redirect
HOME=$TMP
echo hi > ~/tilde1.txt
cat $HOME/tilde1.txt | wc -c
---
(command (word "HOME=$TMP"))
(command (word "echo") (word "hi") (redirect ">" "~/tilde1.txt"))
(pipe (command (word "cat") (word "$HOME/tilde1.txt")) (command (word "wc") (word "-c")))
---

=== other user
echo ~nonexistent
---
(command (word "echo") (word "~nonexistent"))
---

=== ${undef:-~}
HOME=/home/bar
echo ${undef:-~}
echo ${HOME:+~/z}
echo "${undef:-~}"
echo ${undef:-"~"}
---
(command (word "HOME=/home/bar"))
(command (word "echo") (word "${undef:-~}"))
(command (word "echo") (word "${HOME:+~/z}"))
(command (word "echo") (word "\"${undef:-~}\""))
(command (word "echo") (word "${undef:-\"~\"}"))
---

=== ${x//~/~root}
HOME=/home/bar
x=~
echo ${x//~/~root}

# gah there is some expansion, what the hell
echo ${HOME//~/~root}

x=[$HOME]
echo ${x//~/~root}
---
(command (word "HOME=/home/bar"))
(command (word "x=~"))
(command (word "echo") (word "${x//~/~root}"))
(command (word "echo") (word "${HOME//~/~root}"))
(command (word "x=[$HOME]"))
(command (word "echo") (word "${x//~/~root}"))
---

=== x=foo:~ has tilde expansion
HOME=/home/bar
x=foo:~
echo $x
echo "$x"  # quotes don't matter, the expansion happens on assignment?
x='foo:~'
echo $x

x=foo:~,  # comma ruins it, must be /
echo $x

x=~:foo
echo $x

# no tilde expansion here
echo foo:~
---
(command (word "HOME=/home/bar"))
(command (word "x=foo:~"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "\"$x\""))
(command (word "x='foo:~'"))
(command (word "echo") (word "$x"))
(command (word "x=foo:~,"))
(command (word "echo") (word "$x"))
(command (word "x=~:foo"))
(command (word "echo") (word "$x"))
(command (word "echo") (word "foo:~"))
---

=== a[x]=foo:~ has tilde expansion
case $SH in dash|zsh) exit ;; esac

HOME=/home/bar
declare -a a
a[0]=foo:~
echo ${a[0]}

declare -A A
A['x']=foo:~
echo ${A['x']}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "HOME=/home/bar"))
(command (word "declare") (word "-a") (word "a"))
(command (word "a[0]=foo:~"))
(command (word "echo") (word "${a[0]}"))
(command (word "declare") (word "-A") (word "A"))
(command (word "A['x']=foo:~"))
(command (word "echo") (word "${A['x']}"))
---

=== tilde expansion an assignment keyword
HOME=/home/bar
f() {
  local x=foo:~
  echo $x
}
f
---
(command (word "HOME=/home/bar"))
(function "f" (brace-group (semi (command (word "local") (word "x=foo:~")) (command (word "echo") (word "$x")))))
(command (word "f"))
---

=== x=${undef-~:~}
HOME=/home/bar

x=~:${undef-~:~}
echo $x

# Most shells agree on a different behavior, but with the OSH parsing model,
# it's easier to agree with yash.  bash disagrees in a different way
---
(command (word "HOME=/home/bar"))
(command (word "x=~:${undef-~:~}"))
(command (word "echo") (word "$x"))
---

=== strict tilde
echo ~nonexistent

shopt -s strict_tilde
echo ~nonexistent

echo status=$?
---
(command (word "echo") (word "~nonexistent"))
(command (word "shopt") (word "-s") (word "strict_tilde"))
(command (word "echo") (word "~nonexistent"))
(command (word "echo") (word "status=$?"))
---

=== temp assignment x=~ env
HOME=/home/bar

xx=~ env | grep xx=

# Does it respect the colon rule too?
xx=~root:~:~ env | grep xx=
---
(command (word "HOME=/home/bar"))
(pipe (command (word "xx=~") (word "env")) (command (word "grep") (word "xx=")))
(pipe (command (word "xx=~root:~:~") (word "env")) (command (word "grep") (word "xx=")))
---

=== Normal and braced
$SH -c 'echo $0 $1 ${2}' a b c d
---
(command (word "$SH") (word "-c") (word "'echo $0 $1 ${2}'") (word "a") (word "b") (word "c") (word "d"))
---

=== In function
myfunc() {
  echo $1 ${2}
}
myfunc a b c d
---
(function "myfunc" (brace-group (command (word "echo") (word "$1") (word "${2}"))))
(command (word "myfunc") (word "a") (word "b") (word "c") (word "d"))
---

=== $0 with -c
$SH -c 'echo $0' | grep -o 'sh$'
---
(pipe (command (word "$SH") (word "-c") (word "'echo $0'")) (command (word "grep") (word "-o") (word "'sh$'")))
---

=== $0 with stdin
echo 'echo $0' | $SH | grep -o 'sh$'
---
(pipe (command (word "echo") (word "'echo $0'")) (pipe (command (word "$SH")) (command (word "grep") (word "-o") (word "'sh$'"))))
---

=== $0 with -i
echo 'echo $0' | $SH -i | grep -o 'sh$'
---
(pipe (command (word "echo") (word "'echo $0'")) (pipe (command (word "$SH") (word "-i")) (command (word "grep") (word "-o") (word "'sh$'"))))
---

=== $0 with filename
s=dollar0
echo 'echo $0' > $s
chmod +x $s
$SH $s
---
(command (word "s=dollar0"))
(command (word "echo") (word "'echo $0'") (redirect ">" "$s"))
(command (word "chmod") (word "+x") (word "$s"))
(command (word "$SH") (word "$s"))
---

=== $@ with filename
s=dollar0
echo 'echo $@' > $s
chmod +x $s
$SH $s a b c
---
(command (word "s=dollar0"))
(command (word "echo") (word "'echo $@'") (redirect ">" "$s"))
(command (word "chmod") (word "+x") (word "$s"))
(command (word "$SH") (word "$s") (word "a") (word "b") (word "c"))
---

=== Lower Case with , and ,,
x='ABC DEF'
echo ${x,}
echo ${x,,}
echo empty=${empty,}
echo empty=${empty,,}
---
(command (word "x='ABC DEF'"))
(command (word "echo") (word "${x,}"))
(command (word "echo") (word "${x,,}"))
(command (word "echo") (word "empty=${empty,}"))
(command (word "echo") (word "empty=${empty,,}"))
---

=== Upper Case with ^ and ^^
x='abc def'
echo ${x^}
echo ${x^^}
echo empty=${empty^}
echo empty=${empty^^}
---
(command (word "x='abc def'"))
(command (word "echo") (word "${x^}"))
(command (word "echo") (word "${x^^}"))
(command (word "echo") (word "empty=${empty^}"))
(command (word "echo") (word "empty=${empty^^}"))
---

=== Case folding - Unicode characters
# https://www.utf8-chartable.de/unicode-utf8-table.pl

x=$'\u00C0\u00C8'  # upper grave
y=$'\u00E1\u00E9'  # lower acute

echo u ${x^}
echo U ${x^^}

echo l ${x,}
echo L ${x,,}

echo u ${y^}
echo U ${y^^}

echo l ${y,}
echo L ${y,,}
---
(command (word "x='ÀÈ'"))
(command (word "y='áé'"))
(command (word "echo") (word "u") (word "${x^}"))
(command (word "echo") (word "U") (word "${x^^}"))
(command (word "echo") (word "l") (word "${x,}"))
(command (word "echo") (word "L") (word "${x,,}"))
(command (word "echo") (word "u") (word "${y^}"))
(command (word "echo") (word "U") (word "${y^^}"))
(command (word "echo") (word "l") (word "${y,}"))
(command (word "echo") (word "L") (word "${y,,}"))
---

=== Case folding - multi code point
echo shell
small=$'\u00DF'
echo u ${small^}
echo U ${small^^}

echo l ${small,}
echo L ${small,,}
echo

echo python2
python2 -c '
small = u"\u00DF"
print(small.upper().encode("utf-8"))
print(small.lower().encode("utf-8"))
'
echo

# Not in the container images, but python 3 DOES support it!
# This is moved to demo/survey-case-fold.sh

if false; then
echo python3
python3 -c '
import sys
small = u"\u00DF"
sys.stdout.buffer.write(small.upper().encode("utf-8") + b"\n")
sys.stdout.buffer.write(small.lower().encode("utf-8") + b"\n")
'
fi

if false; then
  # Yes, supported
  echo node.js

  nodejs -e '
  var small = "\u00DF"
  console.log(small.toUpperCase())
  console.log(small.toLowerCase())
  '
fi
---
(command (word "echo") (word "shell"))
(command (word "small='ß'"))
(command (word "echo") (word "u") (word "${small^}"))
(command (word "echo") (word "U") (word "${small^^}"))
(command (word "echo") (word "l") (word "${small,}"))
(command (word "echo") (word "L") (word "${small,,}"))
(command (word "echo"))
(command (word "echo") (word "python2"))
(command (word "python2") (word "-c") (word "'\nsmall = u\"\\u00DF\"\nprint(small.upper().encode(\"utf-8\"))\nprint(small.lower().encode(\"utf-8\"))\n'"))
(command (word "echo"))
(if (command (word "false")) (semi (command (word "echo") (word "python3")) (command (word "python3") (word "-c") (word "'\nimport sys\nsmall = u\"\\u00DF\"\nsys.stdout.buffer.write(small.upper().encode(\"utf-8\") + b\"\\n\")\nsys.stdout.buffer.write(small.lower().encode(\"utf-8\") + b\"\\n\")\n'"))))
(if (command (word "false")) (semi (command (word "echo") (word "node.js")) (command (word "nodejs") (word "-e") (word "'\n  var small = \"\\u00DF\"\n  console.log(small.toUpperCase())\n  console.log(small.toLowerCase())\n  '"))))
---

=== Case folding that depends on locale (not enabled, requires Turkish locale)
# Hm this works in demo/survey-case-fold.sh
# Is this a bash 4.4 thing?

#export LANG='tr_TR.UTF-8'
#echo $LANG

x='i'

echo u ${x^}
echo U ${x^^}

echo l ${x,}
echo L ${x,,}
---
(command (word "x='i'"))
(command (word "echo") (word "u") (word "${x^}"))
(command (word "echo") (word "U") (word "${x^^}"))
(command (word "echo") (word "l") (word "${x,}"))
(command (word "echo") (word "L") (word "${x,,}"))
---

=== Lower Case with constant string (VERY WEIRD)
x='AAA ABC DEF'
echo ${x,A}
echo ${x,,A}  # replaces every A only?
---
(command (word "x='AAA ABC DEF'"))
(command (word "echo") (word "${x,A}"))
(command (word "echo") (word "${x,,A}"))
---

=== Lower Case glob
# Hm with C.UTF-8, this does no case folding?
export LC_ALL=en_US.UTF-8

x='ABC DEF'
echo ${x,[d-f]}
echo ${x,,[d-f]}  # bash 4.4 fixed in bash 5.2.21
---
(command (word "export") (word "LC_ALL=en_US.UTF-8"))
(command (word "x='ABC DEF'"))
(command (word "echo") (word "${x,[d-f]}"))
(command (word "echo") (word "${x,,[d-f]}"))
---

=== ${x@u} U L - upper / lower case (bash 5.1 feature)
# https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html

x='abc DEF'

echo "${x@u}"

echo "${x@U}"

echo "${x@L}"
---
(command (word "x='abc DEF'"))
(command (word "echo") (word "\"${x@u}\""))
(command (word "echo") (word "\"${x@U}\""))
(command (word "echo") (word "\"${x@L}\""))
---

=== ${x@Q}
x="FOO'BAR spam\"eggs"
eval "new=${x@Q}"
test "$x" = "$new" && echo OK
---
(command (word "x=\"FOO'BAR spam\\\"eggs\""))
(command (word "eval") (word "\"new=${x@Q}\""))
(and (command (word "test") (word "\"$x\"") (word "=") (word "\"$new\"")) (command (word "echo") (word "OK")))
---

=== ${array@Q} and ${array[@]@Q}
array=(x 'y\nz')
echo ${array[@]@Q}
echo ${array@Q}
echo ${array@Q}
---
(command (word "array=(x 'y\\nz')"))
(command (word "echo") (word "${array[@]@Q}"))
(command (word "echo") (word "${array@Q}"))
(command (word "echo") (word "${array@Q}"))
---

=== ${!prefix@} ${!prefix*} yields sorted array of var names
ZOO=zoo
ZIP=zip
ZOOM='one two'
Z='three four'

z=lower

argv.py ${!Z*}
argv.py ${!Z@}
argv.py "${!Z*}"
argv.py "${!Z@}"
for i in 1 2; do argv.py ${!Z*}  ; done
for i in 1 2; do argv.py ${!Z@}  ; done
for i in 1 2; do argv.py "${!Z*}"; done
for i in 1 2; do argv.py "${!Z@}"; done
---
(command (word "ZOO=zoo"))
(command (word "ZIP=zip"))
(command (word "ZOOM='one two'"))
(command (word "Z='three four'"))
(command (word "z=lower"))
(command (word "argv.py") (word "${!Z*}"))
(command (word "argv.py") (word "${!Z@}"))
(command (word "argv.py") (word "\"${!Z*}\""))
(command (word "argv.py") (word "\"${!Z@}\""))
(for (word "i") (in (word "1") (word "2")) (command (word "argv.py") (word "${!Z*}")))
(for (word "i") (in (word "1") (word "2")) (command (word "argv.py") (word "${!Z@}")))
(for (word "i") (in (word "1") (word "2")) (command (word "argv.py") (word "\"${!Z*}\"")))
(for (word "i") (in (word "1") (word "2")) (command (word "argv.py") (word "\"${!Z@}\"")))
---

=== ${!prefix@} matches var name (regression)
hello1=1 hello2=2 hello3=3
echo ${!hello@}
hello=()
echo ${!hello@}
---
(command (word "hello1=1") (word "hello2=2") (word "hello3=3"))
(command (word "echo") (word "${!hello@}"))
(command (word "hello=()"))
(command (word "echo") (word "${!hello@}"))
---

=== ${var@a} for attributes
array=(one two)
echo ${array@a}
declare -r array=(one two)
echo ${array@a}
declare -rx PYTHONPATH=hi
echo ${PYTHONPATH@a}

# bash and osh differ here
#declare -rxn x=z
#echo ${x@a}
---
(command (word "array=(one two)"))
(command (word "echo") (word "${array@a}"))
(command (word "declare") (word "-r") (word "array=(one two)"))
(command (word "echo") (word "${array@a}"))
(command (word "declare") (word "-rx") (word "PYTHONPATH=hi"))
(command (word "echo") (word "${PYTHONPATH@a}"))
---

=== ${var@a} error conditions
echo [${?@a}]
---
(command (word "echo") (word "[${?@a}]"))
---

=== undef and @P @Q @a
$SH -c 'echo ${undef@P}'
echo status=$?
$SH -c 'echo ${undef@Q}'
echo status=$?
$SH -c 'echo ${undef@a}'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'echo ${undef@P}'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo ${undef@Q}'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo ${undef@a}'"))
(command (word "echo") (word "status=$?"))
---

=== argv array and @P @Q @a
$SH -c 'echo ${@@P}' dummy a b c
echo status=$?
$SH -c 'echo ${@@Q}' dummy a 'b\nc'
echo status=$?
$SH -c 'echo ${@@a}' dummy a b c
echo status=$?
---
(command (word "$SH") (word "-c") (word "'echo ${@@P}'") (word "dummy") (word "a") (word "b") (word "c"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo ${@@Q}'") (word "dummy") (word "a") (word "'b\\nc'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo ${@@a}'") (word "dummy") (word "a") (word "b") (word "c"))
(command (word "echo") (word "status=$?"))
---

=== assoc array and @P @Q @a
# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${A@P} - ${A[@]@P}'
echo status=$?

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${A@Q} - ${A[@]@Q}' | sed 's/^- y$/- '\''y'\''/'
echo status=$?

$SH -c 'declare -A A=(["x"]=y); echo ${A@a} - ${A[@]@a}'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=\"y\"); echo ${A@P} - ${A[@]@P}'"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=\"y\"); echo ${A@Q} - ${A[@]@Q}'")) (command (word "sed") (word "'s/^- y$/- '\\''y'\\''/'")))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=y); echo ${A@a} - ${A[@]@a}'"))
(command (word "echo") (word "status=$?"))
---

=== ${!var[@]@X}
# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${!A[@]@P}'
if test $? -ne 0; then echo fail; fi

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x y"]="y"); echo ${!A[@]@Q}'
if test $? -ne 0; then echo fail; fi

$SH -c 'declare -A A=(["x"]=y); echo ${!A[@]@a}'
if test $? -ne 0; then echo fail; fi
# STDOUT:



# END

#### ${#var@X} is a parse error
# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${#A[@]@P}'
if test $? -ne 0; then echo fail; fi

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${#A[@]@Q}'
if test $? -ne 0; then echo fail; fi

$SH -c 'declare -A A=(["x"]=y); echo ${#A[@]@a}'
if test $? -ne 0; then echo fail; fi
---
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=\"y\"); echo ${!A[@]@P}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x y\"]=\"y\"); echo ${!A[@]@Q}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=y); echo ${!A[@]@a}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=\"y\"); echo ${#A[@]@P}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=\"y\"); echo ${#A[@]@Q}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
(command (word "$SH") (word "-c") (word "'declare -A A=([\"x\"]=y); echo ${#A[@]@a}'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
---

=== ${!A@a} and ${!A[@]@a}
declare -A A=(["x"]=y)
echo x=${!A[@]@a}
echo invalid=${!A@a}

# OSH prints 'a' for indexed array because the AssocArray with ! turns into
# it.  Disallowing it would be the other reasonable behavior.
---
(command (word "declare") (word "-A") (word "A=([\"x\"]=y)"))
(command (word "echo") (word "x=${!A[@]@a}"))
(command (word "echo") (word "invalid=${!A@a}"))
---

=== undef vs. empty string in var ops
empty=''
x=x

echo ${x@Q} ${empty@Q} ${undef@Q} ${x@Q}

echo ${x@K} ${empty@K} ${undef@K} ${x@K}

echo ${x@k} ${empty@k} ${undef@k} ${x@k}

echo ${x@A} ${empty@A} ${undef@A} ${x@A}

declare -r x
echo ${x@a} ${empty@a} ${undef@a} ${x@a}

# x x
#echo ${x@E} ${empty@E} ${undef@E} ${x@E}
# x x
#echo ${x@P} ${empty@P} ${undef@P} ${x@P}
---
(command (word "empty=''"))
(command (word "x=x"))
(command (word "echo") (word "${x@Q}") (word "${empty@Q}") (word "${undef@Q}") (word "${x@Q}"))
(command (word "echo") (word "${x@K}") (word "${empty@K}") (word "${undef@K}") (word "${x@K}"))
(command (word "echo") (word "${x@k}") (word "${empty@k}") (word "${undef@k}") (word "${x@k}"))
(command (word "echo") (word "${x@A}") (word "${empty@A}") (word "${undef@A}") (word "${x@A}"))
(command (word "declare") (word "-r") (word "x"))
(command (word "echo") (word "${x@a}") (word "${empty@a}") (word "${undef@a}") (word "${x@a}"))
---

=== -o nounset with var ops
set -u
(echo ${undef@Q}); echo "stat: $?"
(echo ${undef@P}); echo "stat: $?"
(echo ${undef@a}); echo "stat: $?"
---
(command (word "set") (word "-u"))
(semi (subshell (command (word "echo") (word "${undef@Q}"))) (command (word "echo") (word "\"stat: $?\"")))
(semi (subshell (command (word "echo") (word "${undef@P}"))) (command (word "echo") (word "\"stat: $?\"")))
(semi (subshell (command (word "echo") (word "${undef@a}"))) (command (word "echo") (word "\"stat: $?\"")))
---

=== ${a[0]@a} and ${a@a}
a=(1 2 3)
echo "attr = '${a[0]@a}'"
echo "attr = '${a@a}'"
---
(command (word "a=(1 2 3)"))
(command (word "echo") (word "\"attr = '${a[0]@a}'\""))
(command (word "echo") (word "\"attr = '${a@a}'\""))
---

=== ${!r@a} with r='a[0]' (attribute for indirect expansion of an array element)
a=(1 2 3)
r='a'
echo ${!r@a}
r='a[0]'
echo ${!r@a}

declare -A d=([0]=foo [1]=bar)
r='d'
echo ${!r@a}
r='d[0]'
echo ${!r@a}
---
(command (word "a=(1 2 3)"))
(command (word "r='a'"))
(command (word "echo") (word "${!r@a}"))
(command (word "r='a[0]'"))
(command (word "echo") (word "${!r@a}"))
(command (word "declare") (word "-A") (word "d=([0]=foo [1]=bar)"))
(command (word "r='d'"))
(command (word "echo") (word "${!r@a}"))
(command (word "r='d[0]'"))
(command (word "echo") (word "${!r@a}"))
---

=== Array expansion with nullary var op @Q
declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@Q}"
argv.py "${a[*]@Q}"
argv.py "${A[@]@Q}"
argv.py "${A[*]@Q}"
argv.py "${u[@]@Q}"
argv.py "${u[*]@Q}"
---
(command (word "declare") (word "-a") (word "a=({1..9})"))
(command (word "declare") (word "-A") (word "A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)"))
(command (word "argv.py") (word "\"${a[@]@Q}\""))
(command (word "argv.py") (word "\"${a[*]@Q}\""))
(command (word "argv.py") (word "\"${A[@]@Q}\""))
(command (word "argv.py") (word "\"${A[*]@Q}\""))
(command (word "argv.py") (word "\"${u[@]@Q}\""))
(command (word "argv.py") (word "\"${u[*]@Q}\""))
---

=== Array expansion with nullary var op @P
declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@P}"
argv.py "${a[*]@P}"
argv.py "${A[@]@P}"
argv.py "${A[*]@P}"
argv.py "${u[@]@P}"
argv.py "${u[*]@P}"
---
(command (word "declare") (word "-a") (word "a=({1..9})"))
(command (word "declare") (word "-A") (word "A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)"))
(command (word "argv.py") (word "\"${a[@]@P}\""))
(command (word "argv.py") (word "\"${a[*]@P}\""))
(command (word "argv.py") (word "\"${A[@]@P}\""))
(command (word "argv.py") (word "\"${A[*]@P}\""))
(command (word "argv.py") (word "\"${u[@]@P}\""))
(command (word "argv.py") (word "\"${u[*]@P}\""))
---

=== Array expansion with nullary var op @a
declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@a}"
argv.py "${a[*]@a}"
argv.py "${A[@]@a}"
argv.py "${A[*]@a}"
argv.py "${u[@]@a}"
argv.py "${u[*]@a}"
---
(command (word "declare") (word "-a") (word "a=({1..9})"))
(command (word "declare") (word "-A") (word "A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)"))
(command (word "argv.py") (word "\"${a[@]@a}\""))
(command (word "argv.py") (word "\"${a[*]@a}\""))
(command (word "argv.py") (word "\"${A[@]@a}\""))
(command (word "argv.py") (word "\"${A[*]@a}\""))
(command (word "argv.py") (word "\"${u[@]@a}\""))
(command (word "argv.py") (word "\"${u[*]@a}\""))
---

=== String length
v=foo
echo ${#v}
---
(command (word "v=foo"))
(command (word "echo") (word "${#v}"))
---

=== Unicode string length (UTF-8)
v=$'_\u03bc_'
echo ${#v}
---
(command (word "v='_μ_'"))
(command (word "echo") (word "${#v}"))
---

=== Unicode string length (spec/testdata/utf8-chars.txt)
v=$(cat $REPO_ROOT/spec/testdata/utf8-chars.txt)
echo ${#v}
---
(command (word "v=$(cat $REPO_ROOT/spec/testdata/utf8-chars.txt)"))
(command (word "echo") (word "${#v}"))
---

=== String length with incomplete utf-8
for num_bytes in 0 1 2 3 4 5 6 7 8 9 10 11 12 13; do
  s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)
  echo ${#s}
done 2> $TMP/err.txt

grep 'warning:' $TMP/err.txt
true  # exit 0
---
(for (word "num_bytes") (in (word "0") (word "1") (word "2") (word "3") (word "4") (word "5") (word "6") (word "7") (word "8") (word "9") (word "10") (word "11") (word "12") (word "13")) (semi (command (word "s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)")) (command (word "echo") (word "${#s}")))) (redirect ">" "$TMP/err.txt")
(command (word "grep") (word "'warning:'") (word "$TMP/err.txt"))
(command (word "true"))
---

=== String length with invalid utf-8 continuation bytes
for num_bytes in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14; do
  s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)$(echo -e "\xFF")
  echo ${#s}
done 2> $TMP/err.txt

grep 'warning:' $TMP/err.txt
true
---
(for (word "num_bytes") (in (word "0") (word "1") (word "2") (word "3") (word "4") (word "5") (word "6") (word "7") (word "8") (word "9") (word "10") (word "11") (word "12") (word "13") (word "14")) (semi (command (word "s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)$(echo -e \"\\xFF\")")) (command (word "echo") (word "${#s}")))) (redirect ">" "$TMP/err.txt")
(command (word "grep") (word "'warning:'") (word "$TMP/err.txt"))
(command (word "true"))
---

=== Length of undefined variable
echo ${#undef}
---
(command (word "echo") (word "${#undef}"))
---

=== Length of undefined variable with nounset
set -o nounset
echo ${#undef}
---
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "${#undef}"))
---

=== Length operator can't be followed by test operator
echo ${#x-default}

x=''
echo ${#x-default}

x='foo'
echo ${#x-default}
---
(command (word "echo") (word "${#x-default}"))
(command (word "x=''"))
(command (word "echo") (word "${#x-default}"))
(command (word "x='foo'"))
(command (word "echo") (word "${#x-default}"))
---

=== ${#s} respects LC_ALL - length in bytes or code points
case $SH in dash) exit ;; esac

# This test case is sorta "infected" because spec-common.sh sets LC_ALL=C.UTF-8
#
# For some reason mksh behaves differently
#
# See demo/04-unicode.sh

#echo $LC_ALL
unset LC_ALL 

# note: this may depend on the CI machine config
LANG=en_US.UTF-8

#LC_ALL=en_US.UTF-8

for s in $'\u03bc' $'\U00010000'; do
  LC_ALL=
  echo "len=${#s}"

  LC_ALL=C
  echo "len=${#s}"

  echo
done
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "unset") (word "LC_ALL"))
(command (word "LANG=en_US.UTF-8"))
(for (word "s") (in (word "'μ'") (word "'𐀀'")) (semi (semi (semi (semi (command (word "LC_ALL=")) (command (word "echo") (word "\"len=${#s}\""))) (command (word "LC_ALL=C"))) (command (word "echo") (word "\"len=${#s}\""))) (command (word "echo"))))
---

=== Pattern replacement
v=abcde
echo ${v/c*/XX}
---
(command (word "v=abcde"))
(command (word "echo") (word "${v/c*/XX}"))
---

=== Pattern replacement on unset variable
echo -${v/x/y}-
echo status=$?
set -o nounset  # make sure this fails
echo -${v/x/y}-
---
(command (word "echo") (word "-${v/x/y}-"))
(command (word "echo") (word "status=$?"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "-${v/x/y}-"))
---

=== Global Pattern replacement with /
s=xx_xx_xx
echo ${s/xx?/yy_} ${s//xx?/yy_}
---
(command (word "s=xx_xx_xx"))
(command (word "echo") (word "${s/xx?/yy_}") (word "${s//xx?/yy_}"))
---

=== Left Anchored Pattern replacement with #
s=xx_xx_xx
echo ${s/?xx/_yy} ${s/#?xx/_yy}
---
(command (word "s=xx_xx_xx"))
(command (word "echo") (word "${s/?xx/_yy}") (word "${s/#?xx/_yy}"))
---

=== Right Anchored Pattern replacement with %
s=xx_xx_xx
echo ${s/?xx/_yy} ${s/%?xx/_yy}
---
(command (word "s=xx_xx_xx"))
(command (word "echo") (word "${s/?xx/_yy}") (word "${s/%?xx/_yy}"))
---

=== Replace fixed strings
s=xx_xx
echo ${s/xx/yy} ${s//xx/yy} ${s/#xx/yy} ${s/%xx/yy}
---
(command (word "s=xx_xx"))
(command (word "echo") (word "${s/xx/yy}") (word "${s//xx/yy}") (word "${s/#xx/yy}") (word "${s/%xx/yy}"))
---

=== Replace is longest match
# If it were shortest, then you would just replace the first <html>
s='begin <html></html> end'
echo ${s/<*>/[]}
---
(command (word "s='begin <html></html> end'"))
(command (word "echo") (word "${s/<*>/[]}"))
---

=== Replace char class
s=xx_xx_xx
echo ${s//[[:alpha:]]/y} ${s//[^[:alpha:]]/-}
---
(command (word "s=xx_xx_xx"))
(command (word "echo") (word "${s//[[:alpha:]]/y}") (word "${s//[^[:alpha:]]/-}"))
---

=== Replace hard glob
s='aa*bb+cc'
echo ${s//\**+/__}  # Literal *, then any sequence of characters, then literal +
---
(command (word "s='aa*bb+cc'"))
(command (word "echo") (word "${s//\\**+/__}"))
---

=== ${v/} is empty search and replacement
v=abcde
echo -${v/}-
echo status=$?
---
(command (word "v=abcde"))
(command (word "echo") (word "-${v/}-"))
(command (word "echo") (word "status=$?"))
---

=== ${v//} is empty search and replacement
v='a/b/c'
echo -${v//}-
echo status=$?
---
(command (word "v='a/b/c'"))
(command (word "echo") (word "-${v//}-"))
(command (word "echo") (word "status=$?"))
---

=== Confusing unquoted slash matches bash (and ash)
x='/_/'
echo ${x////c}

echo ${x//'/'/c}
---
(command (word "x='/_/'"))
(command (word "echo") (word "${x////c}"))
(command (word "echo") (word "${x//'/'/c}"))
---

=== Synthesized ${x///} bug (similar to above)
# found via test/parse-errors.sh

x='slash / brace } hi'
echo 'ambiguous:' ${x///}

echo 'quoted:   ' ${x//'/'}

# Wow we have all combination here -- TERRIBLE
---
(command (word "x='slash / brace } hi'"))
(command (word "echo") (word "'ambiguous:'") (word "${x///}"))
(command (word "echo") (word "'quoted:   '") (word "${x//'/'}"))
---

=== ${v/a} is the same as ${v/a/}  -- no replacement string
v='aabb'
echo ${v/a}
echo status=$?
---
(command (word "v='aabb'"))
(command (word "echo") (word "${v/a}"))
(command (word "echo") (word "status=$?"))
---

=== Replacement with special chars (bug fix)
v=xx
echo ${v/x/"?"}
---
(command (word "v=xx"))
(command (word "echo") (word "${v/x/\"?\"}"))
---

=== Replace backslash
v='[\f]'
x='\f'
echo ${v/"$x"/_}

# mksh and zsh differ on this case, but this is consistent with the fact that
# \f as a glob means 'f', not '\f'.  TODO: Warn that it's a bad glob?
# The canonical form is 'f'.
echo ${v/$x/_}

echo ${v/\f/_}
echo ${v/\\f/_}
---
(command (word "v='[\\f]'"))
(command (word "x='\\f'"))
(command (word "echo") (word "${v/\"$x\"/_}"))
(command (word "echo") (word "${v/$x/_}"))
(command (word "echo") (word "${v/\\f/_}"))
(command (word "echo") (word "${v/\\\\f/_}"))
---

=== Replace right ]
v='--]--'
x=']'
echo ${v/"$x"/_}
echo ${v/$x/_}
---
(command (word "v='--]--'"))
(command (word "x=']'"))
(command (word "echo") (word "${v/\"$x\"/_}"))
(command (word "echo") (word "${v/$x/_}"))
---

=== Substitute glob characters in pattern, quoted and unquoted
# INFINITE LOOP in ash!
case $SH in ash) exit ;; esac

g='*'
v='a*b'
echo ${v//"$g"/-}
echo ${v//$g/-}
---
(case (word "$SH") (pattern ((word "ash")) (command (word "exit"))))
(command (word "g='*'"))
(command (word "v='a*b'"))
(command (word "echo") (word "${v//\"$g\"/-}"))
(command (word "echo") (word "${v//$g/-}"))
---

=== Substitute one unicode character (UTF-8)
export LANG='en_US.UTF-8'

s='_μ_ and _μ_'

# ? should match one char

echo ${s//_?_/foo}  # all
echo ${s/#_?_/foo}  # left
echo ${s/%_?_/foo}  # right
---
(command (word "export") (word "LANG='en_US.UTF-8'"))
(command (word "s='_μ_ and _μ_'"))
(command (word "echo") (word "${s//_?_/foo}"))
(command (word "echo") (word "${s/#_?_/foo}"))
(command (word "echo") (word "${s/%_?_/foo}"))
---

=== When LC_ALL=C, pattern ? doesn't match multibyte character
export LC_ALL='C'

s='_μ_ and _μ_'

# ? should match one char

echo ${s//_?_/foo}  # all
echo ${s/#_?_/foo}  # left
echo ${s/%_?_/foo}  # right
echo

a='_x_ and _y_'

echo ${a//_?_/foo}  # all
echo ${a/#_?_/foo}  # left
echo ${a/%_?_/foo}  # right
---
(command (word "export") (word "LC_ALL='C'"))
(command (word "s='_μ_ and _μ_'"))
(command (word "echo") (word "${s//_?_/foo}"))
(command (word "echo") (word "${s/#_?_/foo}"))
(command (word "echo") (word "${s/%_?_/foo}"))
(command (word "echo"))
(command (word "a='_x_ and _y_'"))
(command (word "echo") (word "${a//_?_/foo}"))
(command (word "echo") (word "${a/#_?_/foo}"))
(command (word "echo") (word "${a/%_?_/foo}"))
---

=== ${x/^} regression
x=abc
echo ${x/^}
echo ${x/!}

y=^^^
echo ${y/^}
echo ${y/!}

z=!!!
echo ${z/^}
echo ${z/!}

s=a^b!c
echo ${s/a^}
echo ${s/b!}
---
(command (word "x=abc"))
(command (word "echo") (word "${x/^}"))
(command (word "echo") (word "${x/!}"))
(command (word "y=^^^"))
(command (word "echo") (word "${y/^}"))
(command (word "echo") (word "${y/!}"))
(command (word "z=!!!"))
(command (word "echo") (word "${z/^}"))
(command (word "echo") (word "${z/!}"))
(command (word "s=a^b!c"))
(command (word "echo") (word "${s/a^}"))
(command (word "echo") (word "${s/b!}"))
---

=== \(\) in pattern (regression)
# Not extended globs
x='foo()' 
echo 1 ${x//*\(\)/z}
echo 2 ${x//*\(\)/z}
echo 3 ${x//\(\)/z}
echo 4 ${x//*\(\)/z}
---
(command (word "x='foo()'"))
(command (word "echo") (word "1") (word "${x//*\\(\\)/z}"))
(command (word "echo") (word "2") (word "${x//*\\(\\)/z}"))
(command (word "echo") (word "3") (word "${x//\\(\\)/z}"))
(command (word "echo") (word "4") (word "${x//*\\(\\)/z}"))
---

=== patsub with single quotes and hyphen in character class (regression)
# from Crestwave's bf.bash

program='^++--hello.,world<>[]'
program=${program//[^'><+-.,[]']} 
echo $program
---
(command (word "program='^++--hello.,world<>[]'"))
(command (word "program=${program//[^'><+-.,[]']}"))
(command (word "echo") (word "$program"))
---

=== patsub with [^]]
# This is a PARSING divergence.  In OSH we match [], rather than using POSIX
# rules!

pat='[^]]'
s='ab^cd^'
echo ${s//$pat/z}
---
(command (word "pat='[^]]'"))
(command (word "s='ab^cd^'"))
(command (word "echo") (word "${s//$pat/z}"))
---

=== [a-z] Invalid range end is syntax error
x=fooz
pat='[z-a]'  # Invalid range.  Other shells don't catch it!
#pat='[a-y]'
echo ${x//$pat}
echo status=$?
---
(command (word "x=fooz"))
(command (word "pat='[z-a]'"))
(command (word "echo") (word "${x//$pat}"))
(command (word "echo") (word "status=$?"))
---

=== Pattern is empty $foo$bar -- regression for infinite loop
x=-foo-

echo ${x//$foo$bar/bar}
---
(command (word "x=-foo-"))
(command (word "echo") (word "${x//$foo$bar/bar}"))
---

=== Chromium from http://www.oilshell.org/blog/2016/11/07.html
case $SH in zsh) exit ;; esac

HOST_PATH=/foo/bar/baz
echo ${HOST_PATH////\\/}

# The way bash parses it
echo ${HOST_PATH//'/'/\\/}
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "HOST_PATH=/foo/bar/baz"))
(command (word "echo") (word "${HOST_PATH////\\\\/}"))
(command (word "echo") (word "${HOST_PATH//'/'/\\\\/}"))
---

=== ${x//~homedir/}
path=~/git/oilshell

# ~ expansion occurs
#echo path=$path

echo ${path//~/z}

echo ${path/~/z}
---
(command (word "path=~/git/oilshell"))
(command (word "echo") (word "${path//~/z}"))
(command (word "echo") (word "${path/~/z}"))
---

=== String slice
foo=abcdefg
echo ${foo:1:3}
---
(command (word "foo=abcdefg"))
(command (word "echo") (word "${foo:1:3}"))
---

=== Cannot take length of substring slice
# These are runtime errors, but we could make them parse time errors.
v=abcde
echo ${#v:1:3}
---
(command (word "v=abcde"))
(command (word "echo") (word "${#v:1:3}"))
---

=== Out of range string slice: begin
# out of range begin doesn't raise error in bash, but in mksh it skips the
# whole thing!
foo=abcdefg
echo _${foo:100:3}
echo $?
---
(command (word "foo=abcdefg"))
(command (word "echo") (word "_${foo:100:3}"))
(command (word "echo") (word "$?"))
---

=== Out of range string slice: length
# OK in both bash and mksh
foo=abcdefg
echo _${foo:3:100}
echo $?
---
(command (word "foo=abcdefg"))
(command (word "echo") (word "_${foo:3:100}"))
(command (word "echo") (word "$?"))
---

=== Negative start index
foo=abcdefg
echo ${foo: -4:3}
---
(command (word "foo=abcdefg"))
(command (word "echo") (word "${foo: -4:3}"))
---

=== Negative start index respects unicode
foo=abcd-μ-
echo ${foo: -4:3}
---
(command (word "foo=abcd-μ-"))
(command (word "echo") (word "${foo: -4:3}"))
---

=== Negative second arg is position, not length!
foo=abcdefg
echo ${foo:3:-1} ${foo: 3: -2} ${foo:3 :-3 }
---
(command (word "foo=abcdefg"))
(command (word "echo") (word "${foo:3:-1}") (word "${foo: 3: -2}") (word "${foo:3 :-3 }"))
---

=== Negative start index respects unicode
foo=abcd-μ-
echo ${foo: -5: -3}
---
(command (word "foo=abcd-μ-"))
(command (word "echo") (word "${foo: -5: -3}"))
---

=== String slice with math
# I think this is the $(()) language inside?
i=1
foo=abcdefg
echo ${foo: i+4-2 : i + 2}
---
(command (word "i=1"))
(command (word "foo=abcdefg"))
(command (word "echo") (word "${foo: i+4-2 : i + 2}"))
---

=== Slice undefined
echo -${undef:1:2}-
set -o nounset
echo -${undef:1:2}-
echo -done-
---
(command (word "echo") (word "-${undef:1:2}-"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "-${undef:1:2}-"))
(command (word "echo") (word "-done-"))
---

=== Slice UTF-8 String
# mksh slices by bytes.
foo='--μ--'
echo ${foo:1:3}
---
(command (word "foo='--μ--'"))
(command (word "echo") (word "${foo:1:3}"))
---

=== Slice string with invalid UTF-8 results in empty string and warning
s=$(echo -e "\xFF")bcdef
echo -${s:1:3}-
---
(command (word "s=$(echo -e \"\\xFF\")bcdef"))
(command (word "echo") (word "-${s:1:3}-"))
---

=== Slice string with invalid UTF-8 with strict_word_eval
shopt -s strict_word_eval || true
echo slice
s=$(echo -e "\xFF")bcdef
echo -${s:1:3}-
---
(or (command (word "shopt") (word "-s") (word "strict_word_eval")) (command (word "true")))
(command (word "echo") (word "slice"))
(command (word "s=$(echo -e \"\\xFF\")bcdef"))
(command (word "echo") (word "-${s:1:3}-"))
---

=== Slice with an index that's an array -- silent a[0] decay
i=(3 4 5)
mystr=abcdefg
echo assigned
echo ${mystr:$i:2}
---
(command (word "i=(3 4 5)"))
(command (word "mystr=abcdefg"))
(command (word "echo") (word "assigned"))
(command (word "echo") (word "${mystr:$i:2}"))
---

=== Slice with an assoc array
declare -A A=(['5']=3 ['6']=4)
mystr=abcdefg
echo assigned
echo ${mystr:$A:2}
---
(command (word "declare") (word "-A") (word "A=(['5']=3 ['6']=4)"))
(command (word "mystr=abcdefg"))
(command (word "echo") (word "assigned"))
(command (word "echo") (word "${mystr:$A:2}"))
---

=== Simple ${@:offset}
set -- 4 5 6

result=$(argv.py ${@:0})
echo ${result//"$0"/'SHELL'}

argv.py ${@:1}
argv.py ${@:2}
---
(command (word "set") (word "--") (word "4") (word "5") (word "6"))
(command (word "result=$(argv.py ${@:0})"))
(command (word "echo") (word "${result//\"$0\"/'SHELL'}"))
(command (word "argv.py") (word "${@:1}"))
(command (word "argv.py") (word "${@:2}"))
---

=== ${@:offset} and ${*:offset}
case $SH in zsh) return ;; esac  # zsh is very different

argv.shell-name-checked () {
  argv.py "${@//$0/SHELL}"
}
fun() {
  argv.shell-name-checked -${*:0}- # include $0
  argv.shell-name-checked -${*:1}- # from $1
  argv.shell-name-checked -${*:3}- # last parameter $3
  argv.shell-name-checked -${*:4}- # empty
  argv.shell-name-checked -${*:5}- # out of boundary
  argv.shell-name-checked -${@:0}-
  argv.shell-name-checked -${@:1}-
  argv.shell-name-checked -${@:3}-
  argv.shell-name-checked -${@:4}-
  argv.shell-name-checked -${@:5}-
  argv.shell-name-checked "-${*:0}-"
  argv.shell-name-checked "-${*:1}-"
  argv.shell-name-checked "-${*:3}-"
  argv.shell-name-checked "-${*:4}-"
  argv.shell-name-checked "-${*:5}-"
  argv.shell-name-checked "-${@:0}-"
  argv.shell-name-checked "-${@:1}-"
  argv.shell-name-checked "-${@:3}-"
  argv.shell-name-checked "-${@:4}-"
  argv.shell-name-checked "-${@:5}-"
}
fun "a 1" "b 2" "c 3"
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "return"))))
(function "argv.shell-name-checked" (brace-group (command (word "argv.py") (word "\"${@//$0/SHELL}\""))))
(function "fun" (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "argv.shell-name-checked") (word "-${*:0}-")) (command (word "argv.shell-name-checked") (word "-${*:1}-"))) (command (word "argv.shell-name-checked") (word "-${*:3}-"))) (command (word "argv.shell-name-checked") (word "-${*:4}-"))) (command (word "argv.shell-name-checked") (word "-${*:5}-"))) (command (word "argv.shell-name-checked") (word "-${@:0}-"))) (command (word "argv.shell-name-checked") (word "-${@:1}-"))) (command (word "argv.shell-name-checked") (word "-${@:3}-"))) (command (word "argv.shell-name-checked") (word "-${@:4}-"))) (command (word "argv.shell-name-checked") (word "-${@:5}-"))) (command (word "argv.shell-name-checked") (word "\"-${*:0}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:1}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:3}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:4}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:5}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:0}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:1}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:3}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:4}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:5}-\"")))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== ${@:offset:length} and ${*:offset:length}
case $SH in zsh) return ;; esac  # zsh is very different

argv.shell-name-checked () {
  argv.py "${@//$0/SHELL}"
}
fun() {
  argv.shell-name-checked -${*:0:2}- # include $0
  argv.shell-name-checked -${*:1:2}- # from $1
  argv.shell-name-checked -${*:3:2}- # last parameter $3
  argv.shell-name-checked -${*:4:2}- # empty
  argv.shell-name-checked -${*:5:2}- # out of boundary
  argv.shell-name-checked -${@:0:2}-
  argv.shell-name-checked -${@:1:2}-
  argv.shell-name-checked -${@:3:2}-
  argv.shell-name-checked -${@:4:2}-
  argv.shell-name-checked -${@:5:2}-
  argv.shell-name-checked "-${*:0:2}-"
  argv.shell-name-checked "-${*:1:2}-"
  argv.shell-name-checked "-${*:3:2}-"
  argv.shell-name-checked "-${*:4:2}-"
  argv.shell-name-checked "-${*:5:2}-"
  argv.shell-name-checked "-${@:0:2}-"
  argv.shell-name-checked "-${@:1:2}-"
  argv.shell-name-checked "-${@:3:2}-"
  argv.shell-name-checked "-${@:4:2}-"
  argv.shell-name-checked "-${@:5:2}-"
}
fun "a 1" "b 2" "c 3"
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "return"))))
(function "argv.shell-name-checked" (brace-group (command (word "argv.py") (word "\"${@//$0/SHELL}\""))))
(function "fun" (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "argv.shell-name-checked") (word "-${*:0:2}-")) (command (word "argv.shell-name-checked") (word "-${*:1:2}-"))) (command (word "argv.shell-name-checked") (word "-${*:3:2}-"))) (command (word "argv.shell-name-checked") (word "-${*:4:2}-"))) (command (word "argv.shell-name-checked") (word "-${*:5:2}-"))) (command (word "argv.shell-name-checked") (word "-${@:0:2}-"))) (command (word "argv.shell-name-checked") (word "-${@:1:2}-"))) (command (word "argv.shell-name-checked") (word "-${@:3:2}-"))) (command (word "argv.shell-name-checked") (word "-${@:4:2}-"))) (command (word "argv.shell-name-checked") (word "-${@:5:2}-"))) (command (word "argv.shell-name-checked") (word "\"-${*:0:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:1:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:3:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:4:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${*:5:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:0:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:1:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:3:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:4:2}-\""))) (command (word "argv.shell-name-checked") (word "\"-${@:5:2}-\"")))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== ${@:0:1}
set a b c
result=$(echo ${@:0:1})
echo ${result//"$0"/'SHELL'}
---
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "result=$(echo ${@:0:1})"))
(command (word "echo") (word "${result//\"$0\"/'SHELL'}"))
---

=== Permutations of implicit begin and length
array=(1 2 3)

argv.py ${array[@]}

# *** implicit length of N **
argv.py ${array[@]:0}

# Why is this one not allowed
#argv.py ${array[@]:}

# ** implicit length of ZERO **
#argv.py ${array[@]::}
#argv.py ${array[@]:0:}

argv.py ${array[@]:0:0}
echo

# Same agreed upon permutations
set -- 1 2 3
argv.py ${@}
argv.py ${@:1}
argv.py ${@:1:0}
echo

s='123'
argv.py "${s}"
argv.py "${s:0}"
argv.py "${s:0:0}"
---
(command (word "array=(1 2 3)"))
(command (word "argv.py") (word "${array[@]}"))
(command (word "argv.py") (word "${array[@]:0}"))
(command (word "argv.py") (word "${array[@]:0:0}"))
(command (word "echo"))
(command (word "set") (word "--") (word "1") (word "2") (word "3"))
(command (word "argv.py") (word "${@}"))
(command (word "argv.py") (word "${@:1}"))
(command (word "argv.py") (word "${@:1:0}"))
(command (word "echo"))
(command (word "s='123'"))
(command (word "argv.py") (word "\"${s}\""))
(command (word "argv.py") (word "\"${s:0}\""))
(command (word "argv.py") (word "\"${s:0:0}\""))
---

=== ${array[@]:} vs ${array[@]: }  - bash and zsh inconsistent
$SH -c 'array=(1 2 3); argv.py ${array[@]:}'
$SH -c 'array=(1 2 3); argv.py space ${array[@]: }'

$SH -c 's=123; argv.py ${s:}'
$SH -c 's=123; argv.py space ${s: }'
---
(command (word "$SH") (word "-c") (word "'array=(1 2 3); argv.py ${array[@]:}'"))
(command (word "$SH") (word "-c") (word "'array=(1 2 3); argv.py space ${array[@]: }'"))
(command (word "$SH") (word "-c") (word "'s=123; argv.py ${s:}'"))
(command (word "$SH") (word "-c") (word "'s=123; argv.py space ${s: }'"))
---

=== ${array[@]::} has implicit length of zero - for ble.sh
# https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/.24.7Barr.5B.40.5D.3A.3A.7D.20in.20bash.20-.20is.20it.20documented.3F

array=(1 2 3)
argv.py ${array[@]::}
argv.py ${array[@]:0:}

echo

set -- 1 2 3
argv.py ${@::}
argv.py ${@:0:}
---
(command (word "array=(1 2 3)"))
(command (word "argv.py") (word "${array[@]::}"))
(command (word "argv.py") (word "${array[@]:0:}"))
(command (word "echo"))
(command (word "set") (word "--") (word "1") (word "2") (word "3"))
(command (word "argv.py") (word "${@::}"))
(command (word "argv.py") (word "${@:0:}"))
---

=== Remove const suffix
v=abcd
echo ${v%d} ${v%%cd}
---
(command (word "v=abcd"))
(command (word "echo") (word "${v%d}") (word "${v%%cd}"))
---

=== Remove const prefix
v=abcd
echo ${v#a} ${v##ab}
---
(command (word "v=abcd"))
(command (word "echo") (word "${v#a}") (word "${v##ab}"))
---

=== Remove const suffix is vectorized on user array
a=(1a 2a 3a)
argv.py ${a[@]%a}
---
(command (word "a=(1a 2a 3a)"))
(command (word "argv.py") (word "${a[@]%a}"))
---

=== Remove const suffix is vectorized on $@ array
set -- 1a 2a 3a
argv.py ${@%a}
---
(command (word "set") (word "--") (word "1a") (word "2a") (word "3a"))
(command (word "argv.py") (word "${@%a}"))
---

=== Remove const suffix from undefined
echo ${undef%suffix}
---
(command (word "echo") (word "${undef%suffix}"))
---

=== Remove shortest glob suffix
v=aabbccdd
echo ${v%c*}
---
(command (word "v=aabbccdd"))
(command (word "echo") (word "${v%c*}"))
---

=== Remove longest glob suffix
v=aabbccdd
echo ${v%%c*}
---
(command (word "v=aabbccdd"))
(command (word "echo") (word "${v%%c*}"))
---

=== Remove shortest glob prefix
v=aabbccdd
echo ${v#*b}
---
(command (word "v=aabbccdd"))
(command (word "echo") (word "${v#*b}"))
---

=== Remove longest glob prefix
v=aabbccdd
echo ${v##*b}
---
(command (word "v=aabbccdd"))
(command (word "echo") (word "${v##*b}"))
---

=== Strip char class
v=abc
echo ${v%[[:alpha:]]}
---
(command (word "v=abc"))
(command (word "echo") (word "${v%[[:alpha:]]}"))
---

=== Strip unicode prefix
show_hex() { od -A n -t c -t x1; }

# NOTE: LANG is set to utf-8.
# ? is a glob that stands for one character

v='μ-'
echo ${v#?} | show_hex
echo
echo ${v##?} | show_hex
echo

v='-μ'
echo ${v%?} | show_hex
echo
echo ${v%%?} | show_hex
---
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(command (word "v='μ-'"))
(pipe (command (word "echo") (word "${v#?}")) (command (word "show_hex")))
(command (word "echo"))
(pipe (command (word "echo") (word "${v##?}")) (command (word "show_hex")))
(command (word "echo"))
(command (word "v='-μ'"))
(pipe (command (word "echo") (word "${v%?}")) (command (word "show_hex")))
(command (word "echo"))
(pipe (command (word "echo") (word "${v%%?}")) (command (word "show_hex")))
---

=== Bug fix: Test that you can remove everything with glob
s='--x--'
argv.py "${s%%-*}" "${s%-*}" "${s#*-}" "${s##*-}"
---
(command (word "s='--x--'"))
(command (word "argv.py") (word "\"${s%%-*}\"") (word "\"${s%-*}\"") (word "\"${s#*-}\"") (word "\"${s##*-}\""))
---

=== Test that you can remove everything with const
s='abcd'
argv.py "${s%%abcd}" "${s%abcd}" "${s#abcd}" "${s##abcd}"
# failure case:
argv.py "${s%%abcde}" "${s%abcde}" "${s#abcde}" "${s##abcde}"
---
(command (word "s='abcd'"))
(command (word "argv.py") (word "\"${s%%abcd}\"") (word "\"${s%abcd}\"") (word "\"${s#abcd}\"") (word "\"${s##abcd}\""))
(command (word "argv.py") (word "\"${s%%abcde}\"") (word "\"${s%abcde}\"") (word "\"${s#abcde}\"") (word "\"${s##abcde}\""))
---

=== Prepend using replacement of #
# This case was found in Kubernetes and others
array=(aa bb '')
argv.py ${array[@]/#/prefix-}
---
(command (word "array=(aa bb '')"))
(command (word "argv.py") (word "${array[@]/#/prefix-}"))
---

=== Append using replacement of %
array=(aa bb '')
argv.py ${array[@]/%/-suffix}
---
(command (word "array=(aa bb '')"))
(command (word "argv.py") (word "${array[@]/%/-suffix}"))
---

=== strip unquoted and quoted [
# I guess dash and mksh treat unquoted [ as an invalid glob?
var='[foo]'
echo ${var#[}
echo ${var#"["}
echo "${var#[}"
echo "${var#"["}"
---
(command (word "var='[foo]'"))
(command (word "echo") (word "${var#[}"))
(command (word "echo") (word "${var#\"[\"}"))
(command (word "echo") (word "\"${var#[}\""))
(command (word "echo") (word "\"${var#\"[\"}\""))
---

=== strip unquoted and quoted []
# LooksLikeGlob('[]') is true
# I guess dash, mksh, and zsh treat unquoted [ as an invalid glob?
var='[]foo[]'
echo ${var#[]}
echo ${var#"[]"}
echo "${var#[]}"
echo "${var#"[]"}"
---
(command (word "var='[]foo[]'"))
(command (word "echo") (word "${var#[]}"))
(command (word "echo") (word "${var#\"[]\"}"))
(command (word "echo") (word "\"${var#[]}\""))
(command (word "echo") (word "\"${var#\"[]\"}\""))
---

=== strip unquoted and quoted ?
var='[foo]'
echo ${var#?}
echo ${var#"?"}
echo "${var#?}"
echo "${var#"?"}"
---
(command (word "var='[foo]'"))
(command (word "echo") (word "${var#?}"))
(command (word "echo") (word "${var#\"?\"}"))
(command (word "echo") (word "\"${var#?}\""))
(command (word "echo") (word "\"${var#\"?\"}\""))
---

=== strip unquoted and quoted [a]
var='[a]foo[]'
echo ${var#[a]}
echo ${var#"[a]"}
echo "${var#[a]}"
echo "${var#"[a]"}"
---
(command (word "var='[a]foo[]'"))
(command (word "echo") (word "${var#[a]}"))
(command (word "echo") (word "${var#\"[a]\"}"))
(command (word "echo") (word "\"${var#[a]}\""))
(command (word "echo") (word "\"${var#\"[a]\"}\""))
---

=== Nested % and # operators (bug reported by Crestwave)
var=$'\n'
argv.py "${var#?}"
argv.py "${var%''}"
argv.py "${var%"${var#?}"}"
var='a'
argv.py "${var#?}"
argv.py "${var%''}"
argv.py "${var%"${var#?}"}"
---
(command (word "var='\n'"))
(command (word "argv.py") (word "\"${var#?}\""))
(command (word "argv.py") (word "\"${var%''}\""))
(command (word "argv.py") (word "\"${var%\"${var#?}\"}\""))
(command (word "var='a'"))
(command (word "argv.py") (word "\"${var#?}\""))
(command (word "argv.py") (word "\"${var%''}\""))
(command (word "argv.py") (word "\"${var%\"${var#?}\"}\""))
---

=== strip * (bug regression)
x=abc
argv.py "${x#*}"
argv.py "${x##*}"
argv.py "${x%*}"
argv.py "${x%%*}"
---
(command (word "x=abc"))
(command (word "argv.py") (word "\"${x#*}\""))
(command (word "argv.py") (word "\"${x##*}\""))
(command (word "argv.py") (word "\"${x%*}\""))
(command (word "argv.py") (word "\"${x%%*}\""))
---

=== strip ?
x=abc
argv.py "${x#?}"
argv.py "${x##?}"
argv.py "${x%?}"
argv.py "${x%%?}"
---
(command (word "x=abc"))
(command (word "argv.py") (word "\"${x#?}\""))
(command (word "argv.py") (word "\"${x##?}\""))
(command (word "argv.py") (word "\"${x%?}\""))
(command (word "argv.py") (word "\"${x%%?}\""))
---

=== strip all
x=abc
argv.py "${x#abc}"
argv.py "${x##abc}"
argv.py "${x%abc}"
argv.py "${x%%abc}"
---
(command (word "x=abc"))
(command (word "argv.py") (word "\"${x#abc}\""))
(command (word "argv.py") (word "\"${x##abc}\""))
(command (word "argv.py") (word "\"${x%abc}\""))
(command (word "argv.py") (word "\"${x%%abc}\""))
---

=== strip none
x=abc
argv.py "${x#}"
argv.py "${x##}"
argv.py "${x%}"
argv.py "${x%%}"
---
(command (word "x=abc"))
(command (word "argv.py") (word "\"${x#}\""))
(command (word "argv.py") (word "\"${x##}\""))
(command (word "argv.py") (word "\"${x%}\""))
(command (word "argv.py") (word "\"${x%%}\""))
---

=== strip all unicode
x=μabcμ
echo "${x#?abc?}"
echo "${x##?abc?}"
echo "${x%?abc?}"
echo "${x%%?abc?}"
---
(command (word "x=μabcμ"))
(command (word "echo") (word "\"${x#?abc?}\""))
(command (word "echo") (word "\"${x##?abc?}\""))
(command (word "echo") (word "\"${x%?abc?}\""))
(command (word "echo") (word "\"${x%%?abc?}\""))
---

=== strip none unicode
x=μabcμ
argv.py "${x#}"
argv.py "${x##}"
argv.py "${x%}"
argv.py "${x%%}"
---
(command (word "x=μabcμ"))
(command (word "argv.py") (word "\"${x#}\""))
(command (word "argv.py") (word "\"${x##}\""))
(command (word "argv.py") (word "\"${x%}\""))
(command (word "argv.py") (word "\"${x%%}\""))
---

=== Strip Right Brace (#702)
var='$foo'
echo 1 "${var#$foo}"
echo 2 "${var#\$foo}"

var='}'
echo 10 "${var#}}"
echo 11 "${var#\}}"
echo 12 "${var#'}'}"
echo 13 "${var#"}"}"
---
(command (word "var='$foo'"))
(command (word "echo") (word "1") (word "\"${var#$foo}\""))
(command (word "echo") (word "2") (word "\"${var#\\$foo}\""))
(command (word "var='}'"))
(command (word "echo") (word "10") (word "\"${var#}}\""))
(command (word "echo") (word "11") (word "\"${var#\\}}\""))
(command (word "echo") (word "12") (word "\"${var#'}'}\""))
(command (word "echo") (word "13") (word "\"${var#\"}\"}\""))
---

=== \(\) in pattern (regression)
x='foo()' 
echo 1 ${x%*\(\)}
echo 2 ${x%%*\(\)}
echo 3 ${x#*\(\)}
echo 4 ${x##*\(\)}
---
(command (word "x='foo()'"))
(command (word "echo") (word "1") (word "${x%*\\(\\)}"))
(command (word "echo") (word "2") (word "${x%%*\\(\\)}"))
(command (word "echo") (word "3") (word "${x#*\\(\\)}"))
(command (word "echo") (word "4") (word "${x##*\\(\\)}"))
---

=== extglob in pattern
case $SH in dash|zsh|ash) exit ;; esac

shopt -s extglob

x='foo()' 
echo 1 ${x%*(foo|bar)'()'}
echo 2 ${x%%*(foo|bar)'()'}
echo 3 ${x#*(foo|bar)'()'}
echo 4 ${x##*(foo|bar)'()'}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh") (word "ash")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "x='foo()'"))
(command (word "echo") (word "1") (word "${x%*(foo|bar)'()'}"))
(command (word "echo") (word "2") (word "${x%%*(foo|bar)'()'}"))
(command (word "echo") (word "3") (word "${x#*(foo|bar)'()'}"))
(command (word "echo") (word "4") (word "${x##*(foo|bar)'()'}"))
---

=== Lazy Evaluation of Alternative
i=0
x=x
echo ${x:-$((i++))}
echo $i
echo ${undefined:-$((i++))}
echo $i  # i is one because the alternative was only evaluated once
---
(command (word "i=0"))
(command (word "x=x"))
(command (word "echo") (word "${x:-$((i++))}"))
(command (word "echo") (word "$i"))
(command (word "echo") (word "${undefined:-$((i++))}"))
(command (word "echo") (word "$i"))
---

=== Default value when empty
empty=''
echo ${empty:-is empty}
---
(command (word "empty=''"))
(command (word "echo") (word "${empty:-is empty}"))
---

=== Default value when unset
echo ${unset-is unset}
---
(command (word "echo") (word "${unset-is unset}"))
---

=== Unquoted with array as default value
set -- '1 2' '3 4'
argv.py X${unset=x"$@"x}X
argv.py X${unset=x$@x}X  # If you want OSH to split, write this
# osh
---
(command (word "set") (word "--") (word "'1 2'") (word "'3 4'"))
(command (word "argv.py") (word "X${unset=x\"$@\"x}X"))
(command (word "argv.py") (word "X${unset=x$@x}X"))
---

=== Quoted with array as default value
set -- '1 2' '3 4'
argv.py "X${unset=x"$@"x}X"
argv.py "X${unset=x$@x}X"  # OSH is the same here
---
(command (word "set") (word "--") (word "'1 2'") (word "'3 4'"))
(command (word "argv.py") (word "\"X${unset=x\"$@\"x}X\""))
(command (word "argv.py") (word "\"X${unset=x$@x}X\""))
---

=== Assign default with array
set -- '1 2' '3 4'
argv.py X${unset=x"$@"x}X
argv.py "$unset"
---
(command (word "set") (word "--") (word "'1 2'") (word "'3 4'"))
(command (word "argv.py") (word "X${unset=x\"$@\"x}X"))
(command (word "argv.py") (word "\"$unset\""))
---

=== Assign default value when empty
empty=''
${empty:=is empty}
echo $empty
---
(command (word "empty=''"))
(command (word "${empty:=is empty}"))
(command (word "echo") (word "$empty"))
---

=== Assign default value when unset
${unset=is unset}
echo $unset
---
(command (word "${unset=is unset}"))
(command (word "echo") (word "$unset"))
---

=== ${v:+foo} Alternative value when empty
v=foo
empty=''
echo ${v:+v is not empty} ${empty:+is not empty}
---
(command (word "v=foo"))
(command (word "empty=''"))
(command (word "echo") (word "${v:+v is not empty}") (word "${empty:+is not empty}"))
---

=== ${v+foo} Alternative value when unset
v=foo
echo ${v+v is not unset} ${unset:+is not unset}
---
(command (word "v=foo"))
(command (word "echo") (word "${v+v is not unset}") (word "${unset:+is not unset}"))
---

=== "${x+foo}" quoted (regression)
# Python's configure caught this
argv.py "${with_icc+set}" = set
---
(command (word "argv.py") (word "\"${with_icc+set}\"") (word "=") (word "set"))
---

=== ${s+foo} and ${s:+foo} when set -u
set -u
v=v
echo v=${v:+foo}
echo v=${v+foo}
unset v
echo v=${v:+foo}
echo v=${v+foo}
---
(command (word "set") (word "-u"))
(command (word "v=v"))
(command (word "echo") (word "v=${v:+foo}"))
(command (word "echo") (word "v=${v+foo}"))
(command (word "unset") (word "v"))
(command (word "echo") (word "v=${v:+foo}"))
(command (word "echo") (word "v=${v+foo}"))
---

=== "${array[@]} with set -u (bash is outlier)
case $SH in dash) exit ;; esac

set -u

typeset -a empty
empty=()

echo empty /"${empty[@]}"/
echo undefined /"${undefined[@]}"/
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "set") (word "-u"))
(command (word "typeset") (word "-a") (word "empty"))
(command (word "empty=()"))
(command (word "echo") (word "empty") (word "/\"${empty[@]}\"/"))
(command (word "echo") (word "undefined") (word "/\"${undefined[@]}\"/"))
---

=== "${undefined[@]+foo}" and "${undefined[@]:+foo}", with set -u
case $SH in dash) exit ;; esac

set -u

echo plus /"${array[@]+foo}"/
echo plus colon /"${array[@]:+foo}"/
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "set") (word "-u"))
(command (word "echo") (word "plus") (word "/\"${array[@]+foo}\"/"))
(command (word "echo") (word "plus") (word "colon") (word "/\"${array[@]:+foo}\"/"))
---

=== "${a[@]+foo}" and "${a[@]:+foo}" - operators are equivalent on arrays?
case $SH in dash) exit ;; esac

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

typeset -a array
array=()

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

array=('')

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

array=(spam eggs)

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "echo") (word "'+ '") (word "/\"${array[@]+foo}\"/"))
(command (word "echo") (word "'+:'") (word "/\"${array[@]:+foo}\"/"))
(command (word "echo"))
(command (word "typeset") (word "-a") (word "array"))
(command (word "array=()"))
(command (word "echo") (word "'+ '") (word "/\"${array[@]+foo}\"/"))
(command (word "echo") (word "'+:'") (word "/\"${array[@]:+foo}\"/"))
(command (word "echo"))
(command (word "array=('')"))
(command (word "echo") (word "'+ '") (word "/\"${array[@]+foo}\"/"))
(command (word "echo") (word "'+:'") (word "/\"${array[@]:+foo}\"/"))
(command (word "echo"))
(command (word "array=(spam eggs)"))
(command (word "echo") (word "'+ '") (word "/\"${array[@]+foo}\"/"))
(command (word "echo") (word "'+:'") (word "/\"${array[@]:+foo}\"/"))
(command (word "echo"))
---

=== Nix idiom ${!hooksSlice+"${!hooksSlice}"} - was workaround for obsolete bash 4.3 bug
case $SH in dash|mksh|zsh) exit ;; esac

# https://oilshell.zulipchat.com/#narrow/stream/307442-nix/topic/Replacing.20bash.20with.20osh.20in.20Nixpkgs.20stdenv

(argv.py ${!hooksSlice+"${!hooksSlice}"})

hooksSlice=x

argv.py ${!hooksSlice+"${!hooksSlice}"}

declare -a hookSlice=()

argv.py ${!hooksSlice+"${!hooksSlice}"}

foo=42
bar=43

declare -a hooksSlice=(foo bar spam eggs)

argv.py ${!hooksSlice+"${!hooksSlice}"}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(subshell (command (word "argv.py") (word "${!hooksSlice+\"${!hooksSlice}\"}")))
(command (word "hooksSlice=x"))
(command (word "argv.py") (word "${!hooksSlice+\"${!hooksSlice}\"}"))
(command (word "declare") (word "-a") (word "hookSlice=()"))
(command (word "argv.py") (word "${!hooksSlice+\"${!hooksSlice}\"}"))
(command (word "foo=42"))
(command (word "bar=43"))
(command (word "declare") (word "-a") (word "hooksSlice=(foo bar spam eggs)"))
(command (word "argv.py") (word "${!hooksSlice+\"${!hooksSlice}\"}"))
---

=== ${v-foo} and ${v:-foo} when set -u
set -u
v=v
echo v=${v:-foo}
echo v=${v-foo}
unset v
echo v=${v:-foo}
echo v=${v-foo}
---
(command (word "set") (word "-u"))
(command (word "v=v"))
(command (word "echo") (word "v=${v:-foo}"))
(command (word "echo") (word "v=${v-foo}"))
(command (word "unset") (word "v"))
(command (word "echo") (word "v=${v:-foo}"))
(command (word "echo") (word "v=${v-foo}"))
---

=== array and - and +
case $SH in dash) exit ;; esac

shopt -s compat_array  # to refer to array as scalar

empty=()
a1=('')
a2=('' x)
a3=(3 4)
echo empty=${empty[@]-minus}
echo a1=${a1[@]-minus}
echo a1[0]=${a1[0]-minus}
echo a2=${a2[@]-minus}
echo a3=${a3[@]-minus}
echo ---

echo empty=${empty[@]+plus}
echo a1=${a1[@]+plus}
echo a1[0]=${a1[0]+plus}
echo a2=${a2[@]+plus}
echo a3=${a3[@]+plus}
echo ---

echo empty=${empty+plus}
echo a1=${a1+plus}
echo a2=${a2+plus}
echo a3=${a3+plus}
echo ---

# Test quoted arrays too
argv.py "${empty[@]-minus}"
argv.py "${empty[@]+plus}"
argv.py "${a1[@]-minus}"
argv.py "${a1[@]+plus}"
argv.py "${a1[0]-minus}"
argv.py "${a1[0]+plus}"
argv.py "${a2[@]-minus}"
argv.py "${a2[@]+plus}"
argv.py "${a3[@]-minus}"
argv.py "${a3[@]+plus}"
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "compat_array"))
(command (word "empty=()"))
(command (word "a1=('')"))
(command (word "a2=('' x)"))
(command (word "a3=(3 4)"))
(command (word "echo") (word "empty=${empty[@]-minus}"))
(command (word "echo") (word "a1=${a1[@]-minus}"))
(command (word "echo") (word "a1[0]=${a1[0]-minus}"))
(command (word "echo") (word "a2=${a2[@]-minus}"))
(command (word "echo") (word "a3=${a3[@]-minus}"))
(command (word "echo") (word "---"))
(command (word "echo") (word "empty=${empty[@]+plus}"))
(command (word "echo") (word "a1=${a1[@]+plus}"))
(command (word "echo") (word "a1[0]=${a1[0]+plus}"))
(command (word "echo") (word "a2=${a2[@]+plus}"))
(command (word "echo") (word "a3=${a3[@]+plus}"))
(command (word "echo") (word "---"))
(command (word "echo") (word "empty=${empty+plus}"))
(command (word "echo") (word "a1=${a1+plus}"))
(command (word "echo") (word "a2=${a2+plus}"))
(command (word "echo") (word "a3=${a3+plus}"))
(command (word "echo") (word "---"))
(command (word "argv.py") (word "\"${empty[@]-minus}\""))
(command (word "argv.py") (word "\"${empty[@]+plus}\""))
(command (word "argv.py") (word "\"${a1[@]-minus}\""))
(command (word "argv.py") (word "\"${a1[@]+plus}\""))
(command (word "argv.py") (word "\"${a1[0]-minus}\""))
(command (word "argv.py") (word "\"${a1[0]+plus}\""))
(command (word "argv.py") (word "\"${a2[@]-minus}\""))
(command (word "argv.py") (word "\"${a2[@]+plus}\""))
(command (word "argv.py") (word "\"${a3[@]-minus}\""))
(command (word "argv.py") (word "\"${a3[@]+plus}\""))
---

=== $@ (empty) and - and +
echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}
---
(command (word "echo") (word "argv=${@-minus}"))
(command (word "echo") (word "argv=${@+plus}"))
(command (word "echo") (word "argv=${@:-minus}"))
(command (word "echo") (word "argv=${@:+plus}"))
---

=== $@ ("") and - and +
set -- ""
echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}
---
(command (word "set") (word "--") (word "\"\""))
(command (word "echo") (word "argv=${@-minus}"))
(command (word "echo") (word "argv=${@+plus}"))
(command (word "echo") (word "argv=${@:-minus}"))
(command (word "echo") (word "argv=${@:+plus}"))
---

=== $@ ("" "") and - and +
set -- "" ""
echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}
---
(command (word "set") (word "--") (word "\"\"") (word "\"\""))
(command (word "echo") (word "argv=${@-minus}"))
(command (word "echo") (word "argv=${@+plus}"))
(command (word "echo") (word "argv=${@:-minus}"))
(command (word "echo") (word "argv=${@:+plus}"))
---

=== $* ("" "") and - and + (IFS=)
set -- "" ""
IFS=
echo argv=${*-minus}
echo argv=${*+plus}
echo argv=${*:-minus}
echo argv=${*:+plus}
---
(command (word "set") (word "--") (word "\"\"") (word "\"\""))
(command (word "IFS="))
(command (word "echo") (word "argv=${*-minus}"))
(command (word "echo") (word "argv=${*+plus}"))
(command (word "echo") (word "argv=${*:-minus}"))
(command (word "echo") (word "argv=${*:+plus}"))
---

=== "$*" ("" "") and - and + (IFS=)
set -- "" ""
IFS=
echo "argv=${*-minus}"
echo "argv=${*+plus}"
echo "argv=${*:-minus}"
echo "argv=${*:+plus}"
---
(command (word "set") (word "--") (word "\"\"") (word "\"\""))
(command (word "IFS="))
(command (word "echo") (word "\"argv=${*-minus}\""))
(command (word "echo") (word "\"argv=${*+plus}\""))
(command (word "echo") (word "\"argv=${*:-minus}\""))
(command (word "echo") (word "\"argv=${*:+plus}\""))
---

=== assoc array and - and +
case $SH in dash|mksh) exit ;; esac

declare -A empty=()
declare -A assoc=(['k']=v)

echo empty=${empty[@]-minus}
echo empty=${empty[@]+plus}
echo assoc=${assoc[@]-minus}
echo assoc=${assoc[@]+plus}

echo ---
echo empty=${empty[@]:-minus}
echo empty=${empty[@]:+plus}
echo assoc=${assoc[@]:-minus}
echo assoc=${assoc[@]:+plus}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "declare") (word "-A") (word "empty=()"))
(command (word "declare") (word "-A") (word "assoc=(['k']=v)"))
(command (word "echo") (word "empty=${empty[@]-minus}"))
(command (word "echo") (word "empty=${empty[@]+plus}"))
(command (word "echo") (word "assoc=${assoc[@]-minus}"))
(command (word "echo") (word "assoc=${assoc[@]+plus}"))
(command (word "echo") (word "---"))
(command (word "echo") (word "empty=${empty[@]:-minus}"))
(command (word "echo") (word "empty=${empty[@]:+plus}"))
(command (word "echo") (word "assoc=${assoc[@]:-minus}"))
(command (word "echo") (word "assoc=${assoc[@]:+plus}"))
---

=== Error when empty
empty=''
echo ${empty:?'is em'pty}  # test eval of error
echo should not get here
---
(command (word "empty=''"))
(command (word "echo") (word "${empty:?'is em'pty}"))
(command (word "echo") (word "should") (word "not") (word "get") (word "here"))
---

=== Error when unset
echo ${unset?is empty}
echo should not get here
---
(command (word "echo") (word "${unset?is empty}"))
(command (word "echo") (word "should") (word "not") (word "get") (word "here"))
---

=== Error when unset
v=foo
echo ${v+v is not unset} ${unset:+is not unset}
---
(command (word "v=foo"))
(command (word "echo") (word "${v+v is not unset}") (word "${unset:+is not unset}"))
---

=== ${var=x} dynamic scope
f() { : "${hello:=x}"; echo $hello; }
f
echo hello=$hello

f() { hello=x; }
f
echo hello=$hello
---
(function "f" (brace-group (semi (command (word ":") (word "\"${hello:=x}\"")) (command (word "echo") (word "$hello")))))
(command (word "f"))
(command (word "echo") (word "hello=$hello"))
(function "f" (brace-group (command (word "hello=x"))))
(command (word "f"))
(command (word "echo") (word "hello=$hello"))
---

=== array ${arr[0]=x}
arr=()
echo ${#arr[@]}
: ${arr[0]=x}
echo ${#arr[@]}
---
(command (word "arr=()"))
(command (word "echo") (word "${#arr[@]}"))
(command (word ":") (word "${arr[0]=x}"))
(command (word "echo") (word "${#arr[@]}"))
---

=== assoc array ${arr["k"]=x}
# note: this also works in zsh

declare -A arr=()
echo ${#arr[@]}
: ${arr['k']=x}
echo ${#arr[@]}
---
(command (word "declare") (word "-A") (word "arr=()"))
(command (word "echo") (word "${#arr[@]}"))
(command (word ":") (word "${arr['k']=x}"))
(command (word "echo") (word "${#arr[@]}"))
---

=== "\z" as arg
echo "${undef-\$}"
echo "${undef-\(}"
echo "${undef-\z}"
echo "${undef-\"}"
echo "${undef-\`}"
echo "${undef-\\}"
---
(command (word "echo") (word "\"${undef-\\$}\""))
(command (word "echo") (word "\"${undef-\\(}\""))
(command (word "echo") (word "\"${undef-\\z}\""))
(command (word "echo") (word "\"${undef-\\\"}\""))
(command (word "echo") (word "\"${undef-\\`}\""))
(command (word "echo") (word "\"${undef-\\\\}\""))
---

=== "\e" as arg
echo "${undef-\e}"
---
(command (word "echo") (word "\"${undef-\\e}\""))
---

=== op-test for ${a} and ${a[0]}
case $SH in dash) exit ;; esac

test-hyphen() {
  echo "a   : '${a-no-colon}' '${a:-with-colon}'"
  echo "a[0]: '${a[0]-no-colon}' '${a[0]:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "test-hyphen" (brace-group (semi (command (word "echo") (word "\"a   : '${a-no-colon}' '${a:-with-colon}'\"")) (command (word "echo") (word "\"a[0]: '${a[0]-no-colon}' '${a[0]:-with-colon}'\"")))))
(command (word "a=()"))
(command (word "test-hyphen"))
(command (word "a=(\"\")"))
(command (word "test-hyphen"))
(command (word "a=(\"\" \"\")"))
(command (word "test-hyphen"))
(command (word "IFS="))
(command (word "test-hyphen"))
---

=== op-test for ${a[@]} and ${a[*]}
case $SH in dash) exit ;; esac

test-hyphen() {
  echo "a[@]: '${a[@]-no-colon}' '${a[@]:-with-colon}'"
  echo "a[*]: '${a[*]-no-colon}' '${a[*]:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "test-hyphen" (brace-group (semi (command (word "echo") (word "\"a[@]: '${a[@]-no-colon}' '${a[@]:-with-colon}'\"")) (command (word "echo") (word "\"a[*]: '${a[*]-no-colon}' '${a[*]:-with-colon}'\"")))))
(command (word "a=()"))
(command (word "test-hyphen"))
(command (word "a=(\"\")"))
(command (word "test-hyphen"))
(command (word "a=(\"\" \"\")"))
(command (word "test-hyphen"))
(command (word "IFS="))
(command (word "test-hyphen"))
---

=== op-test for ${!array} with array="a" and array="a[0]"
case $SH in dash|mksh|zsh) exit ;; esac

test-hyphen() {
  ref='a'
  echo "ref=a   : '${!ref-no-colon}' '${!ref:-with-colon}'"
  ref='a[0]'
  echo "ref=a[0]: '${!ref-no-colon}' '${!ref:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(function "test-hyphen" (brace-group (semi (semi (semi (command (word "ref='a'")) (command (word "echo") (word "\"ref=a   : '${!ref-no-colon}' '${!ref:-with-colon}'\""))) (command (word "ref='a[0]'"))) (command (word "echo") (word "\"ref=a[0]: '${!ref-no-colon}' '${!ref:-with-colon}'\"")))))
(command (word "a=()"))
(command (word "test-hyphen"))
(command (word "a=(\"\")"))
(command (word "test-hyphen"))
(command (word "a=(\"\" \"\")"))
(command (word "test-hyphen"))
(command (word "IFS="))
(command (word "test-hyphen"))
---

=== op-test for ${!array} with array="a[@]" or array="a[*]"
case $SH in dash|mksh|zsh) exit ;; esac

test-hyphen() {
  ref='a[@]'
  echo "ref=a[@]: '${!ref-no-colon}' '${!ref:-with-colon}'"
  ref='a[*]'
  echo "ref=a[*]: '${!ref-no-colon}' '${!ref:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(function "test-hyphen" (brace-group (semi (semi (semi (command (word "ref='a[@]'")) (command (word "echo") (word "\"ref=a[@]: '${!ref-no-colon}' '${!ref:-with-colon}'\""))) (command (word "ref='a[*]'"))) (command (word "echo") (word "\"ref=a[*]: '${!ref-no-colon}' '${!ref:-with-colon}'\"")))))
(command (word "a=()"))
(command (word "test-hyphen"))
(command (word "a=(\"\")"))
(command (word "test-hyphen"))
(command (word "a=(\"\" \"\")"))
(command (word "test-hyphen"))
(command (word "IFS="))
(command (word "test-hyphen"))
---

=== op-test for unquoted ${a[*]:-empty} with IFS=
case $SH in dash) exit ;; esac

IFS=
a=("" "")
argv.py ${a[*]:-empty}
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "IFS="))
(command (word "a=(\"\" \"\")"))
(command (word "argv.py") (word "${a[*]:-empty}"))
---

=== var ref ${!a}
a=b
b=c
echo ref ${!a} ${a}
---
(command (word "a=b"))
(command (word "b=c"))
(command (word "echo") (word "ref") (word "${!a}") (word "${a}"))
---

=== ${!ref-default}
ref=x
echo x=${!ref-default}

x=''
echo x=${!ref-default}

x=foo
echo x=${!ref-default}
---
(command (word "ref=x"))
(command (word "echo") (word "x=${!ref-default}"))
(command (word "x=''"))
(command (word "echo") (word "x=${!ref-default}"))
(command (word "x=foo"))
(command (word "echo") (word "x=${!ref-default}"))
---

=== ${!undef:-}
# bash 4.4 gives empty string, but I feel like this could be an error
echo undef=${!undef-'default'}
echo undef=${!undef}

set -u
echo NOUNSET
echo undef=${!undef-'default'}
echo undef=${!undef}
---
(command (word "echo") (word "undef=${!undef-'default'}"))
(command (word "echo") (word "undef=${!undef}"))
(command (word "set") (word "-u"))
(command (word "echo") (word "NOUNSET"))
(command (word "echo") (word "undef=${!undef-'default'}"))
(command (word "echo") (word "undef=${!undef}"))
---

=== comparison to ${!array[@]} keys (similar SYNTAX)
declare -a a=(x y)
argv.py "${!a[@]}"
echo a_keys=$?

argv.py "${!a}"  # missing [] is equivalent to ${!a[0]} ?
echo a_nobrackets=$?

echo ---
declare -A A=([A]=a [B]=b)

argv.py $(printf '%s\n' ${!A[@]} | sort)
echo A_keys=$?

(argv.py "${!A}")  # missing [] is equivalent to ${!A[0]} ?
echo A_nobrackets=$?
---
(command (word "declare") (word "-a") (word "a=(x y)"))
(command (word "argv.py") (word "\"${!a[@]}\""))
(command (word "echo") (word "a_keys=$?"))
(command (word "argv.py") (word "\"${!a}\""))
(command (word "echo") (word "a_nobrackets=$?"))
(command (word "echo") (word "---"))
(command (word "declare") (word "-A") (word "A=([A]=a [B]=b)"))
(command (word "argv.py") (word "$(printf '%s\\n' ${!A[@]} | sort)"))
(command (word "echo") (word "A_keys=$?"))
(subshell (command (word "argv.py") (word "\"${!A}\"")))
(command (word "echo") (word "A_nobrackets=$?"))
---

=== ${!a[@]-'default'} is legal but fails with more than one element
# bash allows this construct, but the indirection fails when the array has more
# than one element because the variable name contains a space.  OSH originally
# made it an error unconditionally because [@] implies it's an array, so the
# behavior has been different from Bash when the array has a single element.
# We now changed it to follow Bash even when the array has a single element.

(argv.py "${!a[@]-default}")
echo status=$?

a=(x y z)
(argv.py "${!a[@]-default}")
echo status=$?
---
(subshell (command (word "argv.py") (word "\"${!a[@]-default}\"")))
(command (word "echo") (word "status=$?"))
(command (word "a=(x y z)"))
(subshell (command (word "argv.py") (word "\"${!a[@]-default}\"")))
(command (word "echo") (word "status=$?"))
---

=== var ref to $@ with @
set -- one two
ref='@'
echo ref=${!ref}
---
(command (word "set") (word "--") (word "one") (word "two"))
(command (word "ref='@'"))
(command (word "echo") (word "ref=${!ref}"))
---

=== var ref to $1 and $2 with 1 and 2
set -- one two
ref1='1'
echo ref1=${!ref1}
ref2='2'
echo ref2=${!ref2}
---
(command (word "set") (word "--") (word "one") (word "two"))
(command (word "ref1='1'"))
(command (word "echo") (word "ref1=${!ref1}"))
(command (word "ref2='2'"))
(command (word "echo") (word "ref2=${!ref2}"))
---

=== var ref: 1, @, *
set -- x y
ref=1; argv.py "${!ref}"
ref=@; argv.py "${!ref}"
ref=*; argv.py "${!ref}"  # maybe_decay_array bug?
---
(command (word "set") (word "--") (word "x") (word "y"))
(semi (command (word "ref=1")) (command (word "argv.py") (word "\"${!ref}\"")))
(semi (command (word "ref=@")) (command (word "argv.py") (word "\"${!ref}\"")))
(semi (command (word "ref=*")) (command (word "argv.py") (word "\"${!ref}\"")))
---

=== var ref to special var BASH_SOURCE
ref='LINENO'
echo lineno=${!ref}
---
(command (word "ref='LINENO'"))
(command (word "echo") (word "lineno=${!ref}"))
---

=== var ref to $? with '?'
myfunc() {
  local ref=$1
  echo ${!ref}
}
myfunc FUNCNAME
myfunc '?'
---
(function "myfunc" (brace-group (semi (command (word "local") (word "ref=$1")) (command (word "echo") (word "${!ref}")))))
(command (word "myfunc") (word "FUNCNAME"))
(command (word "myfunc") (word "'?'"))
---

=== Var ref, then assignment with ${ := }
z=zz
zz=
echo ${!z:=foo}
echo ${!z:=bar}
---
(command (word "z=zz"))
(command (word "zz="))
(command (word "echo") (word "${!z:=foo}"))
(command (word "echo") (word "${!z:=bar}"))
---

=== Var ref, then error with ${ ? }
w=ww
ww=
echo ${!w:?'my message'}
echo done
---
(command (word "w=ww"))
(command (word "ww="))
(command (word "echo") (word "${!w:?'my message'}"))
(command (word "echo") (word "done"))
---

=== Indirect expansion, THEN suffix operators
check_eq() {
  [ "$1" = "$2" ] || { echo "$1 vs $2"; }
}
check_expand() {
  val=$(eval "echo \"$1\"")
  [ "$val" = "$2" ] || { echo "$1 -> expected $2, got $val"; }
}
check_err() {
  e="$1"
  msg=$(eval "$e" 2>&1) && echo "bad success: $e"
  if test -n "$2"; then 
    if [[ "$msg" != $2 ]]; then
      echo "Expected error: $e"
      echo "Got error     : $msg"
    fi
  fi
}
# Nearly everything in manual section 3.5.3 "Shell Parameter Expansion"
# is allowed after a !-indirection.
#
# Not allowed: any further prefix syntax.
x=xx; xx=aaabcc
xd=x
check_err '${!!xd}'
check_err '${!!x*}'
a=(asdf x)
check_err '${!!a[*]}'
check_err '${!#x}'
check_err '${!#a[@]}'
# And an array reference binds tighter in the syntax, so goes first;
# there's no way to spell "indirection, then array reference".
check_expand '${!a[1]}' xx
b=(aoeu a)
check_expand '${!b[1]}' asdf  # i.e. like !(b[1]), not (!b)[1]
#
# Allowed: apparently everything else.
y=yy; yy=
check_expand '${!y:-foo}' foo
check_expand '${!x:-foo}' aaabcc

check_expand '${!x:?oops}' aaabcc

check_expand '${!y:+foo}' ''
check_expand '${!x:+foo}' foo

check_expand '${!x:2}' abcc
check_expand '${!x:2:2}' ab

check_expand '${!x#*a}' aabcc
check_expand '${!x%%c*}' aaab
check_expand '${!x/a*b/d}' dcc

# ^ operator not fully implemented in OSH
#check_expand '${!x^a}' Aaabcc

p=pp; pp='\$ '
check_expand '${!p@P}' '$ '
echo ok
---
(function "check_eq" (brace-group (or (command (word "[") (word "\"$1\"") (word "=") (word "\"$2\"") (word "]")) (brace-group (command (word "echo") (word "\"$1 vs $2\""))))))
(function "check_expand" (brace-group (semi (command (word "val=$(eval \"echo \\\"$1\\\"\")")) (or (command (word "[") (word "\"$val\"") (word "=") (word "\"$2\"") (word "]")) (brace-group (command (word "echo") (word "\"$1 -> expected $2, got $val\"")))))))
(function "check_err" (brace-group (semi (semi (command (word "e=\"$1\"")) (and (command (word "msg=$(eval \"$e\" 2>&1)")) (command (word "echo") (word "\"bad success: $e\"")))) (if (command (word "test") (word "-n") (word "\"$2\"")) (if (cond (cond-binary "!=" (cond-term ""$msg"") (cond-term "$2"))) (semi (command (word "echo") (word "\"Expected error: $e\"")) (command (word "echo") (word "\"Got error     : $msg\""))))))))
(semi (command (word "x=xx")) (command (word "xx=aaabcc")))
(command (word "xd=x"))
(command (word "check_err") (word "'${!!xd}'"))
(command (word "check_err") (word "'${!!x*}'"))
(command (word "a=(asdf x)"))
(command (word "check_err") (word "'${!!a[*]}'"))
(command (word "check_err") (word "'${!#x}'"))
(command (word "check_err") (word "'${!#a[@]}'"))
(command (word "check_expand") (word "'${!a[1]}'") (word "xx"))
(command (word "b=(aoeu a)"))
(command (word "check_expand") (word "'${!b[1]}'") (word "asdf"))
(semi (command (word "y=yy")) (command (word "yy=")))
(command (word "check_expand") (word "'${!y:-foo}'") (word "foo"))
(command (word "check_expand") (word "'${!x:-foo}'") (word "aaabcc"))
(command (word "check_expand") (word "'${!x:?oops}'") (word "aaabcc"))
(command (word "check_expand") (word "'${!y:+foo}'") (word "''"))
(command (word "check_expand") (word "'${!x:+foo}'") (word "foo"))
(command (word "check_expand") (word "'${!x:2}'") (word "abcc"))
(command (word "check_expand") (word "'${!x:2:2}'") (word "ab"))
(command (word "check_expand") (word "'${!x#*a}'") (word "aabcc"))
(command (word "check_expand") (word "'${!x%%c*}'") (word "aaab"))
(command (word "check_expand") (word "'${!x/a*b/d}'") (word "dcc"))
(semi (command (word "p=pp")) (command (word "pp='\\$ '")))
(command (word "check_expand") (word "'${!p@P}'") (word "'$ '"))
(command (word "echo") (word "ok"))
---

=== var ref OF array var -- silent a[0] decay
declare -a a=(ale bean)
echo first=${!a}

ale=zzz
echo first=${!a}
---
(command (word "declare") (word "-a") (word "a=(ale bean)"))
(command (word "echo") (word "first=${!a}"))
(command (word "ale=zzz"))
(command (word "echo") (word "first=${!a}"))
---

=== array ref
declare -a array=(ale bean)
ref='array[0]'
echo ${!ref}
---
(command (word "declare") (word "-a") (word "array=(ale bean)"))
(command (word "ref='array[0]'"))
(command (word "echo") (word "${!ref}"))
---

=== array ref with strict_array
shopt -s strict_array

declare -a array=(ale bean)
ref='array'
echo ${!ref}
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "declare") (word "-a") (word "array=(ale bean)"))
(command (word "ref='array'"))
(command (word "echo") (word "${!ref}"))
---

=== var ref TO array var
shopt -s compat_array

declare -a array=(ale bean)

ref='array'  # when compat_array is on, this is like array[0]
ref_AT='array[@]'

echo ${!ref}
echo ${!ref_AT}
---
(command (word "shopt") (word "-s") (word "compat_array"))
(command (word "declare") (word "-a") (word "array=(ale bean)"))
(command (word "ref='array'"))
(command (word "ref_AT='array[@]'"))
(command (word "echo") (word "${!ref}"))
(command (word "echo") (word "${!ref_AT}"))
---

=== var ref TO array var, with subscripts
f() {
  argv.py "${!1}"
}
f 'nonexistent[0]'
array=(x y z)
f 'array[0]'
f 'array[1+1]'
f 'array[@]'
f 'array[*]'
# Also associative arrays.
---
(function "f" (brace-group (command (word "argv.py") (word "\"${!1}\""))))
(command (word "f") (word "'nonexistent[0]'"))
(command (word "array=(x y z)"))
(command (word "f") (word "'array[0]'"))
(command (word "f") (word "'array[1+1]'"))
(command (word "f") (word "'array[@]'"))
(command (word "f") (word "'array[*]'"))
---

=== var ref TO assoc array a[key]
shopt -s compat_array

declare -A assoc=([ale]=bean [corn]=dip)
ref=assoc
#ref_AT='assoc[@]'

# UNQUOTED doesn't work with the OSH parser
#ref_SUB='assoc[ale]'
ref_SUB='assoc["ale"]'

ref_SUB_QUOTED='assoc["al"e]'

ref_SUB_BAD='assoc["bad"]'

echo ref=${!ref}  # compat_array: assoc is equivalent to assoc[0]
#echo ref_AT=${!ref_AT}
echo ref_SUB=${!ref_SUB}
echo ref_SUB_QUOTED=${!ref_SUB_QUOTED}
echo ref_SUB_BAD=${!ref_SUB_BAD}
---
(command (word "shopt") (word "-s") (word "compat_array"))
(command (word "declare") (word "-A") (word "assoc=([ale]=bean [corn]=dip)"))
(command (word "ref=assoc"))
(command (word "ref_SUB='assoc[\"ale\"]'"))
(command (word "ref_SUB_QUOTED='assoc[\"al\"e]'"))
(command (word "ref_SUB_BAD='assoc[\"bad\"]'"))
(command (word "echo") (word "ref=${!ref}"))
(command (word "echo") (word "ref_SUB=${!ref_SUB}"))
(command (word "echo") (word "ref_SUB_QUOTED=${!ref_SUB_QUOTED}"))
(command (word "echo") (word "ref_SUB_BAD=${!ref_SUB_BAD}"))
---

=== var ref TO array with arbitrary subscripts
shopt -s eval_unsafe_arith compat_array

f() {
  local val=$(echo "${!1}")
  if test "$val" = y; then 
    echo "works: $1"
  fi
}
# Warmup: nice plain array reference
a=(x y)
f 'a[1]'
#
# Not allowed:
# no brace expansion
f 'a[{1,0}]'  # operand expected
# no process substitution (but see command substitution below!)
f 'a[<(echo x)]'  # operand expected
# TODO word splitting seems interesting
aa="1 0"
f 'a[$aa]'  # 1 0: syntax error in expression (error token is "0")
# no filename globbing
f 'a[b*]'  # operand expected
f 'a[1"]'  # bad substitution
#
# Allowed: most everything else in section 3.5 "Shell Expansions".
# shell parameter expansion
b=1
f 'a[$b]'
f 'a[${c:-1}]'
# (... and presumably most of the other features there)
# command substitution, yikes!
f 'a[$(echo 1)]'
# arithmetic expansion
f 'a[$(( 3 - 2 ))]'

# All of these are undocumented and probably shouldn't exist,
# though it's always possible some will turn up in the wild and
# we'll end up implementing them.
---
(command (word "shopt") (word "-s") (word "eval_unsafe_arith") (word "compat_array"))
(function "f" (brace-group (semi (command (word "local") (word "val=$(echo \"${!1}\")")) (if (command (word "test") (word "\"$val\"") (word "=") (word "y")) (command (word "echo") (word "\"works: $1\""))))))
(command (word "a=(x y)"))
(command (word "f") (word "'a[1]'"))
(command (word "f") (word "'a[{1,0}]'"))
(command (word "f") (word "'a[<(echo x)]'"))
(command (word "aa=\"1 0\""))
(command (word "f") (word "'a[$aa]'"))
(command (word "f") (word "'a[b*]'"))
(command (word "f") (word "'a[1\"]'"))
(command (word "b=1"))
(command (word "f") (word "'a[$b]'"))
(command (word "f") (word "'a[${c:-1}]'"))
(command (word "f") (word "'a[$(echo 1)]'"))
(command (word "f") (word "'a[$(( 3 - 2 ))]'"))
---

=== Bizarre tilde expansion in array index
a=(x y)
PWD=1
ref='a[~+]'
echo ${!ref}
---
(command (word "a=(x y)"))
(command (word "PWD=1"))
(command (word "ref='a[~+]'"))
(command (word "echo") (word "${!ref}"))
---

=== Indirect expansion TO fancy expansion features bash disallows
check_indir() {
    result="${!1}"
    desugared_result=$(eval 'echo "${'"$1"'}"')
    [ "$2" = "$desugared_result" ] || { echo "$1 $desugared_result";  }
}
x=y
y=a
a=(x y)
declare -A aa
aa=([k]=r [l]=s)
# malformed array indexing
check_indir "a[0"
check_indir "aa[k"
# double indirection
check_indir "!x"      a
check_indir "!a[0]"   y
# apparently everything else in the manual under "Shell Parameter Expansion"
check_indir "x:-foo"  y
check_indir "x:=foo"  y
check_indir "x:?oops" y
check_indir "x:+yy"   yy
check_indir "x:0"     y
check_indir "x:0:1"   y
check_indir "!a@"    "a aa"
# (!a[@] is elsewhere)
check_indir "#x"      1
check_indir "x#y"
check_indir "x/y/foo" foo
check_indir "x@Q"     y
echo done
---
(function "check_indir" (brace-group (semi (semi (command (word "result=\"${!1}\"")) (command (word "desugared_result=$(eval 'echo \"${'\"$1\"'}\"')"))) (or (command (word "[") (word "\"$2\"") (word "=") (word "\"$desugared_result\"") (word "]")) (brace-group (command (word "echo") (word "\"$1 $desugared_result\"")))))))
(command (word "x=y"))
(command (word "y=a"))
(command (word "a=(x y)"))
(command (word "declare") (word "-A") (word "aa"))
(command (word "aa=([k]=r [l]=s)"))
(command (word "check_indir") (word "\"a[0\""))
(command (word "check_indir") (word "\"aa[k\""))
(command (word "check_indir") (word "\"!x\"") (word "a"))
(command (word "check_indir") (word "\"!a[0]\"") (word "y"))
(command (word "check_indir") (word "\"x:-foo\"") (word "y"))
(command (word "check_indir") (word "\"x:=foo\"") (word "y"))
(command (word "check_indir") (word "\"x:?oops\"") (word "y"))
(command (word "check_indir") (word "\"x:+yy\"") (word "yy"))
(command (word "check_indir") (word "\"x:0\"") (word "y"))
(command (word "check_indir") (word "\"x:0:1\"") (word "y"))
(command (word "check_indir") (word "\"!a@\"") (word "\"a aa\""))
(command (word "check_indir") (word "\"#x\"") (word "1"))
(command (word "check_indir") (word "\"x#y\""))
(command (word "check_indir") (word "\"x/y/foo\"") (word "foo"))
(command (word "check_indir") (word "\"x@Q\"") (word "y"))
(command (word "echo") (word "done"))
---

=== Bad var ref
a='bad var name'
echo ref ${!a}
echo status=$?
---
(command (word "a='bad var name'"))
(command (word "echo") (word "ref") (word "${!a}"))
(command (word "echo") (word "status=$?"))
---

=== Bad var ref 2
b='/'  # really bad
echo ref ${!b}
echo status=$?
---
(command (word "b='/'"))
(command (word "echo") (word "ref") (word "${!b}"))
(command (word "echo") (word "status=$?"))
---

=== ${!OPTIND} (used by bash completion
set -- a b c
echo ${!OPTIND}
f() {
  local OPTIND=1
  echo ${!OPTIND}
  local OPTIND=2
  echo ${!OPTIND}
}
f x y z
---
(command (word "set") (word "--") (word "a") (word "b") (word "c"))
(command (word "echo") (word "${!OPTIND}"))
(function "f" (brace-group (semi (semi (semi (command (word "local") (word "OPTIND=1")) (command (word "echo") (word "${!OPTIND}"))) (command (word "local") (word "OPTIND=2"))) (command (word "echo") (word "${!OPTIND}")))))
(command (word "f") (word "x") (word "y") (word "z"))
---

=== var ref doesn't need cycle detection
x=y
y=x
echo cycle=${!x}

typeset -n a=b
typeset -n b=a
echo cycle=${a}
---
(command (word "x=y"))
(command (word "y=x"))
(command (word "echo") (word "cycle=${!x}"))
(command (word "typeset") (word "-n") (word "a=b"))
(command (word "typeset") (word "-n") (word "b=a"))
(command (word "echo") (word "cycle=${a}"))
---

=== Var Ref Code Injection $(tee PWNED)
typeset -a a
a=(42)

x='a[$(echo 0 | tee PWNED)]'

echo ${!x}

if test -f PWNED; then
  echo PWNED
  cat PWNED
else
  echo NOPE
fi
---
(command (word "typeset") (word "-a") (word "a"))
(command (word "a=(42)"))
(command (word "x='a[$(echo 0 | tee PWNED)]'"))
(command (word "echo") (word "${!x}"))
(if (command (word "test") (word "-f") (word "PWNED")) (semi (command (word "echo") (word "PWNED")) (command (word "cat") (word "PWNED"))) (command (word "echo") (word "NOPE")))
---

=== ${!array_ref:-set} and ${!array_ref:=assign}
ref='a[@]'
a=('' '' '')

echo "==== check ===="

argv.py "${!ref:-set}"
argv.py "${a[@]:-set}"

echo "==== assign ===="

argv.py "${!ref:=assign}"
argv.py "${!ref}"
a=('' '' '') # revert the state in case it is modified

argv.py "${a[@]:=assign}"
argv.py "${a[@]}"
---
(command (word "ref='a[@]'"))
(command (word "a=('' '' '')"))
(command (word "echo") (word "\"==== check ====\""))
(command (word "argv.py") (word "\"${!ref:-set}\""))
(command (word "argv.py") (word "\"${a[@]:-set}\""))
(command (word "echo") (word "\"==== assign ====\""))
(command (word "argv.py") (word "\"${!ref:=assign}\""))
(command (word "argv.py") (word "\"${!ref}\""))
(command (word "a=('' '' '')"))
(command (word "argv.py") (word "\"${a[@]:=assign}\""))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Array indirect expansion with suffix operators
declare -A ref=(['dummy']=v1)
function test-suffixes {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]:2}"
  argv.py "${!ref[@]:1:2}"
  argv.py "${!ref[@]:-empty}"
  argv.py "${!ref[@]:+set}"
  argv.py "${!ref[@]:=assign}"
}

v1=value
test-suffixes v1
echo "v1=$v1"

v2=
test-suffixes v2
echo "v2=$v2"

a1=()
test-suffixes a1
argv.py "${a1[@]}"

a2=(element)
test-suffixes 'a2[0]'
argv.py "${a2[@]}"

a3=(1 2 3)
test-suffixes 'a3[@]'
argv.py "${a3[@]}"
---
(command (word "declare") (word "-A") (word "ref=(['dummy']=v1)"))
(function "test-suffixes" (brace-group (semi (semi (semi (semi (semi (semi (command (word "echo") (word "\"==== $1 ====\"")) (command (word "ref['dummy']=$1"))) (command (word "argv.py") (word "\"${!ref[@]:2}\""))) (command (word "argv.py") (word "\"${!ref[@]:1:2}\""))) (command (word "argv.py") (word "\"${!ref[@]:-empty}\""))) (command (word "argv.py") (word "\"${!ref[@]:+set}\""))) (command (word "argv.py") (word "\"${!ref[@]:=assign}\"")))))
(command (word "v1=value"))
(command (word "test-suffixes") (word "v1"))
(command (word "echo") (word "\"v1=$v1\""))
(command (word "v2="))
(command (word "test-suffixes") (word "v2"))
(command (word "echo") (word "\"v2=$v2\""))
(command (word "a1=()"))
(command (word "test-suffixes") (word "a1"))
(command (word "argv.py") (word "\"${a1[@]}\""))
(command (word "a2=(element)"))
(command (word "test-suffixes") (word "'a2[0]'"))
(command (word "argv.py") (word "\"${a2[@]}\""))
(command (word "a3=(1 2 3)"))
(command (word "test-suffixes") (word "'a3[@]'"))
(command (word "argv.py") (word "\"${a3[@]}\""))
---

=== Array indirect expansion with replacements
declare -A ref=(['dummy']=v1)
function test-rep {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]#?}"
  argv.py "${!ref[@]%?}"
  argv.py "${!ref[@]//[a-f]}"
  argv.py "${!ref[@]//[a-f]/x}"
}

v1=value
test-rep v1

v2=
test-rep v2

a1=()
test-rep a1

a2=(element)
test-rep 'a2[0]'

a3=(1 2 3)
test-rep 'a3[@]'
---
(command (word "declare") (word "-A") (word "ref=(['dummy']=v1)"))
(function "test-rep" (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "\"==== $1 ====\"")) (command (word "ref['dummy']=$1"))) (command (word "argv.py") (word "\"${!ref[@]#?}\""))) (command (word "argv.py") (word "\"${!ref[@]%?}\""))) (command (word "argv.py") (word "\"${!ref[@]//[a-f]}\""))) (command (word "argv.py") (word "\"${!ref[@]//[a-f]/x}\"")))))
(command (word "v1=value"))
(command (word "test-rep") (word "v1"))
(command (word "v2="))
(command (word "test-rep") (word "v2"))
(command (word "a1=()"))
(command (word "test-rep") (word "a1"))
(command (word "a2=(element)"))
(command (word "test-rep") (word "'a2[0]'"))
(command (word "a3=(1 2 3)"))
(command (word "test-rep") (word "'a3[@]'"))
---

=== Array indirect expansion with @? conversion
declare -A ref=(['dummy']=v1)
function test-op0 {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]@Q}"
  argv.py "${!ref[@]@P}"
  argv.py "${!ref[@]@a}"
}

v1=value
test-op0 v1

v2=
test-op0 v2

a1=()
test-op0 a1

a2=(element)
test-op0 'a2[0]'

a3=(1 2 3)
test-op0 'a3[@]'
---
(command (word "declare") (word "-A") (word "ref=(['dummy']=v1)"))
(function "test-op0" (brace-group (semi (semi (semi (semi (command (word "echo") (word "\"==== $1 ====\"")) (command (word "ref['dummy']=$1"))) (command (word "argv.py") (word "\"${!ref[@]@Q}\""))) (command (word "argv.py") (word "\"${!ref[@]@P}\""))) (command (word "argv.py") (word "\"${!ref[@]@a}\"")))))
(command (word "v1=value"))
(command (word "test-op0") (word "v1"))
(command (word "v2="))
(command (word "test-op0") (word "v2"))
(command (word "a1=()"))
(command (word "test-op0") (word "a1"))
(command (word "a2=(element)"))
(command (word "test-op0") (word "'a2[0]'"))
(command (word "a3=(1 2 3)"))
(command (word "test-op0") (word "'a3[@]'"))
---

=== "${empty:-}"
empty=
argv.py "${empty:-}"
---
(command (word "empty="))
(command (word "argv.py") (word "\"${empty:-}\""))
---

=== ${empty:-}
empty=
argv.py ${empty:-}
---
(command (word "empty="))
(command (word "argv.py") (word "${empty:-}"))
---

=== array with empty values
declare -a A=('' x "" '')
argv.py "${A[@]}"
---
(command (word "declare") (word "-a") (word "A=('' x \"\" '')"))
(command (word "argv.py") (word "\"${A[@]}\""))
---

=== substitution of IFS character, quoted and unquoted
IFS=:
s=:
argv.py $s
argv.py "$s"
---
(command (word "IFS=:"))
(command (word "s=:"))
(command (word "argv.py") (word "$s"))
(command (word "argv.py") (word "\"$s\""))
---

=== :-
empty=''
argv.py ${empty:-a} ${Unset:-b}
---
(command (word "empty=''"))
(command (word "argv.py") (word "${empty:-a}") (word "${Unset:-b}"))
---

=== -
empty=''
argv.py ${empty-a} ${Unset-b}
# empty one is still elided!
---
(command (word "empty=''"))
(command (word "argv.py") (word "${empty-a}") (word "${Unset-b}"))
---

=== Inner single quotes
argv.py ${Unset:-'b'}
---
(command (word "argv.py") (word "${Unset:-'b'}"))
---

=== Inner single quotes, outer double quotes
# This is the WEIRD ONE.  Single quotes appear outside.  But all shells agree!
argv.py "${Unset:-'b'}"
---
(command (word "argv.py") (word "\"${Unset:-'b'}\""))
---

=== Inner double quotes
argv.py ${Unset:-"b"}
---
(command (word "argv.py") (word "${Unset:-\"b\"}"))
---

=== Inner double quotes, outer double quotes
argv.py "${Unset-"b"}"
---
(command (word "argv.py") (word "\"${Unset-\"b\"}\""))
---

=== Multiple words: no quotes
argv.py ${Unset:-a b c}
---
(command (word "argv.py") (word "${Unset:-a b c}"))
---

=== Multiple words: no outer quotes, inner single quotes
argv.py ${Unset:-'a b c'}
---
(command (word "argv.py") (word "${Unset:-'a b c'}"))
---

=== Multiple words: no outer quotes, inner double quotes
argv.py ${Unset:-"a b c"}
---
(command (word "argv.py") (word "${Unset:-\"a b c\"}"))
---

=== Multiple words: outer double quotes, no inner quotes
argv.py "${Unset:-a b c}"
---
(command (word "argv.py") (word "\"${Unset:-a b c}\""))
---

=== Multiple words: outer double quotes, inner double quotes
argv.py "${Unset:-"a b c"}"
---
(command (word "argv.py") (word "\"${Unset:-\"a b c\"}\""))
---

=== Multiple words: outer double quotes, inner single quotes
argv.py "${Unset:-'a b c'}"
# WEIRD ONE.
---
(command (word "argv.py") (word "\"${Unset:-'a b c'}\""))
---

=== Mixed inner quotes
argv.py ${Unset:-"a b" c}
---
(command (word "argv.py") (word "${Unset:-\"a b\" c}"))
---

=== Mixed inner quotes with outer quotes
argv.py "${Unset:-"a b" c}"
---
(command (word "argv.py") (word "\"${Unset:-\"a b\" c}\""))
---

=== part_value tree with multiple words
argv.py ${a:-${a:-"1 2" "3 4"}5 "6 7"}
---
(command (word "argv.py") (word "${a:-${a:-\"1 2\" \"3 4\"}5 \"6 7\"}"))
---

=== part_value tree on RHS
v=${a:-${a:-"1 2" "3 4"}5 "6 7"}
argv.py "${v}"
---
(command (word "v=${a:-${a:-\"1 2\" \"3 4\"}5 \"6 7\"}"))
(command (word "argv.py") (word "\"${v}\""))
---

=== Var with multiple words: no quotes
var='a b c'
argv.py ${Unset:-$var}
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "${Unset:-$var}"))
---

=== Multiple words: no outer quotes, inner single quotes
var='a b c'
argv.py ${Unset:-'$var'}
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "${Unset:-'$var'}"))
---

=== Multiple words: no outer quotes, inner double quotes
var='a b c'
argv.py ${Unset:-"$var"}
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "${Unset:-\"$var\"}"))
---

=== Multiple words: outer double quotes, no inner quotes
var='a b c'
argv.py "${Unset:-$var}"
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "\"${Unset:-$var}\""))
---

=== Multiple words: outer double quotes, inner double quotes
var='a b c'
argv.py "${Unset:-"$var"}"
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "\"${Unset:-\"$var\"}\""))
---

=== Multiple words: outer double quotes, inner single quotes
# WEIRD ONE.
#
# I think I should just disallow any word with single quotes inside double
# quotes.
var='a b c'
argv.py "${Unset:-'$var'}"
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "\"${Unset:-'$var'}\""))
---

=== No outer quotes, Multiple internal quotes
# It's like a single command word.  Parts are joined directly.
var='a b c'
argv.py ${Unset:-A$var " $var"D E F}
---
(command (word "var='a b c'"))
(command (word "argv.py") (word "${Unset:-A$var \" $var\"D E F}"))
---

=== Strip a string with single quotes, unquoted
foo="'a b c d'"
argv.py ${foo%d\'}
---
(command (word "foo=\"'a b c d'\""))
(command (word "argv.py") (word "${foo%d\\'}"))
---

=== Strip a string with single quotes, double quoted
foo="'a b c d'"
argv.py "${foo%d\'}"
---
(command (word "foo=\"'a b c d'\""))
(command (word "argv.py") (word "\"${foo%d\\'}\""))
---

=== The string to strip is space sensitive
foo='a b c d'
argv.py "${foo%c d}" "${foo%c  d}"
---
(command (word "foo='a b c d'"))
(command (word "argv.py") (word "\"${foo%c d}\"") (word "\"${foo%c  d}\""))
---

=== The string to strip can be single quoted, outer is unquoted
foo='a b c d'
argv.py ${foo%'c d'} ${foo%'c  d'}
---
(command (word "foo='a b c d'"))
(command (word "argv.py") (word "${foo%'c d'}") (word "${foo%'c  d'}"))
---

=== "${undef-'c d'}" and "${foo%'c d'}" are parsed differently
# quotes are LITERAL here
argv.py "${undef-'c d'}" "${undef-'c  d'}"
argv.py ${undef-'c d'} ${undef-'c  d'}

echo ---

# quotes are RESPECTED here
foo='a b c d'
argv.py "${foo%'c d'}" "${foo%'c  d'}"

case $SH in dash) exit ;; esac

argv.py "${foo//'c d'/zzz}" "${foo//'c  d'/zzz}"
argv.py "${foo//'c d'/'zzz'}" "${foo//'c  d'/'zzz'}"
---
(command (word "argv.py") (word "\"${undef-'c d'}\"") (word "\"${undef-'c  d'}\""))
(command (word "argv.py") (word "${undef-'c d'}") (word "${undef-'c  d'}"))
(command (word "echo") (word "---"))
(command (word "foo='a b c d'"))
(command (word "argv.py") (word "\"${foo%'c d'}\"") (word "\"${foo%'c  d'}\""))
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "argv.py") (word "\"${foo//'c d'/zzz}\"") (word "\"${foo//'c  d'/zzz}\""))
(command (word "argv.py") (word "\"${foo//'c d'/'zzz'}\"") (word "\"${foo//'c  d'/'zzz'}\""))
---

=== $'' allowed within VarSub arguments
# Odd behavior of bash/mksh: $'' is recognized but NOT ''!
x=abc
echo ${x%$'b'*}
echo "${x%$'b'*}"  # git-prompt.sh relies on this
---
(command (word "x=abc"))
(command (word "echo") (word "${x%'b'*}"))
(command (word "echo") (word "\"${x%'b'*}\""))
---

=== # operator with single quoted arg (dash/ash and bash/mksh disagree, reported by Crestwave)
var=a
echo -${var#'a'}-
echo -"${var#'a'}"-
var="'a'"
echo -${var#'a'}-
echo -"${var#'a'}"-
---
(command (word "var=a"))
(command (word "echo") (word "-${var#'a'}-"))
(command (word "echo") (word "-\"${var#'a'}\"-"))
(command (word "var=\"'a'\""))
(command (word "echo") (word "-${var#'a'}-"))
(command (word "echo") (word "-\"${var#'a'}\"-"))
---

=== / operator with single quoted arg (causes syntax error in regex in OSH, reported by Crestwave)
var="++--''++--''"
echo no plus or minus "${var//[+-]}"
echo no plus or minus "${var//['+-']}"
---
(command (word "var=\"++--''++--''\""))
(command (word "echo") (word "no") (word "plus") (word "or") (word "minus") (word "\"${var//[+-]}\""))
(command (word "echo") (word "no") (word "plus") (word "or") (word "minus") (word "\"${var//['+-']}\""))
---

=== single quotes work inside character classes
x='a[[[---]]]b'
echo "${x//['[]']}"
---
(command (word "x='a[[[---]]]b'"))
(command (word "echo") (word "\"${x//['[]']}\""))
---

=== comparison: :- operator with single quoted arg
echo ${unset:-'a'}
echo "${unset:-'a'}"
---
(command (word "echo") (word "${unset:-'a'}"))
(command (word "echo") (word "\"${unset:-'a'}\""))
---

=== Right Brace as argument (similar to #702)
echo "${var-}}"
echo "${var-\}}"
echo "${var-'}'}"
echo "${var-"}"}"
---
(command (word "echo") (word "\"${var-}}\""))
(command (word "echo") (word "\"${var-\\}}\""))
(command (word "echo") (word "\"${var-'}'}\""))
(command (word "echo") (word "\"${var-\"}\"}\""))
---

=== Var substitution with newlines (#2492)
echo "${var-a \
b}"
echo "${var-a
b}"

echo "${var:-c \
d}"
echo "${var:-c
d}"

var=set
echo "${var:+e \
f}"
echo "${var:+e
f}"
---
(command (word "echo") (word "\"${var-a b}\""))
(command (word "echo") (word "\"${var-a\nb}\""))
(command (word "echo") (word "\"${var:-c d}\""))
(command (word "echo") (word "\"${var:-c\nd}\""))
(command (word "var=set"))
(command (word "echo") (word "\"${var:+e f}\""))
(command (word "echo") (word "\"${var:+e\nf}\""))
---

=== Var substitution with \n in value
echo "${var-a\nb}"
echo "${var:-c\nd}"
var=val
echo "${var:+e\nf}"
---
(command (word "echo") (word "\"${var-a\\nb}\""))
(command (word "echo") (word "\"${var:-c\\nd}\""))
(command (word "var=val"))
(command (word "echo") (word "\"${var:+e\\nf}\""))
---

=== Bad var sub
echo ${a&}
---
(command (word "echo") (word "${a&}"))
---

=== Braced block inside ${}
# NOTE: This bug was in bash 4.3 but fixed in bash 4.4.
echo ${foo:-$({ ls /bin/ls; })}
---
(command (word "echo") (word "${foo:-$({ ls /bin/ls; })}"))
---

=== Nested ${}
bar=ZZ
echo ${foo:-${bar}}
---
(command (word "bar=ZZ"))
(command (word "echo") (word "${foo:-${bar}}"))
---

=== Filename redirect with "$@"
# bash - ambiguous redirect -- yeah I want this error
#   - But I want it at PARSE time?  So is there a special DollarAtPart?
#     MultipleArgsPart?
# mksh - tries to create '_tmp/var-sub1 _tmp/var-sub2'
# dash - tries to create '_tmp/var-sub1 _tmp/var-sub2'
fun() {
  echo hi > "$@"
}
fun _tmp/var-sub1 _tmp/var-sub2
---
(function "fun" (brace-group (command (word "echo") (word "hi") (redirect ">" ""$@""))))
(command (word "fun") (word "_tmp/var-sub1") (word "_tmp/var-sub2"))
---

=== Descriptor redirect to bad "$@"
# All of them give errors:
# dash - bad fd number, parse error?
# bash - ambiguous redirect
# mksh - illegal file descriptor name
set -- '2 3' 'c d'
echo hi 1>& "$@"
---
(command (word "set") (word "--") (word "'2 3'") (word "'c d'"))
(command (word "echo") (word "hi") (redirect ">&" ""$@""))
---

=== Evaluation of constant parts
argv.py bare 'sq'
---
(command (word "argv.py") (word "bare") (word "'sq'"))
---

=== Evaluation of each part
#set -o noglob
HOME=/home/bob
str=s
array=(a1 a2)
argv.py bare 'sq' ~ $str "-${str}-" "${array[@]}" $((1+2)) $(echo c) `echo c`
---
(command (word "HOME=/home/bob"))
(command (word "str=s"))
(command (word "array=(a1 a2)"))
(command (word "argv.py") (word "bare") (word "'sq'") (word "~") (word "$str") (word "\"-${str}-\"") (word "\"${array[@]}\"") (word "$((1+2))") (word "$(echo c)") (word "`echo c`"))
---

=== Word splitting
s1='1 2'
s2='3 4'
s3='5 6'
argv.py $s1$s2 "$s3"
---
(command (word "s1='1 2'"))
(command (word "s2='3 4'"))
(command (word "s3='5 6'"))
(command (word "argv.py") (word "$s1$s2") (word "\"$s3\""))
---

=== Word joining
set -- x y z
s1='1 2'
array=(a1 a2)
argv.py $s1"${array[@]}"_"$@"
---
(command (word "set") (word "--") (word "x") (word "y") (word "z"))
(command (word "s1='1 2'"))
(command (word "array=(a1 a2)"))
(command (word "argv.py") (word "$s1\"${array[@]}\"_\"$@\""))
---

=== Word elision
s1=''
argv.py $s1 - "$s1"
---
(command (word "s1=''"))
(command (word "argv.py") (word "$s1") (word "-") (word "\"$s1\""))
---

=== Default values -- more cases
argv.py ${undef:-hi} ${undef:-'a b'} "${undef:-c d}" "${un:-"e f"}" "${un:-'g h'}"
---
(command (word "argv.py") (word "${undef:-hi}") (word "${undef:-'a b'}") (word "\"${undef:-c d}\"") (word "\"${un:-\"e f\"}\"") (word "\"${un:-'g h'}\""))
---

=== Globbing after splitting
mkdir -p _tmp
touch _tmp/foo.gg _tmp/bar.gg _tmp/foo.hh
pat='_tmp/*.hh _tmp/*.gg'
argv.py $pat
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "touch") (word "_tmp/foo.gg") (word "_tmp/bar.gg") (word "_tmp/foo.hh"))
(command (word "pat='_tmp/*.hh _tmp/*.gg'"))
(command (word "argv.py") (word "$pat"))
---

=== Globbing escaping
mkdir -p _tmp
touch '_tmp/[bc]ar.mm' # file that looks like a glob pattern
touch _tmp/bar.mm _tmp/car.mm
argv.py '_tmp/[bc]'*.mm - _tmp/?ar.mm
---
(command (word "mkdir") (word "-p") (word "_tmp"))
(command (word "touch") (word "'_tmp/[bc]ar.mm'"))
(command (word "touch") (word "_tmp/bar.mm") (word "_tmp/car.mm"))
(command (word "argv.py") (word "'_tmp/[bc]'*.mm") (word "-") (word "_tmp/?ar.mm"))
---

=== IFS is scoped
IFS=b
word=abcd
f() { local IFS=c; argv.py $word; }
f
argv.py $word
---
(command (word "IFS=b"))
(command (word "word=abcd"))
(function "f" (brace-group (semi (command (word "local") (word "IFS=c")) (command (word "argv.py") (word "$word")))))
(command (word "f"))
(command (word "argv.py") (word "$word"))
---

=== Tilde sub is not split, but var sub is
HOME="foo bar"
argv.py ~
argv.py $HOME
---
(command (word "HOME=\"foo bar\""))
(command (word "argv.py") (word "~"))
(command (word "argv.py") (word "$HOME"))
---

=== Word splitting
a="1 2"
b="3 4"
argv.py $a"$b"
---
(command (word "a=\"1 2\""))
(command (word "b=\"3 4\""))
(command (word "argv.py") (word "$a\"$b\""))
---

=== Word splitting 2
a="1 2"
b="3 4"
c="5 6"
d="7 8"
argv.py $a"$b"$c"$d"
---
(command (word "a=\"1 2\""))
(command (word "b=\"3 4\""))
(command (word "c=\"5 6\""))
(command (word "d=\"7 8\""))
(command (word "argv.py") (word "$a\"$b\"$c\"$d\""))
---

=== $*
fun() { argv.py -$*-; }
fun "a 1" "b 2" "c 3"
---
(function "fun" (brace-group (command (word "argv.py") (word "-$*-"))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== "$*"
fun() { argv.py "-$*-"; }
fun "a 1" "b 2" "c 3"
---
(function "fun" (brace-group (command (word "argv.py") (word "\"-$*-\""))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== $@
# How does this differ from $* ?  I don't think it does.
fun() { argv.py -$@-; }
fun "a 1" "b 2" "c 3"
---
(function "fun" (brace-group (command (word "argv.py") (word "-$@-"))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== "$@"
fun() { argv.py "-$@-"; }
fun "a 1" "b 2" "c 3"
---
(function "fun" (brace-group (command (word "argv.py") (word "\"-$@-\""))))
(command (word "fun") (word "\"a 1\"") (word "\"b 2\"") (word "\"c 3\""))
---

=== empty argv
argv.py 1 "$@" 2 $@ 3 "$*" 4 $* 5
---
(command (word "argv.py") (word "1") (word "\"$@\"") (word "2") (word "$@") (word "3") (word "\"$*\"") (word "4") (word "$*") (word "5"))
---

=== $* with empty IFS
set -- "1 2" "3  4"

IFS=
argv.py $*
argv.py "$*"
---
(command (word "set") (word "--") (word "\"1 2\"") (word "\"3  4\""))
(command (word "IFS="))
(command (word "argv.py") (word "$*"))
(command (word "argv.py") (word "\"$*\""))
---

=== Word elision with space
s1=' '
argv.py $s1
---
(command (word "s1=' '"))
(command (word "argv.py") (word "$s1"))
---

=== Word elision with non-whitespace IFS
# Treated differently than the default IFS.  What is the rule here?
IFS='_'
char='_'
space=' '
empty=''
argv.py $char
argv.py $space
argv.py $empty
---
(command (word "IFS='_'"))
(command (word "char='_'"))
(command (word "space=' '"))
(command (word "empty=''"))
(command (word "argv.py") (word "$char"))
(command (word "argv.py") (word "$space"))
(command (word "argv.py") (word "$empty"))
---

=== Leading/trailing word elision with non-whitespace IFS
# This behavior is weird.
IFS=_
s1='_a_b_'
argv.py $s1
---
(command (word "IFS=_"))
(command (word "s1='_a_b_'"))
(command (word "argv.py") (word "$s1"))
---

=== Leading ' ' vs leading ' _ '
# This behavior is weird, but all shells agree.
IFS='_ '
s1='_ a  b _ '
s2='  a  b _ '
argv.py $s1
argv.py $s2
---
(command (word "IFS='_ '"))
(command (word "s1='_ a  b _ '"))
(command (word "s2='  a  b _ '"))
(command (word "argv.py") (word "$s1"))
(command (word "argv.py") (word "$s2"))
---

=== Multiple non-whitespace IFS chars.
IFS=_-
s1='a__b---c_d'
argv.py $s1
---
(command (word "IFS=_-"))
(command (word "s1='a__b---c_d'"))
(command (word "argv.py") (word "$s1"))
---

=== IFS with whitespace and non-whitepace.
# NOTE: Three delimiters means two empty words in the middle.  No elision.
IFS='_ '
s1='a_b _ _ _ c  _d e'
argv.py $s1
---
(command (word "IFS='_ '"))
(command (word "s1='a_b _ _ _ c  _d e'"))
(command (word "argv.py") (word "$s1"))
---

=== empty $@ and $* is elided
fun() { argv.py 1 $@ $* 2; }
fun
---
(function "fun" (brace-group (command (word "argv.py") (word "1") (word "$@") (word "$*") (word "2"))))
(command (word "fun"))
---

=== unquoted empty arg is elided
empty=""
argv.py 1 $empty 2
---
(command (word "empty=\"\""))
(command (word "argv.py") (word "1") (word "$empty") (word "2"))
---

=== unquoted whitespace arg is elided
space=" "
argv.py 1 $space 2
---
(command (word "space=\" \""))
(command (word "argv.py") (word "1") (word "$space") (word "2"))
---

=== empty literals are not elided
space=" "
argv.py 1 $space"" 2
---
(command (word "space=\" \""))
(command (word "argv.py") (word "1") (word "$space\"\"") (word "2"))
---

=== no splitting when IFS is empty
IFS=""
foo="a b"
argv.py $foo
---
(command (word "IFS=\"\""))
(command (word "foo=\"a b\""))
(command (word "argv.py") (word "$foo"))
---

=== default value can yield multiple words
argv.py 1 ${undefined:-"2 3" "4 5"} 6
---
(command (word "argv.py") (word "1") (word "${undefined:-\"2 3\" \"4 5\"}") (word "6"))
---

=== default value can yield multiple words with part joining
argv.py 1${undefined:-"2 3" "4 5"}6
---
(command (word "argv.py") (word "1${undefined:-\"2 3\" \"4 5\"}6"))
---

=== default value with unquoted IFS char
IFS=_
argv.py 1${undefined:-"2_3"x_x"4_5"}6
---
(command (word "IFS=_"))
(command (word "argv.py") (word "1${undefined:-\"2_3\"x_x\"4_5\"}6"))
---

=== IFS empty doesn't do splitting
IFS=''
x=$(python2 -c 'print(" a b\tc\n")')
argv.py $x
---
(command (word "IFS=''"))
(command (word "x=$(python2 -c 'print(\" a b\\tc\\n\")')"))
(command (word "argv.py") (word "$x"))
---

=== IFS unset behaves like $' \t\n'
unset IFS
x=$(python2 -c 'print(" a b\tc\n")')
argv.py $x
---
(command (word "unset") (word "IFS"))
(command (word "x=$(python2 -c 'print(\" a b\\tc\\n\")')"))
(command (word "argv.py") (word "$x"))
---

=== IFS='\'
# NOTE: OSH fails this because of double backslash escaping issue!
IFS='\'
s='a\b'
argv.py $s
---
(command (word "IFS='\\'"))
(command (word "s='a\\b'"))
(command (word "argv.py") (word "$s"))
---

=== IFS='\ '
# NOTE: OSH fails this because of double backslash escaping issue!
# When IFS is \, then you're no longer using backslash escaping.
IFS='\ '
s='a\b \\ c d\'
argv.py $s
---
(command (word "IFS='\\ '"))
(command (word "s='a\\b \\\\ c d\\'"))
(command (word "argv.py") (word "$s"))
---

=== IFS characters are glob metacharacters
IFS='* '
s='a*b c'
argv.py $s

IFS='?'
s='?x?y?z?'
argv.py $s

IFS='['
s='[x[y[z['
argv.py $s
---
(command (word "IFS='* '"))
(command (word "s='a*b c'"))
(command (word "argv.py") (word "$s"))
(command (word "IFS='?'"))
(command (word "s='?x?y?z?'"))
(command (word "argv.py") (word "$s"))
(command (word "IFS='['"))
(command (word "s='[x[y[z['"))
(command (word "argv.py") (word "$s"))
---

=== Trailing space
argv.py 'Xec  ho '
argv.py X'ec  ho '
argv.py X"ec  ho "
---
(command (word "argv.py") (word "'Xec  ho '"))
(command (word "argv.py") (word "X'ec  ho '"))
(command (word "argv.py") (word "X\"ec  ho \""))
---

=== Empty IFS (regression for bug)
IFS=
echo ["$*"]
set a b c
echo ["$*"]
---
(command (word "IFS="))
(command (word "echo") (word "[\"$*\"]"))
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "echo") (word "[\"$*\"]"))
---

=== Unset IFS (regression for bug)
set a b c
unset IFS
echo ["$*"]
---
(command (word "set") (word "a") (word "b") (word "c"))
(command (word "unset") (word "IFS"))
(command (word "echo") (word "[\"$*\"]"))
---

=== IFS=o (regression for bug)
IFS=o
echo hi
---
(command (word "IFS=o"))
(command (word "echo") (word "hi"))
---

=== IFS and joining arrays
IFS=:
set -- x 'y z'
argv.py "$@"
argv.py $@
argv.py "$*"
argv.py $*
---
(command (word "IFS=:"))
(command (word "set") (word "--") (word "x") (word "'y z'"))
(command (word "argv.py") (word "\"$@\""))
(command (word "argv.py") (word "$@"))
(command (word "argv.py") (word "\"$*\""))
(command (word "argv.py") (word "$*"))
---

=== IFS and joining arrays by assignments
IFS=:
set -- x 'y z'

s="$@"
argv.py "$s"

s=$@
argv.py "$s"

s="$*"
argv.py "$s"

s=$*
argv.py "$s"

# bash and mksh agree, but this doesn't really make sense to me.
# In OSH, "$@" is the only real array, so that's why it behaves differently.
---
(command (word "IFS=:"))
(command (word "set") (word "--") (word "x") (word "'y z'"))
(command (word "s=\"$@\""))
(command (word "argv.py") (word "\"$s\""))
(command (word "s=$@"))
(command (word "argv.py") (word "\"$s\""))
(command (word "s=\"$*\""))
(command (word "argv.py") (word "\"$s\""))
(command (word "s=$*"))
(command (word "argv.py") (word "\"$s\""))
---

=== TODO
empty=""
space=" "
AB="A B"
X="X"
Yspaces=" Y "


#### IFS='' with $@ and $* (bug #627)
set -- a 'b c'
IFS=''
argv.py at $@
argv.py star $*

# zsh agrees
---
(command (word "empty=\"\""))
(command (word "space=\" \""))
(command (word "AB=\"A B\""))
(command (word "X=\"X\""))
(command (word "Yspaces=\" Y \""))
(command (word "set") (word "--") (word "a") (word "'b c'"))
(command (word "IFS=''"))
(command (word "argv.py") (word "at") (word "$@"))
(command (word "argv.py") (word "star") (word "$*"))
---

=== IFS='' with $@ and $* and printf (bug #627)
set -- a 'b c'
IFS=''
printf '[%s]\n' $@
printf '[%s]\n' $*
---
(command (word "set") (word "--") (word "a") (word "'b c'"))
(command (word "IFS=''"))
(command (word "printf") (word "'[%s]\\n'") (word "$@"))
(command (word "printf") (word "'[%s]\\n'") (word "$*"))
---

=== IFS='' with ${a[@]} and ${a[*]} (bug #627)
case $SH in dash | ash) exit 0 ;; esac

myarray=(a 'b c')
IFS=''
argv.py at ${myarray[@]}
argv.py star ${myarray[*]}
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit") (word "0"))))
(command (word "myarray=(a 'b c')"))
(command (word "IFS=''"))
(command (word "argv.py") (word "at") (word "${myarray[@]}"))
(command (word "argv.py") (word "star") (word "${myarray[*]}"))
---

=== IFS='' with ${!prefix@} and ${!prefix*} (bug #627)
case $SH in dash | mksh | ash | yash) exit 0 ;; esac

gLwbmGzS_var1=1
gLwbmGzS_var2=2
IFS=''
argv.py at ${!gLwbmGzS_@}
argv.py star ${!gLwbmGzS_*}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash") (word "yash")) (command (word "exit") (word "0"))))
(command (word "gLwbmGzS_var1=1"))
(command (word "gLwbmGzS_var2=2"))
(command (word "IFS=''"))
(command (word "argv.py") (word "at") (word "${!gLwbmGzS_@}"))
(command (word "argv.py") (word "star") (word "${!gLwbmGzS_*}"))
---

=== IFS='' with ${!a[@]} and ${!a[*]} (bug #627)
case $SH in dash | mksh | ash | yash) exit 0 ;; esac

IFS=''
a=(v1 v2 v3)
argv.py at ${!a[@]}
argv.py star ${!a[*]}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash") (word "yash")) (command (word "exit") (word "0"))))
(command (word "IFS=''"))
(command (word "a=(v1 v2 v3)"))
(command (word "argv.py") (word "at") (word "${!a[@]}"))
(command (word "argv.py") (word "star") (word "${!a[*]}"))
---

=== Bug #628 split on : with : in literal word
# 2025-03: What's the cause of this bug?
#
# OSH is very wrong here
#   ['a', '\\', 'b']
# Is this a fundamental problem with the IFS state machine?
# It definitely relates to the use of backslashes.
# So we have at least 4 backslash bugs

IFS=':'
word='a:'
argv.py ${word}:b
argv.py ${word}:

echo ---

# Same thing happens for 'z'
IFS='z'
word='az'
argv.py ${word}zb
argv.py ${word}z
---
(command (word "IFS=':'"))
(command (word "word='a:'"))
(command (word "argv.py") (word "${word}:b"))
(command (word "argv.py") (word "${word}:"))
(command (word "echo") (word "---"))
(command (word "IFS='z'"))
(command (word "word='az'"))
(command (word "argv.py") (word "${word}zb"))
(command (word "argv.py") (word "${word}z"))
---

=== Bug #698, similar crash
var='\'
set -f
echo $var
---
(command (word "var='\\'"))
(command (word "set") (word "-f"))
(command (word "echo") (word "$var"))
---

=== Bug #1664, \\ with noglob
# Note that we're not changing IFS

argv.py [\\]_
argv.py "[\\]_"

# TODO: no difference observed here, go back to original bug

#argv.py [\\_
#argv.py "[\\_"

echo noglob

# repeat cases with -f, noglob
set -f

argv.py [\\]_
argv.py "[\\]_"

#argv.py [\\_
#argv.py "[\\_"
---
(command (word "argv.py") (word "[\\\\]_"))
(command (word "argv.py") (word "\"[\\\\]_\""))
(command (word "echo") (word "noglob"))
(command (word "set") (word "-f"))
(command (word "argv.py") (word "[\\\\]_"))
(command (word "argv.py") (word "\"[\\\\]_\""))
---

=== Empty IFS bug #2141 (from pnut)
res=0
sum() {
  # implement callee-save calling convention using `set`
  # here, we save the value of $res after the function parameters
  set $@ $res           # $1 $2 $3 are now set
  res=$(($1 + $2))
  echo "$1 + $2 = $res"
  res=$3                # restore the value of $res
}

unset IFS
sum 12 30 # outputs "12 + 30 = 42"

IFS=' '
sum 12 30 # outputs "12 + 30 = 42"

IFS=
sum 12 30 # outputs "1230 + 0 = 1230"

# I added this
IFS=''
sum 12 30

set -u
IFS=
sum 12 30 # fails with "fatal: Undefined variable '2'" on res=$(($1 + $2))
---
(command (word "res=0"))
(function "sum" (brace-group (semi (semi (semi (command (word "set") (word "$@") (word "$res")) (command (word "res=$(($1 + $2))"))) (command (word "echo") (word "\"$1 + $2 = $res\""))) (command (word "res=$3")))))
(command (word "unset") (word "IFS"))
(command (word "sum") (word "12") (word "30"))
(command (word "IFS=' '"))
(command (word "sum") (word "12") (word "30"))
(command (word "IFS="))
(command (word "sum") (word "12") (word "30"))
(command (word "IFS=''"))
(command (word "sum") (word "12") (word "30"))
(command (word "set") (word "-u"))
(command (word "IFS="))
(command (word "sum") (word "12") (word "30"))
---

=== Unicode in IFS
# bash, zsh, and yash support unicode in IFS, but dash/mksh/ash don't.

# for zsh, though we're not testing it here
setopt SH_WORD_SPLIT

x=çx IFS=ç
printf "<%s>\n" $x
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "x=çx") (word "IFS=ç"))
(command (word "printf") (word "\"<%s>\\n\"") (word "$x"))
---

=== 4 x 3 table: (default IFS, IFS='', IFS=zx) x ( $* "$*" $@ "$@" )
setopt SH_WORD_SPLIT  # for zsh

set -- 'a b' c ''

# default IFS
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
echo

IFS=''
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
echo

IFS=zx
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "set") (word "--") (word "'a b'") (word "c") (word "''"))
(command (word "argv.py") (word "'  $*  '") (word "$*"))
(command (word "argv.py") (word "' \"$*\" '") (word "\"$*\""))
(command (word "argv.py") (word "'  $@  '") (word "$@"))
(command (word "argv.py") (word "' \"$@\" '") (word "\"$@\""))
(command (word "echo"))
(command (word "IFS=''"))
(command (word "argv.py") (word "'  $*  '") (word "$*"))
(command (word "argv.py") (word "' \"$*\" '") (word "\"$*\""))
(command (word "argv.py") (word "'  $@  '") (word "$@"))
(command (word "argv.py") (word "' \"$@\" '") (word "\"$@\""))
(command (word "echo"))
(command (word "IFS=zx"))
(command (word "argv.py") (word "'  $*  '") (word "$*"))
(command (word "argv.py") (word "' \"$*\" '") (word "\"$*\""))
(command (word "argv.py") (word "'  $@  '") (word "$@"))
(command (word "argv.py") (word "' \"$@\" '") (word "\"$@\""))
---

=== 4 x 3 table - with for loop
case $SH in yash) exit ;; esac  # no echo -n

setopt SH_WORD_SPLIT  # for zsh

set -- 'a b' c ''

# default IFS
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo
echo

IFS=''
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo
echo

IFS=zx
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo
---
(case (word "$SH") (pattern ((word "yash")) (command (word "exit"))))
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "set") (word "--") (word "'a b'") (word "c") (word "''"))
(semi (semi (command (word "echo") (word "-n") (word "'  $*  '")) (for (word "i") (in (word "$*")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$*\" '")) (for (word "i") (in (word "\"$*\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "'  $@  '")) (for (word "i") (in (word "$@")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$@\" '")) (for (word "i") (in (word "\"$@\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(command (word "echo"))
(command (word "IFS=''"))
(semi (semi (command (word "echo") (word "-n") (word "'  $*  '")) (for (word "i") (in (word "$*")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$*\" '")) (for (word "i") (in (word "\"$*\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "'  $@  '")) (for (word "i") (in (word "$@")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$@\" '")) (for (word "i") (in (word "\"$@\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(command (word "echo"))
(command (word "IFS=zx"))
(semi (semi (command (word "echo") (word "-n") (word "'  $*  '")) (for (word "i") (in (word "$*")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$*\" '")) (for (word "i") (in (word "\"$*\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "'  $@  '")) (for (word "i") (in (word "$@")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$@\" '")) (for (word "i") (in (word "\"$@\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
---

=== IFS=x and '' and $@ - same bug as spec/toysh-posix case #12
case $SH in yash) exit ;; esac  # no echo -n

setopt SH_WORD_SPLIT  # for zsh

set -- one '' two

IFS=zx
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo

argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
---
(case (word "$SH") (pattern ((word "yash")) (command (word "exit"))))
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "set") (word "--") (word "one") (word "''") (word "two"))
(command (word "IFS=zx"))
(semi (semi (command (word "echo") (word "-n") (word "'  $*  '")) (for (word "i") (in (word "$*")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$*\" '")) (for (word "i") (in (word "\"$*\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "'  $@  '")) (for (word "i") (in (word "$@")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(semi (semi (command (word "echo") (word "-n") (word "' \"$@\" '")) (for (word "i") (in (word "\"$@\"")) (semi (command (word "echo") (word "-n") (word "' '")) (command (word "echo") (word "-n") (word "-$i-"))))) (command (word "echo")))
(command (word "argv.py") (word "'  $*  '") (word "$*"))
(command (word "argv.py") (word "' \"$*\" '") (word "\"$*\""))
(command (word "argv.py") (word "'  $@  '") (word "$@"))
(command (word "argv.py") (word "' \"$@\" '") (word "\"$@\""))
---

=== IFS=x and '' and $@ (#2)
setopt SH_WORD_SPLIT  # for zsh

set -- "" "" "" "" ""
argv.py =$@=
argv.py =$*=
echo

IFS=
argv.py =$@=
argv.py =$*=
echo

IFS=x
argv.py =$@=
argv.py =$*=
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "set") (word "--") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\""))
(command (word "argv.py") (word "=$@="))
(command (word "argv.py") (word "=$*="))
(command (word "echo"))
(command (word "IFS="))
(command (word "argv.py") (word "=$@="))
(command (word "argv.py") (word "=$*="))
(command (word "echo"))
(command (word "IFS=x"))
(command (word "argv.py") (word "=$@="))
(command (word "argv.py") (word "=$*="))
---

=== IFS=x and '' and $@ (#3)
setopt SH_WORD_SPLIT  # for zsh

IFS=x
set -- "" "" "" "" ""

argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "IFS=x"))
(command (word "set") (word "--") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\""))
(command (word "argv.py") (word "$*"))
(command (word "set") (word "--") (word "$*"))
(command (word "argv.py") (word "$*"))
(command (word "set") (word "--") (word "$*"))
(command (word "argv.py") (word "$*"))
(command (word "set") (word "--") (word "$*"))
(command (word "argv.py") (word "$*"))
(command (word "set") (word "--") (word "$*"))
(command (word "argv.py") (word "$*"))
---

=== ""$A"" - empty string on both sides - derived from spec/toysh-posix #15
A="   abc   def   "

argv.py $A
argv.py ""$A""

unset IFS

argv.py $A
argv.py ""$A""

echo

# Do the same thing in a for loop - this is IDENTICAL behavior

for i in $A; do echo =$i=; done
echo

for i in ""$A""; do echo =$i=; done
echo

unset IFS

for i in $A; do echo =$i=; done
echo

for i in ""$A""; do echo =$i=; done
---
(command (word "A=\"   abc   def   \""))
(command (word "argv.py") (word "$A"))
(command (word "argv.py") (word "\"\"$A\"\""))
(command (word "unset") (word "IFS"))
(command (word "argv.py") (word "$A"))
(command (word "argv.py") (word "\"\"$A\"\""))
(command (word "echo"))
(for (word "i") (in (word "$A")) (command (word "echo") (word "=$i=")))
(command (word "echo"))
(for (word "i") (in (word "\"\"$A\"\"")) (command (word "echo") (word "=$i=")))
(command (word "echo"))
(command (word "unset") (word "IFS"))
(for (word "i") (in (word "$A")) (command (word "echo") (word "=$i=")))
(command (word "echo"))
(for (word "i") (in (word "\"\"$A\"\"")) (command (word "echo") (word "=$i=")))
---

=== Regression: "${!v*}"x should not be split
case $SH in dash|mksh|ash|yash) exit 99;; esac
IFS=x
axb=1
echo "${!axb*}"
echo "${!axb*}"x
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash") (word "yash")) (command (word "exit") (word "99"))))
(command (word "IFS=x"))
(command (word "axb=1"))
(command (word "echo") (word "\"${!axb*}\""))
(command (word "echo") (word "\"${!axb*}\"x"))
---

=== Regression: ${!v} should be split
v=hello
IFS=5
echo ${#v}
echo "${#v}"
---
(command (word "v=hello"))
(command (word "IFS=5"))
(command (word "echo") (word "${#v}"))
(command (word "echo") (word "\"${#v}\""))
---

=== Regression: "${v:-AxBxC}"x should not be split
IFS=x
v=
echo "${v:-AxBxC}"
echo "${v:-AxBxC}"x  # <-- osh failed this
echo ${v:-AxBxC}
echo ${v:-AxBxC}x
echo ${v:-"AxBxC"}
echo ${v:-"AxBxC"}x
echo "${v:-"AxBxC"}"
echo "${v:-"AxBxC"}"x
---
(command (word "IFS=x"))
(command (word "v="))
(command (word "echo") (word "\"${v:-AxBxC}\""))
(command (word "echo") (word "\"${v:-AxBxC}\"x"))
(command (word "echo") (word "${v:-AxBxC}"))
(command (word "echo") (word "${v:-AxBxC}x"))
(command (word "echo") (word "${v:-\"AxBxC\"}"))
(command (word "echo") (word "${v:-\"AxBxC\"}x"))
(command (word "echo") (word "\"${v:-\"AxBxC\"}\""))
(command (word "echo") (word "\"${v:-\"AxBxC\"}\"x"))
---
