================================================================================
brace-expansion.test.sh: no expansion
================================================================================

echo {foo}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: incomplete trailing expansion
================================================================================

echo {a,b}_{

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: partial leading expansion
================================================================================

echo }_{a,b}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: partial leading expansion 2
================================================================================

echo {x}_{a,b}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: } in expansion
================================================================================

# hm they treat this the SAME.  Leftmost { is matched by first }, and then
# there is another } as the postfix.
echo {a,b}}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: single expansion
================================================================================

echo {foo,bar}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion
================================================================================

echo {a,b}_{c,d}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: triple expansion
================================================================================

echo {0,1}{0,1}{0,1}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion with single and double quotes
================================================================================

echo {'a',b}_{c,"d"}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: expansion with mixed quotes
================================================================================

echo -{\X"b",'cd'}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: expansion with simple var
================================================================================

a=A
echo -{$a,b}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion with simple var -- bash bug
================================================================================

# bash is inconsistent with the above
a=A
echo {$a,b}_{c,d}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion with braced variable
================================================================================

# This fixes it
a=A
echo {${a},b}_{c,d}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion with literal and simple var
================================================================================

a=A
echo {_$a,b}_{c,d}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: expansion with command sub
================================================================================

a=A
echo -{$(echo a),b}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: expansion with arith sub
================================================================================

a=A
echo -{$((1 + 2)),b}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: double expansion with escaped literals
================================================================================

a=A
echo -{\$,\[,\]}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: { in expansion
================================================================================

# bash and mksh treat this differently.  bash treats the
# first { is a prefix.  I think it's harder to read, and \{{a,b} should be
# required.
echo {{a,b}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: quoted { in expansion
================================================================================

echo \{{a,b}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Empty expansion
================================================================================

echo a{X,,Y}b

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Empty alternative
================================================================================

# zsh and mksh don't do word elision, probably because they do brace expansion
# AFTER variable substitution.
argv.py {X,,Y,}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Empty alternative with empty string suffix
================================================================================

# zsh and mksh don't do word elision, probably because they do brace expansion
# AFTER variable substitution.
argv.py {X,,Y,}''

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: nested brace expansion
================================================================================

echo -{A,={a,b}=,B}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: triple nested brace expansion
================================================================================

echo -{A,={a,.{x,y}.,b}=,B}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: nested and double brace expansion
================================================================================

echo -{A,={a,b}{c,d}=,B}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: expansion on RHS of assignment
================================================================================

# I think bash's behavior is more consistent.  No splitting either.
v={X,Y}
echo $v

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: no expansion with RHS assignment
================================================================================

{v,x}=X

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Tilde expansion
================================================================================

HOME=/home/foo
echo ~
HOME=/home/bar
echo ~

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Tilde expansion with brace expansion
================================================================================


# The brace expansion happens FIRST.  After that, the second token has tilde
# FIRST, so it gets expanded.  The first token has an unexpanded tilde, because
# it's not in the leading position.

HOME=/home/bob

# Command

echo {foo~,~}/bar

# Loop

for x in {foo~,~}/bar; do
  echo -- $x
done

# Array

a=({foo~,~}/bar)

for y in "${a[@]}"; do
  echo "== $y"
done

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Two kinds of tilde expansion
================================================================================


HOME=/home/bob

# Command
echo ~{/src,root}

# Loop

for x in ~{/src,root}; do
  echo -- $x
done

# Array

a=(~{/src,root})

for y in "${a[@]}"; do
  echo "== $y"
done

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Tilde expansion come before var expansion
================================================================================

HOME=/home/bob
foo=~
echo $foo
foo='~'
echo $foo
# In the second instance, we expand into a literal ~, and since var expansion
# comes after tilde expansion, it is NOT tried again.

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Number range expansion
================================================================================

echo -{1..8..3}-
echo -{1..10..3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Ascending number range expansion with negative step is invalid
================================================================================

echo -{1..8..-3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: regression: -1 step disallowed
================================================================================

echo -{1..4..-1}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: regression: 0 step disallowed
================================================================================

echo -{1..4..0}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Descending number range expansion with positive step is invalid
================================================================================

echo -{8..1..3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Descending number range expansion with negative step
================================================================================

echo -{8..1..-3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Singleton ranges
================================================================================

echo {1..1}-
echo {-9..-9}-
echo {-9..-9..3}-
echo {-9..-9..-3}-
echo {a..a}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Singleton char ranges with steps
================================================================================

echo {a..a..2}-
echo {a..a..-2}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Char range expansion
================================================================================

echo -{a..e}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Char range expansion with step
================================================================================

echo -{a..e..2}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Char ranges with steps of the wrong sign
================================================================================

echo -{a..e..-2}-
echo -{e..a..2}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Mixed case char expansion is invalid
================================================================================

case $SH in *zsh) echo BUG; exit ;; esac
echo -{z..A}-
echo -{z..A..2}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Descending char range expansion
================================================================================

echo -{e..a..-2}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Fixed width number range expansion
================================================================================

echo -{01..03}-
echo -{09..12}-  # doesn't become -012-, fixed width
echo -{12..07}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Inconsistent fixed width number range expansion
================================================================================

# zsh uses the first one, bash uses the max width?
echo -{01..003}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Inconsistent fixed width number range expansion
================================================================================

# zsh uses the first width, bash uses the max width?
echo -{01..3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Adjacent comma and range works
================================================================================

echo -{a,b}{1..3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Range inside comma works
================================================================================

echo -{a,_{1..3}_,b}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Mixed comma and range doesn't work
================================================================================

echo -{a,b,1..3}-

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: comma and invalid range (adjacent and nested)
================================================================================

echo -{a,b}{1...3}-
echo -{a,{1...3}}-
echo {a,b}{}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: OSH provides an alternative to invalid syntax
================================================================================

echo -{a,b}\{1...3\}-
echo -{a,\{1...3\}}-
echo {a,b}\{\}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Side effect in expansion
================================================================================

# bash is the only one that does it first.  I guess since this is
# non-POSIX anyway, follow bash?
i=0
echo {a,b,c}-$((i++))

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Invalid brace expansions don't expand
================================================================================

echo {1.3}
echo {1...3}
echo {1__3}

--------------------------------------------------------------------------------

(program)

================================================================================
brace-expansion.test.sh: Invalid brace expansions mixing characters and numbers
================================================================================

# zsh does something crazy like : ; < = > that I'm not writing
case $SH in *zsh) echo BUG; exit ;; esac
echo {1..a}
echo {z..3}

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: @() matches exactly one of the patterns
================================================================================

shopt -s extglob
mkdir -p 0
cd 0
touch {foo,bar}.cc {foo,bar,baz}.h
echo @(*.cc|*.h)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: ?() matches 0 or 1
================================================================================

shopt -s extglob
mkdir -p 1
cd 1
touch {foo,bar}.cc {foo,bar,baz}.h foo. foo.hh
ext=cc
echo foo.?($ext|h)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: *() matches 0 or more
================================================================================

shopt -s extglob
mkdir -p eg1
touch eg1/_ eg1/_One eg1/_OneOne eg1/_TwoTwo eg1/_OneTwo
echo eg1/_*(One|Two)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: +() matches 1 or more
================================================================================

shopt -s extglob
mkdir -p eg2
touch eg2/_ eg2/_One eg2/_OneOne eg2/_TwoTwo eg2/_OneTwo
echo eg2/_+(One|$(echo Two))

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: !(*.h|*.cc) to match everything except C++
================================================================================

shopt -s extglob
mkdir -p extglob2
touch extglob2/{foo,bar}.cc extglob2/{foo,bar,baz}.h \
      extglob2/{foo,bar,baz}.py
echo extglob2/!(*.h|*.cc)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Two adjacent alternations
================================================================================

shopt -s extglob
mkdir -p 2
touch 2/{aa,ab,ac,ba,bb,bc,ca,cb,cc}
echo 2/!(b)@(b|c)
echo 2/!(b)?@(b|c)  # wildcard in between
echo 2/!(b)a@(b|c)  # constant in between

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Nested extended glob pattern
================================================================================

shopt -s extglob
mkdir -p eg6
touch eg6/{ab,ac,ad,az,bc,bd}
echo eg6/a@(!(c|d))
echo eg6/a!(@(ab|b*))

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Extended glob patterns with spaces
================================================================================

shopt -s extglob
mkdir -p eg4
touch eg4/a 'eg4/a b' eg4/foo
argv.py eg4/@(a b|foo)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Filenames with spaces
================================================================================

shopt -s extglob
mkdir -p eg5
touch eg5/'a b'{cd,de,ef}
argv.py eg5/'a '@(bcd|bde|zzz)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: nullglob with extended glob
================================================================================

shopt -s extglob
mkdir eg6
argv.py eg6/@(no|matches)  # no matches
shopt -s nullglob  # test this too
argv.py eg6/@(no|matches)  # no matches

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Glob other punctuation chars (lexer mode)
================================================================================

shopt -s extglob
mkdir -p eg5
cd eg5
touch __{aa,'<>','{}','#','&&'}
argv.py @(__aa|'__<>'|__{}|__#|__&&|)

# mksh sorts them differently

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: More glob escaping
================================================================================

shopt -s extglob
mkdir -p eg7
cd eg7
touch '_[:]' '_*' '_?'
argv.py @('_[:]'|'_*'|'_?')
argv.py @(nested|'_?'|@('_[:]'|'_*'))

# mksh sorts them differently

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Escaping of pipe (glibc bug, see demo/glibc_fnmatch.c)
================================================================================

shopt -s extglob

mkdir -p extpipe
cd extpipe

touch '__|' foo
argv.py @('foo'|__\||bar)
argv.py @('foo'|'__|'|bar)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Extended glob as argument to ${undef:-} (dynamic globbing)
================================================================================


# This case popped into my mind after inspecting osh/word_eval.py for calls to
# _EvalWordToParts()

shopt -s extglob

mkdir -p eg8
cd eg8
touch {foo,bar,spam}.py

# regular glob
echo ${undef:-*.py}

# extended glob
echo ${undef:-@(foo|bar).py}

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Extended glob in assignment builtin
================================================================================


# Another invocation of _EvalWordToParts() that OSH should handle

shopt -s extglob
mkdir -p eg9
cd eg9
touch {foo,bar}.py
typeset -@(*.py) myvar
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Extended glob in same word as array
================================================================================

shopt -s extglob
mkdir -p eg10
cd eg10

touch {'a b c',bee,cee}.{py,cc}
set -- 'a b' 'c'

argv.py "$@"

# This works!
argv.py star glob "$*"*.py
argv.py star extglob "$*"*@(.py|cc)

# Hm this actually still works!  the first two parts are literal.  And then
# there's something like the simple_word_eval algorithm on the rest.  Gah.
argv.py at extglob "$@"*@(.py|cc)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: Extended glob with word splitting
================================================================================

shopt -s extglob
mkdir -p 3
cd 3

x='a b'
touch bar.{cc,h}

# OSH may disallow splitting when there's an extended glob
argv.py $x*.@(cc|h)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: In Array Literal and for loop
================================================================================

shopt -s extglob
mkdir -p eg11
cd eg11
touch {foo,bar,spam}.py
for x in @(fo*|bar).py; do
  echo $x
done

echo ---
declare -a A
A=(zzz @(fo*|bar).py)
echo "${A[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: No extended glob with simple_word_eval (YSH evaluation)
================================================================================

shopt -s ysh:all
shopt -s extglob
mkdir -p eg12
cd eg12
touch {foo,bar,spam}.py
builtin write -- x@(fo*|bar).py
builtin write -- @(fo*|bar).py

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: no_dash_glob
================================================================================

shopt -s extglob
mkdir -p opts
cd opts

touch -- foo bar -dash
echo @(*)

shopt --set no_dash_glob
echo @(*)

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: noglob
================================================================================

shopt -s extglob
mkdir -p _noglob
cd _noglob

set -o noglob
echo @(*)
echo @(__nope__*|__nope__?|'*'|'?'|'[:alpha:]'|'|')

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-files.test.sh: failglob
================================================================================

shopt -s extglob

rm -f _failglob/*
mkdir -p _failglob
cd _failglob

shopt -s failglob
echo @(*)
echo status=$?

touch foo
echo @(*)
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: @ matches exactly one
================================================================================

[[ --verbose == --@(help|verbose) ]] && echo TRUE
[[ --oops == --@(help|verbose) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: @() with variable arms
================================================================================

choice1='help'
choice2='verbose'
[[ --verbose == --@($choice1|$choice2) ]] && echo TRUE
[[ --oops == --@($choice1|$choice2) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extglob in variable
================================================================================

shopt -s extglob

# this syntax requires extglob in bash!!
# OSH never allows it
g=--@(help|verbose)

quoted='--@(help|verbose)'

[[ --help == $g ]] && echo TRUE
[[ --verbose == $g ]] && echo TRUE
[[ -- == $g ]] || echo FALSE
[[ --help == $q ]] || echo FALSE
[[ -- == $q ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: Matching literal '@(cc)'
================================================================================


# extglob is OFF.  Doesn't affect bash or mksh!
[[ cc == @(cc) ]] 
echo status=$?
[[ cc == '@(cc)' ]]
echo status=$?

shopt -s extglob

[[ cc == @(cc) ]]
echo status=$?
[[ cc == '@(cc)' ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: nested @()
================================================================================

shopt -s extglob
pat='--@(help|verbose|no-@(long|short)-option)'
[[ --no-long-option == $pat ]] && echo TRUE
[[ --no-short-option == $pat ]] && echo TRUE
[[ --help == $pat ]] && echo TRUE
[[ --oops == $pat ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: nested @() with quotes and vars
================================================================================

shopt -s extglob
prefix=no
[[ --no-long-option == --@(help|verbose|$prefix-@(long|short)-'option') ]] &&
  echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: ? matches 0 or 1
================================================================================

[[ -- == --?(help|verbose) ]] && echo TRUE
[[ --oops == --?(help|verbose) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: + matches 1 or more
================================================================================

[[ --helphelp == --+(help|verbose) ]] && echo TRUE
[[ -- == --+(help|verbose) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: * matches 0 or more
================================================================================

[[ -- == --*(help|verbose) ]] && echo TRUE
[[ --oops == --*(help|verbose) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: simple repetition with *(foo) and +(Foo)
================================================================================

[[ foofoo == *(foo) ]] && echo TRUE
[[ foofoo == +(foo) ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: ! matches none
================================================================================

[[ --oops == --!(help|verbose) ]] && echo TRUE
[[ --help == --!(help|verbose) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: match is anchored
================================================================================

[[ foo_ == @(foo) ]] || echo FALSE
[[ _foo == @(foo) ]] || echo FALSE
[[ foo == @(foo) ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: repeated match is anchored
================================================================================

[[ foofoo_ == +(foo) ]] || echo FALSE
[[ _foofoo == +(foo) ]] || echo FALSE
[[ foofoo == +(foo) ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: repetition with glob
================================================================================

# NOTE that * means two different things here
[[ foofoo_foo__foo___ == *(foo*) ]] && echo TRUE
[[ Xoofoo_foo__foo___ == *(foo*) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: No brace expansion in ==
================================================================================

[[ --X{a,b}X == --@(help|X{a,b}X) ]] && echo TRUE
[[ --oops == --@(help|X{a,b}X) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: adjacent extglob
================================================================================

[[ --help == @(--|++)@(help|verbose) ]] && echo TRUE
[[ ++verbose == @(--|++)@(help|verbose) ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: nested extglob
================================================================================

[[ --help == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose=1 == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose=2 == --@(help|verbose=@(1|2)) ]] && echo TRUE
[[ --verbose == --@(help|verbose=@(1|2)) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extglob empty string
================================================================================

shopt -s extglob
[[ '' == @(foo|bar) ]] || echo FALSE
[[ '' == @(foo||bar) ]] && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extglob empty pattern
================================================================================

shopt -s extglob
[[ '' == @() ]] && echo TRUE
[[ '' == @(||) ]] && echo TRUE
[[ X == @() ]] || echo FALSE
[[ '|' == @(||) ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: case with extglob
================================================================================

shopt -s extglob
for word in --help --verbose --unmatched -- -zxzx -; do
  case $word in
    --@(help|verbose) )
      echo A
      continue
      ;;
    ( --?(b|c) )
      echo B
      continue
      ;;
    ( -+(x|z) )
      echo C
      continue
      ;;
    ( -*(x|z) )
      echo D
      continue
      ;;
    *)
      echo U
      continue
      ;;
  esac
done

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: [[ $x == !($str) ]]
================================================================================

shopt -s extglob
empty=''
str='x'
[[ $empty == !($str) ]] && echo TRUE  # test glob match
[[ $str == !($str) ]]   || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: Turning extglob on changes the meaning of [[ !(str) ]] in bash
================================================================================

empty=''
str='x'
[[ !($empty) ]]  && echo TRUE   # test if $empty is empty
[[ !($str) ]]    || echo FALSE  # test if $str is empty
shopt -s extglob  # mksh doesn't have this
[[ !($empty) ]]  && echo TRUE   # negated glob
[[ !($str) ]]    && echo TRUE   # negated glob

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: With extglob on, !($str) on the left or right of == has different meanings
================================================================================

shopt -s extglob
str='x'
[[ 1 == !($str) ]]  && echo TRUE   # glob match

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extglob inside arg word
================================================================================

shopt -s extglob
[[ foo == @(foo|bar) ]] && echo rhs
[[ foo == ${unset:-@(foo|bar)} ]] && echo 'rhs arg'
[[ fo == ${unset:-@(foo|bar)} ]] || echo nope

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extglob is not detected in regex!
================================================================================

shopt -s extglob
[[ foo =~ ^@(foo|bar)$ ]] || echo FALSE

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: regular glob of single unicode char
================================================================================

shopt -s extglob
[[ __a__ == __?__ ]]
echo $?
[[ __μ__ == __?__ ]]
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: extended glob of single unicode char
================================================================================

shopt -s extglob
[[ __a__ == @(__?__) ]]
echo $?
[[ __μ__ == @(__?__) ]]
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: Extended glob in ${x//pat/replace}
================================================================================

# not supported in OSH due to GlobToERE() strategy for positional info

shopt -s extglob
x=foo.py
echo ${x//@(?.py)/Z}

--------------------------------------------------------------------------------

(program)

================================================================================
extglob-match.test.sh: Extended glob in ${x%PATTERN}
================================================================================


shopt -s extglob
x=foo.py
echo 'strip % ' ${x%.@(py|cc)}
echo 'strip %%' ${x%%.@(py|cc)}
echo 'strip # ' ${x#@(foo)}
echo 'strip ##' ${x##@(foo)}

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s nullglob
================================================================================

argv.py _tmp/spec-tmp/*.nonexistent
shopt -s nullglob
argv.py _tmp/spec-tmp/*.nonexistent

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob in command context
================================================================================

argv.py *.ZZ
shopt -s failglob
argv.py *.ZZ  # nothing is printed, not []
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob in loop context
================================================================================

for x in *.ZZ; do echo $x; done
echo status=$?
shopt -s failglob
for x in *.ZZ; do echo $x; done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob in array literal context
================================================================================

myarr=(*.ZZ)
echo "${myarr[@]}"
shopt -s failglob
myarr=(*.ZZ)
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob exits properly in command context with set -e
================================================================================

set -e
argv.py *.ZZ
shopt -s failglob
argv.py *.ZZ
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob exits properly in loop context with set -e
================================================================================

set -e
for x in *.ZZ; do echo $x; done
echo status=$?

shopt -s failglob
for x in *.ZZ; do echo $x; done
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: shopt -s failglob behavior on single line with semicolon
================================================================================

# bash behaves differently when commands are separated by a semicolon than when
# separated by a newline. This behavior doesn't make sense or seem to be
# intentional, so osh does not mimic it.

shopt -s failglob
echo *.ZZ; echo status=$? # bash doesn't execute the second part!
echo *.ZZ
echo status=$? # bash executes this

--------------------------------------------------------------------------------

(program)

================================================================================
glob-bash.test.sh: dotglob (bash option that no_dash_glob is roughly consistent with)
================================================================================

mkdir -p $TMP/dotglob
cd $TMP/dotglob
touch .foorc other

echo *
shopt -s dotglob
echo * | sort

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob double quote escape
================================================================================

echo "*.sh"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob single quote escape
================================================================================

echo "*.sh"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob backslash escape
================================================================================

echo \*.sh

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: 1 char glob
================================================================================

cd $REPO_ROOT
echo [b]in

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: 0 char glob -- does NOT work
================================================================================

echo []bin

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: looks like glob at the start, but isn't
================================================================================

echo [bin

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: looks like glob plus negation at the start, but isn't
================================================================================

echo [!bin

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob can expand to command and arg
================================================================================

cd $REPO_ROOT
spec/testdata/echo.s[hz]

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob after var expansion
================================================================================

touch _tmp/a.A _tmp/aa.A _tmp/b.B
f="_tmp/*.A"
g="$f _tmp/*.B"
echo $g

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: quoted var expansion with glob meta characters
================================================================================

touch _tmp/a.A _tmp/aa.A _tmp/b.B
f="_tmp/*.A"
echo "[ $f ]"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob after "$@" expansion
================================================================================

fun() {
  echo "$@"
}
fun '_tmp/*.B'

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob after $@ expansion
================================================================================

touch _tmp/b.B
fun() {
  echo $@
}
fun '_tmp/*.B'

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: no glob after ~ expansion
================================================================================

HOME=*
echo ~/*.py

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: store literal globs in array then expand
================================================================================

touch _tmp/a.A _tmp/aa.A _tmp/b.B
g=("_tmp/*.A" "_tmp/*.B")
echo ${g[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob inside array
================================================================================

touch _tmp/a.A _tmp/aa.A _tmp/b.B
g=(_tmp/*.A _tmp/*.B)
echo "${g[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob with escaped - in char class
================================================================================

touch _tmp/foo.-
touch _tmp/c.C
echo _tmp/*.[C-D] _tmp/*.[C\-D]

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob with char class expression
================================================================================

# note: mksh doesn't support [[:punct:]] ?
touch _tmp/e.E _tmp/foo.-
echo _tmp/*.[[:punct:]E]

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob double quotes
================================================================================

# note: mksh doesn't support [[:punct:]] ?
touch _tmp/\"quoted.py\"
echo _tmp/\"*.py\"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: glob escaped
================================================================================

# - mksh doesn't support [[:punct:]] ?
# - python shell fails because \[ not supported!
touch _tmp/\[abc\] _tmp/\?
echo _tmp/\[???\] _tmp/\?

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: : escaped
================================================================================


touch _tmp/foo.-
echo _tmp/*.[[:punct:]] _tmp/*.[[:punct\:]]

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob after var manipulation
================================================================================

touch _tmp/foo.zzz _tmp/bar.zzz
g='_tmp/*.zzzZ'
echo $g ${g%Z}

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob after part joining
================================================================================

touch _tmp/foo.yyy _tmp/bar.yyy
g='_tmp/*.yy'
echo $g ${g}y

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob flags on file system
================================================================================

touch _tmp/-n _tmp/zzzzz
cd _tmp
echo -* hello zzzz?

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: set -o noglob
================================================================================

cd $REPO_ROOT
touch _tmp/spec-tmp/a.zz _tmp/spec-tmp/b.zz
echo _tmp/spec-tmp/*.zz
set -o noglob
echo _tmp/spec-tmp/*.zz

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: set -o noglob (bug #698)
================================================================================

var='\z'
set -f
echo $var

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Splitting/Globbing doesn't happen on local assignment
================================================================================

cd $REPO_ROOT

f() {
  # Dash splits words and globs before handing it to the 'local' builtin.  But
  # ash doesn't!
  local foo=$1
  echo "$foo"
}
f 'void *'

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob of unescaped [[] and []]
================================================================================

touch $TMP/[ $TMP/]
cd $TMP
echo [\[z] [\]z]  # the right way to do it
echo [[z] []z]    # also accepted

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob of negated unescaped [[] and []]
================================================================================

# osh does this "correctly" because it defers to libc!
touch $TMP/_G
cd $TMP
echo _[^\[z] _[^\]z]  # the right way to do it
echo _[^[z] _[^]z]    # also accepted

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: PatSub of unescaped [[] and []]
================================================================================

x='[foo]'
echo ${x//[\[z]/<}  # the right way to do it
echo ${x//[\]z]/>}
echo ${x//[[z]/<}  # also accepted
echo ${x//[]z]/>}

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: PatSub of negated unescaped [[] and []]
================================================================================

x='[foo]'
echo ${x//[^\[z]/<}  # the right way to do it
echo ${x//[^\]z]/>}
echo ${x//[^[z]/<}  # also accepted
#echo ${x//[^]z]/>}  # only busybox ash interprets as ^\]

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob unicode char
================================================================================


touch $TMP/__a__
touch $TMP/__μ__
cd $TMP

echo __?__

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: Glob ordering respects LC_COLLATE (zsh respects this too)
================================================================================


# test/spec-common.sh sets LC_ALL=C.UTF_8
unset LC_ALL

touch hello hello.py hello_preamble.sh hello-test.sh
echo h*

# bash - hello_preamble.h comes first
# But ord('_') == 95 
#     ord('-') == 45

# https://serverfault.com/questions/122737/in-bash-are-wildcard-expansions-guaranteed-to-be-in-order

#LC_COLLATE=C.UTF-8
LC_COLLATE=en_US.UTF-8  # en_US is necessary
echo h*

LC_COLLATE=en_US.UTF-8 $SH -c 'echo h*'

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: \ in unquoted substitutions does not match a backslash
================================================================================

mkdir x
touch \
  x/test.ifs.\\.txt \
  x/test.ifs.\'.txt \
  x/test.ifs.a.txt \
  x/test.ifs.\\b.txt

v="*\\*.txt"
argv.py x/$v

v="*\'.txt"
argv.py x/$v

v='*\a.txt'
argv.py x/$v

v='*\b.txt'
argv.py x/$v

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: \ in unquoted substitutions is preserved
================================================================================

v='\*\*.txt'
echo $v
echo "$v"

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: \ in unquoted substitutions is preserved with set -o noglob
================================================================================

set -f
v='*\*.txt'
echo $v

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: \ in unquoted substitutions is preserved without glob matching
================================================================================

mkdir x
touch \
  'x/test.ifs.\.txt' \
  'x/test.ifs.*.txt'
v='*\*.txt'
argv.py x/unmatching.$v

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: \ in unquoted substitutions escapes globchars
================================================================================

mkdir x
touch \
  'x/test.ifs.\.txt' \
  'x/test.ifs.*.txt'

v='*\*.txt'
argv.py x/$v

v="\\" u='*.txt'
argv.py x/*$v$u

v="\\" u="*.txt"
argv.py x/*$v*.txt

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: pattern starting with . does not return . and ..
================================================================================


echo hi .*

--------------------------------------------------------------------------------

(program)

================================================================================
glob.test.sh: shopt -u globskipdots shows . and ..
================================================================================

case $SH in dash|ash|mksh) exit ;; esac

shopt -u globskipdots
echo hi .*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Don't glob flags on file system with GLOBIGNORE
================================================================================

touch _tmp/-n _tmp/zzzzz
cd _tmp
GLOBIGNORE=-*:zzzzz  # colon-separated pattern list
echo -* hello zzzz?

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore *.txt
================================================================================

touch one.md one.txt
mkdir -p foo
touch foo/{two.md,two.txt}
GLOBIGNORE=*.txt
echo *.* foo/*.*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore ?.txt
================================================================================

touch {1,10}.txt
mkdir -p foo
touch foo/{2,20}.txt
GLOBIGNORE=?.txt
echo *.* foo/*.*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore *.o:*.h
================================================================================

touch {hello.c,hello.h,hello.o,hello}
GLOBIGNORE=*.o:*.h
echo hello*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore single file src/__main__.py
================================================================================

mkdir src
touch src/{__init__.py,__main__.py}
GLOBIGNORE='src/__init__.py'
echo src/*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore dirs dist/*:node_modules/*
================================================================================

mkdir {src,compose,dist,node_modules}
touch src/{a.js,b.js}
touch compose/{base.compose.yaml,dev.compose.yaml}
touch dist/index.js
touch node_modules/package.js
GLOBIGNORE=dist/*:node_modules/*
echo */*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: find files in subdirectory but not the ignored pattern
================================================================================

mkdir {dir1,dir2}
touch dir1/{a.txt,ignore.txt}
touch dir2/{a.txt,ignore.txt}
GLOBIGNORE=*/ignore*
echo */*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore globs with char patterns like [!ab]
================================================================================

rm -rf _tmp
touch {a,b,c,d,A,B,C,D}
GLOBIGNORE=*[ab]*
echo *
GLOBIGNORE=*[ABC]*
echo *
GLOBIGNORE=*[!ab]*
echo *

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore globs with char classes like [[:alnum:]]
================================================================================

touch {_testing.py,pyproject.toml,20231114.log,.env}
touch 'has space.docx'
GLOBIGNORE=[[:alnum:]]*
echo *.*
GLOBIGNORE=[![:alnum:]]*
echo *.*
GLOBIGNORE=*[[:space:]]*
echo *.*
GLOBIGNORE=[[:digit:]_.]*
echo *.*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore *
================================================================================

# This pattern appears in public repositories
touch {1.txt,2.log,3.md}
GLOBIGNORE=*
echo *

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: treat escaped patterns literally
================================================================================

touch {escape-10.txt,escape*.txt}
GLOBIGNORE="escape\*.txt"
echo *.*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: resetting globignore reverts to default behaviour
================================================================================

touch reset.txt
GLOBIGNORE=*.txt
echo *.*
GLOBIGNORE=
echo *.*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Ignore .:..
================================================================================

# globskipdots is enabled by default in bash >=5.2
# for bash <5.2 this pattern is a common way to match dotfiles but not . or ..
shopt -u globskipdots
touch .env
GLOBIGNORE=.:..
echo .*
GLOBIGNORE=
echo .* | sort

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Quoting GLOBIGNORE
================================================================================

# each style of "ignore everything" spotted in a public repo
touch image.jpeg
GLOBIGNORE=*
echo *
GLOBIGNORE='*'
echo *
GLOBIGNORE="*"
echo *
GLOBIGNORE=\*
echo *

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: . and .. always filtered when GLOBIGNORE is set
================================================================================

# When GLOBIGNORE is set to any non-null value, . and .. are always filtered
touch .hidden
GLOBIGNORE=*.txt

echo .*
shopt -u globskipdots
echo .*

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: When GLOBIGNORE is set, glob may become empty (nullglob too)
================================================================================

touch -- foo.txt -foo.txt

echo *t

GLOBIGNORE=*.txt
echo *t

shopt -s nullglob
echo nullglob *t

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: When GLOBIGNORE is set, no_dash_glob isn't respected
================================================================================

case $SH in bash) exit ;; esac

touch -- foo.txt -foo.txt

shopt -s no_dash_glob  # YSH option

echo *  # expansion does NOT include -foo.txt

GLOBIGNORE=f*.txt
echo *  # expansion includes -foo.txt, because it doesn't match GLOBIGNORE

--------------------------------------------------------------------------------

(program)

================================================================================
globignore.test.sh: Extended glob expansion combined with GLOBIGNORE
================================================================================

shopt -s extglob

touch foo.cc foo.h bar.cc bar.h 
echo @(*.cc|*.h)
GLOBIGNORE=foo.*
echo @(*.cc|*.h)

--------------------------------------------------------------------------------

(program)

================================================================================
globstar.test.sh: globstar is off -> ** is treated like *
================================================================================

case $SH in zsh) exit ;; esac

shopt -u globstar

mkdir -p c/subdir
touch {leaf.md,c/leaf.md,c/subdir/leaf.md}

echo **/*.* | sort

--------------------------------------------------------------------------------

(program)

================================================================================
globstar.test.sh: each occurrence of ** recurses through all depths
================================================================================

shopt -s globstar

mkdir -p c/subdir
touch {leaf.md,c/leaf.md,c/subdir/leaf.md}

echo **/*.* | tr ' ' '\n' | sort
echo
echo **/**/*.* | tr ' ' '\n' | sort

--------------------------------------------------------------------------------

(program)

================================================================================
globstar.test.sh: within braces, globstar works when there is a comma
================================================================================

shopt -s globstar

mkdir -p c/subdir
touch c/subdir/leaf.md

echo {**/*.*,} | sort | sed 's/[[:space:]]*$//'

--------------------------------------------------------------------------------

(program)

================================================================================
globstar.test.sh: ** behaves like * if adjacent to anything other than /
================================================================================

shopt -s globstar

mkdir directory
touch leaf.md
touch directory/leaf.md

echo **/*.* | sort
echo directory/**/*.md | sort
echo d**/*.md | sort
echo **y/*.md | sort
echo d**y/*.md | sort

--------------------------------------------------------------------------------

(program)

================================================================================
globstar.test.sh: in zsh, ***/ follows symlinked directories, while **/ does not
================================================================================

case $SH in bash) exit ;; esac

mkdir directory-1
mkdir directory-2
touch directory-2/leaf-2.md
ln -s -T ../directory-2 directory-1/symlink

echo **/*.* | sort
echo ***/*.* | sort

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: ~ expansion in assignment
================================================================================

HOME=/home/bob
a=~/src
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: ~ expansion in readonly assignment
================================================================================

# dash fails here!
# http://stackoverflow.com/questions/8441473/tilde-expansion-doesnt-work-when-i-logged-into-gui
HOME=/home/bob
readonly const=~/src
echo $const

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: No ~ expansion in dynamic assignment
================================================================================

HOME=/home/bob
binding='const=~/src'
readonly "$binding"
echo $const

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: No tilde expansion in word that looks like assignment but isn't
================================================================================

# bash and mksh mistakenly expand here!
# bash fixes this in POSIX mode (gah).
# http://lists.gnu.org/archive/html/bug-bash/2016-06/msg00001.html
HOME=/home/bob
echo x=~

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: tilde expansion of word after redirect
================================================================================

HOME=$TMP
echo hi > ~/tilde1.txt
cat $HOME/tilde1.txt | wc -c

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: other user
================================================================================

echo ~nonexistent

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: ${undef:-~}
================================================================================

HOME=/home/bar
echo ${undef:-~}
echo ${HOME:+~/z}
echo "${undef:-~}"
echo ${undef:-"~"}

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: ${x//~/~root}
================================================================================

HOME=/home/bar
x=~
echo ${x//~/~root}

# gah there is some expansion, what the hell
echo ${HOME//~/~root}

x=[$HOME]
echo ${x//~/~root}

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: x=foo:~ has tilde expansion
================================================================================

HOME=/home/bar
x=foo:~
echo $x
echo "$x"  # quotes don't matter, the expansion happens on assignment?
x='foo:~'
echo $x

x=foo:~,  # comma ruins it, must be /
echo $x

x=~:foo
echo $x

# no tilde expansion here
echo foo:~

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: a[x]=foo:~ has tilde expansion
================================================================================

case $SH in dash|zsh) exit ;; esac

HOME=/home/bar
declare -a a
a[0]=foo:~
echo ${a[0]}

declare -A A
A['x']=foo:~
echo ${A['x']}

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: tilde expansion an assignment keyword
================================================================================

HOME=/home/bar
f() {
  local x=foo:~
  echo $x
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: x=${undef-~:~}
================================================================================

HOME=/home/bar

x=~:${undef-~:~}
echo $x

# Most shells agree on a different behavior, but with the OSH parsing model,
# it's easier to agree with yash.  bash disagrees in a different way

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: strict tilde
================================================================================

echo ~nonexistent

shopt -s strict_tilde
echo ~nonexistent

echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
tilde.test.sh: temp assignment x=~ env
================================================================================


HOME=/home/bar

xx=~ env | grep xx=

# Does it respect the colon rule too?
xx=~root:~:~ env | grep xx=

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: Normal and braced
================================================================================

$SH -c 'echo $0 $1 ${2}' a b c d

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: In function
================================================================================

myfunc() {
  echo $1 ${2}
}
myfunc a b c d

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: $0 with -c
================================================================================

$SH -c 'echo $0' | grep -o 'sh$'

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: $0 with stdin
================================================================================

echo 'echo $0' | $SH | grep -o 'sh$'

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: $0 with -i
================================================================================

echo 'echo $0' | $SH -i | grep -o 'sh$'

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: $0 with filename
================================================================================

s=dollar0
echo 'echo $0' > $s
chmod +x $s
$SH $s

--------------------------------------------------------------------------------

(program)

================================================================================
var-num.test.sh: $@ with filename
================================================================================

s=dollar0
echo 'echo $@' > $s
chmod +x $s
$SH $s a b c

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Lower Case with , and ,,
================================================================================

x='ABC DEF'
echo ${x,}
echo ${x,,}
echo empty=${empty,}
echo empty=${empty,,}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Upper Case with ^ and ^^
================================================================================

x='abc def'
echo ${x^}
echo ${x^^}
echo empty=${empty^}
echo empty=${empty^^}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Case folding - Unicode characters
================================================================================


# https://www.utf8-chartable.de/unicode-utf8-table.pl

x=$'\u00C0\u00C8'  # upper grave
y=$'\u00E1\u00E9'  # lower acute

echo u ${x^}
echo U ${x^^}

echo l ${x,}
echo L ${x,,}

echo u ${y^}
echo U ${y^^}

echo l ${y,}
echo L ${y,,}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Case folding - multi code point
================================================================================


echo shell
small=$'\u00DF'
echo u ${small^}
echo U ${small^^}

echo l ${small,}
echo L ${small,,}
echo

echo python2
python2 -c '
small = u"\u00DF"
print(small.upper().encode("utf-8"))
print(small.lower().encode("utf-8"))
'
echo

# Not in the container images, but python 3 DOES support it!
# This is moved to demo/survey-case-fold.sh

if false; then
echo python3
python3 -c '
import sys
small = u"\u00DF"
sys.stdout.buffer.write(small.upper().encode("utf-8") + b"\n")
sys.stdout.buffer.write(small.lower().encode("utf-8") + b"\n")
'
fi

if false; then
  # Yes, supported
  echo node.js

  nodejs -e '
  var small = "\u00DF"
  console.log(small.toUpperCase())
  console.log(small.toLowerCase())
  '
fi

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Case folding that depends on locale (not enabled, requires Turkish locale)
================================================================================


# Hm this works in demo/survey-case-fold.sh
# Is this a bash 4.4 thing?

#export LANG='tr_TR.UTF-8'
#echo $LANG

x='i'

echo u ${x^}
echo U ${x^^}

echo l ${x,}
echo L ${x,,}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Lower Case with constant string (VERY WEIRD)
================================================================================

x='AAA ABC DEF'
echo ${x,A}
echo ${x,,A}  # replaces every A only?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Lower Case glob
================================================================================


# Hm with C.UTF-8, this does no case folding?
export LC_ALL=en_US.UTF-8

x='ABC DEF'
echo ${x,[d-f]}
echo ${x,,[d-f]}  # bash 4.4 fixed in bash 5.2.21

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${x@u} U L - upper / lower case (bash 5.1 feature)
================================================================================


# https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html

x='abc DEF'

echo "${x@u}"

echo "${x@U}"

echo "${x@L}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${x@Q}
================================================================================

x="FOO'BAR spam\"eggs"
eval "new=${x@Q}"
test "$x" = "$new" && echo OK

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${array@Q} and ${array[@]@Q}
================================================================================

array=(x 'y\nz')
echo ${array[@]@Q}
echo ${array@Q}
echo ${array@Q}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${!prefix@} ${!prefix*} yields sorted array of var names
================================================================================

ZOO=zoo
ZIP=zip
ZOOM='one two'
Z='three four'

z=lower

argv.py ${!Z*}
argv.py ${!Z@}
argv.py "${!Z*}"
argv.py "${!Z@}"
for i in 1 2; do argv.py ${!Z*}  ; done
for i in 1 2; do argv.py ${!Z@}  ; done
for i in 1 2; do argv.py "${!Z*}"; done
for i in 1 2; do argv.py "${!Z@}"; done

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${!prefix@} matches var name (regression)
================================================================================

hello1=1 hello2=2 hello3=3
echo ${!hello@}
hello=()
echo ${!hello@}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${var@a} for attributes
================================================================================

array=(one two)
echo ${array@a}
declare -r array=(one two)
echo ${array@a}
declare -rx PYTHONPATH=hi
echo ${PYTHONPATH@a}

# bash and osh differ here
#declare -rxn x=z
#echo ${x@a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${var@a} error conditions
================================================================================

echo [${?@a}]

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: undef and @P @Q @a
================================================================================

$SH -c 'echo ${undef@P}'
echo status=$?
$SH -c 'echo ${undef@Q}'
echo status=$?
$SH -c 'echo ${undef@a}'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: argv array and @P @Q @a
================================================================================

$SH -c 'echo ${@@P}' dummy a b c
echo status=$?
$SH -c 'echo ${@@Q}' dummy a 'b\nc'
echo status=$?
$SH -c 'echo ${@@a}' dummy a b c
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: assoc array and @P @Q @a
================================================================================


# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${A@P} - ${A[@]@P}'
echo status=$?

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${A@Q} - ${A[@]@Q}' | sed 's/^- y$/- '\''y'\''/'
echo status=$?

$SH -c 'declare -A A=(["x"]=y); echo ${A@a} - ${A[@]@a}'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${!var[@]@X}
================================================================================

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${!A[@]@P}'
if test $? -ne 0; then echo fail; fi

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x y"]="y"); echo ${!A[@]@Q}'
if test $? -ne 0; then echo fail; fi

$SH -c 'declare -A A=(["x"]=y); echo ${!A[@]@a}'
if test $? -ne 0; then echo fail; fi
# STDOUT:



# END

#### ${#var@X} is a parse error
# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${#A[@]@P}'
if test $? -ne 0; then echo fail; fi

# note: "y z" causes a bug!
$SH -c 'declare -A A=(["x"]="y"); echo ${#A[@]@Q}'
if test $? -ne 0; then echo fail; fi

$SH -c 'declare -A A=(["x"]=y); echo ${#A[@]@a}'
if test $? -ne 0; then echo fail; fi

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${!A@a} and ${!A[@]@a}
================================================================================

declare -A A=(["x"]=y)
echo x=${!A[@]@a}
echo invalid=${!A@a}

# OSH prints 'a' for indexed array because the AssocArray with ! turns into
# it.  Disallowing it would be the other reasonable behavior.

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: undef vs. empty string in var ops
================================================================================


empty=''
x=x

echo ${x@Q} ${empty@Q} ${undef@Q} ${x@Q}

echo ${x@K} ${empty@K} ${undef@K} ${x@K}

echo ${x@k} ${empty@k} ${undef@k} ${x@k}

echo ${x@A} ${empty@A} ${undef@A} ${x@A}

declare -r x
echo ${x@a} ${empty@a} ${undef@a} ${x@a}

# x x
#echo ${x@E} ${empty@E} ${undef@E} ${x@E}
# x x
#echo ${x@P} ${empty@P} ${undef@P} ${x@P}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: -o nounset with var ops
================================================================================


set -u
(echo ${undef@Q}); echo "stat: $?"
(echo ${undef@P}); echo "stat: $?"
(echo ${undef@a}); echo "stat: $?"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${a[0]@a} and ${a@a}
================================================================================


a=(1 2 3)
echo "attr = '${a[0]@a}'"
echo "attr = '${a@a}'"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: ${!r@a} with r='a[0]' (attribute for indirect expansion of an array element)
================================================================================


a=(1 2 3)
r='a'
echo ${!r@a}
r='a[0]'
echo ${!r@a}

declare -A d=([0]=foo [1]=bar)
r='d'
echo ${!r@a}
r='d[0]'
echo ${!r@a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Array expansion with nullary var op @Q
================================================================================

declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@Q}"
argv.py "${a[*]@Q}"
argv.py "${A[@]@Q}"
argv.py "${A[*]@Q}"
argv.py "${u[@]@Q}"
argv.py "${u[*]@Q}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Array expansion with nullary var op @P
================================================================================

declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@P}"
argv.py "${a[*]@P}"
argv.py "${A[@]@P}"
argv.py "${A[*]@P}"
argv.py "${u[@]@P}"
argv.py "${u[*]@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-bash.test.sh: Array expansion with nullary var op @a
================================================================================

declare -a a=({1..9})
declare -A A=(['a']=hello ['b']=world ['c']=osh ['d']=ysh)

argv.py "${a[@]@a}"
argv.py "${a[*]@a}"
argv.py "${A[@]@a}"
argv.py "${A[*]@a}"
argv.py "${u[@]@a}"
argv.py "${u[*]@a}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: String length
================================================================================

v=foo
echo ${#v}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: Unicode string length (UTF-8)
================================================================================

v=$'_\u03bc_'
echo ${#v}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: Unicode string length (spec/testdata/utf8-chars.txt)
================================================================================

v=$(cat $REPO_ROOT/spec/testdata/utf8-chars.txt)
echo ${#v}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: String length with incomplete utf-8
================================================================================

for num_bytes in 0 1 2 3 4 5 6 7 8 9 10 11 12 13; do
  s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)
  echo ${#s}
done 2> $TMP/err.txt

grep 'warning:' $TMP/err.txt
true  # exit 0

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: String length with invalid utf-8 continuation bytes
================================================================================

for num_bytes in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14; do
  s=$(head -c $num_bytes $REPO_ROOT/spec/testdata/utf8-chars.txt)$(echo -e "\xFF")
  echo ${#s}
done 2> $TMP/err.txt

grep 'warning:' $TMP/err.txt
true

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: Length of undefined variable
================================================================================

echo ${#undef}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: Length of undefined variable with nounset
================================================================================

set -o nounset
echo ${#undef}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: Length operator can't be followed by test operator
================================================================================

echo ${#x-default}

x=''
echo ${#x-default}

x='foo'
echo ${#x-default}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-len.test.sh: ${#s} respects LC_ALL - length in bytes or code points
================================================================================

case $SH in dash) exit ;; esac

# This test case is sorta "infected" because spec-common.sh sets LC_ALL=C.UTF-8
#
# For some reason mksh behaves differently
#
# See demo/04-unicode.sh

#echo $LC_ALL
unset LC_ALL 

# note: this may depend on the CI machine config
LANG=en_US.UTF-8

#LC_ALL=en_US.UTF-8

for s in $'\u03bc' $'\U00010000'; do
  LC_ALL=
  echo "len=${#s}"

  LC_ALL=C
  echo "len=${#s}"

  echo
done

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Pattern replacement
================================================================================

v=abcde
echo ${v/c*/XX}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Pattern replacement on unset variable
================================================================================

echo -${v/x/y}-
echo status=$?
set -o nounset  # make sure this fails
echo -${v/x/y}-

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Global Pattern replacement with /
================================================================================

s=xx_xx_xx
echo ${s/xx?/yy_} ${s//xx?/yy_}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Left Anchored Pattern replacement with #
================================================================================

s=xx_xx_xx
echo ${s/?xx/_yy} ${s/#?xx/_yy}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Right Anchored Pattern replacement with %
================================================================================

s=xx_xx_xx
echo ${s/?xx/_yy} ${s/%?xx/_yy}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace fixed strings
================================================================================

s=xx_xx
echo ${s/xx/yy} ${s//xx/yy} ${s/#xx/yy} ${s/%xx/yy}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace is longest match
================================================================================

# If it were shortest, then you would just replace the first <html>
s='begin <html></html> end'
echo ${s/<*>/[]}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace char class
================================================================================

s=xx_xx_xx
echo ${s//[[:alpha:]]/y} ${s//[^[:alpha:]]/-}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace hard glob
================================================================================

s='aa*bb+cc'
echo ${s//\**+/__}  # Literal *, then any sequence of characters, then literal +

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: ${v/} is empty search and replacement
================================================================================

v=abcde
echo -${v/}-
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: ${v//} is empty search and replacement
================================================================================

v='a/b/c'
echo -${v//}-
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Confusing unquoted slash matches bash (and ash)
================================================================================

x='/_/'
echo ${x////c}

echo ${x//'/'/c}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Synthesized ${x///} bug (similar to above)
================================================================================


# found via test/parse-errors.sh

x='slash / brace } hi'
echo 'ambiguous:' ${x///}

echo 'quoted:   ' ${x//'/'}

# Wow we have all combination here -- TERRIBLE

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: ${v/a} is the same as ${v/a/}  -- no replacement string
================================================================================

v='aabb'
echo ${v/a}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replacement with special chars (bug fix)
================================================================================

v=xx
echo ${v/x/"?"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace backslash
================================================================================

v='[\f]'
x='\f'
echo ${v/"$x"/_}

# mksh and zsh differ on this case, but this is consistent with the fact that
# \f as a glob means 'f', not '\f'.  TODO: Warn that it's a bad glob?
# The canonical form is 'f'.
echo ${v/$x/_}

echo ${v/\f/_}
echo ${v/\\f/_}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Replace right ]
================================================================================

v='--]--'
x=']'
echo ${v/"$x"/_}
echo ${v/$x/_}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Substitute glob characters in pattern, quoted and unquoted
================================================================================


# INFINITE LOOP in ash!
case $SH in ash) exit ;; esac

g='*'
v='a*b'
echo ${v//"$g"/-}
echo ${v//$g/-}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Substitute one unicode character (UTF-8)
================================================================================

export LANG='en_US.UTF-8'

s='_μ_ and _μ_'

# ? should match one char

echo ${s//_?_/foo}  # all
echo ${s/#_?_/foo}  # left
echo ${s/%_?_/foo}  # right

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: When LC_ALL=C, pattern ? doesn't match multibyte character
================================================================================

export LC_ALL='C'

s='_μ_ and _μ_'

# ? should match one char

echo ${s//_?_/foo}  # all
echo ${s/#_?_/foo}  # left
echo ${s/%_?_/foo}  # right
echo

a='_x_ and _y_'

echo ${a//_?_/foo}  # all
echo ${a/#_?_/foo}  # left
echo ${a/%_?_/foo}  # right

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: ${x/^} regression
================================================================================

x=abc
echo ${x/^}
echo ${x/!}

y=^^^
echo ${y/^}
echo ${y/!}

z=!!!
echo ${z/^}
echo ${z/!}

s=a^b!c
echo ${s/a^}
echo ${s/b!}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: \(\) in pattern (regression)
================================================================================


# Not extended globs
x='foo()' 
echo 1 ${x//*\(\)/z}
echo 2 ${x//*\(\)/z}
echo 3 ${x//\(\)/z}
echo 4 ${x//*\(\)/z}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: patsub with single quotes and hyphen in character class (regression)
================================================================================


# from Crestwave's bf.bash

program='^++--hello.,world<>[]'
program=${program//[^'><+-.,[]']} 
echo $program

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: patsub with [^]]
================================================================================


# This is a PARSING divergence.  In OSH we match [], rather than using POSIX
# rules!

pat='[^]]'
s='ab^cd^'
echo ${s//$pat/z}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: [a-z] Invalid range end is syntax error
================================================================================

x=fooz
pat='[z-a]'  # Invalid range.  Other shells don't catch it!
#pat='[a-y]'
echo ${x//$pat}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Pattern is empty $foo$bar -- regression for infinite loop
================================================================================


x=-foo-

echo ${x//$foo$bar/bar}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: Chromium from http://www.oilshell.org/blog/2016/11/07.html
================================================================================


case $SH in zsh) exit ;; esac

HOST_PATH=/foo/bar/baz
echo ${HOST_PATH////\\/}

# The way bash parses it
echo ${HOST_PATH//'/'/\\/}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-patsub.test.sh: ${x//~homedir/}
================================================================================


path=~/git/oilshell

# ~ expansion occurs
#echo path=$path

echo ${path//~/z}

echo ${path/~/z}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: String slice
================================================================================

foo=abcdefg
echo ${foo:1:3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Cannot take length of substring slice
================================================================================

# These are runtime errors, but we could make them parse time errors.
v=abcde
echo ${#v:1:3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Out of range string slice: begin
================================================================================

# out of range begin doesn't raise error in bash, but in mksh it skips the
# whole thing!
foo=abcdefg
echo _${foo:100:3}
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Out of range string slice: length
================================================================================

# OK in both bash and mksh
foo=abcdefg
echo _${foo:3:100}
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Negative start index
================================================================================

foo=abcdefg
echo ${foo: -4:3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Negative start index respects unicode
================================================================================

foo=abcd-μ-
echo ${foo: -4:3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Negative second arg is position, not length!
================================================================================

foo=abcdefg
echo ${foo:3:-1} ${foo: 3: -2} ${foo:3 :-3 }

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Negative start index respects unicode
================================================================================

foo=abcd-μ-
echo ${foo: -5: -3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: String slice with math
================================================================================

# I think this is the $(()) language inside?
i=1
foo=abcdefg
echo ${foo: i+4-2 : i + 2}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice undefined
================================================================================

echo -${undef:1:2}-
set -o nounset
echo -${undef:1:2}-
echo -done-

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice UTF-8 String
================================================================================

# mksh slices by bytes.
foo='--μ--'
echo ${foo:1:3}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice string with invalid UTF-8 results in empty string and warning
================================================================================

s=$(echo -e "\xFF")bcdef
echo -${s:1:3}-

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice string with invalid UTF-8 with strict_word_eval
================================================================================

shopt -s strict_word_eval || true
echo slice
s=$(echo -e "\xFF")bcdef
echo -${s:1:3}-

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice with an index that's an array -- silent a[0] decay
================================================================================

i=(3 4 5)
mystr=abcdefg
echo assigned
echo ${mystr:$i:2}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Slice with an assoc array
================================================================================

declare -A A=(['5']=3 ['6']=4)
mystr=abcdefg
echo assigned
echo ${mystr:$A:2}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Simple ${@:offset}
================================================================================


set -- 4 5 6

result=$(argv.py ${@:0})
echo ${result//"$0"/'SHELL'}

argv.py ${@:1}
argv.py ${@:2}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: ${@:offset} and ${*:offset}
================================================================================

case $SH in zsh) return ;; esac  # zsh is very different

argv.shell-name-checked () {
  argv.py "${@//$0/SHELL}"
}
fun() {
  argv.shell-name-checked -${*:0}- # include $0
  argv.shell-name-checked -${*:1}- # from $1
  argv.shell-name-checked -${*:3}- # last parameter $3
  argv.shell-name-checked -${*:4}- # empty
  argv.shell-name-checked -${*:5}- # out of boundary
  argv.shell-name-checked -${@:0}-
  argv.shell-name-checked -${@:1}-
  argv.shell-name-checked -${@:3}-
  argv.shell-name-checked -${@:4}-
  argv.shell-name-checked -${@:5}-
  argv.shell-name-checked "-${*:0}-"
  argv.shell-name-checked "-${*:1}-"
  argv.shell-name-checked "-${*:3}-"
  argv.shell-name-checked "-${*:4}-"
  argv.shell-name-checked "-${*:5}-"
  argv.shell-name-checked "-${@:0}-"
  argv.shell-name-checked "-${@:1}-"
  argv.shell-name-checked "-${@:3}-"
  argv.shell-name-checked "-${@:4}-"
  argv.shell-name-checked "-${@:5}-"
}
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: ${@:offset:length} and ${*:offset:length}
================================================================================

case $SH in zsh) return ;; esac  # zsh is very different

argv.shell-name-checked () {
  argv.py "${@//$0/SHELL}"
}
fun() {
  argv.shell-name-checked -${*:0:2}- # include $0
  argv.shell-name-checked -${*:1:2}- # from $1
  argv.shell-name-checked -${*:3:2}- # last parameter $3
  argv.shell-name-checked -${*:4:2}- # empty
  argv.shell-name-checked -${*:5:2}- # out of boundary
  argv.shell-name-checked -${@:0:2}-
  argv.shell-name-checked -${@:1:2}-
  argv.shell-name-checked -${@:3:2}-
  argv.shell-name-checked -${@:4:2}-
  argv.shell-name-checked -${@:5:2}-
  argv.shell-name-checked "-${*:0:2}-"
  argv.shell-name-checked "-${*:1:2}-"
  argv.shell-name-checked "-${*:3:2}-"
  argv.shell-name-checked "-${*:4:2}-"
  argv.shell-name-checked "-${*:5:2}-"
  argv.shell-name-checked "-${@:0:2}-"
  argv.shell-name-checked "-${@:1:2}-"
  argv.shell-name-checked "-${@:3:2}-"
  argv.shell-name-checked "-${@:4:2}-"
  argv.shell-name-checked "-${@:5:2}-"
}
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: ${@:0:1}
================================================================================

set a b c
result=$(echo ${@:0:1})
echo ${result//"$0"/'SHELL'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: Permutations of implicit begin and length
================================================================================

array=(1 2 3)

argv.py ${array[@]}

# *** implicit length of N **
argv.py ${array[@]:0}

# Why is this one not allowed
#argv.py ${array[@]:}

# ** implicit length of ZERO **
#argv.py ${array[@]::}
#argv.py ${array[@]:0:}

argv.py ${array[@]:0:0}
echo

# Same agreed upon permutations
set -- 1 2 3
argv.py ${@}
argv.py ${@:1}
argv.py ${@:1:0}
echo

s='123'
argv.py "${s}"
argv.py "${s:0}"
argv.py "${s:0:0}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: ${array[@]:} vs ${array[@]: }  - bash and zsh inconsistent
================================================================================


$SH -c 'array=(1 2 3); argv.py ${array[@]:}'
$SH -c 'array=(1 2 3); argv.py space ${array[@]: }'

$SH -c 's=123; argv.py ${s:}'
$SH -c 's=123; argv.py space ${s: }'

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-slice.test.sh: ${array[@]::} has implicit length of zero - for ble.sh
================================================================================


# https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/.24.7Barr.5B.40.5D.3A.3A.7D.20in.20bash.20-.20is.20it.20documented.3F

array=(1 2 3)
argv.py ${array[@]::}
argv.py ${array[@]:0:}

echo

set -- 1 2 3
argv.py ${@::}
argv.py ${@:0:}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove const suffix
================================================================================

v=abcd
echo ${v%d} ${v%%cd}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove const prefix
================================================================================

v=abcd
echo ${v#a} ${v##ab}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove const suffix is vectorized on user array
================================================================================

a=(1a 2a 3a)
argv.py ${a[@]%a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove const suffix is vectorized on $@ array
================================================================================

set -- 1a 2a 3a
argv.py ${@%a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove const suffix from undefined
================================================================================

echo ${undef%suffix}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove shortest glob suffix
================================================================================

v=aabbccdd
echo ${v%c*}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove longest glob suffix
================================================================================

v=aabbccdd
echo ${v%%c*}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove shortest glob prefix
================================================================================

v=aabbccdd
echo ${v#*b}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Remove longest glob prefix
================================================================================

v=aabbccdd
echo ${v##*b}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Strip char class
================================================================================

v=abc
echo ${v%[[:alpha:]]}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Strip unicode prefix
================================================================================


show_hex() { od -A n -t c -t x1; }

# NOTE: LANG is set to utf-8.
# ? is a glob that stands for one character

v='μ-'
echo ${v#?} | show_hex
echo
echo ${v##?} | show_hex
echo

v='-μ'
echo ${v%?} | show_hex
echo
echo ${v%%?} | show_hex

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Bug fix: Test that you can remove everything with glob
================================================================================

s='--x--'
argv.py "${s%%-*}" "${s%-*}" "${s#*-}" "${s##*-}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Test that you can remove everything with const
================================================================================

s='abcd'
argv.py "${s%%abcd}" "${s%abcd}" "${s#abcd}" "${s##abcd}"
# failure case:
argv.py "${s%%abcde}" "${s%abcde}" "${s#abcde}" "${s##abcde}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Prepend using replacement of #
================================================================================

# This case was found in Kubernetes and others
array=(aa bb '')
argv.py ${array[@]/#/prefix-}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Append using replacement of %
================================================================================

array=(aa bb '')
argv.py ${array[@]/%/-suffix}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip unquoted and quoted [
================================================================================

# I guess dash and mksh treat unquoted [ as an invalid glob?
var='[foo]'
echo ${var#[}
echo ${var#"["}
echo "${var#[}"
echo "${var#"["}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip unquoted and quoted []
================================================================================

# LooksLikeGlob('[]') is true
# I guess dash, mksh, and zsh treat unquoted [ as an invalid glob?
var='[]foo[]'
echo ${var#[]}
echo ${var#"[]"}
echo "${var#[]}"
echo "${var#"[]"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip unquoted and quoted ?
================================================================================

var='[foo]'
echo ${var#?}
echo ${var#"?"}
echo "${var#?}"
echo "${var#"?"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip unquoted and quoted [a]
================================================================================

var='[a]foo[]'
echo ${var#[a]}
echo ${var#"[a]"}
echo "${var#[a]}"
echo "${var#"[a]"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Nested % and # operators (bug reported by Crestwave)
================================================================================

var=$'\n'
argv.py "${var#?}"
argv.py "${var%''}"
argv.py "${var%"${var#?}"}"
var='a'
argv.py "${var#?}"
argv.py "${var%''}"
argv.py "${var%"${var#?}"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip * (bug regression)
================================================================================

x=abc
argv.py "${x#*}"
argv.py "${x##*}"
argv.py "${x%*}"
argv.py "${x%%*}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip ?
================================================================================

x=abc
argv.py "${x#?}"
argv.py "${x##?}"
argv.py "${x%?}"
argv.py "${x%%?}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip all
================================================================================

x=abc
argv.py "${x#abc}"
argv.py "${x##abc}"
argv.py "${x%abc}"
argv.py "${x%%abc}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip none
================================================================================

x=abc
argv.py "${x#}"
argv.py "${x##}"
argv.py "${x%}"
argv.py "${x%%}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip all unicode
================================================================================

x=μabcμ
echo "${x#?abc?}"
echo "${x##?abc?}"
echo "${x%?abc?}"
echo "${x%%?abc?}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: strip none unicode
================================================================================

x=μabcμ
argv.py "${x#}"
argv.py "${x##}"
argv.py "${x%}"
argv.py "${x%%}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: Strip Right Brace (#702)
================================================================================

var='$foo'
echo 1 "${var#$foo}"
echo 2 "${var#\$foo}"

var='}'
echo 10 "${var#}}"
echo 11 "${var#\}}"
echo 12 "${var#'}'}"
echo 13 "${var#"}"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: \(\) in pattern (regression)
================================================================================

x='foo()' 
echo 1 ${x%*\(\)}
echo 2 ${x%%*\(\)}
echo 3 ${x#*\(\)}
echo 4 ${x##*\(\)}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-strip.test.sh: extglob in pattern
================================================================================

case $SH in dash|zsh|ash) exit ;; esac

shopt -s extglob

x='foo()' 
echo 1 ${x%*(foo|bar)'()'}
echo 2 ${x%%*(foo|bar)'()'}
echo 3 ${x#*(foo|bar)'()'}
echo 4 ${x##*(foo|bar)'()'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Lazy Evaluation of Alternative
================================================================================

i=0
x=x
echo ${x:-$((i++))}
echo $i
echo ${undefined:-$((i++))}
echo $i  # i is one because the alternative was only evaluated once

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Default value when empty
================================================================================

empty=''
echo ${empty:-is empty}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Default value when unset
================================================================================

echo ${unset-is unset}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Unquoted with array as default value
================================================================================

set -- '1 2' '3 4'
argv.py X${unset=x"$@"x}X
argv.py X${unset=x$@x}X  # If you want OSH to split, write this
# osh

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Quoted with array as default value
================================================================================

set -- '1 2' '3 4'
argv.py "X${unset=x"$@"x}X"
argv.py "X${unset=x$@x}X"  # OSH is the same here

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Assign default with array
================================================================================

set -- '1 2' '3 4'
argv.py X${unset=x"$@"x}X
argv.py "$unset"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Assign default value when empty
================================================================================

empty=''
${empty:=is empty}
echo $empty

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Assign default value when unset
================================================================================

${unset=is unset}
echo $unset

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: ${v:+foo} Alternative value when empty
================================================================================

v=foo
empty=''
echo ${v:+v is not empty} ${empty:+is not empty}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: ${v+foo} Alternative value when unset
================================================================================

v=foo
echo ${v+v is not unset} ${unset:+is not unset}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "${x+foo}" quoted (regression)
================================================================================

# Python's configure caught this
argv.py "${with_icc+set}" = set

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: ${s+foo} and ${s:+foo} when set -u
================================================================================

set -u
v=v
echo v=${v:+foo}
echo v=${v+foo}
unset v
echo v=${v:+foo}
echo v=${v+foo}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "${array[@]} with set -u (bash is outlier)
================================================================================

case $SH in dash) exit ;; esac

set -u

typeset -a empty
empty=()

echo empty /"${empty[@]}"/
echo undefined /"${undefined[@]}"/

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "${undefined[@]+foo}" and "${undefined[@]:+foo}", with set -u
================================================================================

case $SH in dash) exit ;; esac

set -u

echo plus /"${array[@]+foo}"/
echo plus colon /"${array[@]:+foo}"/

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "${a[@]+foo}" and "${a[@]:+foo}" - operators are equivalent on arrays?
================================================================================


case $SH in dash) exit ;; esac

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

typeset -a array
array=()

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

array=('')

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

array=(spam eggs)

echo '+ ' /"${array[@]+foo}"/
echo '+:' /"${array[@]:+foo}"/
echo

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Nix idiom ${!hooksSlice+"${!hooksSlice}"} - was workaround for obsolete bash 4.3 bug
================================================================================


case $SH in dash|mksh|zsh) exit ;; esac

# https://oilshell.zulipchat.com/#narrow/stream/307442-nix/topic/Replacing.20bash.20with.20osh.20in.20Nixpkgs.20stdenv

(argv.py ${!hooksSlice+"${!hooksSlice}"})

hooksSlice=x

argv.py ${!hooksSlice+"${!hooksSlice}"}

declare -a hookSlice=()

argv.py ${!hooksSlice+"${!hooksSlice}"}

foo=42
bar=43

declare -a hooksSlice=(foo bar spam eggs)

argv.py ${!hooksSlice+"${!hooksSlice}"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: ${v-foo} and ${v:-foo} when set -u
================================================================================

set -u
v=v
echo v=${v:-foo}
echo v=${v-foo}
unset v
echo v=${v:-foo}
echo v=${v-foo}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: array and - and +
================================================================================

case $SH in dash) exit ;; esac

shopt -s compat_array  # to refer to array as scalar

empty=()
a1=('')
a2=('' x)
a3=(3 4)
echo empty=${empty[@]-minus}
echo a1=${a1[@]-minus}
echo a1[0]=${a1[0]-minus}
echo a2=${a2[@]-minus}
echo a3=${a3[@]-minus}
echo ---

echo empty=${empty[@]+plus}
echo a1=${a1[@]+plus}
echo a1[0]=${a1[0]+plus}
echo a2=${a2[@]+plus}
echo a3=${a3[@]+plus}
echo ---

echo empty=${empty+plus}
echo a1=${a1+plus}
echo a2=${a2+plus}
echo a3=${a3+plus}
echo ---

# Test quoted arrays too
argv.py "${empty[@]-minus}"
argv.py "${empty[@]+plus}"
argv.py "${a1[@]-minus}"
argv.py "${a1[@]+plus}"
argv.py "${a1[0]-minus}"
argv.py "${a1[0]+plus}"
argv.py "${a2[@]-minus}"
argv.py "${a2[@]+plus}"
argv.py "${a3[@]-minus}"
argv.py "${a3[@]+plus}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: $@ (empty) and - and +
================================================================================

echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: $@ ("") and - and +
================================================================================

set -- ""
echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: $@ ("" "") and - and +
================================================================================

set -- "" ""
echo argv=${@-minus}
echo argv=${@+plus}
echo argv=${@:-minus}
echo argv=${@:+plus}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: $* ("" "") and - and + (IFS=)
================================================================================

set -- "" ""
IFS=
echo argv=${*-minus}
echo argv=${*+plus}
echo argv=${*:-minus}
echo argv=${*:+plus}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "$*" ("" "") and - and + (IFS=)
================================================================================

set -- "" ""
IFS=
echo "argv=${*-minus}"
echo "argv=${*+plus}"
echo "argv=${*:-minus}"
echo "argv=${*:+plus}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: assoc array and - and +
================================================================================

case $SH in dash|mksh) exit ;; esac

declare -A empty=()
declare -A assoc=(['k']=v)

echo empty=${empty[@]-minus}
echo empty=${empty[@]+plus}
echo assoc=${assoc[@]-minus}
echo assoc=${assoc[@]+plus}

echo ---
echo empty=${empty[@]:-minus}
echo empty=${empty[@]:+plus}
echo assoc=${assoc[@]:-minus}
echo assoc=${assoc[@]:+plus}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Error when empty
================================================================================

empty=''
echo ${empty:?'is em'pty}  # test eval of error
echo should not get here

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Error when unset
================================================================================

echo ${unset?is empty}
echo should not get here

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: Error when unset
================================================================================

v=foo
echo ${v+v is not unset} ${unset:+is not unset}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: ${var=x} dynamic scope
================================================================================

f() { : "${hello:=x}"; echo $hello; }
f
echo hello=$hello

f() { hello=x; }
f
echo hello=$hello

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: array ${arr[0]=x}
================================================================================

arr=()
echo ${#arr[@]}
: ${arr[0]=x}
echo ${#arr[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: assoc array ${arr["k"]=x}
================================================================================

# note: this also works in zsh

declare -A arr=()
echo ${#arr[@]}
: ${arr['k']=x}
echo ${#arr[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "\z" as arg
================================================================================

echo "${undef-\$}"
echo "${undef-\(}"
echo "${undef-\z}"
echo "${undef-\"}"
echo "${undef-\`}"
echo "${undef-\\}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: "\e" as arg
================================================================================

echo "${undef-\e}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: op-test for ${a} and ${a[0]}
================================================================================

case $SH in dash) exit ;; esac

test-hyphen() {
  echo "a   : '${a-no-colon}' '${a:-with-colon}'"
  echo "a[0]: '${a[0]-no-colon}' '${a[0]:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: op-test for ${a[@]} and ${a[*]}
================================================================================

case $SH in dash) exit ;; esac

test-hyphen() {
  echo "a[@]: '${a[@]-no-colon}' '${a[@]:-with-colon}'"
  echo "a[*]: '${a[*]-no-colon}' '${a[*]:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: op-test for ${!array} with array="a" and array="a[0]"
================================================================================

case $SH in dash|mksh|zsh) exit ;; esac

test-hyphen() {
  ref='a'
  echo "ref=a   : '${!ref-no-colon}' '${!ref:-with-colon}'"
  ref='a[0]'
  echo "ref=a[0]: '${!ref-no-colon}' '${!ref:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: op-test for ${!array} with array="a[@]" or array="a[*]"
================================================================================

case $SH in dash|mksh|zsh) exit ;; esac

test-hyphen() {
  ref='a[@]'
  echo "ref=a[@]: '${!ref-no-colon}' '${!ref:-with-colon}'"
  ref='a[*]'
  echo "ref=a[*]: '${!ref-no-colon}' '${!ref:-with-colon}'"
}

a=()
test-hyphen
a=("")
test-hyphen
a=("" "")
test-hyphen
IFS=
test-hyphen

--------------------------------------------------------------------------------

(program)

================================================================================
var-op-test.test.sh: op-test for unquoted ${a[*]:-empty} with IFS=
================================================================================

case $SH in dash) exit ;; esac

IFS=
a=("" "")
argv.py ${a[*]:-empty}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref ${!a}
================================================================================

a=b
b=c
echo ref ${!a} ${a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: ${!ref-default}
================================================================================

ref=x
echo x=${!ref-default}

x=''
echo x=${!ref-default}

x=foo
echo x=${!ref-default}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: ${!undef:-}
================================================================================

# bash 4.4 gives empty string, but I feel like this could be an error
echo undef=${!undef-'default'}
echo undef=${!undef}

set -u
echo NOUNSET
echo undef=${!undef-'default'}
echo undef=${!undef}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: comparison to ${!array[@]} keys (similar SYNTAX)
================================================================================


declare -a a=(x y)
argv.py "${!a[@]}"
echo a_keys=$?

argv.py "${!a}"  # missing [] is equivalent to ${!a[0]} ?
echo a_nobrackets=$?

echo ---
declare -A A=([A]=a [B]=b)

argv.py $(printf '%s\n' ${!A[@]} | sort)
echo A_keys=$?

(argv.py "${!A}")  # missing [] is equivalent to ${!A[0]} ?
echo A_nobrackets=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: ${!a[@]-'default'} is legal but fails with more than one element
================================================================================


# bash allows this construct, but the indirection fails when the array has more
# than one element because the variable name contains a space.  OSH originally
# made it an error unconditionally because [@] implies it's an array, so the
# behavior has been different from Bash when the array has a single element.
# We now changed it to follow Bash even when the array has a single element.

(argv.py "${!a[@]-default}")
echo status=$?

a=(x y z)
(argv.py "${!a[@]-default}")
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref to $@ with @
================================================================================

set -- one two
ref='@'
echo ref=${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref to $1 and $2 with 1 and 2
================================================================================

set -- one two
ref1='1'
echo ref1=${!ref1}
ref2='2'
echo ref2=${!ref2}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref: 1, @, *
================================================================================

set -- x y
ref=1; argv.py "${!ref}"
ref=@; argv.py "${!ref}"
ref=*; argv.py "${!ref}"  # maybe_decay_array bug?

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref to special var BASH_SOURCE
================================================================================

ref='LINENO'
echo lineno=${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref to $? with '?'
================================================================================

myfunc() {
  local ref=$1
  echo ${!ref}
}
myfunc FUNCNAME
myfunc '?'

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Var ref, then assignment with ${ := }
================================================================================

z=zz
zz=
echo ${!z:=foo}
echo ${!z:=bar}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Var ref, then error with ${ ? }
================================================================================

w=ww
ww=
echo ${!w:?'my message'}
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Indirect expansion, THEN suffix operators
================================================================================


check_eq() {
  [ "$1" = "$2" ] || { echo "$1 vs $2"; }
}
check_expand() {
  val=$(eval "echo \"$1\"")
  [ "$val" = "$2" ] || { echo "$1 -> expected $2, got $val"; }
}
check_err() {
  e="$1"
  msg=$(eval "$e" 2>&1) && echo "bad success: $e"
  if test -n "$2"; then 
    if [[ "$msg" != $2 ]]; then
      echo "Expected error: $e"
      echo "Got error     : $msg"
    fi
  fi
}
# Nearly everything in manual section 3.5.3 "Shell Parameter Expansion"
# is allowed after a !-indirection.
#
# Not allowed: any further prefix syntax.
x=xx; xx=aaabcc
xd=x
check_err '${!!xd}'
check_err '${!!x*}'
a=(asdf x)
check_err '${!!a[*]}'
check_err '${!#x}'
check_err '${!#a[@]}'
# And an array reference binds tighter in the syntax, so goes first;
# there's no way to spell "indirection, then array reference".
check_expand '${!a[1]}' xx
b=(aoeu a)
check_expand '${!b[1]}' asdf  # i.e. like !(b[1]), not (!b)[1]
#
# Allowed: apparently everything else.
y=yy; yy=
check_expand '${!y:-foo}' foo
check_expand '${!x:-foo}' aaabcc

check_expand '${!x:?oops}' aaabcc

check_expand '${!y:+foo}' ''
check_expand '${!x:+foo}' foo

check_expand '${!x:2}' abcc
check_expand '${!x:2:2}' ab

check_expand '${!x#*a}' aabcc
check_expand '${!x%%c*}' aaab
check_expand '${!x/a*b/d}' dcc

# ^ operator not fully implemented in OSH
#check_expand '${!x^a}' Aaabcc

p=pp; pp='\$ '
check_expand '${!p@P}' '$ '
echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref OF array var -- silent a[0] decay
================================================================================

declare -a a=(ale bean)
echo first=${!a}

ale=zzz
echo first=${!a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: array ref
================================================================================


declare -a array=(ale bean)
ref='array[0]'
echo ${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: array ref with strict_array
================================================================================

shopt -s strict_array

declare -a array=(ale bean)
ref='array'
echo ${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref TO array var
================================================================================

shopt -s compat_array

declare -a array=(ale bean)

ref='array'  # when compat_array is on, this is like array[0]
ref_AT='array[@]'

echo ${!ref}
echo ${!ref_AT}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref TO array var, with subscripts
================================================================================

f() {
  argv.py "${!1}"
}
f 'nonexistent[0]'
array=(x y z)
f 'array[0]'
f 'array[1+1]'
f 'array[@]'
f 'array[*]'
# Also associative arrays.

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref TO assoc array a[key]
================================================================================

shopt -s compat_array

declare -A assoc=([ale]=bean [corn]=dip)
ref=assoc
#ref_AT='assoc[@]'

# UNQUOTED doesn't work with the OSH parser
#ref_SUB='assoc[ale]'
ref_SUB='assoc["ale"]'

ref_SUB_QUOTED='assoc["al"e]'

ref_SUB_BAD='assoc["bad"]'

echo ref=${!ref}  # compat_array: assoc is equivalent to assoc[0]
#echo ref_AT=${!ref_AT}
echo ref_SUB=${!ref_SUB}
echo ref_SUB_QUOTED=${!ref_SUB_QUOTED}
echo ref_SUB_BAD=${!ref_SUB_BAD}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref TO array with arbitrary subscripts
================================================================================

shopt -s eval_unsafe_arith compat_array

f() {
  local val=$(echo "${!1}")
  if test "$val" = y; then 
    echo "works: $1"
  fi
}
# Warmup: nice plain array reference
a=(x y)
f 'a[1]'
#
# Not allowed:
# no brace expansion
f 'a[{1,0}]'  # operand expected
# no process substitution (but see command substitution below!)
f 'a[<(echo x)]'  # operand expected
# TODO word splitting seems interesting
aa="1 0"
f 'a[$aa]'  # 1 0: syntax error in expression (error token is "0")
# no filename globbing
f 'a[b*]'  # operand expected
f 'a[1"]'  # bad substitution
#
# Allowed: most everything else in section 3.5 "Shell Expansions".
# shell parameter expansion
b=1
f 'a[$b]'
f 'a[${c:-1}]'
# (... and presumably most of the other features there)
# command substitution, yikes!
f 'a[$(echo 1)]'
# arithmetic expansion
f 'a[$(( 3 - 2 ))]'

# All of these are undocumented and probably shouldn't exist,
# though it's always possible some will turn up in the wild and
# we'll end up implementing them.

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Bizarre tilde expansion in array index
================================================================================

a=(x y)
PWD=1
ref='a[~+]'
echo ${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Indirect expansion TO fancy expansion features bash disallows
================================================================================


check_indir() {
    result="${!1}"
    desugared_result=$(eval 'echo "${'"$1"'}"')
    [ "$2" = "$desugared_result" ] || { echo "$1 $desugared_result";  }
}
x=y
y=a
a=(x y)
declare -A aa
aa=([k]=r [l]=s)
# malformed array indexing
check_indir "a[0"
check_indir "aa[k"
# double indirection
check_indir "!x"      a
check_indir "!a[0]"   y
# apparently everything else in the manual under "Shell Parameter Expansion"
check_indir "x:-foo"  y
check_indir "x:=foo"  y
check_indir "x:?oops" y
check_indir "x:+yy"   yy
check_indir "x:0"     y
check_indir "x:0:1"   y
check_indir "!a@"    "a aa"
# (!a[@] is elsewhere)
check_indir "#x"      1
check_indir "x#y"
check_indir "x/y/foo" foo
check_indir "x@Q"     y
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Bad var ref
================================================================================

a='bad var name'
echo ref ${!a}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Bad var ref 2
================================================================================

b='/'  # really bad
echo ref ${!b}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: ${!OPTIND} (used by bash completion
================================================================================

set -- a b c
echo ${!OPTIND}
f() {
  local OPTIND=1
  echo ${!OPTIND}
  local OPTIND=2
  echo ${!OPTIND}
}
f x y z

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: var ref doesn't need cycle detection
================================================================================

x=y
y=x
echo cycle=${!x}

typeset -n a=b
typeset -n b=a
echo cycle=${a}

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Var Ref Code Injection $(tee PWNED)
================================================================================


typeset -a a
a=(42)

x='a[$(echo 0 | tee PWNED)]'

echo ${!x}

if test -f PWNED; then
  echo PWNED
  cat PWNED
else
  echo NOPE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: ${!array_ref:-set} and ${!array_ref:=assign}
================================================================================


ref='a[@]'
a=('' '' '')

echo "==== check ===="

argv.py "${!ref:-set}"
argv.py "${a[@]:-set}"

echo "==== assign ===="

argv.py "${!ref:=assign}"
argv.py "${!ref}"
a=('' '' '') # revert the state in case it is modified

argv.py "${a[@]:=assign}"
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Array indirect expansion with suffix operators
================================================================================


declare -A ref=(['dummy']=v1)
function test-suffixes {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]:2}"
  argv.py "${!ref[@]:1:2}"
  argv.py "${!ref[@]:-empty}"
  argv.py "${!ref[@]:+set}"
  argv.py "${!ref[@]:=assign}"
}

v1=value
test-suffixes v1
echo "v1=$v1"

v2=
test-suffixes v2
echo "v2=$v2"

a1=()
test-suffixes a1
argv.py "${a1[@]}"

a2=(element)
test-suffixes 'a2[0]'
argv.py "${a2[@]}"

a3=(1 2 3)
test-suffixes 'a3[@]'
argv.py "${a3[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Array indirect expansion with replacements
================================================================================


declare -A ref=(['dummy']=v1)
function test-rep {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]#?}"
  argv.py "${!ref[@]%?}"
  argv.py "${!ref[@]//[a-f]}"
  argv.py "${!ref[@]//[a-f]/x}"
}

v1=value
test-rep v1

v2=
test-rep v2

a1=()
test-rep a1

a2=(element)
test-rep 'a2[0]'

a3=(1 2 3)
test-rep 'a3[@]'

--------------------------------------------------------------------------------

(program)

================================================================================
var-ref.test.sh: Array indirect expansion with @? conversion
================================================================================


declare -A ref=(['dummy']=v1)
function test-op0 {
  echo "==== $1 ===="
  ref['dummy']=$1
  argv.py "${!ref[@]@Q}"
  argv.py "${!ref[@]@P}"
  argv.py "${!ref[@]@a}"
}

v1=value
test-op0 v1

v2=
test-op0 v2

a1=()
test-op0 a1

a2=(element)
test-op0 'a2[0]'

a3=(1 2 3)
test-op0 'a3[@]'

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: "${empty:-}"
================================================================================

empty=
argv.py "${empty:-}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: ${empty:-}
================================================================================

empty=
argv.py ${empty:-}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: array with empty values
================================================================================

declare -a A=('' x "" '')
argv.py "${A[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: substitution of IFS character, quoted and unquoted
================================================================================

IFS=:
s=:
argv.py $s
argv.py "$s"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: :-
================================================================================

empty=''
argv.py ${empty:-a} ${Unset:-b}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: -
================================================================================

empty=''
argv.py ${empty-a} ${Unset-b}
# empty one is still elided!

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Inner single quotes
================================================================================

argv.py ${Unset:-'b'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Inner single quotes, outer double quotes
================================================================================

# This is the WEIRD ONE.  Single quotes appear outside.  But all shells agree!
argv.py "${Unset:-'b'}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Inner double quotes
================================================================================

argv.py ${Unset:-"b"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Inner double quotes, outer double quotes
================================================================================

argv.py "${Unset-"b"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: no quotes
================================================================================

argv.py ${Unset:-a b c}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: no outer quotes, inner single quotes
================================================================================

argv.py ${Unset:-'a b c'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: no outer quotes, inner double quotes
================================================================================

argv.py ${Unset:-"a b c"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, no inner quotes
================================================================================

argv.py "${Unset:-a b c}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, inner double quotes
================================================================================

argv.py "${Unset:-"a b c"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, inner single quotes
================================================================================

argv.py "${Unset:-'a b c'}"
# WEIRD ONE.

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Mixed inner quotes
================================================================================

argv.py ${Unset:-"a b" c}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Mixed inner quotes with outer quotes
================================================================================

argv.py "${Unset:-"a b" c}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: part_value tree with multiple words
================================================================================

argv.py ${a:-${a:-"1 2" "3 4"}5 "6 7"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: part_value tree on RHS
================================================================================

v=${a:-${a:-"1 2" "3 4"}5 "6 7"}
argv.py "${v}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Var with multiple words: no quotes
================================================================================

var='a b c'
argv.py ${Unset:-$var}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: no outer quotes, inner single quotes
================================================================================

var='a b c'
argv.py ${Unset:-'$var'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: no outer quotes, inner double quotes
================================================================================

var='a b c'
argv.py ${Unset:-"$var"}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, no inner quotes
================================================================================

var='a b c'
argv.py "${Unset:-$var}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, inner double quotes
================================================================================

var='a b c'
argv.py "${Unset:-"$var"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Multiple words: outer double quotes, inner single quotes
================================================================================

# WEIRD ONE.
#
# I think I should just disallow any word with single quotes inside double
# quotes.
var='a b c'
argv.py "${Unset:-'$var'}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: No outer quotes, Multiple internal quotes
================================================================================

# It's like a single command word.  Parts are joined directly.
var='a b c'
argv.py ${Unset:-A$var " $var"D E F}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Strip a string with single quotes, unquoted
================================================================================

foo="'a b c d'"
argv.py ${foo%d\'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Strip a string with single quotes, double quoted
================================================================================

foo="'a b c d'"
argv.py "${foo%d\'}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: The string to strip is space sensitive
================================================================================

foo='a b c d'
argv.py "${foo%c d}" "${foo%c  d}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: The string to strip can be single quoted, outer is unquoted
================================================================================

foo='a b c d'
argv.py ${foo%'c d'} ${foo%'c  d'}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: "${undef-'c d'}" and "${foo%'c d'}" are parsed differently
================================================================================


# quotes are LITERAL here
argv.py "${undef-'c d'}" "${undef-'c  d'}"
argv.py ${undef-'c d'} ${undef-'c  d'}

echo ---

# quotes are RESPECTED here
foo='a b c d'
argv.py "${foo%'c d'}" "${foo%'c  d'}"

case $SH in dash) exit ;; esac

argv.py "${foo//'c d'/zzz}" "${foo//'c  d'/zzz}"
argv.py "${foo//'c d'/'zzz'}" "${foo//'c  d'/'zzz'}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: $'' allowed within VarSub arguments
================================================================================

# Odd behavior of bash/mksh: $'' is recognized but NOT ''!
x=abc
echo ${x%$'b'*}
echo "${x%$'b'*}"  # git-prompt.sh relies on this

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: # operator with single quoted arg (dash/ash and bash/mksh disagree, reported by Crestwave)
================================================================================

var=a
echo -${var#'a'}-
echo -"${var#'a'}"-
var="'a'"
echo -${var#'a'}-
echo -"${var#'a'}"-

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: / operator with single quoted arg (causes syntax error in regex in OSH, reported by Crestwave)
================================================================================

var="++--''++--''"
echo no plus or minus "${var//[+-]}"
echo no plus or minus "${var//['+-']}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: single quotes work inside character classes
================================================================================

x='a[[[---]]]b'
echo "${x//['[]']}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: comparison: :- operator with single quoted arg
================================================================================

echo ${unset:-'a'}
echo "${unset:-'a'}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Right Brace as argument (similar to #702)
================================================================================


echo "${var-}}"
echo "${var-\}}"
echo "${var-'}'}"
echo "${var-"}"}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Var substitution with newlines (#2492)
================================================================================

echo "${var-a \
b}"
echo "${var-a
b}"

echo "${var:-c \
d}"
echo "${var:-c
d}"

var=set
echo "${var:+e \
f}"
echo "${var:+e
f}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub-quote.test.sh: Var substitution with \n in value
================================================================================

echo "${var-a\nb}"
echo "${var:-c\nd}"
var=val
echo "${var:+e\nf}"

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub.test.sh: Bad var sub
================================================================================

echo ${a&}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub.test.sh: Braced block inside ${}
================================================================================

# NOTE: This bug was in bash 4.3 but fixed in bash 4.4.
echo ${foo:-$({ ls /bin/ls; })}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub.test.sh: Nested ${}
================================================================================

bar=ZZ
echo ${foo:-${bar}}

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub.test.sh: Filename redirect with "$@"
================================================================================

# bash - ambiguous redirect -- yeah I want this error
#   - But I want it at PARSE time?  So is there a special DollarAtPart?
#     MultipleArgsPart?
# mksh - tries to create '_tmp/var-sub1 _tmp/var-sub2'
# dash - tries to create '_tmp/var-sub1 _tmp/var-sub2'
fun() {
  echo hi > "$@"
}
fun _tmp/var-sub1 _tmp/var-sub2

--------------------------------------------------------------------------------

(program)

================================================================================
var-sub.test.sh: Descriptor redirect to bad "$@"
================================================================================

# All of them give errors:
# dash - bad fd number, parse error?
# bash - ambiguous redirect
# mksh - illegal file descriptor name
set -- '2 3' 'c d'
echo hi 1>& "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Evaluation of constant parts
================================================================================

argv.py bare 'sq'

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Evaluation of each part
================================================================================

#set -o noglob
HOME=/home/bob
str=s
array=(a1 a2)
argv.py bare 'sq' ~ $str "-${str}-" "${array[@]}" $((1+2)) $(echo c) `echo c`

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Word splitting
================================================================================

s1='1 2'
s2='3 4'
s3='5 6'
argv.py $s1$s2 "$s3"

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Word joining
================================================================================

set -- x y z
s1='1 2'
array=(a1 a2)
argv.py $s1"${array[@]}"_"$@"

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Word elision
================================================================================

s1=''
argv.py $s1 - "$s1"

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Default values -- more cases
================================================================================

argv.py ${undef:-hi} ${undef:-'a b'} "${undef:-c d}" "${un:-"e f"}" "${un:-'g h'}"

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Globbing after splitting
================================================================================

mkdir -p _tmp
touch _tmp/foo.gg _tmp/bar.gg _tmp/foo.hh
pat='_tmp/*.hh _tmp/*.gg'
argv.py $pat

--------------------------------------------------------------------------------

(program)

================================================================================
word-eval.test.sh: Globbing escaping
================================================================================

mkdir -p _tmp
touch '_tmp/[bc]ar.mm' # file that looks like a glob pattern
touch _tmp/bar.mm _tmp/car.mm
argv.py '_tmp/[bc]'*.mm - _tmp/?ar.mm

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS is scoped
================================================================================

IFS=b
word=abcd
f() { local IFS=c; argv.py $word; }
f
argv.py $word

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Tilde sub is not split, but var sub is
================================================================================

HOME="foo bar"
argv.py ~
argv.py $HOME

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Word splitting
================================================================================

a="1 2"
b="3 4"
argv.py $a"$b"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Word splitting 2
================================================================================

a="1 2"
b="3 4"
c="5 6"
d="7 8"
argv.py $a"$b"$c"$d"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: $*
================================================================================

fun() { argv.py -$*-; }
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: "$*"
================================================================================

fun() { argv.py "-$*-"; }
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: $@
================================================================================

# How does this differ from $* ?  I don't think it does.
fun() { argv.py -$@-; }
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: "$@"
================================================================================

fun() { argv.py "-$@-"; }
fun "a 1" "b 2" "c 3"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: empty argv
================================================================================

argv.py 1 "$@" 2 $@ 3 "$*" 4 $* 5

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: $* with empty IFS
================================================================================

set -- "1 2" "3  4"

IFS=
argv.py $*
argv.py "$*"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Word elision with space
================================================================================

s1=' '
argv.py $s1

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Word elision with non-whitespace IFS
================================================================================

# Treated differently than the default IFS.  What is the rule here?
IFS='_'
char='_'
space=' '
empty=''
argv.py $char
argv.py $space
argv.py $empty

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Leading/trailing word elision with non-whitespace IFS
================================================================================

# This behavior is weird.
IFS=_
s1='_a_b_'
argv.py $s1

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Leading ' ' vs leading ' _ '
================================================================================

# This behavior is weird, but all shells agree.
IFS='_ '
s1='_ a  b _ '
s2='  a  b _ '
argv.py $s1
argv.py $s2

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Multiple non-whitespace IFS chars.
================================================================================

IFS=_-
s1='a__b---c_d'
argv.py $s1

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS with whitespace and non-whitepace.
================================================================================

# NOTE: Three delimiters means two empty words in the middle.  No elision.
IFS='_ '
s1='a_b _ _ _ c  _d e'
argv.py $s1

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: empty $@ and $* is elided
================================================================================

fun() { argv.py 1 $@ $* 2; }
fun

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: unquoted empty arg is elided
================================================================================

empty=""
argv.py 1 $empty 2

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: unquoted whitespace arg is elided
================================================================================

space=" "
argv.py 1 $space 2

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: empty literals are not elided
================================================================================

space=" "
argv.py 1 $space"" 2

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: no splitting when IFS is empty
================================================================================

IFS=""
foo="a b"
argv.py $foo

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: default value can yield multiple words
================================================================================

argv.py 1 ${undefined:-"2 3" "4 5"} 6

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: default value can yield multiple words with part joining
================================================================================

argv.py 1${undefined:-"2 3" "4 5"}6

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: default value with unquoted IFS char
================================================================================

IFS=_
argv.py 1${undefined:-"2_3"x_x"4_5"}6

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS empty doesn't do splitting
================================================================================

IFS=''
x=$(python2 -c 'print(" a b\tc\n")')
argv.py $x

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS unset behaves like $' \t\n'
================================================================================

unset IFS
x=$(python2 -c 'print(" a b\tc\n")')
argv.py $x

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='\'
================================================================================

# NOTE: OSH fails this because of double backslash escaping issue!
IFS='\'
s='a\b'
argv.py $s

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='\ '
================================================================================

# NOTE: OSH fails this because of double backslash escaping issue!
# When IFS is \, then you're no longer using backslash escaping.
IFS='\ '
s='a\b \\ c d\'
argv.py $s

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS characters are glob metacharacters
================================================================================

IFS='* '
s='a*b c'
argv.py $s

IFS='?'
s='?x?y?z?'
argv.py $s

IFS='['
s='[x[y[z['
argv.py $s

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Trailing space
================================================================================

argv.py 'Xec  ho '
argv.py X'ec  ho '
argv.py X"ec  ho "

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Empty IFS (regression for bug)
================================================================================

IFS=
echo ["$*"]
set a b c
echo ["$*"]

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Unset IFS (regression for bug)
================================================================================

set a b c
unset IFS
echo ["$*"]

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS=o (regression for bug)
================================================================================

IFS=o
echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS and joining arrays
================================================================================

IFS=:
set -- x 'y z'
argv.py "$@"
argv.py $@
argv.py "$*"
argv.py $*

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS and joining arrays by assignments
================================================================================

IFS=:
set -- x 'y z'

s="$@"
argv.py "$s"

s=$@
argv.py "$s"

s="$*"
argv.py "$s"

s=$*
argv.py "$s"

# bash and mksh agree, but this doesn't really make sense to me.
# In OSH, "$@" is the only real array, so that's why it behaves differently.

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: TODO
================================================================================

empty=""
space=" "
AB="A B"
X="X"
Yspaces=" Y "


#### IFS='' with $@ and $* (bug #627)
set -- a 'b c'
IFS=''
argv.py at $@
argv.py star $*

# zsh agrees

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='' with $@ and $* and printf (bug #627)
================================================================================

set -- a 'b c'
IFS=''
printf '[%s]\n' $@
printf '[%s]\n' $*

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='' with ${a[@]} and ${a[*]} (bug #627)
================================================================================

case $SH in dash | ash) exit 0 ;; esac

myarray=(a 'b c')
IFS=''
argv.py at ${myarray[@]}
argv.py star ${myarray[*]}

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='' with ${!prefix@} and ${!prefix*} (bug #627)
================================================================================

case $SH in dash | mksh | ash | yash) exit 0 ;; esac

gLwbmGzS_var1=1
gLwbmGzS_var2=2
IFS=''
argv.py at ${!gLwbmGzS_@}
argv.py star ${!gLwbmGzS_*}

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS='' with ${!a[@]} and ${!a[*]} (bug #627)
================================================================================

case $SH in dash | mksh | ash | yash) exit 0 ;; esac

IFS=''
a=(v1 v2 v3)
argv.py at ${!a[@]}
argv.py star ${!a[*]}

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Bug #628 split on : with : in literal word
================================================================================


# 2025-03: What's the cause of this bug?
#
# OSH is very wrong here
#   ['a', '\\', 'b']
# Is this a fundamental problem with the IFS state machine?
# It definitely relates to the use of backslashes.
# So we have at least 4 backslash bugs

IFS=':'
word='a:'
argv.py ${word}:b
argv.py ${word}:

echo ---

# Same thing happens for 'z'
IFS='z'
word='az'
argv.py ${word}zb
argv.py ${word}z

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Bug #698, similar crash
================================================================================

var='\'
set -f
echo $var

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Bug #1664, \\ with noglob
================================================================================


# Note that we're not changing IFS

argv.py [\\]_
argv.py "[\\]_"

# TODO: no difference observed here, go back to original bug

#argv.py [\\_
#argv.py "[\\_"

echo noglob

# repeat cases with -f, noglob
set -f

argv.py [\\]_
argv.py "[\\]_"

#argv.py [\\_
#argv.py "[\\_"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Empty IFS bug #2141 (from pnut)
================================================================================


res=0
sum() {
  # implement callee-save calling convention using `set`
  # here, we save the value of $res after the function parameters
  set $@ $res           # $1 $2 $3 are now set
  res=$(($1 + $2))
  echo "$1 + $2 = $res"
  res=$3                # restore the value of $res
}

unset IFS
sum 12 30 # outputs "12 + 30 = 42"

IFS=' '
sum 12 30 # outputs "12 + 30 = 42"

IFS=
sum 12 30 # outputs "1230 + 0 = 1230"

# I added this
IFS=''
sum 12 30

set -u
IFS=
sum 12 30 # fails with "fatal: Undefined variable '2'" on res=$(($1 + $2))

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Unicode in IFS
================================================================================


# bash, zsh, and yash support unicode in IFS, but dash/mksh/ash don't.

# for zsh, though we're not testing it here
setopt SH_WORD_SPLIT

x=çx IFS=ç
printf "<%s>\n" $x

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: 4 x 3 table: (default IFS, IFS='', IFS=zx) x ( $* "$*" $@ "$@" )
================================================================================


setopt SH_WORD_SPLIT  # for zsh

set -- 'a b' c ''

# default IFS
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
echo

IFS=''
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"
echo

IFS=zx
argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: 4 x 3 table - with for loop
================================================================================

case $SH in yash) exit ;; esac  # no echo -n

setopt SH_WORD_SPLIT  # for zsh

set -- 'a b' c ''

# default IFS
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo
echo

IFS=''
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo
echo

IFS=zx
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS=x and '' and $@ - same bug as spec/toysh-posix case #12
================================================================================

case $SH in yash) exit ;; esac  # no echo -n

setopt SH_WORD_SPLIT  # for zsh

set -- one '' two

IFS=zx
echo -n '  $*  ';  for i in  $*;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$*" ';  for i in "$*"; do echo -n ' '; echo -n -$i-; done; echo
echo -n '  $@  ';  for i in  $@;  do echo -n ' '; echo -n -$i-; done; echo
echo -n ' "$@" ';  for i in "$@"; do echo -n ' '; echo -n -$i-; done; echo

argv.py '  $*  '  $*
argv.py ' "$*" ' "$*"
argv.py '  $@  '  $@
argv.py ' "$@" ' "$@"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS=x and '' and $@ (#2)
================================================================================

setopt SH_WORD_SPLIT  # for zsh

set -- "" "" "" "" ""
argv.py =$@=
argv.py =$*=
echo

IFS=
argv.py =$@=
argv.py =$*=
echo

IFS=x
argv.py =$@=
argv.py =$*=

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: IFS=x and '' and $@ (#3)
================================================================================

setopt SH_WORD_SPLIT  # for zsh

IFS=x
set -- "" "" "" "" ""

argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*
set -- $*
argv.py $*

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: ""$A"" - empty string on both sides - derived from spec/toysh-posix #15
================================================================================


A="   abc   def   "

argv.py $A
argv.py ""$A""

unset IFS

argv.py $A
argv.py ""$A""

echo

# Do the same thing in a for loop - this is IDENTICAL behavior

for i in $A; do echo =$i=; done
echo

for i in ""$A""; do echo =$i=; done
echo

unset IFS

for i in $A; do echo =$i=; done
echo

for i in ""$A""; do echo =$i=; done

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Regression: "${!v*}"x should not be split
================================================================================

case $SH in dash|mksh|ash|yash) exit 99;; esac
IFS=x
axb=1
echo "${!axb*}"
echo "${!axb*}"x

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Regression: ${!v} should be split
================================================================================

v=hello
IFS=5
echo ${#v}
echo "${#v}"

--------------------------------------------------------------------------------

(program)

================================================================================
word-split.test.sh: Regression: "${v:-AxBxC}"x should not be split
================================================================================

IFS=x
v=
echo "${v:-AxBxC}"
echo "${v:-AxBxC}"x  # <-- osh failed this
echo ${v:-AxBxC}
echo ${v:-AxBxC}x
echo ${v:-"AxBxC"}
echo ${v:-"AxBxC"}x
echo "${v:-"AxBxC"}"
echo "${v:-"AxBxC"}"x

--------------------------------------------------------------------------------

(program)
