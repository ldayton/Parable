# Converted from Oils corpus: misc.txt

=== Usage of builtins
shopt -s expand_aliases || true
alias -- foo=echo
echo status=$?
foo x
unalias -- foo
foo x
---
(or (command (word "shopt") (word "-s") (word "expand_aliases")) (command (word "true")))
(command (word "alias") (word "--") (word "foo=echo"))
(command (word "echo") (word "status=$?"))
(command (word "foo") (word "x"))
(command (word "unalias") (word "--") (word "foo"))
(command (word "foo") (word "x"))
---

=== Basic alias
shopt -s expand_aliases  # bash requires this
alias hi='echo hello world'
hi || echo 'should not run this'
echo hi  # second word is not
'hi' || echo 'expected failure'
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "hi='echo hello world'"))
(or (command (word "hi")) (command (word "echo") (word "'should not run this'")))
(command (word "echo") (word "hi"))
(or (command (word "'hi'")) (command (word "echo") (word "'expected failure'")))
---

=== define and use alias on a single line
shopt -s expand_aliases
alias e=echo; e one  # this is not alias-expanded because we parse lines at once
e two; e three
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(semi (command (word "alias") (word "e=echo")) (command (word "e") (word "one")))
(semi (command (word "e") (word "two")) (command (word "e") (word "three")))
---

=== alias can override builtin
shopt -s expand_aliases
alias echo='echo foo'
echo bar
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "echo='echo foo'"))
(command (word "echo") (word "bar"))
---

=== defining multiple aliases, then unalias
shopt -s expand_aliases  # bash requires this
x=x
y=y
alias echo-x='echo $x' echo-y='echo $y'
echo status=$?
echo-x X
echo-y Y
unalias echo-x echo-y
echo status=$?
echo-x X || echo undefined
echo-y Y || echo undefined
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "x=x"))
(command (word "y=y"))
(command (word "alias") (word "echo-x='echo $x'") (word "echo-y='echo $y'"))
(command (word "echo") (word "status=$?"))
(command (word "echo-x") (word "X"))
(command (word "echo-y") (word "Y"))
(command (word "unalias") (word "echo-x") (word "echo-y"))
(command (word "echo") (word "status=$?"))
(or (command (word "echo-x") (word "X")) (command (word "echo") (word "undefined")))
(or (command (word "echo-y") (word "Y")) (command (word "echo") (word "undefined")))
---

=== alias not defined
alias e='echo' nonexistentZ
echo status=$?
---
(command (word "alias") (word "e='echo'") (word "nonexistentZ"))
(command (word "echo") (word "status=$?"))
---

=== unalias not defined
alias e=echo ll='ls -l'
unalias e nonexistentZ ll
echo status=$?
---
(command (word "alias") (word "e=echo") (word "ll='ls -l'"))
(command (word "unalias") (word "e") (word "nonexistentZ") (word "ll"))
(command (word "echo") (word "status=$?"))
---

=== unalias -a
alias foo=bar
alias spam=eggs

alias | egrep 'foo|spam' | wc -l

unalias -a

alias
echo status=$?
---
(command (word "alias") (word "foo=bar"))
(command (word "alias") (word "spam=eggs"))
(pipe (command (word "alias")) (pipe (command (word "egrep") (word "'foo|spam'")) (command (word "wc") (word "-l"))))
(command (word "unalias") (word "-a"))
(command (word "alias"))
(command (word "echo") (word "status=$?"))
---

=== List aliases by providing names
alias e=echo ll='ls -l'
alias e ll
---
(command (word "alias") (word "e=echo") (word "ll='ls -l'"))
(command (word "alias") (word "e") (word "ll"))
---

=== alias without args lists all aliases
alias ex=exit ll='ls -l'
alias | grep -E 'ex=|ll='  # need to grep because mksh/zsh have builtin aliases
echo status=$?
---
(command (word "alias") (word "ex=exit") (word "ll='ls -l'"))
(pipe (command (word "alias")) (command (word "grep") (word "-E") (word "'ex=|ll='")))
(command (word "echo") (word "status=$?"))
---

=== unalias without args is a usage error
unalias
if test "$?" != 0; then echo usage-error; fi
---
(command (word "unalias"))
(if (command (word "test") (word "\"$?\"") (word "!=") (word "0")) (command (word "echo") (word "usage-error")))
---

=== alias with trailing space causes alias expansion on second word
shopt -s expand_aliases  # bash requires this

alias hi='echo hello world '
alias punct='!!!'

hi punct

alias hi='echo hello world'  # No trailing space

hi punct
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "hi='echo hello world '"))
(command (word "alias") (word "punct='!!!'"))
(command (word "hi") (word "punct"))
(command (word "alias") (word "hi='echo hello world'"))
(command (word "hi") (word "punct"))
---

=== Recursive alias expansion of first word
shopt -s expand_aliases  # bash requires this
alias hi='e_ hello world'
alias e_='echo __'
hi   # first hi is expanded to echo hello world; then echo is expanded.  gah.
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "hi='e_ hello world'"))
(command (word "alias") (word "e_='echo __'"))
(command (word "hi"))
---

=== Recursive alias expansion of SECOND word
shopt -s expand_aliases  # bash requires this
alias one='ONE '
alias two='TWO '
alias e_='echo one '
e_ two hello world
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "one='ONE '"))
(command (word "alias") (word "two='TWO '"))
(command (word "alias") (word "e_='echo one '"))
(command (word "e_") (word "two") (word "hello") (word "world"))
---

=== Expansion of alias with variable
shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x'  # nothing is evaluated here
x=y
echo-x hi
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "x=x"))
(command (word "alias") (word "echo-x='echo $x'"))
(command (word "x=y"))
(command (word "echo-x") (word "hi"))
---

=== Alias must be an unquoted word, no expansions allowed
shopt -s expand_aliases  # bash requires this
alias echo_alias_='echo'
cmd=echo_alias_
echo_alias_ X  # this works
$cmd X  # this fails because it's quoted
echo status=$?
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "echo_alias_='echo'"))
(command (word "cmd=echo_alias_"))
(command (word "echo_alias_") (word "X"))
(command (word "$cmd") (word "X"))
(command (word "echo") (word "status=$?"))
---

=== first and second word are the same alias, but no trailing space
shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x'  # nothing is evaluated here
echo-x echo-x
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "x=x"))
(command (word "alias") (word "echo-x='echo $x'"))
(command (word "echo-x") (word "echo-x"))
---

=== first and second word are the same alias, with trailing space
shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x '  # nothing is evaluated here
echo-x echo-x
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "x=x"))
(command (word "alias") (word "echo-x='echo $x '"))
(command (word "echo-x") (word "echo-x"))
---

=== Invalid syntax of alias
shopt -s expand_aliases  # bash requires this
alias echo_alias_= 'echo --; echo'  # bad space here
echo_alias_ x
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "echo_alias_=") (word "'echo --; echo'"))
(command (word "echo_alias_") (word "x"))
---

=== Dynamic alias definition
shopt -s expand_aliases  # bash requires this
x=x
name='echo_alias_'
val='=echo'
alias "$name$val"
echo_alias_ X
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "x=x"))
(command (word "name='echo_alias_'"))
(command (word "val='=echo'"))
(command (word "alias") (word "\"$name$val\""))
(command (word "echo_alias_") (word "X"))
---

=== Alias name with punctuation
# NOTE: / is not OK in bash, but OK in other shells.  Must less restrictive
# than var names.
shopt -s expand_aliases  # bash requires this
alias e_+.~x='echo'
e_+.~x X
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_+.~x='echo'"))
(command (word "e_+.~x") (word "X"))
---

=== Syntax error after expansion
shopt -s expand_aliases  # bash requires this
alias e_=';; oops'
e_ x
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_=';; oops'"))
(command (word "e_") (word "x"))
---

=== Loop split across alias and arg works
shopt -s expand_aliases  # bash requires this
alias e_='for i in 1 2 3; do echo $i;'
e_ done
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_='for i in 1 2 3; do echo $i;'"))
(command (word "e_") (word "done"))
---

=== Alias with a quote in the middle is a syntax error
shopt -s expand_aliases
alias e_='echo "'
var=x
e_ '${var}"'
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_='echo \"'"))
(command (word "var=x"))
(command (word "e_") (word "'${var}\"'"))
---

=== Alias with internal newlines
shopt -s expand_aliases
alias e_='echo 1
echo 2
echo 3'
var='echo foo'
e_ ${var}
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_='echo 1\necho 2\necho 3'"))
(command (word "var='echo foo'"))
(command (word "e_") (word "${var}"))
---

=== Alias trailing newline
shopt -s expand_aliases
alias e_='echo 1
echo 2
echo 3
'
var='echo foo'
e_ ${var}
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_='echo 1\necho 2\necho 3\n'"))
(command (word "var='echo foo'"))
(command (word "e_") (word "${var}"))
---

=== Two aliases in pipeline
shopt -s expand_aliases
alias SEQ='seq '
alias THREE='3 '
alias WC='wc '
SEQ THREE | WC -l
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "SEQ='seq '"))
(command (word "alias") (word "THREE='3 '"))
(command (word "alias") (word "WC='wc '"))
(pipe (command (word "SEQ") (word "THREE")) (command (word "WC") (word "-l")))
---

=== Alias not respected inside $()
# This could be parsed correctly, but it is only defined in a child process.
shopt -s expand_aliases
echo $(alias sayhi='echo hello')
sayhi
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "echo") (word "$(alias sayhi='echo hello')"))
(command (word "sayhi"))
---

=== Alias can be defined and used on a single line
shopt -s expand_aliases
alias sayhi='echo hello'; sayhi same line
sayhi other line
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(semi (command (word "alias") (word "sayhi='echo hello'")) (command (word "sayhi") (word "same") (word "line")))
(command (word "sayhi") (word "other") (word "line"))
---

=== Alias is respected inside eval
shopt -s expand_aliases
eval "alias sayhi='echo hello'
sayhi inside"
sayhi outside
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "eval") (word "\"alias sayhi='echo hello'\nsayhi inside\""))
(command (word "sayhi") (word "outside"))
---

=== alias with redirects works
shopt -s expand_aliases
alias e_=echo
>$TMP/alias1.txt e_ 1
e_ >$TMP/alias2.txt 2
e_ 3 >$TMP/alias3.txt
cat $TMP/alias1.txt $TMP/alias2.txt $TMP/alias3.txt
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_=echo"))
(command (word "e_") (word "1") (redirect ">" "$TMP/alias1.txt"))
(command (word "e_") (word "2") (redirect ">" "$TMP/alias2.txt"))
(command (word "e_") (word "3") (redirect ">" "$TMP/alias3.txt"))
(command (word "cat") (word "$TMP/alias1.txt") (word "$TMP/alias2.txt") (word "$TMP/alias3.txt"))
---

=== alias with environment bindings works
shopt -s expand_aliases
alias p_=printenv.py
FOO=1 printenv.py FOO
FOO=2 p_ FOO
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "p_=printenv.py"))
(command (word "FOO=1") (word "printenv.py") (word "FOO"))
(command (word "FOO=2") (word "p_") (word "FOO"))
---

=== alias with line continuation in the middle
shopt -s expand_aliases
alias e_='echo '
alias one='ONE '
alias two='TWO '
alias three='THREE'  # no trailing space
e_ one \
  two one \
  two three two \
  one
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "e_='echo '"))
(command (word "alias") (word "one='ONE '"))
(command (word "alias") (word "two='TWO '"))
(command (word "alias") (word "three='THREE'"))
(command (word "e_") (word "one") (word "two") (word "one") (word "two") (word "three") (word "two") (word "one"))
---

=== alias used in subshell and command sub
# This spec seems to be contradictoary?
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_03_01
# "When used as specified by this volume of POSIX.1-2017, alias definitions
# shall not be inherited by separate invocations of the shell or by the utility
# execution environments invoked by the shell; see Shell Execution
# Environment."
shopt -s expand_aliases
alias echo_='echo [ '
( echo_ subshell; )
echo $(echo_ commandsub)
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "echo_='echo [ '"))
(subshell (command (word "echo_") (word "subshell")))
(command (word "echo") (word "$(echo_ commandsub)"))
---

=== alias used in here doc
shopt -s expand_aliases
alias echo_='echo [ '
cat <<EOF
$(echo_ ])
EOF
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "echo_='echo [ '"))
(command (word "cat") (redirect "<<" "$(echo_ ])
"))
---

=== here doc inside alias
shopt -s expand_aliases
alias c='cat <<EOF
$(echo hi)
EOF
'
c
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "c='cat <<EOF\n$(echo hi)\nEOF\n'"))
(command (word "c"))
---

=== Corner case: alias inside LHS array arithmetic expression
shopt -s expand_aliases
alias zero='echo 0'
a[$(zero)]=ZERO
a[1]=ONE
argv.py "${a[@]}"
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "zero='echo 0'"))
(command (word "a[$(zero)]=ZERO"))
(command (word "a[1]=ONE"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Alias that is pipeline
shopt -s expand_aliases
alias t1='echo hi|wc -c'
t1
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "t1='echo hi|wc -c'"))
(command (word "t1"))
---

=== Alias that is && || ;
shopt -s expand_aliases
alias t1='echo one && echo two && echo 3 | wc -l;
echo four'
t1
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "t1='echo one && echo two && echo 3 | wc -l;\necho four'"))
(command (word "t1"))
---

=== Alias and command sub (bug regression)
cd $TMP
shopt -s expand_aliases
echo foo bar > tmp.txt
alias a=argv.py
a `cat tmp.txt`
---
(command (word "cd") (word "$TMP"))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "echo") (word "foo") (word "bar") (redirect ">" "tmp.txt"))
(command (word "alias") (word "a=argv.py"))
(command (word "a") (word "`cat tmp.txt`"))
---

=== Alias and arithmetic
shopt -s expand_aliases
alias a=argv.py
a $((1 + 2))
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "a=argv.py"))
(command (word "a") (word "$((1 + 2))"))
---

=== Alias and PS4
# dash enters an infinite loop!
case $SH in
  dash)
    exit 1
    ;;
esac

set -x
PS4='+$(echo trace) '
shopt -s expand_aliases
alias a=argv.py
a foo bar
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit") (word "1"))))
(command (word "set") (word "-x"))
(command (word "PS4='+$(echo trace) '"))
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "a=argv.py"))
(command (word "a") (word "foo") (word "bar"))
---

=== alias with word of multiple lines
shopt -s expand_aliases

alias ll='ls -l'
ll '1
  2
  3'
echo status=$?
---
(command (word "shopt") (word "-s") (word "expand_aliases"))
(command (word "alias") (word "ll='ls -l'"))
(command (word "ll") (word "'1\n  2\n  3'"))
(command (word "echo") (word "status=$?"))
---

=== Append string to string
s='abc'
s+=d
echo $s
---
(command (word "s='abc'"))
(command (word "s+=d"))
(command (word "echo") (word "$s"))
---

=== Append array to array
a=(x y )
a+=(t 'u v')
argv.py "${a[@]}"
---
(command (word "a=(x y)"))
(command (word "a+=(t 'u v')"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Append string to undefined variable
s+=foo
echo s=$s

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

t+=foo
echo t=$t
t+=foo
echo t=$t
---
(command (word "s+=foo"))
(command (word "echo") (word "s=$s"))
(command (word "set") (word "-u"))
(command (word "t+=foo"))
(command (word "echo") (word "t=$t"))
(command (word "t+=foo"))
(command (word "echo") (word "t=$t"))
---

=== Append to array to undefined variable
y+=(c d)
argv.py "${y[@]}"
---
(command (word "y+=(c d)"))
(command (word "argv.py") (word "\"${y[@]}\""))
---

=== error: s+=(my array)
s='abc'
s+=(d e f)
argv.py "${s[@]}"
---
(command (word "s='abc'"))
(command (word "s+=(d e f)"))
(command (word "argv.py") (word "\"${s[@]}\""))
---

=== error: myarray+=s
# They treat this as implicit index 0.  We disallow this on the LHS, so we will
# also disallow it on the RHS.
a=(x y )
a+=z
argv.py "${a[@]}"
---
(command (word "a=(x y)"))
(command (word "a+=z"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== typeset s+=(my array)
typeset s='abc'
echo $s

typeset s+=(d e f)
echo status=$?
argv.py "${s[@]}"
---
(command (word "typeset") (word "s='abc'"))
(command (word "echo") (word "$s"))
(command (word "typeset") (word "s+=(d e f)"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${s[@]}\""))
---

=== error: typeset myarray+=s
typeset a=(x y)
argv.py "${a[@]}"
typeset a+=s
argv.py "${a[@]}"
---
(command (word "typeset") (word "a=(x y)"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "typeset") (word "a+=s"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== error: append used like env prefix
# This should be an error in other shells but it's not.
A=a
A+=a printenv.py A
---
(command (word "A=a"))
(command (word "A+=a") (word "printenv.py") (word "A"))
---

=== myarray[1]+=s - Append to element
# They treat this as implicit index 0.  We disallow this on the LHS, so we will
# also disallow it on the RHS.
a=(x y )
a[1]+=z
argv.py "${a[@]}"
---
(command (word "a=(x y)"))
(command (word "a[1]+=z"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== myarray[-1]+=s - Append to last element
# Works in bash, but not mksh.  It seems like bash is doing the right thing.
# a[-1] is allowed on the LHS.  mksh doesn't have negative indexing?
a=(1 '2 3')
a[-1]+=' 4'
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "a[-1]+=' 4'"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Try to append list to element
# bash - runtime error: cannot assign list to array number
# mksh - a[-1]+: is not an identifier
# osh - parse error -- could be better!
a=(1 '2 3')
a[-1]+=(4 5)
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "a[-1]+=(4 5)"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Strings have value semantics, not reference semantics
s1='abc'
s2=$s1
s1+='d'
echo $s1 $s2
---
(command (word "s1='abc'"))
(command (word "s2=$s1"))
(command (word "s1+='d'"))
(command (word "echo") (word "$s1") (word "$s2"))
---

=== typeset s+=
typeset s+=foo
echo s=$s

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

typeset t+=foo
echo t=$t
typeset t+=foo
echo t=$t
---
(command (word "typeset") (word "s+=foo"))
(command (word "echo") (word "s=$s"))
(command (word "set") (word "-u"))
(command (word "typeset") (word "t+=foo"))
(command (word "echo") (word "t=$t"))
(command (word "typeset") (word "t+=foo"))
(command (word "echo") (word "t=$t"))
---

=== typeset s${dyn}+=
dyn=x

typeset s${dyn}+=foo
echo sx=$sx

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

typeset t${dyn}+=foo
echo tx=$tx
typeset t${dyn}+=foo
echo tx=$tx
---
(command (word "dyn=x"))
(command (word "typeset") (word "s${dyn}+=foo"))
(command (word "echo") (word "sx=$sx"))
(command (word "set") (word "-u"))
(command (word "typeset") (word "t${dyn}+=foo"))
(command (word "echo") (word "tx=$tx"))
(command (word "typeset") (word "t${dyn}+=foo"))
(command (word "echo") (word "tx=$tx"))
---

=== export readonly +=
export e+=foo
echo e=$e

readonly r+=bar
echo r=$r

set -u

export e+=foo
echo e=$e

#readonly r+=foo
#echo r=$e
---
(command (word "export") (word "e+=foo"))
(command (word "echo") (word "e=$e"))
(command (word "readonly") (word "r+=bar"))
(command (word "echo") (word "r=$r"))
(command (word "set") (word "-u"))
(command (word "export") (word "e+=foo"))
(command (word "echo") (word "e=$e"))
---

=== local +=
f() {
  local s+=foo
  echo s=$s

  set -u
  local s+=foo
  echo s=$s
}

f
---
(function "f" (brace-group (semi (semi (semi (semi (command (word "local") (word "s+=foo")) (command (word "echo") (word "s=$s"))) (command (word "set") (word "-u"))) (command (word "local") (word "s+=foo"))) (command (word "echo") (word "s=$s")))))
(command (word "f"))
---

=== assign builtin appending array: declare d+=(d e)
declare d+=(d e)
echo "${d[@]}"
declare d+=(c l)
echo "${d[@]}"

readonly r+=(r e)
echo "${r[@]}"
# can't do this again

f() {
  local l+=(l o)
  echo "${l[@]}"

  local l+=(c a)
  echo "${l[@]}"
}

f
---
(command (word "declare") (word "d+=(d e)"))
(command (word "echo") (word "\"${d[@]}\""))
(command (word "declare") (word "d+=(c l)"))
(command (word "echo") (word "\"${d[@]}\""))
(command (word "readonly") (word "r+=(r e)"))
(command (word "echo") (word "\"${r[@]}\""))
(function "f" (brace-group (semi (semi (semi (command (word "local") (word "l+=(l o)")) (command (word "echo") (word "\"${l[@]}\""))) (command (word "local") (word "l+=(c a)"))) (command (word "echo") (word "\"${l[@]}\"")))))
(command (word "f"))
---

=== export+=array disallowed (strict_array)
shopt -s strict_array

export e+=(e x)
echo "${e[@]}"
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "export") (word "e+=(e x)"))
(command (word "echo") (word "\"${e[@]}\""))
---

=== Type mismatching of lhs+=rhs should not cause a crash
case $SH in mksh|zsh) exit ;; esac
s=
a=()
declare -A d=([lemon]=yellow)

s+=(1)
s+=([melon]=green)

a+=lime
a+=([1]=banana)

d+=orange
d+=(0)

true
---
(case (word "$SH") (pattern ((word "mksh") (word "zsh")) (command (word "exit"))))
(command (word "s="))
(command (word "a=()"))
(command (word "declare") (word "-A") (word "d=([lemon]=yellow)"))
(command (word "s+=(1)"))
(command (word "s+=([melon]=green)"))
(command (word "a+=lime"))
(command (word "a+=([1]=banana)"))
(command (word "d+=orange"))
(command (word "d+=(0)"))
(command (word "true"))
---

=== true extra
true extra
---
(command (word "true") (word "extra"))
---

=== shift 1 extra
$SH -c '
set -- a b c
shift 1 extra
'
if test $? -eq 0; then
  echo fail
fi
---
(command (word "$SH") (word "-c") (word "'\nset -- a b c\nshift 1 extra\n'"))
(if (command (word "test") (word "$?") (word "-eq") (word "0")) (command (word "echo") (word "fail")))
---

=== continue 1 extra, break, etc.
$SH -c '
for i in foo; do
  continue 1 extra
done
echo status=$?
'
if test $? -eq 0; then
  echo fail
fi
---
(command (word "$SH") (word "-c") (word "'\nfor i in foo; do\n  continue 1 extra\ndone\necho status=$?\n'"))
(if (command (word "test") (word "$?") (word "-eq") (word "0")) (command (word "echo") (word "fail")))
---

=== wait with nothing to wait for
wait
---
(command (word "wait"))
---

=== wait -n with arguments - arguments are respected
case $SH in dash|mksh) exit ;; esac

echo x &

# here, you can't tell if it's -n or the other
wait -n $!
echo status=$?

# by the bash error, you can tell which is preferred
wait -n $! bad 2>err.txt
echo status=$?
echo

n=$(wc -l < err.txt)
if test "$n" -gt 0; then
  echo 'got error lines'
fi
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(background (command (word "echo") (word "x")))
(command (word "wait") (word "-n") (word "$!"))
(command (word "echo") (word "status=$?"))
(command (word "wait") (word "-n") (word "$!") (word "bad") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "n=$(wc -l < err.txt)"))
(if (command (word "test") (word "\"$n\"") (word "-gt") (word "0")) (command (word "echo") (word "'got error lines'")))
---

=== wait -n with nothing to wait for
# The 127 is STILL overloaded.  Copying bash for now.
wait -n
---
(command (word "wait") (word "-n"))
---

=== wait with jobspec syntax %nonexistent
wait %nonexistent
---
(command (word "wait") (word "%nonexistent"))
---

=== wait with invalid PID
wait 12345678
---
(command (word "wait") (word "12345678"))
---

=== wait with invalid arg
wait zzz
---
(command (word "wait") (word "zzz"))
---

=== wait for N parallel jobs
for i in 3 2 1; do
  { sleep 0.0$i; exit $i; } &
done
wait

# status is lost
echo status=$?
---
(for (word "i") (in (word "3") (word "2") (word "1")) (background (brace-group (semi (command (word "sleep") (word "0.0$i")) (command (word "exit") (word "$i"))))))
(command (word "wait"))
(command (word "echo") (word "status=$?"))
---

=== wait for N parallel jobs and check failure
set -o errexit

pids=''
for i in 3 2 1; do
  { sleep 0.0$i; echo $i; exit $i; } &
  pids="$pids $!"
done

for pid in $pids; do
  set +o errexit
  wait $pid
  status=$?
  set -o errexit

  echo status=$status
done
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "pids=''"))
(for (word "i") (in (word "3") (word "2") (word "1")) (background (brace-group (semi (semi (command (word "sleep") (word "0.0$i")) (command (word "echo") (word "$i"))) (command (word "exit") (word "$i")))) (command (word "pids=\"$pids $!\""))))
(for (word "pid") (in (word "$pids")) (semi (semi (semi (semi (command (word "set") (word "+o") (word "errexit")) (command (word "wait") (word "$pid"))) (command (word "status=$?"))) (command (word "set") (word "-o") (word "errexit"))) (command (word "echo") (word "status=$status"))))
---

=== Builtin in background
echo async &
wait
---
(background (command (word "echo") (word "async")))
(command (word "wait"))
---

=== External command in background
sleep 0.01 &
wait
---
(background (command (word "sleep") (word "0.01")))
(command (word "wait"))
---

=== Start background pipeline, wait $pid
echo hi | { exit 99; } &
echo status=$?
wait $!
echo status=$?
echo --

pids=''
for i in 3 2 1; do
  sleep 0.0$i | echo i=$i | ( exit $i ) &
  pids="$pids $!"
done
#echo "PIDS $pids"

for pid in $pids; do
  wait $pid
  echo status=$?
done

# Not cleaned up
if false; then
  echo 'DEBUG'
  jobs --debug
fi
---
(background (pipe (command (word "echo") (word "hi")) (brace-group (command (word "exit") (word "99")))))
(command (word "echo") (word "status=$?"))
(command (word "wait") (word "$!"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "--"))
(command (word "pids=''"))
(for (word "i") (in (word "3") (word "2") (word "1")) (background (pipe (command (word "sleep") (word "0.0$i")) (pipe (command (word "echo") (word "i=$i")) (subshell (command (word "exit") (word "$i"))))) (command (word "pids=\"$pids $!\""))))
(for (word "pid") (in (word "$pids")) (semi (command (word "wait") (word "$pid")) (command (word "echo") (word "status=$?"))))
(if (command (word "false")) (semi (command (word "echo") (word "'DEBUG'")) (command (word "jobs") (word "--debug"))))
---

=== Start background pipeline, wait %job_spec
case $SH in mksh) exit ;; esac  # flakiness?

echo hi | { exit 99; } &
echo status=$?
wait %1
echo status=$?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(background (pipe (command (word "echo") (word "hi")) (brace-group (command (word "exit") (word "99")))))
(command (word "echo") (word "status=$?"))
(command (word "wait") (word "%1"))
(command (word "echo") (word "status=$?"))
---

=== Wait for job and PIPESTATUS
# foreground
{ echo hi; exit 55; } | false
echo fore status=$? pipestatus=${PIPESTATUS[@]}

# background
{ echo hi; exit 44; } | false &
echo back status=$? pipestatus=${PIPESTATUS[@]}

# wait for pipeline
wait %+
#wait %1
#wait $!
echo wait status=$? pipestatus=${PIPESTATUS[@]}
---
(pipe (brace-group (semi (command (word "echo") (word "hi")) (command (word "exit") (word "55")))) (command (word "false")))
(command (word "echo") (word "fore") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
(background (pipe (brace-group (semi (command (word "echo") (word "hi")) (command (word "exit") (word "44")))) (command (word "false"))))
(command (word "echo") (word "back") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
(command (word "wait") (word "%+"))
(command (word "echo") (word "wait") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
---

=== Wait for job and PIPESTATUS - cat
# foreground
exit 55 | ( cat; exit 99 )
echo fore status=$? pipestatus=${PIPESTATUS[@]}

# background
exit 44 | ( cat; exit 88 ) &
echo back status=$? pipestatus=${PIPESTATUS[@]}

# wait for pipeline
wait %+
#wait %1
#wait $!
echo wait status=$? pipestatus=${PIPESTATUS[@]}
echo

# wait for non-pipeline
( exit 77 ) &
wait %+
echo wait status=$? pipestatus=${PIPESTATUS[@]}
---
(pipe (command (word "exit") (word "55")) (subshell (semi (command (word "cat")) (command (word "exit") (word "99")))))
(command (word "echo") (word "fore") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
(background (pipe (command (word "exit") (word "44")) (subshell (semi (command (word "cat")) (command (word "exit") (word "88"))))))
(command (word "echo") (word "back") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
(command (word "wait") (word "%+"))
(command (word "echo") (word "wait") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
(command (word "echo"))
(background (subshell (command (word "exit") (word "77"))))
(command (word "wait") (word "%+"))
(command (word "echo") (word "wait") (word "status=$?") (word "pipestatus=${PIPESTATUS[@]}"))
---

=== Brace group in background, wait all
{ sleep 0.09; exit 9; } &
{ sleep 0.07; exit 7; } &
wait  # wait for all gives 0
echo "status=$?"
---
(background (brace-group (semi (command (word "sleep") (word "0.09")) (command (word "exit") (word "9")))))
(background (brace-group (semi (command (word "sleep") (word "0.07")) (command (word "exit") (word "7")))))
(command (word "wait"))
(command (word "echo") (word "\"status=$?\""))
---

=== Wait on background process PID
{ sleep 0.09; exit 9; } &
pid1=$!
{ sleep 0.07; exit 7; } &
pid2=$!
wait $pid2
echo "status=$?"
wait $pid1
echo "status=$?"
---
(background (brace-group (semi (command (word "sleep") (word "0.09")) (command (word "exit") (word "9")))))
(command (word "pid1=$!"))
(background (brace-group (semi (command (word "sleep") (word "0.07")) (command (word "exit") (word "7")))))
(command (word "pid2=$!"))
(command (word "wait") (word "$pid2"))
(command (word "echo") (word "\"status=$?\""))
(command (word "wait") (word "$pid1"))
(command (word "echo") (word "\"status=$?\""))
---

=== Wait on multiple specific IDs returns last status
{ sleep 0.08; exit 8; } &
jid1=$!
{ sleep 0.09; exit 9; } &
jid2=$!
{ sleep 0.07; exit 7; } &
jid3=$!
wait $jid1 $jid2 $jid3  # NOTE: not using %1 %2 %3 syntax on purpose
echo "status=$?"  # third job I think
---
(background (brace-group (semi (command (word "sleep") (word "0.08")) (command (word "exit") (word "8")))))
(command (word "jid1=$!"))
(background (brace-group (semi (command (word "sleep") (word "0.09")) (command (word "exit") (word "9")))))
(command (word "jid2=$!"))
(background (brace-group (semi (command (word "sleep") (word "0.07")) (command (word "exit") (word "7")))))
(command (word "jid3=$!"))
(command (word "wait") (word "$jid1") (word "$jid2") (word "$jid3"))
(command (word "echo") (word "\"status=$?\""))
---

=== wait -n
case $SH in dash|mksh) return ;; esac

{ sleep 0.09; exit 9; } &
{ sleep 0.03; exit 3; } &
wait -n
echo "status=$?"
wait -n
echo "status=$?"
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "return"))))
(background (brace-group (semi (command (word "sleep") (word "0.09")) (command (word "exit") (word "9")))))
(background (brace-group (semi (command (word "sleep") (word "0.03")) (command (word "exit") (word "3")))))
(command (word "wait") (word "-n"))
(command (word "echo") (word "\"status=$?\""))
(command (word "wait") (word "-n"))
(command (word "echo") (word "\"status=$?\""))
---

=== Async for loop
for i in 1 2 3; do
  echo $i
  sleep 0.0$i
done &
wait
---
(background (for (word "i") (in (word "1") (word "2") (word "3")) (semi (command (word "echo") (word "$i")) (command (word "sleep") (word "0.0$i")))))
(command (word "wait"))
---

=== Background process doesn't affect parent
echo ${foo=1}
echo $foo
echo ${bar=2} &
wait
echo $bar  # bar is NOT SET in the parent process
---
(command (word "echo") (word "${foo=1}"))
(command (word "echo") (word "$foo"))
(background (command (word "echo") (word "${bar=2}")))
(command (word "wait"))
(command (word "echo") (word "$bar"))
---

=== Background process and then a singleton pipeline
# This was inspired by #416, although that symptom there was timing, so it's
# technically not a regression test.  It's hard to test timing.

{ sleep 0.1; exit 42; } &
echo begin
! true
echo end
wait $!
echo status=$?
---
(background (brace-group (semi (command (word "sleep") (word "0.1")) (command (word "exit") (word "42")))))
(command (word "echo") (word "begin"))
(negation (command (word "true")))
(command (word "echo") (word "end"))
(command (word "wait") (word "$!"))
(command (word "echo") (word "status=$?"))
---

=== jobs prints one line per job
sleep 0.1 & 
sleep 0.1 | cat & 

# dash doesn't print if it's not a terminal?
jobs | wc -l
---
(background (command (word "sleep") (word "0.1")))
(background (pipe (command (word "sleep") (word "0.1")) (command (word "cat"))))
(pipe (command (word "jobs")) (command (word "wc") (word "-l")))
---

=== jobs -p prints one line per job
sleep 0.1 &
sleep 0.1 | cat &

jobs -p > tmp.txt

cat tmp.txt | wc -l  # 2 lines, one for each job
cat tmp.txt | wc -w  # each line is a single "word"
---
(background (command (word "sleep") (word "0.1")))
(background (pipe (command (word "sleep") (word "0.1")) (command (word "cat"))))
(command (word "jobs") (word "-p") (redirect ">" "tmp.txt"))
(pipe (command (word "cat") (word "tmp.txt")) (command (word "wc") (word "-l")))
(pipe (command (word "cat") (word "tmp.txt")) (command (word "wc") (word "-w")))
---

=== No stderr spew when shell is not interactive
# in interactive shell, this prints 'Process' or 'Pipeline'
sleep 0.01 &
sleep 0.01 | cat &
wait
---
(background (command (word "sleep") (word "0.01")))
(background (pipe (command (word "sleep") (word "0.01")) (command (word "cat"))))
(command (word "wait"))
---

=== YSH wait --all
case $SH in dash|bash|mksh) exit ;; esac

sleep 0.01 &
(exit 55) &
true &
wait
echo wait $?

sleep 0.01 &
(exit 44) &
true &
wait --all
echo wait --all $?
---
(case (word "$SH") (pattern ((word "dash") (word "bash") (word "mksh")) (command (word "exit"))))
(background (command (word "sleep") (word "0.01")))
(background (subshell (command (word "exit") (word "55"))))
(background (command (word "true")))
(command (word "wait"))
(command (word "echo") (word "wait") (word "$?"))
(background (command (word "sleep") (word "0.01")))
(background (subshell (command (word "exit") (word "44"))))
(background (command (word "true")))
(command (word "wait") (word "--all"))
(command (word "echo") (word "wait") (word "--all") (word "$?"))
---

=== YSH wait --verbose
case $SH in dash|bash|mksh) exit ;; esac

sleep 0.01 &
(exit 55) &
wait --verbose
echo wait $?

(exit 44) &
sleep 0.01 &
wait --all --verbose
echo wait --all $?
---
(case (word "$SH") (pattern ((word "dash") (word "bash") (word "mksh")) (command (word "exit"))))
(background (command (word "sleep") (word "0.01")))
(background (subshell (command (word "exit") (word "55"))))
(command (word "wait") (word "--verbose"))
(command (word "echo") (word "wait") (word "$?"))
(background (subshell (command (word "exit") (word "44"))))
(background (command (word "sleep") (word "0.01")))
(command (word "wait") (word "--all") (word "--verbose"))
(command (word "echo") (word "wait") (word "--all") (word "$?"))
---

=== Signal message for killed background job
case $SH in dash|mksh) exit ;; esac

sleep 1 &
kill -HUP $!
wait $! 2>err.txt
echo status=$?
grep -o "Hangup" err.txt
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(background (command (word "sleep") (word "1")))
(command (word "kill") (word "-HUP") (word "$!"))
(command (word "wait") (word "$!") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(command (word "grep") (word "-o") (word "\"Hangup\"") (word "err.txt"))
---

=== [bash_unset] local-unset / dynamic-unset for localvar
unlocal() { unset -v "$1"; }

f1() {
  local v=local
  unset v
  echo "[$1,local,(unset)] v: ${v-(unset)}"
}
v=global
f1 global

f1() {
  local v=local
  unlocal v
  echo "[$1,local,(unlocal)] v: ${v-(unset)}"
}
v=global
f1 'global'
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f1" (brace-group (semi (semi (command (word "local") (word "v=local")) (command (word "unset") (word "v"))) (command (word "echo") (word "\"[$1,local,(unset)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "f1") (word "global"))
(function "f1" (brace-group (semi (semi (command (word "local") (word "v=local")) (command (word "unlocal") (word "v"))) (command (word "echo") (word "\"[$1,local,(unlocal)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "f1") (word "'global'"))
---

=== [bash_unset] local-unset / dynamic-unset for localvar (mutated from tempenv)
unlocal() { unset -v "$1"; }

f1() {
  local v=local
  unset v
  echo "[$1,local,(unset)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

f1() {
  local v=local
  unlocal v
  echo "[$1,local,(unlocal)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f1" (brace-group (semi (semi (command (word "local") (word "v=local")) (command (word "unset") (word "v"))) (command (word "echo") (word "\"[$1,local,(unset)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "v=tempenv") (word "f1") (word "'global,tempenv'"))
(function "f1" (brace-group (semi (semi (command (word "local") (word "v=local")) (command (word "unlocal") (word "v"))) (command (word "echo") (word "\"[$1,local,(unlocal)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "v=tempenv") (word "f1") (word "'global,tempenv'"))
---

=== [bash_unset] local-unset / dynamic-unset for tempenv
unlocal() { unset -v "$1"; }

f1() {
  unset v
  echo "[$1,(unset)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

f1() {
  unlocal v
  echo "[$1,(unlocal)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f1" (brace-group (semi (command (word "unset") (word "v")) (command (word "echo") (word "\"[$1,(unset)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "v=tempenv") (word "f1") (word "'global,tempenv'"))
(function "f1" (brace-group (semi (command (word "unlocal") (word "v")) (command (word "echo") (word "\"[$1,(unlocal)] v: ${v-(unset)}\"")))))
(command (word "v=global"))
(command (word "v=tempenv") (word "f1") (word "'global,tempenv'"))
---

=== [bash_unset] function call with tempenv vs tempenv-eval
unlocal() { unset -v "$1"; }

f5() {
  echo "[$1] v: ${v-(unset)}"
  local v
  echo "[$1,local] v: ${v-(unset)}"
  ( unset v
    echo "[$1,local+unset] v: ${v-(unset)}" )
  ( unlocal v
    echo "[$1,local+unlocal] v: ${v-(unset)}" )
}
v=global
f5 'global'
v=tempenv f5 'global,tempenv'
v=tempenv eval 'f5 "global,tempenv,(eval)"'
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f5" (brace-group (semi (semi (semi (semi (command (word "echo") (word "\"[$1] v: ${v-(unset)}\"")) (command (word "local") (word "v"))) (command (word "echo") (word "\"[$1,local] v: ${v-(unset)}\""))) (subshell (semi (command (word "unset") (word "v")) (command (word "echo") (word "\"[$1,local+unset] v: ${v-(unset)}\""))))) (subshell (semi (command (word "unlocal") (word "v")) (command (word "echo") (word "\"[$1,local+unlocal] v: ${v-(unset)}\"")))))))
(command (word "v=global"))
(command (word "f5") (word "'global'"))
(command (word "v=tempenv") (word "f5") (word "'global,tempenv'"))
(command (word "v=tempenv") (word "eval") (word "'f5 \"global,tempenv,(eval)\"'"))
---

=== [bash_unset] localvar-inherit from tempenv
f1() {
  local v
  echo "[$1,(local)] v: ${v-(unset)}"
}
f2() {
  f1 "$1,(func)"
}
f3() {
  local v=local
  f1 "$1,local,(func)"
}
v=global

f1 'global'
v=tempenv f1 'global,tempenv'
(export v=global; f1 'xglobal')

f2 'global'
v=tempenv f2 'global,tempenv'
(export v=global; f2 'xglobal')

f3 'global'
---
(function "f1" (brace-group (semi (command (word "local") (word "v")) (command (word "echo") (word "\"[$1,(local)] v: ${v-(unset)}\"")))))
(function "f2" (brace-group (command (word "f1") (word "\"$1,(func)\""))))
(function "f3" (brace-group (semi (command (word "local") (word "v=local")) (command (word "f1") (word "\"$1,local,(func)\"")))))
(command (word "v=global"))
(command (word "f1") (word "'global'"))
(command (word "v=tempenv") (word "f1") (word "'global,tempenv'"))
(subshell (semi (command (word "export") (word "v=global")) (command (word "f1") (word "'xglobal'"))))
(command (word "f2") (word "'global'"))
(command (word "v=tempenv") (word "f2") (word "'global,tempenv'"))
(subshell (semi (command (word "export") (word "v=global")) (command (word "f2") (word "'xglobal'"))))
(command (word "f3") (word "'global'"))
---

=== [compat_array] ${arr} is ${arr[0]}
case ${SH##*/} in dash|ash) exit 1 ;; esac # dash/ash does not have arrays
case ${SH##*/} in osh) shopt -s compat_array ;; esac
case ${SH##*/} in zsh) setopt KSH_ARRAYS ;; esac
arr=(foo bar baz)
argv.py "$arr" "${arr}"
---
(case (word "${SH##*/}") (pattern ((word "dash") (word "ash")) (command (word "exit") (word "1"))))
(case (word "${SH##*/}") (pattern ((word "osh")) (command (word "shopt") (word "-s") (word "compat_array"))))
(case (word "${SH##*/}") (pattern ((word "zsh")) (command (word "setopt") (word "KSH_ARRAYS"))))
(command (word "arr=(foo bar baz)"))
(command (word "argv.py") (word "\"$arr\"") (word "\"${arr}\""))
---

=== [compat_array] scalar write to arrays
case ${SH##*/} in
(dash|ash) exit 1;; # dash/ash does not have arrays
(osh) shopt -s compat_array;;
(zsh) setopt KSH_ARRAYS;;
esac

a=(1 0 0)
: $(( a++ ))
argv.py "${a[@]}"
---
(case (word "${SH##*/}") (pattern ((word "dash") (word "ash")) (command (word "exit") (word "1"))) (pattern ((word "osh")) (command (word "shopt") (word "-s") (word "compat_array"))) (pattern ((word "zsh")) (command (word "setopt") (word "KSH_ARRAYS"))))
(command (word "a=(1 0 0)"))
(command (word ":") (word "$(( a++ ))"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== [compat_array] scalar write to associative arrays
case ${SH##*/} in
(dash|ash|yash|mksh) exit 1;; # dash/ash/yash/mksh does not have associative arrays
(osh) shopt -s compat_array;;
(zsh) setopt KSH_ARRAYS;;
esac

declare -A d=()
d['0']=1
d['foo']=hello
d['bar']=world
((d++))
argv.py ${d['0']} ${d['foo']} ${d['bar']}
---
(case (word "${SH##*/}") (pattern ((word "dash") (word "ash") (word "yash") (word "mksh")) (command (word "exit") (word "1"))) (pattern ((word "osh")) (command (word "shopt") (word "-s") (word "compat_array"))) (pattern ((word "zsh")) (command (word "setopt") (word "KSH_ARRAYS"))))
(command (word "declare") (word "-A") (word "d=()"))
(command (word "d['0']=1"))
(command (word "d['foo']=hello"))
(command (word "d['bar']=world"))
(arith (word "d++"))
(command (word "argv.py") (word "${d['0']}") (word "${d['foo']}") (word "${d['bar']}"))
---

=== [compat_array] ${alpha@a}
declare -A alpha=(['1']=2)
echo type=${alpha@a}
shopt -s compat_array
echo type=${alpha@a}
---
(command (word "declare") (word "-A") (word "alpha=(['1']=2)"))
(command (word "echo") (word "type=${alpha@a}"))
(command (word "shopt") (word "-s") (word "compat_array"))
(command (word "echo") (word "type=${alpha@a}"))
---

=== recursive arith: one level
a='b=123'
echo $((a))
---
(command (word "a='b=123'"))
(command (word "echo") (word "$((a))"))
---

=== recursive arith: two levels
a='b=c' c='d=123'
echo $((a))
---
(command (word "a='b=c'") (word "c='d=123'"))
(command (word "echo") (word "$((a))"))
---

=== recursive arith: short circuit &&, ||
# Note: mksh R52 has a bug. Even though it supports a short circuit like
#   "echo $((cond&&(a=1)))", it doesn't work with "x=a=1; echo
#   $((cond&&x))". It is fixed at least in mksh R57.
# Note: "busybox sh" doesn't support short circuit.
a=b=123
echo $((1||a)):$((b))
echo $((0||a)):$((b))
c=d=321
echo $((0&&c)):$((d))
echo $((1&&c)):$((d))
---
(command (word "a=b=123"))
(command (word "echo") (word "$((1||a)):$((b))"))
(command (word "echo") (word "$((0||a)):$((b))"))
(command (word "c=d=321"))
(command (word "echo") (word "$((0&&c)):$((d))"))
(command (word "echo") (word "$((1&&c)):$((d))"))
---

=== recursive arith: short circuit ?:
# Note: "busybox sh" behaves strangely.
y=a=123 n=a=321
echo $((1?(y):(n))):$((a))
echo $((0?(y):(n))):$((a))
---
(command (word "y=a=123") (word "n=a=321"))
(command (word "echo") (word "$((1?(y):(n))):$((a))"))
(command (word "echo") (word "$((0?(y):(n))):$((a))"))
---

=== recursive arith: side effects
# In Zsh and Busybox sh, the side effect of inner arithmetic
# evaluations seems to take effect only after the whole evaluation.
a='b=c' c='d=123'
echo $((a,d)):$((d))
---
(command (word "a='b=c'") (word "c='d=123'"))
(command (word "echo") (word "$((a,d)):$((d))"))
---

=== recursive arith: recursion
loop='i<=100&&(s+=i,i++,loop)' s=0 i=0
echo $((a=loop,s))
---
(command (word "loop='i<=100&&(s+=i,i++,loop)'") (word "s=0") (word "i=0"))
(command (word "echo") (word "$((a=loop,s))"))
---

=== recursive arith: array elements
text[1]='d=123'
text[2]='text[1]'
text[3]='text[2]'
echo $((a=text[3]))
---
(command (word "text[1]='d=123'"))
(command (word "text[2]='text[1]'"))
(command (word "text[3]='text[2]'"))
(command (word "echo") (word "$((a=text[3]))"))
---

=== dynamic arith varname: assign
vec2_set () {
  local this=$1 x=$2 y=$3
  : $(( ${this}_x = $2 ))
  : $(( ${this}_y = y ))
}
vec2_set a 3 4
vec2_set b 5 12
echo a_x=$a_x a_y=$a_y
echo b_x=$b_x b_y=$b_y
---
(function "vec2_set" (brace-group (semi (semi (command (word "local") (word "this=$1") (word "x=$2") (word "y=$3")) (command (word ":") (word "$(( ${this}_x = $2 ))"))) (command (word ":") (word "$(( ${this}_y = y ))")))))
(command (word "vec2_set") (word "a") (word "3") (word "4"))
(command (word "vec2_set") (word "b") (word "5") (word "12"))
(command (word "echo") (word "a_x=$a_x") (word "a_y=$a_y"))
(command (word "echo") (word "b_x=$b_x") (word "b_y=$b_y"))
---

=== dynamic arith varname: read
vec2_load() {
  local this=$1
  x=$(( ${this}_x ))
  : $(( y = ${this}_y ))
}
a_x=12 a_y=34
vec2_load a
echo x=$x y=$y
---
(function "vec2_load" (brace-group (semi (semi (command (word "local") (word "this=$1")) (command (word "x=$(( ${this}_x ))"))) (command (word ":") (word "$(( y = ${this}_y ))")))))
(command (word "a_x=12") (word "a_y=34"))
(command (word "vec2_load") (word "a"))
(command (word "echo") (word "x=$x") (word "y=$y"))
---

=== dynamic arith varname: copy/add
shopt -s eval_unsafe_arith  # for RHS

vec2_copy () {
  local this=$1 rhs=$2
  : $(( ${this}_x = $(( ${rhs}_x )) ))
  : $(( ${this}_y = ${rhs}_y ))
}
vec2_add () {
  local this=$1 rhs=$2
  : $(( ${this}_x += $(( ${rhs}_x )) ))
  : $(( ${this}_y += ${rhs}_y ))
}
a_x=3 a_y=4
b_x=4 b_y=20
vec2_copy c a
echo c_x=$c_x c_y=$c_y
vec2_add c b
echo c_x=$c_x c_y=$c_y
---
(command (word "shopt") (word "-s") (word "eval_unsafe_arith"))
(function "vec2_copy" (brace-group (semi (semi (command (word "local") (word "this=$1") (word "rhs=$2")) (command (word ":") (word "$(( ${this}_x = $(( ${rhs}_x )) ))"))) (command (word ":") (word "$(( ${this}_y = ${rhs}_y ))")))))
(function "vec2_add" (brace-group (semi (semi (command (word "local") (word "this=$1") (word "rhs=$2")) (command (word ":") (word "$(( ${this}_x += $(( ${rhs}_x )) ))"))) (command (word ":") (word "$(( ${this}_y += ${rhs}_y ))")))))
(command (word "a_x=3") (word "a_y=4"))
(command (word "b_x=4") (word "b_y=20"))
(command (word "vec2_copy") (word "c") (word "a"))
(command (word "echo") (word "c_x=$c_x") (word "c_y=$c_y"))
(command (word "vec2_add") (word "c") (word "b"))
(command (word "echo") (word "c_x=$c_x") (word "c_y=$c_y"))
---

=== is-array with ${var@a}
case $SH in mksh|ash|dash|yash) exit 1 ;; esac

function ble/is-array { [[ ${!1@a} == *a* ]]; }

ble/is-array undef
echo undef $?

string=''
ble/is-array string
echo string $?

array=(one two three)
ble/is-array array
echo array $?
---
(case (word "$SH") (pattern ((word "mksh") (word "ash") (word "dash") (word "yash")) (command (word "exit") (word "1"))))
(function "ble/is-array" (brace-group (cond (cond-binary "==" (cond-term "${!1@a}") (cond-term "*a*")))))
(command (word "ble/is-array") (word "undef"))
(command (word "echo") (word "undef") (word "$?"))
(command (word "string=''"))
(command (word "ble/is-array") (word "string"))
(command (word "echo") (word "string") (word "$?"))
(command (word "array=(one two three)"))
(command (word "ble/is-array") (word "array"))
(command (word "echo") (word "array") (word "$?"))
---

=== Sparse array with big index
# TODO: more InternalStringArray idioms / stress tests ?

a=()

if false; then
  # This takes too long!  # From Zulip
  i=$(( 0x0100000000000000 ))
else
  # smaller number that's OK
  i=$(( 0x0100000 ))
fi

a[i]=1

echo len=${#a[@]}
---
(command (word "a=()"))
(if (command (word "false")) (command (word "i=$(( 0x0100000000000000 ))")) (command (word "i=$(( 0x0100000 ))")))
(command (word "a[i]=1"))
(command (word "echo") (word "len=${#a[@]}"))
---

=== shift unshift reverse
case $SH in mksh|ash) exit ;; esac

# https://github.com/akinomyoga/ble.sh/blob/79beebd928cf9f6506a687d395fd450d027dc4cd/src/util.sh#L578-L582

# @fn ble/array#unshift arr value...
function ble/array#unshift {
  builtin eval -- "$1=(\"\${@:2}\" \"\${$1[@]}\")"
}
# @fn ble/array#shift arr count
function ble/array#shift {
  # Note: Bash 4.3  ${arr[@]:${2:-1}}  offset='${2'
  # length='-1' 
  builtin eval -- "$1=(\"\${$1[@]:$((${2:-1}))}\")"
}
# @fn ble/array#reverse arr
function ble/array#reverse {
  builtin eval "
  set -- \"\${$1[@]}\"; $1=()
  local e$1 i$1=\$#
  for e$1; do $1[--i$1]=\"\$e$1\"; done"
}

a=( {1..6} )
echo "${a[@]}"

ble/array#shift a 1
echo "${a[@]}"

ble/array#shift a 2
echo "${a[@]}"

echo ---

ble/array#unshift a 99
echo "${a[@]}"

echo ---

# doesn't work in zsh!
ble/array#reverse a
echo "${a[@]}"
---
(case (word "$SH") (pattern ((word "mksh") (word "ash")) (command (word "exit"))))
(function "ble/array#unshift" (brace-group (command (word "builtin") (word "eval") (word "--") (word "\"$1=(\\\"\\${@:2}\\\" \\\"\\${$1[@]}\\\")\""))))
(function "ble/array#shift" (brace-group (command (word "builtin") (word "eval") (word "--") (word "\"$1=(\\\"\\${$1[@]:$((${2:-1}))}\\\")\""))))
(function "ble/array#reverse" (brace-group (command (word "builtin") (word "eval") (word "\"\n  set -- \\\"\\${$1[@]}\\\"; $1=()\n  local e$1 i$1=\\$#\n  for e$1; do $1[--i$1]=\\\"\\$e$1\\\"; done\""))))
(command (word "a=({1..6})"))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "ble/array#shift") (word "a") (word "1"))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "ble/array#shift") (word "a") (word "2"))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "echo") (word "---"))
(command (word "ble/array#unshift") (word "a") (word "99"))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "echo") (word "---"))
(command (word "ble/array#reverse") (word "a"))
(command (word "echo") (word "\"${a[@]}\""))
---

=== shopt -u expand_aliases and eval
case $SH in zsh|mksh|ash|dash|yash) exit ;; esac

alias echo=false

function f {
  shopt -u expand_aliases
  eval -- "$1"
  shopt -s expand_aliases
}

f 'echo hello'
---
(case (word "$SH") (pattern ((word "zsh") (word "mksh") (word "ash") (word "dash") (word "yash")) (command (word "exit"))))
(command (word "alias") (word "echo=false"))
(function "f" (brace-group (semi (semi (command (word "shopt") (word "-u") (word "expand_aliases")) (command (word "eval") (word "--") (word "\"$1\""))) (command (word "shopt") (word "-s") (word "expand_aliases")))))
(command (word "f") (word "'echo hello'"))
---

=== Issue #1069 [40] BUG: a=(declare v); "${a[@]}" fails
case $SH in ash|dash)  exit 99 ;; esac
a=(typeset v=1)
v=x
"${a[@]}"
echo "v=$v"
---
(case (word "$SH") (pattern ((word "ash") (word "dash")) (command (word "exit") (word "99"))))
(command (word "a=(typeset v=1)"))
(command (word "v=x"))
(command (word "\"${a[@]}\""))
(command (word "echo") (word "\"v=$v\""))
---

=== Issue #1069 [40] BUG: a=declare; "$a" v=1 fails
case $SH in ash|dash)  exit 99 ;; esac
a=typeset
v=x
"$a" v=1
echo "v=$v"
---
(case (word "$SH") (pattern ((word "ash") (word "dash")) (command (word "exit") (word "99"))))
(command (word "a=typeset"))
(command (word "v=x"))
(command (word "\"$a\"") (word "v=1"))
(command (word "echo") (word "\"v=$v\""))
---

=== Issue #1069 [49] BUG: \return 0 does not work
f0() { return 3;          echo unexpected; return 0; }
f1() { \return 3;         echo unexpected; return 0; }
f0; echo "status=$?"
f1; echo "status=$?"
---
(function "f0" (brace-group (semi (semi (command (word "return") (word "3")) (command (word "echo") (word "unexpected"))) (command (word "return") (word "0")))))
(function "f1" (brace-group (semi (semi (command (word "\\return") (word "3")) (command (word "echo") (word "unexpected"))) (command (word "return") (word "0")))))
(semi (command (word "f0")) (command (word "echo") (word "\"status=$?\"")))
(semi (command (word "f1")) (command (word "echo") (word "\"status=$?\"")))
---

=== Issue #1069 [49] BUG: \return 0 does not work (other variations)
f2() { builtin return 3;  echo unexpected; return 0; }
f3() { \builtin return 3; echo unexpected; return 0; }
f4() { command return 3;  echo unexpected; return 0; }
f2; echo "status=$?"
f3; echo "status=$?"
f4; echo "status=$?"
---
(function "f2" (brace-group (semi (semi (command (word "builtin") (word "return") (word "3")) (command (word "echo") (word "unexpected"))) (command (word "return") (word "0")))))
(function "f3" (brace-group (semi (semi (command (word "\\builtin") (word "return") (word "3")) (command (word "echo") (word "unexpected"))) (command (word "return") (word "0")))))
(function "f4" (brace-group (semi (semi (command (word "command") (word "return") (word "3")) (command (word "echo") (word "unexpected"))) (command (word "return") (word "0")))))
(semi (command (word "f2")) (command (word "echo") (word "\"status=$?\"")))
(semi (command (word "f3")) (command (word "echo") (word "\"status=$?\"")))
(semi (command (word "f4")) (command (word "echo") (word "\"status=$?\"")))
---

=== Issue #1069 [52] BUG: \builtin local v=1 fails
case $SH in ash|dash|yash) exit 99 ;; esac
v=x
case $SH in
mksh) f1() { \builtin typeset v=1; echo "l:v=$v"; } ;;
*)    f1() { \builtin local   v=1; echo "l:v=$v"; } ;;
esac
f1
echo "g:v=$v"
---
(case (word "$SH") (pattern ((word "ash") (word "dash") (word "yash")) (command (word "exit") (word "99"))))
(command (word "v=x"))
(case (word "$SH") (pattern ((word "mksh")) (function "f1" (brace-group (semi (command (word "\\builtin") (word "typeset") (word "v=1")) (command (word "echo") (word "\"l:v=$v\"")))))) (pattern ((word "*")) (function "f1" (brace-group (semi (command (word "\\builtin") (word "local") (word "v=1")) (command (word "echo") (word "\"l:v=$v\"")))))))
(command (word "f1"))
(command (word "echo") (word "\"g:v=$v\""))
---

=== Issue #1069 [53] BUG: a[1 + 1]=2, etc. fails
case $SH in ash|dash|yash) exit 99 ;; esac
a=()

a[1]=x
eval 'a[5&3]=hello'
echo "status=$?, a[1]=${a[1]}"

a[2]=x
eval 'a[1 + 1]=hello'
echo "status=$?, a[2]=${a[2]}"

a[3]=x
eval 'a[1|2]=hello'
echo "status=$?, a[3]=${a[3]}"
---
(case (word "$SH") (pattern ((word "ash") (word "dash") (word "yash")) (command (word "exit") (word "99"))))
(command (word "a=()"))
(command (word "a[1]=x"))
(command (word "eval") (word "'a[5&3]=hello'"))
(command (word "echo") (word "\"status=$?, a[1]=${a[1]}\""))
(command (word "a[2]=x"))
(command (word "eval") (word "'a[1 + 1]=hello'"))
(command (word "echo") (word "\"status=$?, a[2]=${a[2]}\""))
(command (word "a[3]=x"))
(command (word "eval") (word "'a[1|2]=hello'"))
(command (word "echo") (word "\"status=$?, a[3]=${a[3]}\""))
---

=== Issue #1069 [53] - LHS array parsing a[1 + 2]=3 (see spec/array-assign for more)
case $SH in zsh|ash) exit ;; esac

a[1 + 2]=7
a[3|4]=8
a[(1+2)*3]=9

typeset -p a

# Dynamic parsing
expr='1 + 2'
a[expr]=55

b=(42)
expr='b[0]'
a[3 + $expr - 4]=66

typeset -p a
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a[1 + 2]=7"))
(command (word "a[3|4]=8"))
(command (word "a[(1+2)*3]=9"))
(command (word "typeset") (word "-p") (word "a"))
(command (word "expr='1 + 2'"))
(command (word "a[expr]=55"))
(command (word "b=(42)"))
(command (word "expr='b[0]'"))
(command (word "a[3 + $expr - 4]=66"))
(command (word "typeset") (word "-p") (word "a"))
---

=== Issue #1069 [56] BUG: declare -p unset does not print any error message
typeset -p nonexistent
---
(command (word "typeset") (word "-p") (word "nonexistent"))
---

=== Issue #1069 [57] BUG: variable v is invisible after IFS= eval 'local v=...'
v=x
case $SH in
mksh) f() { IFS= eval 'typeset v=1'; echo "l:$v"; } ;;
*)    f() { IFS= eval 'local   v=1'; echo "l:$v"; } ;;
esac
f
echo "g:$v"
---
(command (word "v=x"))
(case (word "$SH") (pattern ((word "mksh")) (function "f" (brace-group (semi (command (word "IFS=") (word "eval") (word "'typeset v=1'")) (command (word "echo") (word "\"l:$v\"")))))) (pattern ((word "*")) (function "f" (brace-group (semi (command (word "IFS=") (word "eval") (word "'local   v=1'")) (command (word "echo") (word "\"l:$v\"")))))))
(command (word "f"))
(command (word "echo") (word "\"g:$v\""))
---

=== Issue #1069 [57] - Variable v should be visible after IFS= eval 'local v=...'
set -u

f() {
  # The temp env messes it up
  IFS= eval "local v=\"\$*\""

  # Bug does not appear with only eval
  # eval "local v=\"\$*\""

  #declare -p v
  echo v=$v

  # test -v v; echo "v defined $?"
}

f h e l l o
---
(command (word "set") (word "-u"))
(function "f" (brace-group (semi (command (word "IFS=") (word "eval") (word "\"local v=\\\"\\$*\\\"\"")) (command (word "echo") (word "v=$v")))))
(command (word "f") (word "h") (word "e") (word "l") (word "l") (word "o"))
---

=== Issue #1069 [59] N-I: arr=s should set RHS to arr[0]
case $SH in ash|dash) exit 99 ;; esac
a=(1 2 3)
a=v
argv.py "${a[@]}"
---
(case (word "$SH") (pattern ((word "ash") (word "dash")) (command (word "exit") (word "99"))))
(command (word "a=(1 2 3)"))
(command (word "a=v"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Issue #1069 [59] - Assigning Str to BashArray/BashAssoc should not remove BashArray/BashAssoc
case $SH in zsh|ash) exit ;; esac

a=(1 2 3)
a=99
typeset -p a

typeset -A A=([k]=v)
A=99
typeset -p A
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a=(1 2 3)"))
(command (word "a=99"))
(command (word "typeset") (word "-p") (word "a"))
(command (word "typeset") (word "-A") (word "A=([k]=v)"))
(command (word "A=99"))
(command (word "typeset") (word "-p") (word "A"))
---

=== [bash_unset] nested context by tempenv-eval
f1() {
  local v=local1
  echo "[$1,local1] v: ${v-(unset)}"
  v=tempenv2 eval '
    echo "[$1,local1,tempenv2,(eval)] v: ${v-(unset)}"
    local v=local2
    echo "[$1,local1,tempenv2,(eval),local2] v: ${v-(unset)}"
  '
  echo "[$1,local1] v: ${v-(unset)} (after)"
}
v=global
v=tempenv1 f1 global,tempenv1
---
(function "f1" (brace-group (semi (semi (semi (command (word "local") (word "v=local1")) (command (word "echo") (word "\"[$1,local1] v: ${v-(unset)}\""))) (command (word "v=tempenv2") (word "eval") (word "'\n    echo \"[$1,local1,tempenv2,(eval)] v: ${v-(unset)}\"\n    local v=local2\n    echo \"[$1,local1,tempenv2,(eval),local2] v: ${v-(unset)}\"\n  '"))) (command (word "echo") (word "\"[$1,local1] v: ${v-(unset)} (after)\"")))))
(command (word "v=global"))
(command (word "v=tempenv1") (word "f1") (word "global,tempenv1"))
---

=== [bash_unset] local-unset / dynamic-unset for localvar on nested-context
unlocal() { unset -v "$1"; }

f2() {
  local v=local1
  v=tempenv2 eval '
    local v=local2
    (unset v  ; echo "[$1,local1,tempenv2,(eval),local2,(unset)] v: ${v-(unset)}")
    (unlocal v; echo "[$1,local1,tempenv2,(eval),local2,(unlocal)] v: ${v-(unset)}")
  '
}
v=global
v=tempenv1 f2 global,tempenv1
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f2" (brace-group (semi (command (word "local") (word "v=local1")) (command (word "v=tempenv2") (word "eval") (word "'\n    local v=local2\n    (unset v  ; echo \"[$1,local1,tempenv2,(eval),local2,(unset)] v: ${v-(unset)}\")\n    (unlocal v; echo \"[$1,local1,tempenv2,(eval),local2,(unlocal)] v: ${v-(unset)}\")\n  '")))))
(command (word "v=global"))
(command (word "v=tempenv1") (word "f2") (word "global,tempenv1"))
---

=== [bash_unset] dynamic-unset for nested localvars
unlocal() { unset -v "$1"; }

f3() {
  local v=local1
  v=tempenv2 eval '
    local v=local2
    v=tempenv3 eval "
      local v=local3
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)}\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 1)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 2)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 3)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 4)\"
    "
  '
}
v=global
v=tempenv1 f3 global,tempenv1
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f3" (brace-group (semi (command (word "local") (word "v=local1")) (command (word "v=tempenv2") (word "eval") (word "'\n    local v=local2\n    v=tempenv3 eval \"\n      local v=local3\n      echo \\\"[\\$1/local1,tempenv2/local2,tempenv3/local3] v: \\${v-(unset)}\\\"\n      unlocal v\n      echo \\\"[\\$1/local1,tempenv2/local2,tempenv3/local3] v: \\${v-(unset)} (unlocal 1)\\\"\n      unlocal v\n      echo \\\"[\\$1/local1,tempenv2/local2,tempenv3/local3] v: \\${v-(unset)} (unlocal 2)\\\"\n      unlocal v\n      echo \\\"[\\$1/local1,tempenv2/local2,tempenv3/local3] v: \\${v-(unset)} (unlocal 3)\\\"\n      unlocal v\n      echo \\\"[\\$1/local1,tempenv2/local2,tempenv3/local3] v: \\${v-(unset)} (unlocal 4)\\\"\n    \"\n  '")))))
(command (word "v=global"))
(command (word "v=tempenv1") (word "f3") (word "global,tempenv1"))
---

=== [bash_unset] dynamic-unset for nested tempenvs
unlocal() { unset -v "$1"; }

f4_unlocal() {
  v=tempenv2 eval '
    v=tempenv3 eval "
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)}\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 1)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 2)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 3)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 4)\"
    "
  '
}
v=global
v=tempenv1 f4_unlocal global,tempenv1
---
(function "unlocal" (brace-group (command (word "unset") (word "-v") (word "\"$1\""))))
(function "f4_unlocal" (brace-group (command (word "v=tempenv2") (word "eval") (word "'\n    v=tempenv3 eval \"\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)}\\\"\n      unlocal v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unlocal 1)\\\"\n      unlocal v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unlocal 2)\\\"\n      unlocal v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unlocal 3)\\\"\n      unlocal v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unlocal 4)\\\"\n    \"\n  '"))))
(command (word "v=global"))
(command (word "v=tempenv1") (word "f4_unlocal") (word "global,tempenv1"))
---

=== [bash_unset] local-unset for nested tempenvs
f4_unset() {
  v=tempenv2 eval '
    v=tempenv3 eval "
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)}\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 1)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 2)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 3)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 4)\"
    "
  '
}
v=global
v=tempenv1 f4_unset global,tempenv1
---
(function "f4_unset" (brace-group (command (word "v=tempenv2") (word "eval") (word "'\n    v=tempenv3 eval \"\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)}\\\"\n      unset v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unset 1)\\\"\n      unset v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unset 2)\\\"\n      unset v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unset 3)\\\"\n      unset v\n      echo \\\"[\\$1,tempenv2,tempenv3] v: \\${v-(unset)} (unset 4)\\\"\n    \"\n  '"))))
(command (word "v=global"))
(command (word "v=tempenv1") (word "f4_unset") (word "global,tempenv1"))
---

=== Blog Post Example
paths=`tr '\n' ':' | sed -e 's/:$//'`<<EOPATHS
/foo
/bar
/baz
EOPATHS
echo "$paths"
---
(command (word "paths=`tr '\\n' ':' | sed -e 's/:$//'`") (redirect "<<" "/foo
/bar
/baz
"))
(command (word "echo") (word "\"$paths\""))
---

=== Blog Post Example Fix
paths=`tr '\n' ':' | sed -e 's/:$//'<<EOPATHS
/foo
/bar
/baz
EOPATHS`
echo "$paths"
---
(command (word "paths=`tr '\\n' ':' | sed -e 's/:$//'<<EOPATHS\n/foo\n/bar\n/baz\nEOPATHS`"))
(command (word "echo") (word "\"$paths\""))
---

=== Rewrite of Blog Post Example
paths=$(tr '\n' ':' | sed -e 's/:$//' <<EOPATHS
/foo
/bar
/baz
EOPATHS
)
echo "$paths"
---
(command (word "paths=$(tr '\\n' ':' | sed -e 's/:$//' <<EOPATHS\n/foo\n/bar\n/baz\nEOPATHS\n)"))
(command (word "echo") (word "\"$paths\""))
---

=== Simpler example
foo=`cat`<<EOM
hello world
EOM
echo "$foo"
---
(command (word "foo=`cat`") (redirect "<<" "hello world
"))
(command (word "echo") (word "\"$foo\""))
---

=== ` after here doc delimiter
foo=`cat <<EOM
hello world
EOM`
echo "$foo"
---
(command (word "foo=`cat <<EOM\nhello world\nEOM`"))
(command (word "echo") (word "\"$foo\""))
---

=== ` on its own line
foo=`cat <<EOM
hello world
EOM
`
echo "$foo"
---
(command (word "foo=`cat <<EOM\nhello world\nEOM\n`"))
(command (word "echo") (word "\"$foo\""))
---

=== ${##}
set -- $(seq 25)
echo ${##}
---
(command (word "set") (word "--") (word "$(seq 25)"))
(command (word "echo") (word "${##}"))
---

=== ${###}
set -- $(seq 25)
echo ${###}
---
(command (word "set") (word "--") (word "$(seq 25)"))
(command (word "echo") (word "${###}"))
---

=== ${####}
set -- $(seq 25)
echo ${####}
---
(command (word "set") (word "--") (word "$(seq 25)"))
(command (word "echo") (word "${####}"))
---

=== ${##2}
set -- $(seq 25)
echo ${##2}
---
(command (word "set") (word "--") (word "$(seq 25)"))
(command (word "echo") (word "${##2}"))
---

=== ${###2}
set -- $(seq 25)
echo ${###2}
---
(command (word "set") (word "--") (word "$(seq 25)"))
(command (word "echo") (word "${###2}"))
---

=== ${1####}
set -- '####'
echo ${1####}
---
(command (word "set") (word "--") (word "'####'"))
(command (word "echo") (word "${1####}"))
---

=== ${1#'###'}
set -- '####'
echo ${1#'###'}
---
(command (word "set") (word "--") (word "'####'"))
(command (word "echo") (word "${1#'###'}"))
---

=== ${#1#'###'}
set -- '####'
echo ${#1#'###'}
# dash and zsh accept; mksh/bash/osh don't.
---
(command (word "set") (word "--") (word "'####'"))
(command (word "echo") (word "${#1#'###'}"))
---

=== Julia example from spec/oil-user-feedback
case $SH in dash|mksh|zsh) exit ;; esac

git-branch-merged() {
  cat <<EOF
  foo
* bar
  baz
  master
EOF
}

shopt -s lastpipe  # required for bash, not OSH

branches=()  # dangerous when set -e is on
git-branch-merged | while read -r line; do
  line=${line# *}  # strip leading spaces
  if [[ $line != 'master' && ! ${line:0:1} == '*' ]]; then
    branches+=("$line")
  fi
done

if [[ ${#branches[@]} -eq 0 ]]; then
  echo "No merged branches"
else
  echo git branch -D "${branches[@]}"
fi
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(function "git-branch-merged" (brace-group (command (word "cat") (redirect "<<" "  foo
* bar
  baz
  master
"))))
(command (word "shopt") (word "-s") (word "lastpipe"))
(command (word "branches=()"))
(pipe (command (word "git-branch-merged")) (while (command (word "read") (word "-r") (word "line")) (semi (command (word "line=${line# *}")) (if (cond (cond-and (cond-binary "!=" (cond-term "$line") (cond-term "'master'")) (cond-binary "==" (cond-term "${line:0:1}") (cond-term "'*'")))) (command (word "branches+=(\"$line\")"))))))
(if (cond (cond-binary "-eq" (cond-term "${#branches[@]}") (cond-term "0"))) (command (word "echo") (word "\"No merged branches\"")) (command (word "echo") (word "git") (word "branch") (word "-D") (word "\"${branches[@]}\"")))
---

=== -a
[ -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a
[ -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a
[ -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a -a
[ -a -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a -a -a
[ -a -a -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a -a -a -a
[ -a -a -a -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a -a -a -a -a
[ -a -a -a -a -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== -a -a -a -a -a -a -a -a
[ -a -a -a -a -a -a -a -a ]
echo status=$?
---
(command (word "[") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "-a") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== test builtin - Unexpected trailing word '--' (#2409)
# Minimal repro of sqsh build error
set -- -o; test $# -ne 0 -a "$1" != "--"
echo status=$?

# Now hardcode $1
test $# -ne 0 -a "-o" != "--"
echo status=$?

# Remove quotes around -o
test $# -ne 0 -a -o != "--"
echo status=$?

# How about a different flag?
set -- -z; test $# -ne 0 -a "$1" != "--"
echo status=$?

# A non-flag?
set -- z; test $# -ne 0 -a "$1" != "--"
echo status=$?
---
(semi (command (word "set") (word "--") (word "-o")) (command (word "test") (word "$#") (word "-ne") (word "0") (word "-a") (word "\"$1\"") (word "!=") (word "\"--\"")))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "$#") (word "-ne") (word "0") (word "-a") (word "\"-o\"") (word "!=") (word "\"--\""))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "$#") (word "-ne") (word "0") (word "-a") (word "-o") (word "!=") (word "\"--\""))
(command (word "echo") (word "status=$?"))
(semi (command (word "set") (word "--") (word "-z")) (command (word "test") (word "$#") (word "-ne") (word "0") (word "-a") (word "\"$1\"") (word "!=") (word "\"--\"")))
(command (word "echo") (word "status=$?"))
(semi (command (word "set") (word "--") (word "z")) (command (word "test") (word "$#") (word "-ne") (word "0") (word "-a") (word "\"$1\"") (word "!=") (word "\"--\"")))
(command (word "echo") (word "status=$?"))
---

=== test builtin: ( = ) is confusing: equality test or non-empty string test
# here it's equality
test '(' = ')'
echo status=$?

# here it's like -n =
test 0 -eq 0 -a '(' = ')'
echo status=$?
---
(command (word "test") (word "'('") (word "=") (word "')'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "0") (word "-eq") (word "0") (word "-a") (word "'('") (word "=") (word "')'"))
(command (word "echo") (word "status=$?"))
---

=== test builtin: ( == ) is confusing: equality test or non-empty string test
# here it's equality
test '(' == ')'
echo status=$?

# here it's like -n ==
test 0 -eq 0 -a '(' == ')'
echo status=$?
---
(command (word "test") (word "'('") (word "==") (word "')'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "0") (word "-eq") (word "0") (word "-a") (word "'('") (word "==") (word "')'"))
(command (word "echo") (word "status=$?"))
---

=== Allowed: [[ = ]] and [[ == ]]
[[ = ]]
echo status=$?
[[ == ]]
echo status=$?
---
(cond (cond-unary "-n" (cond-term "=")))
(command (word "echo") (word "status=$?"))
(cond (cond-unary "-n" (cond-term "==")))
(command (word "echo") (word "status=$?"))
---

=== test builtin: ( x ) behavior is the same in both cases
test '(' x ')'
echo status=$?

test 0 -eq 0 -a '(' x ')'
echo status=$?
---
(command (word "test") (word "'('") (word "x") (word "')'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "0") (word "-eq") (word "0") (word "-a") (word "'('") (word "x") (word "')'"))
(command (word "echo") (word "status=$?"))
---

=== [ -f = ] and [ -f == ]
[ -f = ]
echo status=$?
[ -f == ]
echo status=$?
---
(command (word "[") (word "-f") (word "=") (word "]"))
(command (word "echo") (word "status=$?"))
(command (word "[") (word "-f") (word "==") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== [[ -f -f ]] and [[ -f == ]]
[[ -f -f ]]
echo status=$?

[[ -f == ]]
echo status=$?
---
(cond (cond-unary "-f" (cond-term "-f")))
(command (word "echo") (word "status=$?"))
(cond (cond-unary "-f" (cond-term "==")))
(command (word "echo") (word "status=$?"))
---

=== echo keyword
echo done
---
(command (word "echo") (word "done"))
---

=== if/else
if false; then
  echo THEN
else
  echo ELSE
fi
---
(if (command (word "false")) (command (word "echo") (word "THEN")) (command (word "echo") (word "ELSE")))
---

=== Turn an array into an integer.
a=(1 2 3)
(( a = 42 )) 
echo $a
---
(command (word "a=(1 2 3)"))
(arith (word " a = 42 "))
(command (word "echo") (word "$a"))
---

=== assign readonly -- one line
readonly x=1; x=2; echo hi
---
(semi (semi (command (word "readonly") (word "x=1")) (command (word "x=2"))) (command (word "echo") (word "hi")))
---

=== assign readonly -- multiple lines
readonly x=1
x=2
echo hi
---
(command (word "readonly") (word "x=1"))
(command (word "x=2"))
(command (word "echo") (word "hi"))
---

=== assign readonly -- multiple lines -- set -o posix
set -o posix
readonly x=1
x=2
echo hi
---
(command (word "set") (word "-o") (word "posix"))
(command (word "readonly") (word "x=1"))
(command (word "x=2"))
(command (word "echo") (word "hi"))
---

=== unset readonly -- one line
readonly x=1; unset x; echo hi
---
(semi (semi (command (word "readonly") (word "x=1")) (command (word "unset") (word "x"))) (command (word "echo") (word "hi")))
---

=== unset readonly -- multiple lines
readonly x=1
unset x
echo hi
---
(command (word "readonly") (word "x=1"))
(command (word "unset") (word "x"))
(command (word "echo") (word "hi"))
---

=== file with NUL byte
echo -e 'echo one \0 echo two' > tmp.sh
$SH tmp.sh
---
(command (word "echo") (word "-e") (word "'echo one \\0 echo two'") (redirect ">" "tmp.sh"))
(command (word "$SH") (word "tmp.sh"))
---

=== fastlex: PS1 format string that's incomplete / with NUL byte
case $SH in bash) exit ;; esac

x=$'\\D{%H:%M'  # leave off trailing }
echo x=${x@P}
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "x='\\D{%H:%M'"))
(command (word "echo") (word "x=${x@P}"))
---

=== 'echo' and printf fail on writing to full disk
# Inspired by https://blog.sunfishcode.online/bugs-in-hello-world/

echo hi > /dev/full
echo status=$?

printf '%s\n' hi > /dev/full
echo status=$?
---
(command (word "echo") (word "hi") (redirect ">" "/dev/full"))
(command (word "echo") (word "status=$?"))
(command (word "printf") (word "'%s\\n'") (word "hi") (redirect ">" "/dev/full"))
(command (word "echo") (word "status=$?"))
---

=== other builtins fail on writing to full disk
type echo > /dev/full
echo status=$?

# other random builtin
ulimit -a > /dev/full
echo status=$?
---
(command (word "type") (word "echo") (redirect ">" "/dev/full"))
(command (word "echo") (word "status=$?"))
(command (word "ulimit") (word "-a") (redirect ">" "/dev/full"))
(command (word "echo") (word "status=$?"))
---

=== subshell while running a script (regression)
# Ensures that spawning a subshell doesn't cause a seek on the file input stream
# representing the current script (issue #1233).
cat >tmp.sh <<'EOF'
echo start
(:)
echo end
EOF
$SH tmp.sh
---
(command (word "cat") (redirect ">" "tmp.sh") (redirect "<<" "echo start
(:)
echo end
"))
(command (word "$SH") (word "tmp.sh"))
---

=== for loop (issue #1446)
case $SH in dash|mksh|ash) exit ;; esac

for (( n=0; n<(3-(1)); n++ )) ; do echo $n; done
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(arith-for (init (word "n=0")) (test (word "n<(3-(1))")) (step (word "n++ ")) (command (word "echo") (word "$n")))
---

=== for loop 2 (issue #1446)
case $SH in dash|mksh|ash) exit ;; esac


for (( n=0; n<(3- (1)); n++ )) ; do echo $n; done
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "ash")) (command (word "exit"))))
(arith-for (init (word "n=0")) (test (word "n<(3- (1))")) (step (word "n++ ")) (command (word "echo") (word "$n")))
---

=== autoconf word split (#1449)
mysed() {
  for line in "$@"; do
    echo "[$line]"
  done
}

sedinputs="f1 f2"
sedscript='my sed command'

# Parsed and evaluated correctly: with word_part.EscapedLiteral \"

x=$(eval "mysed -n \"\$sedscript\" $sedinputs")
echo '--- $()'
echo "$x"

# With backticks, the \" gets lost somehow

x=`eval "mysed -n \"\$sedscript\" $sedinputs"`
echo '--- backticks'
echo "$x"


# Test it in a case statement

case `eval "mysed -n \"\$sedscript\" $sedinputs"` in 
  (*'[my sed command]'*)
    echo 'NOT SPLIT'
    ;;
esac
---
(function "mysed" (brace-group (for (word "line") (in (word "\"$@\"")) (command (word "echo") (word "\"[$line]\"")))))
(command (word "sedinputs=\"f1 f2\""))
(command (word "sedscript='my sed command'"))
(command (word "x=$(eval \"mysed -n \\\"\\$sedscript\\\" $sedinputs\")"))
(command (word "echo") (word "'--- $()'"))
(command (word "echo") (word "\"$x\""))
(command (word "x=`eval \"mysed -n \\\"\\$sedscript\\\" $sedinputs\"`"))
(command (word "echo") (word "'--- backticks'"))
(command (word "echo") (word "\"$x\""))
(case (word "`eval \"mysed -n \\\"\\$sedscript\\\" $sedinputs\"`") (pattern ((word "*'[my sed command]'*")) (command (word "echo") (word "'NOT SPLIT'"))))
---

=== autoconf arithmetic - relaxed eval_unsafe_arith (#1450)
as_fn_arith ()
{
    as_val=$(( $* ))
}
as_fn_arith 1 + 1
echo $as_val
---
(function "as_fn_arith" (brace-group (command (word "as_val=$(( $* ))"))))
(command (word "as_fn_arith") (word "1") (word "+") (word "1"))
(command (word "echo") (word "$as_val"))
---

=== command execution $(echo 42 | tee PWNED) not allowed
rm -f PWNED

x='a[$(echo 42 | tee PWNED)]=1'
echo $(( x ))

if test -f PWNED; then
  cat PWNED
else
  echo NOPE
fi
---
(command (word "rm") (word "-f") (word "PWNED"))
(command (word "x='a[$(echo 42 | tee PWNED)]=1'"))
(command (word "echo") (word "$(( x ))"))
(if (command (word "test") (word "-f") (word "PWNED")) (command (word "cat") (word "PWNED")) (command (word "echo") (word "NOPE")))
---

=== process sub <(echo 42 | tee PWNED) not allowed
rm -f PWNED

x='a[<(echo 42 | tee PWNED)]=1'
echo $(( x ))

if test -f PWNED; then
  cat PWNED
else
  echo NOPE
fi
---
(command (word "rm") (word "-f") (word "PWNED"))
(command (word "x='a[<(echo 42 | tee PWNED)]=1'"))
(command (word "echo") (word "$(( x ))"))
(if (command (word "test") (word "-f") (word "PWNED")) (command (word "cat") (word "PWNED")) (command (word "echo") (word "NOPE")))
---

=== unset doesn't allow command execution
typeset -a a  # for mksh
a=(42)
echo len=${#a[@]}

unset -v 'a[$(echo 0 | tee PWNED)]'
echo len=${#a[@]}

if test -f PWNED; then
  echo PWNED
  cat PWNED
else
  echo NOPE
fi
---
(command (word "typeset") (word "-a") (word "a"))
(command (word "a=(42)"))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "unset") (word "-v") (word "'a[$(echo 0 | tee PWNED)]'"))
(command (word "echo") (word "len=${#a[@]}"))
(if (command (word "test") (word "-f") (word "PWNED")) (semi (command (word "echo") (word "PWNED")) (command (word "cat") (word "PWNED"))) (command (word "echo") (word "NOPE")))
---

=== printf integer size bug
# from Koiche on Zulip

printf '%x\n' 2147483648
printf '%u\n' 2147483648
---
(command (word "printf") (word "'%x\\n'") (word "2147483648"))
(command (word "printf") (word "'%u\\n'") (word "2147483648"))
---

=== (( status bug
case $SH in dash|ash) exit ;; esac

# from Koiche on Zulip

(( 1 << 32 ))
echo status=$?

(( 1 << 32 )) && echo yes
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(arith (word " 1 << 32 "))
(command (word "echo") (word "status=$?"))
(and (arith (word " 1 << 32 ")) (command (word "echo") (word "yes")))
---

=== autotools as_fn_arith bug in configure
# Causes 'grep -e' check to infinite loop.
# Reduced from a configure script.

as_fn_arith() {
  as_val=$(( $* ))
}

as_fn_arith 0 + 1
echo as_val=$as_val
---
(function "as_fn_arith" (brace-group (command (word "as_val=$(( $* ))"))))
(command (word "as_fn_arith") (word "0") (word "+") (word "1"))
(command (word "echo") (word "as_val=$as_val"))
---

=== OSH can use ARGV name
case $SH in dash|ash) exit ;; esac

foo() {
  if test -v ARGV; then
    echo 'BUG local'
  fi
  ARGV=( a b )
  echo len=${#ARGV[@]}
}

if test -v ARGV; then
  echo 'BUG global'
fi
foo
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(function "foo" (brace-group (semi (semi (if (command (word "test") (word "-v") (word "ARGV")) (command (word "echo") (word "'BUG local'"))) (command (word "ARGV=(a b)"))) (command (word "echo") (word "len=${#ARGV[@]}")))))
(if (command (word "test") (word "-v") (word "ARGV")) (command (word "echo") (word "'BUG global'")))
(command (word "foo"))
---

=== Crash in {1..10} - issue #2296
{1..10}
---
(command (word "{1..10}"))
---

=== Crash after changing $[] to be alias of $(( ))
echo $[i + 1]
case foo in
  foo) echo hello ;;
esac
---
(command (word "echo") (word "$[i + 1]"))
(case (word "foo") (pattern ((word "foo")) (command (word "echo") (word "hello"))))
---

=== ${ echo hi;}
x=${ echo hi;}
echo "[$x]"
echo

# trailing space allowed
x=${ echo one; echo two; }
echo "[$x]"
echo

myfunc() {
  echo ' 3 '
  echo ' 4 5 '
}

x=${ myfunc;}
echo "[$x]"
echo

# SYNTAX ERROR
x=${myfunc;}
echo "[$x]"
---
(command (word "x=${ echo hi; }"))
(command (word "echo") (word "\"[$x]\""))
(command (word "echo"))
(command (word "x=${ echo one; echo two; }"))
(command (word "echo") (word "\"[$x]\""))
(command (word "echo"))
(function "myfunc" (brace-group (semi (command (word "echo") (word "' 3 '")) (command (word "echo") (word "' 4 5 '")))))
(command (word "x=${ myfunc; }"))
(command (word "echo") (word "\"[$x]\""))
(command (word "echo"))
(command (word "x=${myfunc;}"))
(command (word "echo") (word "\"[$x]\""))
---

=== for loop / case
x=${ for i in a b; do echo -$i-; done; }
echo "$x"

y=${|for i in a b; do REPLY+="-$i-"; done; }
echo "$y"

echo

x2=${ case foo in foo) echo sh-case ;; esac; }
echo "$x2"

y2=${|case foo in foo) REPLY=sh-case ;; esac; }
echo "$y2"
---
(command (word "x=${ for i in a b;\ndo\n    echo -$i-;\ndone; }"))
(command (word "echo") (word "\"$x\""))
(command (word "y=${|for i in a b;\ndo\n    REPLY+=\"-$i-\";\ndone; }"))
(command (word "echo") (word "\"$y\""))
(command (word "echo"))
(command (word "x2=${ case foo in foo)\n        echo sh-case\n    ;;\nesac; }"))
(command (word "echo") (word "\"$x2\""))
(command (word "y2=${|case foo in foo)\n        REPLY=sh-case\n    ;;\nesac; }"))
(command (word "echo") (word "\"$y2\""))
---

=== case
foo=a; case $foo in [0-9]) echo number;; [a-z]) echo letter ;; esac
---
(semi (command (word "foo=a")) (case (word "$foo") (pattern ((word "[0-9]")) (command (word "echo") (word "number"))) (pattern ((word "[a-z]")) (command (word "echo") (word "letter")))))
---

=== case in subshell
# Hm this subhell has to know about the closing ) and stuff like that.
# case_clause is a compound_command, which is a command.  And a subshell
# takes a compound_list, which is a list of terms, which has and_ors in them
# ... which eventually boils down to a command.
echo $(foo=a; case $foo in [0-9]) echo number;; [a-z]) echo letter ;; esac)
---
(command (word "echo") (word "$(foo=a; case $foo in [0-9])\n        echo number\n    ;;\n    [a-z])\n        echo letter\n    ;;\nesac)"))
---

=== Command sub word part
# "The token shall not be delimited by the end of the substitution."
foo=FOO; echo $(echo $foo)bar$(echo $foo)
---
(semi (command (word "foo=FOO")) (command (word "echo") (word "$(echo $foo)bar$(echo $foo)")))
---

=== Backtick
foo=FOO; echo `echo $foo`bar`echo $foo`
---
(semi (command (word "foo=FOO")) (command (word "echo") (word "`echo $foo`bar`echo $foo`")))
---

=== Backtick 2
echo `echo -n l; echo -n s`
---
(command (word "echo") (word "`echo -n l; echo -n s`"))
---

=== Nested backticks
# Inner `` are escaped!  Not sure how to do triple..  Seems like an unlikely
# use case.  Not sure if I even want to support this!
echo X > $TMP/000000-first
echo `\`echo -n l; echo -n s\` $TMP | grep 000000-first`
---
(command (word "echo") (word "X") (redirect ">" "$TMP/000000-first"))
(command (word "echo") (word "`\\`echo -n l; echo -n s\\` $TMP | grep 000000-first`"))
---

=== Making command out of command sub should work
# Works in bash and dash!
$(echo ec)$(echo ho) split builtin
---
(command (word "$(echo ec)$(echo ho)") (word "split") (word "builtin"))
---

=== Command sub with here doc
echo $(<<EOF tac
one
two
EOF
)
---
(command (word "echo") (word "$(tac <<EOF\none\ntwo\nEOF\n)"))
---

=== Here doc with pipeline
<<EOF tac | tr '\n' 'X'
one
two
EOF
---
(pipe (command (word "tac") (redirect "<<" "one
two
")) (command (word "tr") (word "'\\n'") (word "'X'")))
---

=== Command Sub word split
argv.py $(echo 'hi there') "$(echo 'hi there')"
---
(command (word "argv.py") (word "$(echo 'hi there')") (word "\"$(echo 'hi there')\""))
---

=== Command Sub trailing newline removed
s=$(python2 -c 'print("ab\ncd\n")')
argv.py "$s"
---
(command (word "s=$(python2 -c 'print(\"ab\\ncd\\n\")')"))
(command (word "argv.py") (word "\"$s\""))
---

=== Command Sub trailing whitespace not removed
s=$(python2 -c 'print("ab\ncd\n ")')
argv.py "$s"
---
(command (word "s=$(python2 -c 'print(\"ab\\ncd\\n \")')"))
(command (word "argv.py") (word "\"$s\""))
---

=== Command Sub and exit code
# A command resets the exit code, but an assignment doesn't.
echo $(echo x; exit 33)
echo $?
x=$(echo x; exit 33)
echo $?
---
(command (word "echo") (word "$(echo x; exit 33)"))
(command (word "echo") (word "$?"))
(command (word "x=$(echo x; exit 33)"))
(command (word "echo") (word "$?"))
---

=== Command Sub in local sets exit code
# A command resets the exit code, but an assignment doesn't.
f() {
  echo $(echo x; exit 33)
  echo $?
  local x=$(echo x; exit 33)
  echo $?
}
f
---
(function "f" (brace-group (semi (semi (semi (command (word "echo") (word "$(echo x; exit 33)")) (command (word "echo") (word "$?"))) (command (word "local") (word "x=$(echo x; exit 33)"))) (command (word "echo") (word "$?")))))
(command (word "f"))
---

=== Double Quotes in Command Sub in Double Quotes
# virtualenv's bin/activate uses this.
# This is weird!  Double quotes within `` is different than double quotes
# within $()!  All shells agree.
# I think this is related to the nested backticks case!
echo "x $(echo hi)"
echo "x $(echo "hi")"
echo "x $(echo \"hi\")"
echo "x `echo hi`"
echo "x `echo "hi"`"
echo "x `echo \"hi\"`"
---
(command (word "echo") (word "\"x $(echo hi)\""))
(command (word "echo") (word "\"x $(echo \"hi\")\""))
(command (word "echo") (word "\"x $(echo \\\"hi\\\")\""))
(command (word "echo") (word "\"x `echo hi`\""))
(command (word "echo") (word "\"x `echo \"hi\"`\""))
(command (word "echo") (word "\"x `echo \\\"hi\\\"`\""))
---

=== Escaped quote in [[ ]]
file=$TMP/command-sub-dbracket
#rm -f $file
echo "123 `[[ $(echo \\" > $file) ]]` 456";
cat $file
---
(command (word "file=$TMP/command-sub-dbracket"))
(command (word "echo") (word "\"123 `[[ $(echo \\\\\" > $file) ]]` 456\""))
(command (word "cat") (word "$file"))
---

=== Quoting " within ``
echo 1 `echo \"`
#echo 2 `echo \\"`
#echo 3 `echo \\\"`
#echo 4 `echo \\\\"`
---
(command (word "echo") (word "1") (word "`echo \\\"`"))
---

=== Quoting $ within ``
echo 1 `echo $`
echo 2 `echo \$`
echo 3 `echo \\$`
echo 4 `echo \\\$`
echo 5 `echo \\\\$`
---
(command (word "echo") (word "1") (word "`echo $`"))
(command (word "echo") (word "2") (word "`echo \\$`"))
(command (word "echo") (word "3") (word "`echo \\\\$`"))
(command (word "echo") (word "4") (word "`echo \\\\\\$`"))
(command (word "echo") (word "5") (word "`echo \\\\\\\\$`"))
---

=== Quoting $ within `` within double quotes
echo "1 `echo $`"
echo "2 `echo \$`"
echo "3 `echo \\$`"
echo "4 `echo \\\$`"
echo "5 `echo \\\\$`"
---
(command (word "echo") (word "\"1 `echo $`\""))
(command (word "echo") (word "\"2 `echo \\$`\""))
(command (word "echo") (word "\"3 `echo \\\\$`\""))
(command (word "echo") (word "\"4 `echo \\\\\\$`\""))
(command (word "echo") (word "\"5 `echo \\\\\\\\$`\""))
---

=== Quoting \ within ``
# You need FOUR backslashes to make a literal \.
echo [1 `echo \ `]
echo [2 `echo \\ `]
echo [3 `echo \\\\ `]
---
(command (word "echo") (word "[1") (word "`echo \\ `]"))
(command (word "echo") (word "[2") (word "`echo \\\\ `]"))
(command (word "echo") (word "[3") (word "`echo \\\\\\\\ `]"))
---

=== Quoting \ within `` within double quotes
echo "[1 `echo \ `]"
echo "[2 `echo \\ `]"
echo "[3 `echo \\\\ `]"
---
(command (word "echo") (word "\"[1 `echo \\ `]\""))
(command (word "echo") (word "\"[2 `echo \\\\ `]\""))
(command (word "echo") (word "\"[3 `echo \\\\\\\\ `]\""))
---

=== Quoting ( within ``
echo 1 `echo \(`
echo 2 `echo \\(`
echo 3 `echo \\ \\(`
---
(command (word "echo") (word "1") (word "`echo \\(`"))
(command (word "echo") (word "2") (word "`echo \\\\(`"))
(command (word "echo") (word "3") (word "`echo \\\\ \\\\(`"))
---

=== Quoting ( within `` within double quotes
echo "1 `echo \(`"
echo "2 `echo \\(`"
echo "3 `echo \\ \\(`"
---
(command (word "echo") (word "\"1 `echo \\(`\""))
(command (word "echo") (word "\"2 `echo \\\\(`\""))
(command (word "echo") (word "\"3 `echo \\\\ \\\\(`\""))
---

=== Quoting non-special characters within ``
echo [1 `echo \z]`
echo [2 `echo \\z]`
echo [3 `echo \\\z]`
echo [4 `echo \\\\z]`
---
(command (word "echo") (word "[1") (word "`echo \\z]`"))
(command (word "echo") (word "[2") (word "`echo \\\\z]`"))
(command (word "echo") (word "[3") (word "`echo \\\\\\z]`"))
(command (word "echo") (word "[4") (word "`echo \\\\\\\\z]`"))
---

=== Quoting non-special characters within `` within double quotes
echo "[1 `echo \z`]"
echo "[2 `echo \\z`]"
echo "[3 `echo \\\z`]"
echo "[4 `echo \\\\z`]"
---
(command (word "echo") (word "\"[1 `echo \\z`]\""))
(command (word "echo") (word "\"[2 `echo \\\\z`]\""))
(command (word "echo") (word "\"[3 `echo \\\\\\z`]\""))
(command (word "echo") (word "\"[4 `echo \\\\\\\\z`]\""))
---

=== Quoting double quotes within backticks
echo \"foo\"   # for comparison
echo `echo \"foo\"`
echo `echo \\"foo\\"`
---
(command (word "echo") (word "\\\"foo\\\""))
(command (word "echo") (word "`echo \\\"foo\\\"`"))
(command (word "echo") (word "`echo \\\\\"foo\\\\\"`"))
---

=== More levels of double quotes in backticks
# Shells don't agree here, some of them give you form feeds!
# There are two levels of processing I don't understand.

#echo BUG
#exit

echo `echo \\\"foo\\\"` -
echo `echo \\\\"foo\\\\"` -
echo `echo \\\\\"foo\\\\\"` -
---
(command (word "echo") (word "`echo \\\\\\\"foo\\\\\\\"`") (word "-"))
(command (word "echo") (word "`echo \\\\\\\\\"foo\\\\\\\\\"`") (word "-"))
(command (word "echo") (word "`echo \\\\\\\\\\\"foo\\\\\\\\\\\"`") (word "-"))
---

=== Syntax errors with double quotes within backticks
# bash does print syntax errors but somehow it exits 0

$SH -c 'echo `echo "`'
echo status=$?
$SH -c 'echo `echo \\\\"`'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'echo `echo \"`'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo `echo \\\\\\\\\"`'"))
(command (word "echo") (word "status=$?"))
---

=== Empty command sub $() (command::NoOp)
# IMPORTANT: catch assert() failure in child process!!!
shopt -s command_sub_errexit

echo -$()- ".$()."
---
(command (word "shopt") (word "-s") (word "command_sub_errexit"))
(command (word "echo") (word "-$()-") (word "\".$().\""))
---

=== Command block
PATH=/bin

{ which ls; }
---
(command (word "PATH=/bin"))
(brace-group (command (word "which") (word "ls")))
---

=== Permission denied
touch $TMP/text-file
$TMP/text-file
---
(command (word "touch") (word "$TMP/text-file"))
(command (word "$TMP/text-file"))
---

=== Not a dir
$TMP/not-a-dir/text-file
---
(command (word "$TMP/not-a-dir/text-file"))
---

=== Name too long
./0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
---
(command (word "./0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"))
---

=== External programs don't have _OVM in environment
# bug fix for leakage
env | grep _OVM
echo status=$?
---
(pipe (command (word "env")) (command (word "grep") (word "_OVM")))
(command (word "echo") (word "status=$?"))
---

=== File with no shebang is executed
# most shells execute /bin/sh; bash may execute itself
echo 'echo hi' > $TMP/no-shebang
chmod +x $TMP/no-shebang
$SH -c '$TMP/no-shebang'
---
(command (word "echo") (word "'echo hi'") (redirect ">" "$TMP/no-shebang"))
(command (word "chmod") (word "+x") (word "$TMP/no-shebang"))
(command (word "$SH") (word "-c") (word "'$TMP/no-shebang'"))
---

=== File with relative path and no shebang is executed
cd $TMP
echo 'echo hi' > no-shebang
chmod +x no-shebang
"$SH" -c './no-shebang'
---
(command (word "cd") (word "$TMP"))
(command (word "echo") (word "'echo hi'") (redirect ">" "no-shebang"))
(command (word "chmod") (word "+x") (word "no-shebang"))
(command (word "\"$SH\"") (word "-c") (word "'./no-shebang'"))
---

=== File in relative subdirectory and no shebang is executed
cd $TMP
mkdir -p test-no-shebang
echo 'echo hi' > test-no-shebang/script
chmod +x test-no-shebang/script
"$SH" -c 'test-no-shebang/script'
---
(command (word "cd") (word "$TMP"))
(command (word "mkdir") (word "-p") (word "test-no-shebang"))
(command (word "echo") (word "'echo hi'") (redirect ">" "test-no-shebang/script"))
(command (word "chmod") (word "+x") (word "test-no-shebang/script"))
(command (word "\"$SH\"") (word "-c") (word "'test-no-shebang/script'"))
---

=== $PATH lookup
cd $TMP
mkdir -p one two
echo 'echo one' > one/mycmd
echo 'echo two' > two/mycmd
chmod +x one/mycmd two/mycmd

PATH='one:two'
mycmd
---
(command (word "cd") (word "$TMP"))
(command (word "mkdir") (word "-p") (word "one") (word "two"))
(command (word "echo") (word "'echo one'") (redirect ">" "one/mycmd"))
(command (word "echo") (word "'echo two'") (redirect ">" "two/mycmd"))
(command (word "chmod") (word "+x") (word "one/mycmd") (word "two/mycmd"))
(command (word "PATH='one:two'"))
(command (word "mycmd"))
---

=== filling $PATH cache, then insert the same command earlier in cache
cd $TMP
PATH="one:two:$PATH"
mkdir -p one two
rm -f one/* two/*
echo 'echo two' > two/mycmd
chmod +x two/mycmd
mycmd

# Insert earlier in the path
echo 'echo one' > one/mycmd
chmod +x one/mycmd
mycmd  # still runs the cached 'two'

# clear the cache
hash -r
mycmd  # now it runs the new 'one'
---
(command (word "cd") (word "$TMP"))
(command (word "PATH=\"one:two:$PATH\""))
(command (word "mkdir") (word "-p") (word "one") (word "two"))
(command (word "rm") (word "-f") (word "one/*") (word "two/*"))
(command (word "echo") (word "'echo two'") (redirect ">" "two/mycmd"))
(command (word "chmod") (word "+x") (word "two/mycmd"))
(command (word "mycmd"))
(command (word "echo") (word "'echo one'") (redirect ">" "one/mycmd"))
(command (word "chmod") (word "+x") (word "one/mycmd"))
(command (word "mycmd"))
(command (word "hash") (word "-r"))
(command (word "mycmd"))
---

=== filling $PATH cache, then deleting command
cd $TMP
PATH="one:two:$PATH"
mkdir -p one two
rm -f one/mycmd two/mycmd

echo 'echo two' > two/mycmd
chmod +x two/mycmd
mycmd
echo status=$?

# Insert earlier in the path
echo 'echo one' > one/mycmd
chmod +x one/mycmd
rm two/mycmd
mycmd  # still runs the cached 'two'
echo status=$?
---
(command (word "cd") (word "$TMP"))
(command (word "PATH=\"one:two:$PATH\""))
(command (word "mkdir") (word "-p") (word "one") (word "two"))
(command (word "rm") (word "-f") (word "one/mycmd") (word "two/mycmd"))
(command (word "echo") (word "'echo two'") (redirect ">" "two/mycmd"))
(command (word "chmod") (word "+x") (word "two/mycmd"))
(command (word "mycmd"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "'echo one'") (redirect ">" "one/mycmd"))
(command (word "chmod") (word "+x") (word "one/mycmd"))
(command (word "rm") (word "two/mycmd"))
(command (word "mycmd"))
(command (word "echo") (word "status=$?"))
---

=== Non-executable on $PATH
# shells differ in whether they actually execve('one/cmd') and get EPERM

mkdir -p one two
PATH="one:two:$PATH"

rm -f one/mycmd two/mycmd
echo 'echo one' > one/mycmd
echo 'echo two' > two/mycmd

# only make the second one executable
chmod +x two/mycmd
mycmd
echo status=$?
---
(command (word "mkdir") (word "-p") (word "one") (word "two"))
(command (word "PATH=\"one:two:$PATH\""))
(command (word "rm") (word "-f") (word "one/mycmd") (word "two/mycmd"))
(command (word "echo") (word "'echo one'") (redirect ">" "one/mycmd"))
(command (word "echo") (word "'echo two'") (redirect ">" "two/mycmd"))
(command (word "chmod") (word "+x") (word "two/mycmd"))
(command (word "mycmd"))
(command (word "echo") (word "status=$?"))
---

=== hash without args prints the cache
whoami >/dev/null
hash
echo status=$?
---
(command (word "whoami") (redirect ">" "/dev/null"))
(command (word "hash"))
(command (word "echo") (word "status=$?"))
---

=== hash with args
hash whoami
echo status=$?
hash | grep -o /whoami  # prints it twice
hash _nonexistent_
echo status=$?
---
(command (word "hash") (word "whoami"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "hash")) (command (word "grep") (word "-o") (word "/whoami")))
(command (word "hash") (word "_nonexistent_"))
(command (word "echo") (word "status=$?"))
---

=== hash -r doesn't allow additional args
hash -r whoami >/dev/null  # avoid weird output with mksh
echo status=$?
---
(command (word "hash") (word "-r") (word "whoami") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== Executing command with same name as directory in PATH (#2429)
# Make the following directory structure. File type and permission bits are
# given on the left.
# [drwxr-xr-x]  _tmp
# +-- [drwxr-xr-x]  bin
# | \-- [-rwxr-xr-x]  hello
# +-- [drwxr-xr-x]  notbin
# | \-- [-rw-r--r--]  hello
# \-- [drwxr-xr-x]  dir
#     \-- [drwxr-xr-x]  hello
mkdir -p _tmp/bin
mkdir -p _tmp/bin2
mkdir -p _tmp/notbin
mkdir -p _tmp/dir/hello
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/notbin/hello
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/bin/hello
chmod +x _tmp/bin/hello

DIR=$PWD/_tmp/dir
BIN=$PWD/_tmp/bin
NOTBIN=$PWD/_tmp/notbin

# The command resolution will search the path for matching *files* (not
# directories) WITH the execute bit set.

# Should find executable hello right away and run it
PATH="$BIN:$PATH" hello
echo status=$?

hash -r  # Needed to clear the PATH cache

# Will see hello dir, skip it and then find&run the hello exe
PATH="$DIR:$BIN:$PATH" hello
echo status=$?

hash -r  # Needed to clear the PATH cache

# Will see hello (non-executable) file, skip it and then find&run the hello exe
PATH="$NOTBIN:$BIN:$PATH" hello
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp/bin"))
(command (word "mkdir") (word "-p") (word "_tmp/bin2"))
(command (word "mkdir") (word "-p") (word "_tmp/notbin"))
(command (word "mkdir") (word "-p") (word "_tmp/dir/hello"))
(command (word "printf") (word "'#!/usr/bin/env sh\\necho hi\\n'") (redirect ">" "_tmp/notbin/hello"))
(command (word "printf") (word "'#!/usr/bin/env sh\\necho hi\\n'") (redirect ">" "_tmp/bin/hello"))
(command (word "chmod") (word "+x") (word "_tmp/bin/hello"))
(command (word "DIR=$PWD/_tmp/dir"))
(command (word "BIN=$PWD/_tmp/bin"))
(command (word "NOTBIN=$PWD/_tmp/notbin"))
(command (word "PATH=\"$BIN:$PATH\"") (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "hash") (word "-r"))
(command (word "PATH=\"$DIR:$BIN:$PATH\"") (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "hash") (word "-r"))
(command (word "PATH=\"$NOTBIN:$BIN:$PATH\"") (word "hello"))
(command (word "echo") (word "status=$?"))
---

=== comment
echo foo #comment
---
(command (word "echo") (word "foo"))
---

=== not a comment without leading space x
echo foo#not_comment
---
(command (word "echo") (word "foo#not_comment"))
---

=== [[ glob matching, [[ has no glob expansion
[[ foo.py == *.py ]] && echo true
[[ foo.p  == *.py ]] || echo false
---
(and (cond (cond-binary "==" (cond-term "foo.py") (cond-term "*.py"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "==" (cond-term "foo.p") (cond-term "*.py"))) (command (word "echo") (word "false")))
---

=== [[ glob matching with escapes
[[ 'foo.*' == *."*" ]] && echo true
# note that the pattern arg to fnmatch should be '*.\*'
---
(and (cond (cond-binary "==" (cond-term "'foo.*'") (cond-term "*."*""))) (command (word "echo") (word "true")))
---

=== equality
[[ '*.py' == '*.py' ]] && echo true
[[ foo.py == '*.py' ]] || echo false
---
(and (cond (cond-binary "==" (cond-term "'*.py'") (cond-term "'*.py'"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "==" (cond-term "foo.py") (cond-term "'*.py'"))) (command (word "echo") (word "false")))
---

=== [[ glob matching with unquoted var
pat=*.py
[[ foo.py == $pat ]] && echo true
[[ foo.p  == $pat ]] || echo false
---
(command (word "pat=*.py"))
(and (cond (cond-binary "==" (cond-term "foo.py") (cond-term "$pat"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "==" (cond-term "foo.p") (cond-term "$pat"))) (command (word "echo") (word "false")))
---

=== [[ regex matching
# mksh doesn't have this syntax of regex matching.  I guess it comes from perl?
regex='.*\.py'
[[ foo.py =~ $regex ]] && echo true
[[ foo.p  =~ $regex ]] || echo false
---
(command (word "regex='.*\\.py'"))
(and (cond (cond-binary "=~" (cond-term "foo.py") (cond-term "$regex"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=~" (cond-term "foo.p") (cond-term "$regex"))) (command (word "echo") (word "false")))
---

=== [[ regex syntax error
# hm, it doesn't show any error, but it exits 2.
[[ foo.py =~ * ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "foo.py") (cond-term "*"))) (command (word "echo") (word "true")))
---

=== [[ has no word splitting
var='one two'
[[ 'one two' == $var ]] && echo true
---
(command (word "var='one two'"))
(and (cond (cond-binary "==" (cond-term "'one two'") (cond-term "$var"))) (command (word "echo") (word "true")))
---

=== [[ has quote joining
var='one two'
[[ 'one 'tw"o" == $var ]] && echo true
---
(command (word "var='one two'"))
(and (cond (cond-binary "==" (cond-term "'one 'tw"o"") (cond-term "$var"))) (command (word "echo") (word "true")))
---

=== [[ empty string is false
[[ 'a' ]] && echo true
[[ ''  ]] || echo false
---
(and (cond (cond-unary "-n" (cond-term "'a'"))) (command (word "echo") (word "true")))
(or (cond (cond-unary "-n" (cond-term "''"))) (command (word "echo") (word "false")))
---

=== && chain
[[ t && t && '' ]] || echo false
---
(or (cond (cond-and (cond-unary "-n" (cond-term "t")) (cond-and (cond-unary "-n" (cond-term "t")) (cond-unary "-n" (cond-term "''"))))) (command (word "echo") (word "false")))
---

=== || chain
[[ '' || '' || t ]] && echo true
---
(and (cond (cond-or (cond-unary "-n" (cond-term "''")) (cond-or (cond-unary "-n" (cond-term "''")) (cond-unary "-n" (cond-term "t"))))) (command (word "echo") (word "true")))
---

=== [[ compound expressions
# Notes on whitespace:
# - 1 and == need space seprating them, but ! and ( don't.
# - [[ needs whitesapce after it, but ]] doesn't need whitespace before it!
[[ ''||! (1 == 2)&&(2 == 2)]] && echo true
---
(and (cond (cond-or (cond-unary "-n" (cond-term "''")) (cond-and (cond-expr (cond-binary "==" (cond-term "1") (cond-term "2"))) (cond-expr (cond-binary "==" (cond-term "2") (cond-term "2")))))) (command (word "echo") (word "true")))
---

=== precedence of && and || inside [[
[[ True || '' && '' ]] && echo true
---
(and (cond (cond-or (cond-unary "-n" (cond-term "True")) (cond-and (cond-unary "-n" (cond-term "''")) (cond-unary "-n" (cond-term "''"))))) (command (word "echo") (word "true")))
---

=== precedence of && and || in a command context
if test True || test '' && test ''; then
  echo YES
else
  echo "NO precedence"
fi
---
(if (and (or (command (word "test") (word "True")) (command (word "test") (word "''"))) (command (word "test") (word "''"))) (command (word "echo") (word "YES")) (command (word "echo") (word "\"NO precedence\"")))
---

=== Octal literals with -eq
shopt -u strict_arith || true
decimal=15
octal=017   # = 15 (decimal)
[[ $decimal -eq $octal ]] && echo true
[[ $decimal -eq ZZZ$octal ]] || echo false
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "decimal=15"))
(command (word "octal=017"))
(and (cond (cond-binary "-eq" (cond-term "$decimal") (cond-term "$octal"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "-eq" (cond-term "$decimal") (cond-term "ZZZ$octal"))) (command (word "echo") (word "false")))
---

=== Hex literals with -eq
shopt -u strict_arith || true
decimal=15
hex=0x0f    # = 15 (decimal)
[[ $decimal -eq $hex ]] && echo true
[[ $decimal -eq ZZZ$hex ]] || echo false
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "decimal=15"))
(command (word "hex=0x0f"))
(and (cond (cond-binary "-eq" (cond-term "$decimal") (cond-term "$hex"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "-eq" (cond-term "$decimal") (cond-term "ZZZ$hex"))) (command (word "echo") (word "false")))
---

=== > on strings
# NOTE: < doesn't need space, even though == does?  That's silly.
[[ b>a ]] && echo true
[[ b<a ]] || echo false
---
(and (cond (cond-binary ">" (cond-term "b") (cond-term "a"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "<" (cond-term "b") (cond-term "a"))) (command (word "echo") (word "false")))
---

=== != on strings
# NOTE: b!=a does NOT work
[[ b != a ]] && echo true
[[ a != a ]] || echo false
---
(and (cond (cond-binary "!=" (cond-term "b") (cond-term "a"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "!=" (cond-term "a") (cond-term "a"))) (command (word "echo") (word "false")))
---

=== -eq on strings
# This is lame behavior: it does a conversion to 0 first for any string
shopt -u strict_arith || true
[[ a -eq a ]] && echo true
[[ a -eq b ]] && echo true
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(and (cond (cond-binary "-eq" (cond-term "a") (cond-term "a"))) (command (word "echo") (word "true")))
(and (cond (cond-binary "-eq" (cond-term "a") (cond-term "b"))) (command (word "echo") (word "true")))
---

=== [[ compare with literal -f (compare with test-builtin.test.sh)
var=-f
[[ $var == -f ]] && echo true
[[ '-f' == $var ]] && echo true
---
(command (word "var=-f"))
(and (cond (cond-binary "==" (cond-term "$var") (cond-term "-f"))) (command (word "echo") (word "true")))
(and (cond (cond-binary "==" (cond-term "'-f'") (cond-term "$var"))) (command (word "echo") (word "true")))
---

=== [[ with unquoted empty var (compare with test-builtin.test.sh)
empty=''
[[ $empty == '' ]] && echo true
---
(command (word "empty=''"))
(and (cond (cond-binary "==" (cond-term "$empty") (cond-term "''"))) (command (word "echo") (word "true")))
---

=== [[ at runtime doesn't work
dbracket=[[
$dbracket foo == foo ]]
---
(command (word "dbracket=[["))
(command (word "$dbracket") (word "foo") (word "==") (word "foo") (word "]]"))
---

=== [[ with env prefix doesn't work
FOO=bar [[ foo == foo ]]
---
(command (word "FOO=bar") (word "[[") (word "foo") (word "==") (word "foo") (word "]]"))
---

=== [[ over multiple lines is OK
# Hm it seems you can't split anywhere?
[[ foo == foo
&& bar == bar
]] && echo true
---
(and (cond (cond-and (cond-binary "==" (cond-term "foo") (cond-term "foo")) (cond-binary "==" (cond-term "bar") (cond-term "bar")))) (command (word "echo") (word "true")))
---

=== User array compared to "$@" (broken unless shopt -s strict_array)
# Both are coerced to string!  It treats it more like an  UNQUOTED ${a[@]}.

a=('1 3' 5)
b=(1 2 3)
set -- 1 '3 5'
[[ "$@" = "${a[@]}" ]] && echo true
[[ "$@" = "${b[@]}" ]] || echo false
---
(command (word "a=('1 3' 5)"))
(command (word "b=(1 2 3)"))
(command (word "set") (word "--") (word "1") (word "'3 5'"))
(and (cond (cond-binary "=" (cond-term ""$@"") (cond-term ""${a[@]}""))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=" (cond-term ""$@"") (cond-term ""${b[@]}""))) (command (word "echo") (word "false")))
---

=== Array coerces to string (shopt -s strict_array to disallow)
a=('1 3' 5)
[[ '1 3 5' = "${a[@]}" ]] && echo true
[[ '1 3 4' = "${a[@]}" ]] || echo false
---
(command (word "a=('1 3' 5)"))
(and (cond (cond-binary "=" (cond-term "'1 3 5'") (cond-term ""${a[@]}""))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=" (cond-term "'1 3 4'") (cond-term ""${a[@]}""))) (command (word "echo") (word "false")))
---

=== (( array1 == array2 )) doesn't work
a=('1 3' 5)
b=('1 3' 5)
c=('1' '3 5')
d=('1' '3 6')

# shells EXPAND a and b first
(( a == b ))
echo status=$?

(( a == c ))
echo status=$?

(( a == d ))
echo status=$?
---
(command (word "a=('1 3' 5)"))
(command (word "b=('1 3' 5)"))
(command (word "c=('1' '3 5')"))
(command (word "d=('1' '3 6')"))
(arith (word " a == b "))
(command (word "echo") (word "status=$?"))
(arith (word " a == c "))
(command (word "echo") (word "status=$?"))
(arith (word " a == d "))
(command (word "echo") (word "status=$?"))
---

=== Quotes don't matter in comparison
[[ '3' = 3 ]] && echo true
[[ '3' -eq 3 ]] && echo true
---
(and (cond (cond-binary "=" (cond-term "'3'") (cond-term "3"))) (command (word "echo") (word "true")))
(and (cond (cond-binary "-eq" (cond-term "'3'") (cond-term "3"))) (command (word "echo") (word "true")))
---

=== -eq does dynamic arithmetic parsing (not supported in OSH)
[[ 1+2 -eq 3 ]] && echo true
expr='1+2'
[[ $expr -eq 3 ]] && echo true  # must be dynamically parsed
---
(and (cond (cond-binary "-eq" (cond-term "1+2") (cond-term "3"))) (command (word "echo") (word "true")))
(command (word "expr='1+2'"))
(and (cond (cond-binary "-eq" (cond-term "$expr") (cond-term "3"))) (command (word "echo") (word "true")))
---

=== -eq coercion produces weird results
shopt -u strict_arith || true
[[ '' -eq 0 ]] && echo true
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(and (cond (cond-binary "-eq" (cond-term "''") (cond-term "0"))) (command (word "echo") (word "true")))
---

=== [[ '(' ]] is treated as literal
[[ '(' ]]
echo status=$?
---
(cond (cond-unary "-n" (cond-term "'('")))
(command (word "echo") (word "status=$?"))
---

=== empty ! is treated as literal
[[ '!' ]]
echo status=$?
---
(cond (cond-unary "-n" (cond-term "'!'")))
(command (word "echo") (word "status=$?"))
---

=== [[ -z '>' ]]
[[ -z '>' ]] || echo false  # -z is operator
---
(or (cond (cond-unary "-z" (cond-term "'>'"))) (command (word "echo") (word "false")))
---

=== test whether ']]' is empty
[[ ']]' ]]
echo status=$?
---
(cond (cond-unary "-n" (cond-term "']]'")))
(command (word "echo") (word "status=$?"))
---

=== tilde expansion in [[
HOME=/home/bob
[[ ~ == /home/bob ]]
echo status=$?

[[ ~ == */bob ]]
echo status=$?

[[ ~ == */z ]]
echo status=$?
---
(command (word "HOME=/home/bob"))
(cond (cond-binary "==" (cond-term "~") (cond-term "/home/bob")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "==" (cond-term "~") (cond-term "*/bob")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "==" (cond-term "~") (cond-term "*/z")))
(command (word "echo") (word "status=$?"))
---

=== more tilde expansion
[[ ~ ]]
echo status=$?
HOME=''
[[ ~ ]]
echo status=$?
[[ -n ~ ]]
echo unary=$?

[[ ~ == ~ ]]
echo status=$?

[[ $HOME == ~ ]]
echo fnmatch=$?
[[ ~ == $HOME ]]
echo fnmatch=$?
---
(cond (cond-unary "-n" (cond-term "~")))
(command (word "echo") (word "status=$?"))
(command (word "HOME=''"))
(cond (cond-unary "-n" (cond-term "~")))
(command (word "echo") (word "status=$?"))
(cond (cond-unary "-n" (cond-term "~")))
(command (word "echo") (word "unary=$?"))
(cond (cond-binary "==" (cond-term "~") (cond-term "~")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "==" (cond-term "$HOME") (cond-term "~")))
(command (word "echo") (word "fnmatch=$?"))
(cond (cond-binary "==" (cond-term "~") (cond-term "$HOME")))
(command (word "echo") (word "fnmatch=$?"))
---

=== tilde expansion with =~ (confusing)
case $SH in mksh) exit ;; esac

HOME=foo
[[ ~ =~ $HOME ]]
echo regex=$?
[[ $HOME =~ ~ ]]
echo regex=$?

HOME='^a$'  # looks like regex
[[ ~ =~ $HOME ]]
echo regex=$?
[[ $HOME =~ ~ ]]
echo regex=$?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "HOME=foo"))
(cond (cond-binary "=~" (cond-term "~") (cond-term "$HOME")))
(command (word "echo") (word "regex=$?"))
(cond (cond-binary "=~" (cond-term "$HOME") (cond-term "~")))
(command (word "echo") (word "regex=$?"))
(command (word "HOME='^a$'"))
(cond (cond-binary "=~" (cond-term "~") (cond-term "$HOME")))
(command (word "echo") (word "regex=$?"))
(cond (cond-binary "=~" (cond-term "$HOME") (cond-term "~")))
(command (word "echo") (word "regex=$?"))
---

=== [[ ]] with redirect
[[ $(stdout_stderr.py) == STDOUT ]] 2>$TMP/x.txt
echo $?
echo --
cat $TMP/x.txt
---
(cond (cond-binary "==" (cond-term "$(stdout_stderr.py)") (cond-term "STDOUT"))) (redirect ">" "$TMP/x.txt")
(command (word "echo") (word "$?"))
(command (word "echo") (word "--"))
(command (word "cat") (word "$TMP/x.txt"))
---

=== special chars
[[ ^ == ^ ]]
echo caret $?
[[ '!' == ! ]]
echo bang $?
---
(cond (cond-binary "==" (cond-term "^") (cond-term "^")))
(command (word "echo") (word "caret") (word "$?"))
(cond (cond-binary "==" (cond-term "'!'") (cond-term "!")))
(command (word "echo") (word "bang") (word "$?"))
---

=== \(\) in pattern (regression)
if [[ 'foo()' == *\(\) ]]; then echo match1; fi
if [[ 'foo()' == *'()' ]]; then echo match2; fi
if [[ 'foo()' == '*()' ]]; then echo match3; fi

shopt -s extglob

if [[ 'foo()' == *\(\) ]]; then echo match1; fi
if [[ 'foo()' == *'()' ]]; then echo match2; fi
if [[ 'foo()' == '*()' ]]; then echo match3; fi
---
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "*\(\)"))) (command (word "echo") (word "match1")))
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "*'()'"))) (command (word "echo") (word "match2")))
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "'*()'"))) (command (word "echo") (word "match3")))
(command (word "shopt") (word "-s") (word "extglob"))
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "*\(\)"))) (command (word "echo") (word "match1")))
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "*'()'"))) (command (word "echo") (word "match2")))
(if (cond (cond-binary "==" (cond-term "'foo()'") (cond-term "'*()'"))) (command (word "echo") (word "match3")))
---

=== negative numbers - zero, decimal, octal, hex, base N
[[ -0 -eq 0 ]]; echo zero=$?

[[ -42 -eq -42 ]]; echo decimal=$?

# note: mksh doesn't do octal conversion
[[ -0123 -eq -83 ]]; echo octal=$?

[[ -0xff -eq -255 ]]; echo hex=$?

[[ -64#a -eq -10 ]]; echo baseN=$?
---
(semi (cond (cond-binary "-eq" (cond-term "-0") (cond-term "0"))) (command (word "echo") (word "zero=$?")))
(semi (cond (cond-binary "-eq" (cond-term "-42") (cond-term "-42"))) (command (word "echo") (word "decimal=$?")))
(semi (cond (cond-binary "-eq" (cond-term "-0123") (cond-term "-83"))) (command (word "echo") (word "octal=$?")))
(semi (cond (cond-binary "-eq" (cond-term "-0xff") (cond-term "-255"))) (command (word "echo") (word "hex=$?")))
(semi (cond (cond-binary "-eq" (cond-term "-64#a") (cond-term "-10"))) (command (word "echo") (word "baseN=$?")))
---

=== xz package: dirprefix="${line##*([}"
# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/alpine.20xz.20-.20.22.24.7Bline.23.23*.28.5B.7D.22.20interpreted.20as.20extended.20glob/with/519718284

# NOTE: spec/extglob-match shows that bash respects it
#
# echo 'strip ##' ${x##@(foo)}

shopt -s extglob


dirprefix="${line##*([}"
echo "-$dirprefix-"

# Now try with real data
line='*([foo'
dirprefix="${line##*([}"
echo "-$dirprefix-"
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "dirprefix=\"${line##*([}\""))
(command (word "echo") (word "\"-$dirprefix-\""))
(command (word "line='*([foo'"))
(command (word "dirprefix=\"${line##*([}\""))
(command (word "echo") (word "\"-$dirprefix-\""))
---

=== !( as negation and subshell versus extended glob - #2463
# @extglob
have_icu_uc=false
have_icu_i18n=false

if !($have_icu_uc && $have_icu_i18n); then
  echo one
fi
echo two
---
(command (word "have_icu_uc=false"))
(command (word "have_icu_i18n=false"))
(if (command (word "!($have_icu_uc && $have_icu_i18n)")) (command (word "echo") (word "one")))
(command (word "echo") (word "two"))
---

=== Changing PATH will invalidate PATH cache
mkdir -p _tmp/bin
mkdir -p _tmp/bin2
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/bin/hello
printf '#!/usr/bin/env sh\necho hey\n' >_tmp/bin2/hello
chmod +x _tmp/bin/hello
chmod +x _tmp/bin2/hello

BIN=$PWD/_tmp/bin
BIN2=$PWD/_tmp/bin2

# Will find _tmp/bin/hello
PATH="$BIN:$PATH" hello
echo status=$?

# Should invalidate cache and then find _tmp/bin2/hello
PATH="$BIN2:$PATH" hello
echo status=$?

# Same when PATH= and export PATH=
PATH="$BIN:$PATH"
hello
echo status=$?
PATH="$BIN2:$PATH"
hello
echo status=$?

export PATH="$BIN:$PATH"
hello
echo status=$?
export PATH="$BIN2:$PATH"
hello
echo status=$?
---
(command (word "mkdir") (word "-p") (word "_tmp/bin"))
(command (word "mkdir") (word "-p") (word "_tmp/bin2"))
(command (word "printf") (word "'#!/usr/bin/env sh\\necho hi\\n'") (redirect ">" "_tmp/bin/hello"))
(command (word "printf") (word "'#!/usr/bin/env sh\\necho hey\\n'") (redirect ">" "_tmp/bin2/hello"))
(command (word "chmod") (word "+x") (word "_tmp/bin/hello"))
(command (word "chmod") (word "+x") (word "_tmp/bin2/hello"))
(command (word "BIN=$PWD/_tmp/bin"))
(command (word "BIN2=$PWD/_tmp/bin2"))
(command (word "PATH=\"$BIN:$PATH\"") (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "PATH=\"$BIN2:$PATH\"") (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "PATH=\"$BIN:$PATH\""))
(command (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "PATH=\"$BIN2:$PATH\""))
(command (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "export") (word "PATH=\"$BIN:$PATH\""))
(command (word "hello"))
(command (word "echo") (word "status=$?"))
(command (word "export") (word "PATH=\"$BIN2:$PATH\""))
(command (word "hello"))
(command (word "echo") (word "status=$?"))
---

=== builtin cat crashes a subshell (#2530)
((/usr/bin/cat </dev/zero; echo $? >&7) | true) 7>&1

((cat </dev/zero; echo $? >&7) | true) 7>&1
---
(subshell (pipe (subshell (semi (command (word "/usr/bin/cat") (redirect "<" "/dev/zero")) (command (word "echo") (word "$?") (redirect ">&" 7)))) (command (word "true")))) (redirect ">&" 1)
(subshell (pipe (subshell (semi (command (word "cat") (redirect "<" "/dev/zero")) (command (word "echo") (word "$?") (redirect ">&" 7)))) (command (word "true")))) (redirect ">&" 1)
---

=== (( )) result
(( 1 )) && echo True
(( 0 )) || echo False
---
(and (arith (word " 1 ")) (command (word "echo") (word "True")))
(or (arith (word " 0 ")) (command (word "echo") (word "False")))
---

=== negative number is true
(( -1 )) && echo True
---
(and (arith (word " -1 ")) (command (word "echo") (word "True")))
---

=== (( )) in if statement
if (( 3 > 2)); then
  echo True
fi
---
(if (arith (word " 3 > 2")) (command (word "echo") (word "True")))
---

=== (( ))
# What is the difference with this and let?  One difference: spaces are allowed.
(( x = 1 ))
(( y = x + 2 ))
echo $x $y
---
(arith (word " x = 1 "))
(arith (word " y = x + 2 "))
(command (word "echo") (word "$x") (word "$y"))
---

=== (( )) with arrays
a=(4 5 6)
(( sum = a[0] + a[1] + a[2] ))
echo $sum
---
(command (word "a=(4 5 6)"))
(arith (word " sum = a[0] + a[1] + a[2] "))
(command (word "echo") (word "$sum"))
---

=== (( )) with error
(( a = 0 )) || echo false
(( b = 1 )) && echo true
(( c = -1 )) && echo true
echo $((a + b + c))
---
(or (arith (word " a = 0 ")) (command (word "echo") (word "false")))
(and (arith (word " b = 1 ")) (command (word "echo") (word "true")))
(and (arith (word " c = -1 ")) (command (word "echo") (word "true")))
(command (word "echo") (word "$((a + b + c))"))
---

=== bash and mksh: V in (( a[K] = V )) gets coerced to integer
shopt -u strict_arith || true
K=key
V=value
typeset -a a
(( a[K] = V ))

# not there!
echo a[\"key\"]=${a[$K]}

echo keys = ${!a[@]}
echo values = ${a[@]}
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "K=key"))
(command (word "V=value"))
(command (word "typeset") (word "-a") (word "a"))
(arith (word " a[K] = V "))
(command (word "echo") (word "a[\\\"key\\\"]=${a[$K]}"))
(command (word "echo") (word "keys") (word "=") (word "${!a[@]}"))
(command (word "echo") (word "values") (word "=") (word "${a[@]}"))
---

=== bash: K in (( A[K] = V )) is a constant string
K=5
V=42
typeset -A A
(( A[K] = V ))

echo A["5"]=${A["5"]}
echo keys = ${!A[@]}
echo values = ${A[@]}
---
(command (word "K=5"))
(command (word "V=42"))
(command (word "typeset") (word "-A") (word "A"))
(arith (word " A[K] = V "))
(command (word "echo") (word "A[\"5\"]=${A[\"5\"]}"))
(command (word "echo") (word "keys") (word "=") (word "${!A[@]}"))
(command (word "echo") (word "values") (word "=") (word "${A[@]}"))
---

=== BUG: (( V = A[K] )) doesn't retrieve the right value
typeset -A A
K=5
V=42
A["$K"]=$V
A["K"]=oops
A[K]=oops2

# We don't neither 42 nor "oops".  Bad!
(( V = A[K] ))

echo V=$V
---
(command (word "typeset") (word "-A") (word "A"))
(command (word "K=5"))
(command (word "V=42"))
(command (word "A[\"$K\"]=$V"))
(command (word "A[\"K\"]=oops"))
(command (word "A[K]=oops2"))
(arith (word " V = A[K] "))
(command (word "echo") (word "V=$V"))
---

=== bash: V in (( A["K"] = V )) gets coerced to integer
shopt -u strict_arith || true
K=key
V=value
typeset -A A || exit 1
(( A["K"] = V ))

# not there!
echo A[\"key\"]=${A[$K]}

echo keys = ${!A[@]}
echo values = ${A[@]}
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "K=key"))
(command (word "V=value"))
(or (command (word "typeset") (word "-A") (word "A")) (command (word "exit") (word "1")))
(arith (word " A[\"K\"] = V "))
(command (word "echo") (word "A[\\\"key\\\"]=${A[$K]}"))
(command (word "echo") (word "keys") (word "=") (word "${!A[@]}"))
(command (word "echo") (word "values") (word "=") (word "${A[@]}"))
---

=== literal strings inside (( ))
declare -A A
A['x']=42
(( x = A['x'] ))
(( A['y'] = 'y' ))  # y is a variable, gets coerced to 0
echo $x ${A['y']}
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A['x']=42"))
(arith (word " x = A['x'] "))
(arith (word " A['y'] = 'y' "))
(command (word "echo") (word "$x") (word "${A['y']}"))
---

=== (( )) with redirect
(( a = $(stdout_stderr.py 42) + 10 )) 2>$TMP/x.txt
echo $a
echo --
cat $TMP/x.txt
---
(arith (word " a = $(stdout_stderr.py 42) + 10 ")) (redirect ">" "$TMP/x.txt")
(command (word "echo") (word "$a"))
(command (word "echo") (word "--"))
(command (word "cat") (word "$TMP/x.txt"))
---

=== Assigning whole raray (( b = a ))
a=(4 5 6)
(( b = a ))

echo "${a[@]}"

# OSH doesn't like this
echo "${b[@]}"
---
(command (word "a=(4 5 6)"))
(arith (word " b = a "))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "echo") (word "\"${b[@]}\""))
---

=== set associative array
declare -A A=(['foo']=bar ['spam']=42)
(( x = A['spam'] ))
echo $x
---
(command (word "declare") (word "-A") (word "A=(['foo']=bar ['spam']=42)"))
(arith (word " x = A['spam'] "))
(command (word "echo") (word "$x"))
---

=== Example of incrementing associative array entry with var key (ble.sh)
declare -A A=(['foo']=42)
key='foo'

# note: in bash, (( A[\$key] += 1 )) works the same way.

set -- 1 2
(( A[$key] += $2 ))

echo foo=${A['foo']}
---
(command (word "declare") (word "-A") (word "A=(['foo']=42)"))
(command (word "key='foo'"))
(command (word "set") (word "--") (word "1") (word "2"))
(arith (word " A[$key] += $2 "))
(command (word "echo") (word "foo=${A['foo']}"))
---

=== Empty case/esac
case foo in
esac
echo empty
---
(case (word "foo"))
(command (word "echo") (word "empty"))
---

=== Truncating 'exit' status
$SH -c 'exit 255'
echo status=$?

$SH -c 'exit 256'
echo status=$?

$SH -c 'exit 257'
echo status=$?

echo ===

$SH -c 'exit -1'
echo status=$?

$SH -c 'exit -2'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'exit 255'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'exit 256'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'exit 257'"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "==="))
(command (word "$SH") (word "-c") (word "'exit -1'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'exit -2'"))
(command (word "echo") (word "status=$?"))
---

=== Truncating 'return' status
f() { return 255; }; f
echo status=$?

f() { return 256; }; f
echo status=$?

f() { return 257; }; f
echo status=$?

echo ===

f() { return -1; }; f
echo status=$?

f() { return -2; }; f
echo status=$?
---
(semi (function "f" (brace-group (command (word "return") (word "255")))) (command (word "f")))
(command (word "echo") (word "status=$?"))
(semi (function "f" (brace-group (command (word "return") (word "256")))) (command (word "f")))
(command (word "echo") (word "status=$?"))
(semi (function "f" (brace-group (command (word "return") (word "257")))) (command (word "f")))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "==="))
(semi (function "f" (brace-group (command (word "return") (word "-1")))) (command (word "f")))
(command (word "echo") (word "status=$?"))
(semi (function "f" (brace-group (command (word "return") (word "-2")))) (command (word "f")))
(command (word "echo") (word "status=$?"))
---

=== subshell OverflowError https://github.com/oilshell/oil/issues/996
# We have to capture stderr here 

filter_err() {
  # check for bash/dash/mksh messages, and unwanted Python OverflowError
  egrep -o 'Illegal number|bad number|return: can only|expected a small integer|OverflowError'
  return 0
}

# true; disables subshell optimization!

# exit status too big, but integer isn't
$SH -c 'true; ( return 2147483647; )' 2>err.txt
echo status=$?
cat err.txt | filter_err

# now integer is too big
$SH -c 'true; ( return 2147483648; )' 2> err.txt
echo status=$?
cat err.txt | filter_err

# even bigger
$SH -c 'true; ( return 2147483649; )' 2> err.txt
echo status=$?
cat err.txt | filter_err

echo
echo '--- negative ---'

# negative vlaues
$SH -c 'true; ( return -2147483648; )' 2>err.txt
echo status=$?
cat err.txt | filter_err

# negative vlaues
$SH -c 'true; ( return -2147483649; )' 2>err.txt
echo status=$?
cat err.txt | filter_err
---
(function "filter_err" (brace-group (semi (command (word "egrep") (word "-o") (word "'Illegal number|bad number|return: can only|expected a small integer|OverflowError'")) (command (word "return") (word "0")))))
(command (word "$SH") (word "-c") (word "'true; ( return 2147483647; )'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "$SH") (word "-c") (word "'true; ( return 2147483648; )'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "$SH") (word "-c") (word "'true; ( return 2147483649; )'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "echo"))
(command (word "echo") (word "'--- negative ---'"))
(command (word "$SH") (word "-c") (word "'true; ( return -2147483648; )'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "$SH") (word "-c") (word "'true; ( return -2147483649; )'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
---

=== func subshell OverflowError https://github.com/oilshell/oil/issues/996
# We have to capture stderr here 

filter_err() {
  # check for bash/dash/mksh messages, and unwanted Python OverflowError
  egrep -o 'Illegal number|bad number|return: can only|expected a small integer|OverflowError'
  return 0
}

# exit status too big, but integer isn't
$SH -c 'f() ( return 2147483647; ); f' 2>err.txt
echo status=$?
cat err.txt | filter_err

# now integer is too big
$SH -c 'f() ( return 2147483648; ); f' 2> err.txt
echo status=$?
cat err.txt | filter_err

# even bigger
$SH -c 'f() ( return 2147483649; ); f' 2> err.txt
echo status=$?
cat err.txt | filter_err
---
(function "filter_err" (brace-group (semi (command (word "egrep") (word "-o") (word "'Illegal number|bad number|return: can only|expected a small integer|OverflowError'")) (command (word "return") (word "0")))))
(command (word "$SH") (word "-c") (word "'f() ( return 2147483647; ); f'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "$SH") (word "-c") (word "'f() ( return 2147483648; ); f'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
(command (word "$SH") (word "-c") (word "'f() ( return 2147483649; ); f'") (redirect ">" "err.txt"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "cat") (word "err.txt")) (command (word "filter_err")))
---

=== If empty command
if ''; then echo TRUE; else echo FALSE; fi
---
(if (command (word "''")) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== If subshell true
if `true`; then echo TRUE; else echo FALSE; fi
---
(if (command (word "`true`")) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== If subshell true WITH OUTPUT is different
if `sh -c 'echo X; true'`; then echo TRUE; else echo FALSE; fi
---
(if (command (word "`sh -c 'echo X; true'`")) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== If subshell true WITH ARGUMENT
if `true` X; then echo TRUE; else echo FALSE; fi
---
(if (command (word "`true`") (word "X")) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== If subshell false -- exit code is propagated in a weird way (strict_argv prevents)
if `false`; then echo TRUE; else echo FALSE; fi
---
(if (command (word "`false`")) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== Exit code when command sub evaluates to empty str, e.g. `false` (#2416)
# OSH had a bug here
`true`; echo $?
`false`; echo $?
$(true); echo $?
$(false); echo $?
echo ---

# OSH and others agree on these
eval true; echo $?
eval false; echo $?
`echo true`; echo $?
`echo false`; echo $?
---
(semi (command (word "`true`")) (command (word "echo") (word "$?")))
(semi (command (word "`false`")) (command (word "echo") (word "$?")))
(semi (command (word "$(true)")) (command (word "echo") (word "$?")))
(semi (command (word "$(false)")) (command (word "echo") (word "$?")))
(command (word "echo") (word "---"))
(semi (command (word "eval") (word "true")) (command (word "echo") (word "$?")))
(semi (command (word "eval") (word "false")) (command (word "echo") (word "$?")))
(semi (command (word "`echo true`")) (command (word "echo") (word "$?")))
(semi (command (word "`echo false`")) (command (word "echo") (word "$?")))
---

=== More test cases with empty argv
true $(false)
echo status=$?

$(exit 42)
echo status=$?

$(exit 42) $(exit 43)
echo status=$?
---
(command (word "true") (word "$(false)"))
(command (word "echo") (word "status=$?"))
(command (word "$(exit 42)"))
(command (word "echo") (word "status=$?"))
(command (word "$(exit 42)") (word "$(exit 43)"))
(command (word "echo") (word "status=$?"))
---

=== Length of length of ARGS!
fun() { echo ${##}; }
fun 0 1 2 3 4 5 6 7 8 
---
(function "fun" (brace-group (command (word "echo") (word "${##}"))))
(command (word "fun") (word "0") (word "1") (word "2") (word "3") (word "4") (word "5") (word "6") (word "7") (word "8"))
---

=== Length of length of ARGS!  2 digit
fun() { echo ${##}; }
fun 0 1 2 3 4 5 6 7 8 9
---
(function "fun" (brace-group (command (word "echo") (word "${##}"))))
(command (word "fun") (word "0") (word "1") (word "2") (word "3") (word "4") (word "5") (word "6") (word "7") (word "8") (word "9"))
---

=== Is \r considered whitespace?
echo -e 'echo\rTEST' > myscript
$SH myscript
---
(command (word "echo") (word "-e") (word "'echo\\rTEST'") (redirect ">" "myscript"))
(command (word "$SH") (word "myscript"))
---

=== readonly +
# dash and bash validate this!  But not set +

readonly + >/dev/null
echo status=$?
---
(command (word "readonly") (word "+") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== set +
set + >/dev/null
echo status=$?
---
(command (word "set") (word "+") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== ${FUNCNAME[@]} array
g() {
  argv.py "${FUNCNAME[@]}"
}
f() {
  argv.py "${FUNCNAME[@]}"
  g
  argv.py "${FUNCNAME[@]}"
}
f
---
(function "g" (brace-group (command (word "argv.py") (word "\"${FUNCNAME[@]}\""))))
(function "f" (brace-group (semi (semi (command (word "argv.py") (word "\"${FUNCNAME[@]}\"")) (command (word "g"))) (command (word "argv.py") (word "\"${FUNCNAME[@]}\"")))))
(command (word "f"))
---

=== FUNCNAME with source (scalar or array)
cd $REPO_ROOT

# Comments on bash quirk:
# https://github.com/oilshell/oil/pull/656#issuecomment-599162211

f() {
  . spec/testdata/echo-funcname.sh
}
g() {
  f
}

g
echo -----

. spec/testdata/echo-funcname.sh
echo -----

argv.py "${FUNCNAME[@]}"

# Show bash inconsistency.  FUNCNAME doesn't behave like a normal array.
case $SH in 
  (bash)
    echo -----
    a=('A')
    argv.py '  @' "${a[@]}"
    argv.py '  0' "${a[0]}"
    argv.py '${}' "${a}"
    argv.py '  $' "$a"
    ;;
esac
---
(command (word "cd") (word "$REPO_ROOT"))
(function "f" (brace-group (command (word ".") (word "spec/testdata/echo-funcname.sh"))))
(function "g" (brace-group (command (word "f"))))
(command (word "g"))
(command (word "echo") (word "-----"))
(command (word ".") (word "spec/testdata/echo-funcname.sh"))
(command (word "echo") (word "-----"))
(command (word "argv.py") (word "\"${FUNCNAME[@]}\""))
(case (word "$SH") (pattern ((word "bash")) (semi (semi (semi (semi (semi (command (word "echo") (word "-----")) (command (word "a=('A')"))) (command (word "argv.py") (word "'  @'") (word "\"${a[@]}\""))) (command (word "argv.py") (word "'  0'") (word "\"${a[0]}\""))) (command (word "argv.py") (word "'${}'") (word "\"${a}\""))) (command (word "argv.py") (word "'  $'") (word "\"$a\"")))))
---

=== BASH_SOURCE and BASH_LINENO scalar or array (e.g. for virtualenv)
cd $REPO_ROOT

# https://github.com/pypa/virtualenv/blob/master/virtualenv_embedded/activate.sh
# https://github.com/akinomyoga/ble.sh/blob/6f6c2e5/ble.pp#L374

argv.py "$BASH_SOURCE"  # SimpleVarSub
argv.py "${BASH_SOURCE}"  # BracedVarSub
argv.py "$BASH_LINENO"  # SimpleVarSub
argv.py "${BASH_LINENO}"  # BracedVarSub
argv.py "$FUNCNAME"  # SimpleVarSub
argv.py "${FUNCNAME}"  # BracedVarSub
echo __
source spec/testdata/bash-source-string.sh
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "argv.py") (word "\"$BASH_SOURCE\""))
(command (word "argv.py") (word "\"${BASH_SOURCE}\""))
(command (word "argv.py") (word "\"$BASH_LINENO\""))
(command (word "argv.py") (word "\"${BASH_LINENO}\""))
(command (word "argv.py") (word "\"$FUNCNAME\""))
(command (word "argv.py") (word "\"${FUNCNAME}\""))
(command (word "echo") (word "__"))
(command (word "source") (word "spec/testdata/bash-source-string.sh"))
---

=== ${FUNCNAME} with prefix/suffix operators
check() {
  argv.py "${#FUNCNAME}"
  argv.py "${FUNCNAME::1}"
  argv.py "${FUNCNAME:1}"
}
check
---
(function "check" (brace-group (semi (semi (command (word "argv.py") (word "\"${#FUNCNAME}\"")) (command (word "argv.py") (word "\"${FUNCNAME::1}\""))) (command (word "argv.py") (word "\"${FUNCNAME:1}\"")))))
(command (word "check"))
---

=== operators on FUNCNAME
check() {
  argv.py "${FUNCNAME}"
  argv.py "${#FUNCNAME}"
  argv.py "${FUNCNAME::1}"
  argv.py "${FUNCNAME:1}"
}
check
---
(function "check" (brace-group (semi (semi (semi (command (word "argv.py") (word "\"${FUNCNAME}\"")) (command (word "argv.py") (word "\"${#FUNCNAME}\""))) (command (word "argv.py") (word "\"${FUNCNAME::1}\""))) (command (word "argv.py") (word "\"${FUNCNAME:1}\"")))))
(command (word "check"))
---

=== ${FUNCNAME} and "set -u" (OSH regression)
set -u
argv.py "$FUNCNAME"
---
(command (word "set") (word "-u"))
(command (word "argv.py") (word "\"$FUNCNAME\""))
---

=== $((BASH_LINENO)) (scalar form in arith)
check() {
  echo $((BASH_LINENO))
}
check
---
(function "check" (brace-group (command (word "echo") (word "$((BASH_LINENO))"))))
(command (word "check"))
---

=== ${BASH_SOURCE[@]} with source and function name
cd $REPO_ROOT

argv.py "${BASH_SOURCE[@]}"
source spec/testdata/bash-source-simple.sh
f
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "argv.py") (word "\"${BASH_SOURCE[@]}\""))
(command (word "source") (word "spec/testdata/bash-source-simple.sh"))
(command (word "f"))
---

=== ${BASH_SOURCE[@]} with line numbers
cd $REPO_ROOT

$SH spec/testdata/bash-source.sh
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "$SH") (word "spec/testdata/bash-source.sh"))
---

=== ${BASH_LINENO[@]} is a stack of line numbers for function calls
# note: it's CALLS, not DEFINITIONS.
g() {
  argv.py G "${BASH_LINENO[@]}"
}
f() {
  argv.py 'begin F' "${BASH_LINENO[@]}"
  g  # line 6
  argv.py 'end F' "${BASH_LINENO[@]}"
}
argv.py ${BASH_LINENO[@]}
f  # line 9
---
(function "g" (brace-group (command (word "argv.py") (word "G") (word "\"${BASH_LINENO[@]}\""))))
(function "f" (brace-group (semi (semi (command (word "argv.py") (word "'begin F'") (word "\"${BASH_LINENO[@]}\"")) (command (word "g"))) (command (word "argv.py") (word "'end F'") (word "\"${BASH_LINENO[@]}\"")))))
(command (word "argv.py") (word "${BASH_LINENO[@]}"))
(command (word "f"))
---

=== Locations with temp frame
cd $REPO_ROOT

$SH spec/testdata/bash-source-pushtemp.sh
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "$SH") (word "spec/testdata/bash-source-pushtemp.sh"))
---

=== Locations when sourcing
cd $REPO_ROOT

# like above test case, but we source

# bash location doesn't make sense:
# - It says 'source' happens at line 1 of bash-source-pushtemp.  Well I think
# - It really happens at line 2 of '-c' !    I guess that's to line up
#   with the 'main' frame

$SH -c 'true;
source spec/testdata/bash-source-pushtemp.sh'
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "$SH") (word "-c") (word "'true;\nsource spec/testdata/bash-source-pushtemp.sh'"))
---

=== Sourcing inside function grows the debug stack
cd $REPO_ROOT

$SH spec/testdata/bash-source-source.sh
---
(command (word "cd") (word "$REPO_ROOT"))
(command (word "$SH") (word "spec/testdata/bash-source-source.sh"))
---

=== let
# NOTE: no spaces are allowed.  How is this tokenized?
let x=1
let y=x+2
let z=y*3  # zsh treats this as a glob; bash doesn't
let z2='y*3'  # both are OK with this
echo $x $y $z $z2
---
(command (word "let") (word "x=1"))
(command (word "let") (word "y=x+2"))
(command (word "let") (word "z=y*3"))
(command (word "let") (word "z2='y*3'"))
(command (word "echo") (word "$x") (word "$y") (word "$z") (word "$z2"))
---

=== let with ()
let x=( 1 )
let y=( x + 2 )
let z=( y * 3 )
echo $x $y $z
---
(command (word "let") (word "x=(1)"))
(command (word "let") (word "y=(x + 2)"))
(command (word "let") (word "z=(y * 3)"))
(command (word "echo") (word "$x") (word "$y") (word "$z"))
---

=== pass array by reference
show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
shadock=(ga bu zo meu)
show_value shadock 2
---
(function "show_value" (brace-group (semi (semi (command (word "local") (word "-n") (word "array_name=$1")) (command (word "local") (word "idx=$2"))) (command (word "echo") (word "\"${array_name[$idx]}\"")))))
(command (word "shadock=(ga bu zo meu)"))
(command (word "show_value") (word "shadock") (word "2"))
---

=== mutate array by reference
set1() {
  local -n array_name=$1
  local val=$2
  array_name[1]=$val
}
shadock=(a b c d)
set1 shadock ZZZ
echo ${shadock[@]}
---
(function "set1" (brace-group (semi (semi (command (word "local") (word "-n") (word "array_name=$1")) (command (word "local") (word "val=$2"))) (command (word "array_name[1]=$val")))))
(command (word "shadock=(a b c d)"))
(command (word "set1") (word "shadock") (word "ZZZ"))
(command (word "echo") (word "${shadock[@]}"))
---

=== pass assoc array by reference
show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
days=([monday]=eggs [tuesday]=bread [sunday]=jam)
show_value days sunday
---
(function "show_value" (brace-group (semi (semi (command (word "local") (word "-n") (word "array_name=$1")) (command (word "local") (word "idx=$2"))) (command (word "echo") (word "\"${array_name[$idx]}\"")))))
(command (word "days=([monday]=eggs [tuesday]=bread [sunday]=jam)"))
(command (word "show_value") (word "days") (word "sunday"))
---

=== pass local array by reference, relying on DYNAMIC SCOPING
show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
caller() {
  local shadock=(ga bu zo meu)
  show_value shadock 2
}
caller
---
(function "show_value" (brace-group (semi (semi (command (word "local") (word "-n") (word "array_name=$1")) (command (word "local") (word "idx=$2"))) (command (word "echo") (word "\"${array_name[$idx]}\"")))))
(function "caller" (brace-group (semi (command (word "local") (word "shadock=(ga bu zo meu)")) (command (word "show_value") (word "shadock") (word "2")))))
(command (word "caller"))
---

=== flag -n and +n
x=foo

ref=x

echo ref=$ref

typeset -n ref
echo ref=$ref

# mutate underlying var
x=bar
echo ref=$ref

typeset +n ref
echo ref=$ref
---
(command (word "x=foo"))
(command (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "x=bar"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "+n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
---

=== mutating through nameref: ref=
x=XX
y=YY

ref=x
ref=y
echo 1 ref=$ref

# now it's a reference
typeset -n ref

echo 2 ref=$ref  # prints YY

ref=XXXX
echo 3 ref=$ref  # it actually prints y, which is XXXX

# now Y is mutated!
echo 4 y=$y
---
(command (word "x=XX"))
(command (word "y=YY"))
(command (word "ref=x"))
(command (word "ref=y"))
(command (word "echo") (word "1") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "2") (word "ref=$ref"))
(command (word "ref=XXXX"))
(command (word "echo") (word "3") (word "ref=$ref"))
(command (word "echo") (word "4") (word "y=$y"))
---

=== flag -n combined ${!ref} -- bash INVERTS
foo=FOO  # should NOT use this

x=foo
ref=x

echo ref=$ref
echo "!ref=${!ref}"

echo 'NOW A NAMEREF'

typeset -n ref
echo ref=$ref
echo "!ref=${!ref}"
---
(command (word "foo=FOO"))
(command (word "x=foo"))
(command (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "\"!ref=${!ref}\""))
(command (word "echo") (word "'NOW A NAMEREF'"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "\"!ref=${!ref}\""))
---

=== named ref with $# doesn't work
set -- one two three

ref='#'
echo ref=$ref
typeset -n ref
echo ref=$ref
---
(command (word "set") (word "--") (word "one") (word "two") (word "three"))
(command (word "ref='#'"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
---

=== named ref with $# and shopt -s strict_nameref
shopt -s strict_nameref

ref='#'
echo ref=$ref
typeset -n ref
echo ref=$ref
---
(command (word "shopt") (word "-s") (word "strict_nameref"))
(command (word "ref='#'"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
---

=== named ref with 1 $1 etc.
set -- one two three

x=X

ref='1'
echo ref=$ref
typeset -n ref
echo ref=$ref

# BUG: This is really assigning '1', which is INVALID
# with strict_nameref that degrades!!!
ref2='$1'
echo ref2=$ref2
typeset -n ref2
echo ref2=$ref2

x=foo

ref3='x'
echo ref3=$ref3
typeset -n ref3
echo ref3=$ref3
---
(command (word "set") (word "--") (word "one") (word "two") (word "three"))
(command (word "x=X"))
(command (word "ref='1'"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref2='$1'"))
(command (word "echo") (word "ref2=$ref2"))
(command (word "typeset") (word "-n") (word "ref2"))
(command (word "echo") (word "ref2=$ref2"))
(command (word "x=foo"))
(command (word "ref3='x'"))
(command (word "echo") (word "ref3=$ref3"))
(command (word "typeset") (word "-n") (word "ref3"))
(command (word "echo") (word "ref3=$ref3"))
---

=== assign to invalid ref
ref=1   # mksh makes this READ-ONLY!  Because it's not valid.

echo ref=$ref
typeset -n ref
echo ref=$ref

ref=foo
echo ref=$ref
---
(command (word "ref=1"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref=foo"))
(command (word "echo") (word "ref=$ref"))
---

=== assign to invalid ref with strict_nameref
case $SH in *bash|*mksh) exit ;; esac

shopt -s strict_nameref

ref=1

echo ref=$ref
typeset -n ref
echo ref=$ref

ref=foo
echo ref=$ref
---
(case (word "$SH") (pattern ((word "*bash") (word "*mksh")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "strict_nameref"))
(command (word "ref=1"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref=foo"))
(command (word "echo") (word "ref=$ref"))
---

=== name ref on Undef cell
typeset  -n ref

# This is technically incorrect: an undefined name shouldn't evaluate to empty
# string.  mksh doesn't allow it.
echo ref=$ref

echo nounset
set -o nounset
echo ref=$ref
---
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "nounset"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "ref=$ref"))
---

=== assign to empty nameref and invalid nameref
typeset -n ref
echo ref=$ref

# this is a no-op in bash, should be stricter
ref=x
echo ref=$ref

typeset -n ref2=undef
echo ref2=$ref2
ref2=x
echo ref2=$ref2
---
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-n") (word "ref2=undef"))
(command (word "echo") (word "ref2=$ref2"))
(command (word "ref2=x"))
(command (word "echo") (word "ref2=$ref2"))
---

=== -n attribute before it has a value
typeset -n ref

echo ref=$ref

# Now that it's a string, it still has the -n attribute
x=XX
ref=x
echo ref=$ref
---
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "x=XX"))
(command (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
---

=== -n attribute on array is hard error, not a warning
x=X
typeset -n ref #=x
echo hi

# bash prints warning: REMOVES the nameref attribute here!
ref=(x y)
echo ref=$ref
---
(command (word "x=X"))
(command (word "typeset") (word "-n") (word "ref"))
(command (word "echo") (word "hi"))
(command (word "ref=(x y)"))
(command (word "echo") (word "ref=$ref"))
---

=== exported nameref
x=foo
typeset -n -x ref=x

# hm bash ignores it but mksh doesn't.  maybe disallow it.
printenv.py x ref
echo ---
export x
printenv.py x ref
---
(command (word "x=foo"))
(command (word "typeset") (word "-n") (word "-x") (word "ref=x"))
(command (word "printenv.py") (word "x") (word "ref"))
(command (word "echo") (word "---"))
(command (word "export") (word "x"))
(command (word "printenv.py") (word "x") (word "ref"))
---

=== readonly nameref doesn't prevent assigning through it
# hm bash also ignores -r when -n is set

x=XX
typeset -n -r ref=x

echo ref=$ref

# it feels like I shouldn't be able to mutate this?
ref=XXXX
echo ref=$ref

x=X
echo x=$x
---
(command (word "x=XX"))
(command (word "typeset") (word "-n") (word "-r") (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref=XXXX"))
(command (word "echo") (word "ref=$ref"))
(command (word "x=X"))
(command (word "echo") (word "x=$x"))
---

=== readonly var can't be assigned through nameref
x=X
typeset -n -r ref=x

echo ref=$ref

# it feels like I shouldn't be able to mutate this?
ref=XX
echo ref=$ref

# now the underling variable is immutable
typeset -r x

ref=XXX
echo ref=$ref
echo x=$x
---
(command (word "x=X"))
(command (word "typeset") (word "-n") (word "-r") (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "ref=XX"))
(command (word "echo") (word "ref=$ref"))
(command (word "typeset") (word "-r") (word "x"))
(command (word "ref=XXX"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "x=$x"))
---

=== unset nameref
x=X
typeset -n ref=x
echo ref=$ref

# this works
unset ref
echo ref=$ref
echo x=$x
---
(command (word "x=X"))
(command (word "typeset") (word "-n") (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "unset") (word "ref"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "x=$x"))
---

=== Chain of namerefs
x=foo
typeset -n ref=x
typeset -n ref_to_ref=ref
echo ref_to_ref=$ref_to_ref
echo ref=$ref
---
(command (word "x=foo"))
(command (word "typeset") (word "-n") (word "ref=x"))
(command (word "typeset") (word "-n") (word "ref_to_ref=ref"))
(command (word "echo") (word "ref_to_ref=$ref_to_ref"))
(command (word "echo") (word "ref=$ref"))
---

=== Mutually recursive namerefs detected on READ
typeset -n ref1=ref2
typeset -n ref2=ref1
echo defined
echo ref1=$ref1
echo ref2=$ref1
---
(command (word "typeset") (word "-n") (word "ref1=ref2"))
(command (word "typeset") (word "-n") (word "ref2=ref1"))
(command (word "echo") (word "defined"))
(command (word "echo") (word "ref1=$ref1"))
(command (word "echo") (word "ref2=$ref1"))
---

=== Mutually recursive namerefs detected on WRITE
typeset -n ref1=ref2
typeset -n ref2=ref1  # not detected here
echo defined $?
ref1=z  # detected here
echo mutated $?
---
(command (word "typeset") (word "-n") (word "ref1=ref2"))
(command (word "typeset") (word "-n") (word "ref2=ref1"))
(command (word "echo") (word "defined") (word "$?"))
(command (word "ref1=z"))
(command (word "echo") (word "mutated") (word "$?"))
---

=== Dynamic scope with namerefs
f3() {
  local -n ref=$1
  ref=x
}

f2() {
  f3 "$@"
}

f1() {
  local F1=F1
  echo F1=$F1
  f2 F1
  echo F1=$F1
}
f1
---
(function "f3" (brace-group (semi (command (word "local") (word "-n") (word "ref=$1")) (command (word "ref=x")))))
(function "f2" (brace-group (command (word "f3") (word "\"$@\""))))
(function "f1" (brace-group (semi (semi (semi (command (word "local") (word "F1=F1")) (command (word "echo") (word "F1=$F1"))) (command (word "f2") (word "F1"))) (command (word "echo") (word "F1=$F1")))))
(command (word "f1"))
---

=== change reference itself
x=XX
y=YY
typeset -n ref=x
echo ref=$ref
echo x=$x
echo y=$y

echo ----
typeset -n ref=y
echo ref=$ref
echo x=$x
echo y=$y
echo ----
ref=z
echo ref=$ref
echo x=$x
echo y=$y
---
(command (word "x=XX"))
(command (word "y=YY"))
(command (word "typeset") (word "-n") (word "ref=x"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "y=$y"))
(command (word "echo") (word "----"))
(command (word "typeset") (word "-n") (word "ref=y"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "y=$y"))
(command (word "echo") (word "----"))
(command (word "ref=z"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "y=$y"))
---

=== a[2] in nameref
typeset -n ref='a[2]'
a=(zero one two three)
echo ref=$ref
---
(command (word "typeset") (word "-n") (word "ref='a[2]'"))
(command (word "a=(zero one two three)"))
(command (word "echo") (word "ref=$ref"))
---

=== a[expr] in nameref
# this confuses code and data
typeset -n ref='a[$(echo 2) + 1]'
a=(zero one two three)
echo ref=$ref
---
(command (word "typeset") (word "-n") (word "ref='a[$(echo 2) + 1]'"))
(command (word "a=(zero one two three)"))
(command (word "echo") (word "ref=$ref"))
---

=== a[@] in nameref
# this confuses code and data
typeset -n ref='a[@]'
a=('A B' C)
argv.py ref "$ref"  # READ through ref works
ref=(X Y Z)    # WRITE through doesn't work
echo status=$?
argv.py 'ref[@]' "${ref[@]}"
argv.py ref "$ref"  # JOINING mangles the array?
argv.py 'a[@]' "${a[@]}"
---
(command (word "typeset") (word "-n") (word "ref='a[@]'"))
(command (word "a=('A B' C)"))
(command (word "argv.py") (word "ref") (word "\"$ref\""))
(command (word "ref=(X Y Z)"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "'ref[@]'") (word "\"${ref[@]}\""))
(command (word "argv.py") (word "ref") (word "\"$ref\""))
(command (word "argv.py") (word "'a[@]'") (word "\"${a[@]}\""))
---

=== mutate through nameref: ref[0]=
# This is DIFFERENT than the nameref itself being 'array[0]' !

array=(X Y Z)
typeset -n ref=array
ref[0]=xx
echo ${array[@]}
---
(command (word "array=(X Y Z)"))
(command (word "typeset") (word "-n") (word "ref=array"))
(command (word "ref[0]=xx"))
(command (word "echo") (word "${array[@]}"))
---

=== bad mutation through nameref: ref[0]= where ref is array[0]
array=(X Y Z)
typeset -n ref='array[0]'
ref[0]=foo  # error in bash: 'array[0]': not a valid identifier
echo status=$?
echo ${array[@]}
---
(command (word "array=(X Y Z)"))
(command (word "typeset") (word "-n") (word "ref='array[0]'"))
(command (word "ref[0]=foo"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "${array[@]}"))
---

=== @ in nameref isn't supported, unlike in ${!ref}
set -- A B
typeset -n ref='@'  # bash gives an error here
echo status=$?

echo ref=$ref  # bash doesn't give an error here
echo status=$?
---
(command (word "set") (word "--") (word "A") (word "B"))
(command (word "typeset") (word "-n") (word "ref='@'"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "ref=$ref"))
(command (word "echo") (word "status=$?"))
---

=== Unquoted assoc reference on RHS
typeset -A bashup_ev_r
bashup_ev_r['foo']=bar

p() {
  local s=foo
  local -n e=bashup_ev["$s"] f=bashup_ev_r["$s"]
  # Different!
  #local e=bashup_ev["$s"] f=bashup_ev_r["$s"]
  argv.py "$f"
}
p
---
(command (word "typeset") (word "-A") (word "bashup_ev_r"))
(command (word "bashup_ev_r['foo']=bar"))
(function "p" (brace-group (semi (semi (command (word "local") (word "s=foo")) (command (word "local") (word "-n") (word "e=bashup_ev[\"$s\"]") (word "f=bashup_ev_r[\"$s\"]"))) (command (word "argv.py") (word "\"$f\"")))))
(command (word "p"))
---

=== NUL bytes with echo -e
case $SH in dash) exit ;; esac

show_hex() { od -A n -t c -t x1; }

echo -e '\0-' | show_hex
#echo -e '\x00-'
#echo -e '\000-'
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(pipe (command (word "echo") (word "-e") (word "'\\0-'")) (command (word "show_hex")))
---

=== printf - literal NUL in format string
case $SH in dash|ash) return ;; esac

# Show both printable and hex
show_hex() { od -A n -t c -t x1; }

printf $'x\U0z' | show_hex
echo ---

printf $'x\U00z' | show_hex
echo ---

printf $'\U0z' | show_hex
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "return"))))
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(pipe (command (word "printf") (word "'x'")) (command (word "show_hex")))
(command (word "echo") (word "---"))
(pipe (command (word "printf") (word "'x'")) (command (word "show_hex")))
(command (word "echo") (word "---"))
(pipe (command (word "printf") (word "''")) (command (word "show_hex")))
---

=== printf - \0 escape shows NUL byte
show_hex() { od -A n -t c -t x1; }

printf '\0\n' | show_hex
---
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(pipe (command (word "printf") (word "'\\0\\n'")) (command (word "show_hex")))
---

=== printf - NUL byte in value (OSH and zsh agree)
case $SH in dash) exit ;; esac
show_hex() { od -A n -t c -t x1; }

nul=$'\0'
echo "$nul" | show_hex
printf '%s\n' "$nul" | show_hex
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(command (word "nul=''"))
(pipe (command (word "echo") (word "\"$nul\"")) (command (word "show_hex")))
(pipe (command (word "printf") (word "'%s\\n'") (word "\"$nul\"")) (command (word "show_hex")))
---

=== NUL bytes with echo $'\0' (OSH and zsh agree)
case $SH in dash) exit ;; esac
show_hex() { od -A n -t c -t x1; }

# OSH agrees with ZSH -- so you have the ability to print NUL bytes without
# legacy echo -e

echo $'\0' | show_hex
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "show_hex" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(pipe (command (word "echo") (word "''")) (command (word "show_hex")))
---

=== NUL bytes and IFS splitting
case $SH in dash) exit ;; esac

argv.py $(echo -e '\0')
argv.py "$(echo -e '\0')"
argv.py $(echo -e 'a\0b')
argv.py "$(echo -e 'a\0b')"
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "argv.py") (word "$(echo -e '\\0')"))
(command (word "argv.py") (word "\"$(echo -e '\\0')\""))
(command (word "argv.py") (word "$(echo -e 'a\\0b')"))
(command (word "argv.py") (word "\"$(echo -e 'a\\0b')\""))
---

=== NUL bytes with test -n
case $SH in dash) exit ;; esac

# zsh is buggy here, weird
test -n $''
echo status=$?

test -n $'\0'
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "test") (word "-n") (word "''"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-n") (word "''"))
(command (word "echo") (word "status=$?"))
---

=== NUL bytes with test -f
case $SH in dash) exit ;; esac


test -f $'\0'
echo status=$?

touch foo
test -f $'foo\0'
echo status=$?

test -f $'foo\0bar'
echo status=$?

test -f $'foobar'
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "test") (word "-f") (word "''"))
(command (word "echo") (word "status=$?"))
(command (word "touch") (word "foo"))
(command (word "test") (word "-f") (word "'foo'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-f") (word "'foo'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-f") (word "'foobar'"))
(command (word "echo") (word "status=$?"))
---

=== NUL bytes with ${#s} (OSH and zsh agree)
case $SH in dash) exit ;; esac

empty=$''
nul=$'\0'

echo empty=${#empty}
echo nul=${#nul}
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "empty=''"))
(command (word "nul=''"))
(command (word "echo") (word "empty=${#empty}"))
(command (word "echo") (word "nul=${#nul}"))
---

=== Compare \x00 byte versus \x01 byte - command sub
# https://stackoverflow.com/questions/32722007/is-skipping-ignoring-nul-bytes-on-process-substitution-standardized
# bash contains a warning!

show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '.\001.')
echo len=${#s}
show_bytes "$s"

s=$(printf '.\000.')
echo len=${#s}
show_bytes "$s"

s=$(printf '\000')
echo len=${#s} 
show_bytes "$s"
---
(function "show_bytes" (brace-group (pipe (command (word "echo") (word "-n") (word "\"$1\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")))))
(command (word "s=$(printf '.\\001.')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "s=$(printf '.\\000.')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "s=$(printf '\\000')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
---

=== Compare \x00 byte versus \x01 byte - read builtin
# Hm same odd behavior

show_string() {
  read s
  echo len=${#s}
  echo -n "$s" | od -A n -t x1
}

printf '.\001.' | show_string

printf '.\000.' | show_string

printf '\000' | show_string
---
(function "show_string" (brace-group (semi (semi (command (word "read") (word "s")) (command (word "echo") (word "len=${#s}"))) (pipe (command (word "echo") (word "-n") (word "\"$s\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1"))))))
(pipe (command (word "printf") (word "'.\\001.'")) (command (word "show_string")))
(pipe (command (word "printf") (word "'.\\000.'")) (command (word "show_string")))
(pipe (command (word "printf") (word "'\\000'")) (command (word "show_string")))
---

=== Compare \x00 byte versus \x01 byte - read -n
case $SH in dash) exit ;; esac

show_string() {
  read -n 3 s
  echo len=${#s}
  echo -n "$s" | od -A n -t x1
}


printf '.\001.' | show_string

printf '.\000.' | show_string

printf '\000' | show_string
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(function "show_string" (brace-group (semi (semi (command (word "read") (word "-n") (word "3") (word "s")) (command (word "echo") (word "len=${#s}"))) (pipe (command (word "echo") (word "-n") (word "\"$s\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1"))))))
(pipe (command (word "printf") (word "'.\\001.'")) (command (word "show_string")))
(pipe (command (word "printf") (word "'.\\000.'")) (command (word "show_string")))
(pipe (command (word "printf") (word "'\\000'")) (command (word "show_string")))
---

=== Compare \x00 byte versus \x01 byte - mapfile builtin
case $SH in dash|mksh|zsh|ash) exit ;; esac

{ 
  printf '.\000.\n'
  printf '.\000.\n'
} |
{ mapfile LINES
  echo len=${#LINES[@]}
  for line in ${LINES[@]}; do
    echo -n "$line" | od -A n -t x1
  done
}

# bash is INCONSISTENT:
# - it TRUNCATES at \0, with 'mapfile'
# - rather than just IGNORING \0, with 'read'
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh") (word "ash")) (command (word "exit"))))
(pipe (brace-group (semi (command (word "printf") (word "'.\\000.\\n'")) (command (word "printf") (word "'.\\000.\\n'")))) (brace-group (semi (semi (command (word "mapfile") (word "LINES")) (command (word "echo") (word "len=${#LINES[@]}"))) (for (word "line") (in (word "${LINES[@]}")) (pipe (command (word "echo") (word "-n") (word "\"$line\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")))))))
---

=== Strip ops # ## % %% with NUL bytes
show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '\000.\000')
echo len=${#s}
show_bytes "$s"

echo ---

t=${s#?}
echo len=${#t}
show_bytes "$t"

t=${s##?}
echo len=${#t}
show_bytes "$t"

t=${s%?}
echo len=${#t}
show_bytes "$t"

t=${s%%?}
echo len=${#t}
show_bytes "$t"
---
(function "show_bytes" (brace-group (pipe (command (word "echo") (word "-n") (word "\"$1\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")))))
(command (word "s=$(printf '\\000.\\000')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "echo") (word "---"))
(command (word "t=${s#?}"))
(command (word "echo") (word "len=${#t}"))
(command (word "show_bytes") (word "\"$t\""))
(command (word "t=${s##?}"))
(command (word "echo") (word "len=${#t}"))
(command (word "show_bytes") (word "\"$t\""))
(command (word "t=${s%?}"))
(command (word "echo") (word "len=${#t}"))
(command (word "show_bytes") (word "\"$t\""))
(command (word "t=${s%%?}"))
(command (word "echo") (word "len=${#t}"))
(command (word "show_bytes") (word "\"$t\""))
---

=== Issue 2269 Reduction
show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '\000x')
echo len=${#s}
show_bytes "$s"

# strip one char from the front
s=${s#?}
echo len=${#s}
show_bytes "$s"

echo ---

s=$(printf '\001x')
echo len=${#s}
show_bytes "$s"

# strip one char from the front
s=${s#?}
echo len=${#s}
show_bytes "$s"
---
(function "show_bytes" (brace-group (pipe (command (word "echo") (word "-n") (word "\"$1\"")) (command (word "od") (word "-A") (word "n") (word "-t") (word "x1")))))
(command (word "s=$(printf '\\000x')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "s=${s#?}"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "echo") (word "---"))
(command (word "s=$(printf '\\001x')"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
(command (word "s=${s#?}"))
(command (word "echo") (word "len=${#s}"))
(command (word "show_bytes") (word "\"$s\""))
---

=== Issue 2269 - Do NUL bytes match ? in ${a#?}
# https://github.com/oils-for-unix/oils/issues/2269

escape_arg() {
	a="$1"
	until [ -z "$a" ]; do
		case "$a" in
		(\'*) printf "'\"'\"'";;
		(*) printf %.1s "$a";;
		esac
		a="${a#?}"
    echo len=${#a} >&2
	done
}

# encode
phrase="$(escape_arg "that's it!")"
echo escaped "$phrase"

# decode
eval "printf '%s\\n' '$phrase'"

echo ---

# harder input: NUL surrounded with ::
arg="$(printf ':\000:')" 
#echo "arg=$arg"

case $SH in
  zsh) echo 'writes binary data' ;;
  *) echo escaped "$(escape_arg "$arg")" ;;
esac
#echo "arg=$arg"
---
(function "escape_arg" (brace-group (semi (command (word "a=\"$1\"")) (until (command (word "[") (word "-z") (word "\"$a\"") (word "]")) (semi (semi (case (word "\"$a\"") (pattern ((word "\\'*")) (command (word "printf") (word "\"'\\\"'\\\"'\""))) (pattern ((word "*")) (command (word "printf") (word "%.1s") (word "\"$a\"")))) (command (word "a=\"${a#?}\""))) (command (word "echo") (word "len=${#a}") (redirect ">&" 2)))))))
(command (word "phrase=\"$(escape_arg \"that's it!\")\""))
(command (word "echo") (word "escaped") (word "\"$phrase\""))
(command (word "eval") (word "\"printf '%s\\\\n' '$phrase'\""))
(command (word "echo") (word "---"))
(command (word "arg=\"$(printf ':\\000:')\""))
(case (word "$SH") (pattern ((word "zsh")) (command (word "echo") (word "'writes binary data'"))) (pattern ((word "*")) (command (word "echo") (word "escaped") (word "\"$(escape_arg \"$arg\")\""))))
---

=== YSH $[expr_sub] in OSH should not do dynamic globbing
touch {foo,bar}.txt

shopt -s parse_ysh_expr_sub
echo $["*.txt"]
---
(command (word "touch") (word "{foo,bar}.txt"))
(command (word "shopt") (word "-s") (word "parse_ysh_expr_sub"))
(command (word "echo") (word "$[\"*.txt\"]"))
---

=== SHELLOPTS bug with ysh:ugprade
cd $REPO_ROOT/spec/testdata/bug-shellopts

#shopt -p no_init_globals

$SH -o ysh:upgrade ./top-level.ysh

#echo ---
#$SH -e -c 'echo SHELLOPTS=$SHELLOPTS'
#$SH -e -o ysh:upgrade -c 'echo SHELLOPTS=$SHELLOPTS'
---
(command (word "cd") (word "$REPO_ROOT/spec/testdata/bug-shellopts"))
(command (word "$SH") (word "-o") (word "ysh:upgrade") (word "./top-level.ysh"))
---

=== (( closed with ) ) after multiple lines is command - #2337
(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
) )
---
(subshell (subshell (semi (semi (semi (semi (command (word "echo") (word "1")) (command (word "echo") (word "2"))) (arith (word " x "))) (command (word ":") (word "$(( x ))"))) (command (word "echo") (word "3")))))
---

=== $(( closed with ) ) after multiple lines is command - #2337
echo $(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
) )
---
(command (word "echo") (word "$(( echo 1\necho 2\n(( x ))\n: $(( x ))\necho 3\n) )"))
---

=== (( closed with )) after multiple lines is parse error - #2337
$SH -c '
(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
))
'
if test $? -ne 0; then
  echo ok
fi
---
(command (word "$SH") (word "-c") (word "'\n(( echo 1\necho 2\n(( x ))\n: $(( x ))\necho 3\n))\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
---

=== $(( closed with )) after multiple lines is parse error - #2337
$SH -c '
echo $(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
))
'
if test $? -ne 0; then
  echo ok
fi
---
(command (word "$SH") (word "-c") (word "'\necho $(( echo 1\necho 2\n(( x ))\n: $(( x ))\necho 3\n))\n'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "ok")))
---

=== (((grep example - 4+ instances in regtest/aports - #2337
# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/.28.28.28.20not.20parsed.20like.20bash/with/518874141

# spaces help
good() {
  cputype=`( ( (grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`
}

bad() {
  cputype=`(((grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`
  #echo cputype=$cputype
}

good
bad
---
(function "good" (brace-group (command (word "cputype=`( ( (grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`"))))
(function "bad" (brace-group (command (word "cputype=`(((grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`"))))
(command (word "good"))
(command (word "bad"))
---

=== ((gzip example - zdiff package - #2337
# https://github.com/git-for-windows/git-sdk-64/blob/main/usr/bin/zdiff#L136

gzip_status=$(
  exec 4>&1
  (gzip -cdfq -- "$file1" 4>&-; echo $? >&4) 3>&- |
      ((gzip -cdfq -- "$file2" 4>&-
        echo $? >&4) 3>&- 5<&- </dev/null |
       eval "$cmp" /dev/fd/5 - >&3) 5<&0
)
echo bye
---
(command (word "gzip_status=$(exec 4>&1\n( gzip -cdfq -- \"$file1\" 4>&-; echo $? 1>&4 ) 3>&- | ( ( gzip -cdfq -- \"$file2\" 4>&-\necho $? 1>&4 ) 3>&- 5>&- < /dev/null | eval \"$cmp\" /dev/fd/5 - 1>&3 ) 5<&0)"))
(command (word "echo") (word "bye"))
---

=== ((pkg-config example - postfix package - #2337
icu_cppflags=`((pkg-config --cflags icu-uc icu-i18n) ||
                  (pkgconf --cflags icu-uc icu-i18n) ||
                  (icu-config --cppflags)) 2>/dev/null`
echo bye
---
(command (word "icu_cppflags=`((pkg-config --cflags icu-uc icu-i18n) ||\n                  (pkgconf --cflags icu-uc icu-i18n) ||\n                  (icu-config --cppflags)) 2>/dev/null`"))
(command (word "echo") (word "bye"))
---

=== ((test example - liblo package - #2337
if ! ((test x"$i" = x-g) || (test x"$i" = x-O2)); then
    CF="$CF $i"
fi
echo bye
---
(if (negation (subshell (or (subshell (command (word "test") (word "x\"$i\"") (word "=") (word "x-g"))) (subshell (command (word "test") (word "x\"$i\"") (word "=") (word "x-O2")))))) (command (word "CF=\"$CF $i\"")))
(command (word "echo") (word "bye"))
---

=== $((which example - command sub versus arith sub - gnunet-gtk package
        gtk_update_icon_cache_bin="$((which gtk-update-icon-cache ||
echo /opt/gnome/bin/gtk-update-icon-cache)2>/dev/null)"

echo bye
---
(command (word "gtk_update_icon_cache_bin=\"$((which gtk-update-icon-cache ||\necho /opt/gnome/bin/gtk-update-icon-cache)2>/dev/null)\""))
(command (word "echo") (word "bye"))
---

=== Long Token - 65535 bytes
python2 -c 'print("echo -n %s" % ("x" * 65535))' > tmp.sh
$SH tmp.sh > out
wc --bytes out
---
(command (word "python2") (word "-c") (word "'print(\"echo -n %s\" % (\"x\" * 65535))'") (redirect ">" "tmp.sh"))
(command (word "$SH") (word "tmp.sh") (redirect ">" "out"))
(command (word "wc") (word "--bytes") (word "out"))
---

=== Token that's too long for Oils - 65536 bytes
python2 -c 'print("echo -n %s" % ("x" * 65536))' > tmp.sh
$SH tmp.sh > out
echo status=$?
wc --bytes out
---
(command (word "python2") (word "-c") (word "'print(\"echo -n %s\" % (\"x\" * 65536))'") (redirect ">" "tmp.sh"))
(command (word "$SH") (word "tmp.sh") (redirect ">" "out"))
(command (word "echo") (word "status=$?"))
(command (word "wc") (word "--bytes") (word "out"))
---

=== $% is not a parse error
echo $%
---
(command (word "echo") (word "$%"))
---

=== Bad braced var sub -- not allowed
echo ${%}
---
(command (word "echo") (word "${%}"))
---

=== Bad var sub caught at parse time
if test -f /; then
  echo ${%}
else
  echo ok
fi
---
(if (command (word "test") (word "-f") (word "/")) (command (word "echo") (word "${%}")) (command (word "echo") (word "ok")))
---

=== Invalid for loop variable name
for i.j in a b c; do
  echo hi
done
echo done
---
(for (word "i.j") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "hi")))
(command (word "echo") (word "done"))
---

=== bad var name globally isn't parsed like an assignment
# bash and dash disagree on exit code.
FOO-BAR=foo
---
(command (word "FOO-BAR=foo"))
---

=== bad var name in export
# bash and dash disagree on exit code.
export FOO-BAR=foo
---
(command (word "export") (word "FOO-BAR=foo"))
---

=== bad var name in local
# bash and dash disagree on exit code.
f() {
  local FOO-BAR=foo
}
f
---
(function "f" (brace-group (command (word "local") (word "FOO-BAR=foo"))))
(command (word "f"))
---

=== interactive parse error (regression)
flags=''
case $SH in
  bash*|*osh)
    flags='--rcfile /dev/null'
    ;;
esac  
$SH $flags -i -c 'var=)'
---
(command (word "flags=''"))
(case (word "$SH") (pattern ((word "bash*") (word "*osh")) (command (word "flags='--rcfile /dev/null'"))))
(command (word "$SH") (word "$flags") (word "-i") (word "-c") (word "'var=)'"))
---

=== echo =word is allowed
echo =word
---
(command (word "echo") (word "=word"))
---

=== Empty for loop is allowed
set -- a b
for x in; do
  echo hi
  echo $x
done
---
(command (word "set") (word "--") (word "a") (word "b"))
(for (word "x") (in) (semi (command (word "echo") (word "hi")) (command (word "echo") (word "$x"))))
---

=== Empty for loop without in.  Do can be on the same line I guess.
set -- a b
for x do
  echo hi
  echo $x
done
---
(command (word "set") (word "--") (word "a") (word "b"))
(for (word "x") (in (word "\"$@\"")) (semi (command (word "echo") (word "hi")) (command (word "echo") (word "$x"))))
---

=== Empty case statement
case foo in
esac
---
(case (word "foo"))
---

=== Last case without ;;
foo=a
case $foo in
  a) echo A ;;
  b) echo B  
esac
---
(command (word "foo=a"))
(case (word "$foo") (pattern ((word "a")) (command (word "echo") (word "A"))) (pattern ((word "b")) (command (word "echo") (word "B"))))
---

=== Only case without ;;
foo=a
case $foo in
  a) echo A
esac
---
(command (word "foo=a"))
(case (word "$foo") (pattern ((word "a")) (command (word "echo") (word "A"))))
---

=== Case with optional (
foo=a
case $foo in
  (a) echo A ;;
  (b) echo B  
esac
---
(command (word "foo=a"))
(case (word "$foo") (pattern ((word "a")) (command (word "echo") (word "A"))) (pattern ((word "b")) (command (word "echo") (word "B"))))
---

=== Empty action is allowed for last case
foo=b
case $foo in
  a) echo A ;;
  b)
esac
---
(command (word "foo=b"))
(case (word "$foo") (pattern ((word "a")) (command (word "echo") (word "A"))) (pattern ((word "b")) ()))
---

=== Case with | pattern
foo=a
case $foo in
  a|b) echo A ;;
  c)
esac
---
(command (word "foo=a"))
(case (word "$foo") (pattern ((word "a") (word "b")) (command (word "echo") (word "A"))) (pattern ((word "c")) ()))
---

=== Command substitution in default
echo ${x:-$(ls -d /bin)}
---
(command (word "echo") (word "${x:-$(ls -d /bin)}"))
---

=== Arithmetic expansion
x=3
while [ $x -gt 0 ]
do
  echo $x
  x=$(($x-1))
done
---
(command (word "x=3"))
(while (command (word "[") (word "$x") (word "-gt") (word "0") (word "]")) (semi (command (word "echo") (word "$x")) (command (word "x=$(($x-1))"))))
---

=== Newlines in compound lists
x=3
while
  # a couple of <newline>s

  # a list
  date && ls -d /bin || echo failed; cat tests/hello.txt
  # a couple of <newline>s

  # another list
  wc tests/hello.txt > _tmp/posix-compound.txt & true

do
  # 2 lists
  ls -d /bin
  cat tests/hello.txt
  x=$(($x-1))
  [ $x -eq 0 ] && break
done
# Not testing anything but the status since output is complicated
---
(command (word "x=3"))
(while (semi (semi (or (and (command (word "date")) (command (word "ls") (word "-d") (word "/bin"))) (command (word "echo") (word "failed"))) (command (word "cat") (word "tests/hello.txt"))) (background (command (word "wc") (word "tests/hello.txt") (redirect ">" "_tmp/posix-compound.txt")) (command (word "true")))) (semi (semi (semi (command (word "ls") (word "-d") (word "/bin")) (command (word "cat") (word "tests/hello.txt"))) (command (word "x=$(($x-1))"))) (and (command (word "[") (word "$x") (word "-eq") (word "0") (word "]")) (command (word "break")))))
---

=== Multiple here docs on one line
cat <<EOF1; cat <<EOF2
one
EOF1
two
EOF2
---
(semi (command (word "cat") (redirect "<<" "one
")) (command (word "cat") (redirect "<<" "two
")))
---

=== cat here doc; echo; cat here doc
cat <<EOF1; echo two; cat <<EOF2
one
EOF1
three
EOF2
---
(semi (semi (command (word "cat") (redirect "<<" "one
")) (command (word "echo") (word "two"))) (command (word "cat") (redirect "<<" "three
")))
---

=== typeset -f prints function source code
: prefix; myfunc() { echo serialized; }

code=$(typeset -f myfunc)

$SH -c "$code; myfunc"
---
(semi (command (word ":") (word "prefix")) (function "myfunc" (brace-group (command (word "echo") (word "serialized")))))
(command (word "code=$(typeset -f myfunc)"))
(command (word "$SH") (word "-c") (word "\"$code; myfunc\""))
---

=== typeset -f with function keyword (ksh style)
: prefix; function myfunc {
	echo serialized
}

code=$(typeset -f myfunc)

$SH -c "$code; myfunc"
---
(semi (command (word ":") (word "prefix")) (function "myfunc" (brace-group (command (word "echo") (word "serialized")))))
(command (word "code=$(typeset -f myfunc)"))
(command (word "$SH") (word "-c") (word "\"$code; myfunc\""))
---

=== typeset -f prints function source code - nested functions
outer() {
  echo outer
  : prefix; inner() {
    echo inner
  }
}

code=$(typeset -f outer)

if false; then
  echo ---
  echo $code
  echo ---
fi

$SH -c "$code; outer; inner"
---
(function "outer" (brace-group (semi (semi (command (word "echo") (word "outer")) (command (word ":") (word "prefix"))) (function "inner" (brace-group (command (word "echo") (word "inner")))))))
(command (word "code=$(typeset -f outer)"))
(if (command (word "false")) (semi (semi (command (word "echo") (word "---")) (command (word "echo") (word "$code"))) (command (word "echo") (word "---"))))
(command (word "$SH") (word "-c") (word "\"$code; outer; inner\""))
---

=== non-{ } function bodies can be serialized (rare)
# TODO: we can add more of these

f() ( echo 'subshell body' )

code=$(typeset -f f)

$SH -c "$code; f"
---
(function "f" (subshell (command (word "echo") (word "'subshell body'"))))
(command (word "code=$(typeset -f f)"))
(command (word "$SH") (word "-c") (word "\"$code; f\""))
---

=== sh -i
# Notes:
# - OSH prompt goes to stdout and bash goes to stderr
# - This test seems to fail on the system bash, but succeeds with spec-bin/bash
echo 'echo foo' | PS1='[prompt] ' $SH --rcfile /dev/null -i >out.txt 2>err.txt
fgrep -q '[prompt]' out.txt err.txt
echo match=$?
---
(pipe (command (word "echo") (word "'echo foo'")) (command (word "PS1='[prompt] '") (word "$SH") (word "--rcfile") (word "/dev/null") (word "-i") (redirect ">" "out.txt") (redirect ">" "err.txt")))
(command (word "fgrep") (word "-q") (word "'[prompt]'") (word "out.txt") (word "err.txt"))
(command (word "echo") (word "match=$?"))
---

=== \[\] are non-printing
PS1='\[foo\]\$'
echo "${PS1@P}"
---
(command (word "PS1='\\[foo\\]\\$'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== literal escapes
PS1='\a\e\r\n'
echo "${PS1@P}"
---
(command (word "PS1='\\a\\e\\r\\n'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== special case for $
# NOTE: This might be broken for # but it's hard to tell since we don't have
# root.  Could inject __TEST_EUID or something.
PS1='$'
echo "${PS1@P}"
PS1='\$'
echo "${PS1@P}"
PS1='\\$'
echo "${PS1@P}"
PS1='\\\$'
echo "${PS1@P}"
PS1='\\\\$'
echo "${PS1@P}"
---
(command (word "PS1='$'"))
(command (word "echo") (word "\"${PS1@P}\""))
(command (word "PS1='\\$'"))
(command (word "echo") (word "\"${PS1@P}\""))
(command (word "PS1='\\\\$'"))
(command (word "echo") (word "\"${PS1@P}\""))
(command (word "PS1='\\\\\\$'"))
(command (word "echo") (word "\"${PS1@P}\""))
(command (word "PS1='\\\\\\\\$'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== PS1 evaluation order
x='\'
y='h'
PS1='$x$y'
echo "${PS1@P}"
---
(command (word "x='\\'"))
(command (word "y='h'"))
(command (word "PS1='$x$y'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== PS1 evaluation order 2
foo=foo_value
dir=$TMP/'$foo'  # Directory name with a dollar!
mkdir -p $dir
cd $dir
PS1='\w $foo'
test "${PS1@P}" = "$PWD foo_value"
echo status=$?
---
(command (word "foo=foo_value"))
(command (word "dir=$TMP/'$foo'"))
(command (word "mkdir") (word "-p") (word "$dir"))
(command (word "cd") (word "$dir"))
(command (word "PS1='\\w $foo'"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"$PWD foo_value\""))
(command (word "echo") (word "status=$?"))
---

=== \1004
PS1='\1004$'
echo "${PS1@P}"
---
(command (word "PS1='\\1004$'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== \001 octal literals are supported
PS1='[\045]'
echo "${PS1@P}"
---
(command (word "PS1='[\\045]'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== \555 is beyond max octal byte of \377 and wrapped to m
PS1='\555$'
echo "${PS1@P}"
---
(command (word "PS1='\\555$'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== \x55 hex literals not supported
PS1='[\x55]'
echo "${PS1@P}"
---
(command (word "PS1='[\\x55]'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== Single backslash
PS1='\'
echo "${PS1@P}"
---
(command (word "PS1='\\'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== Escaped backslash
PS1='\\'
echo "${PS1@P}"
---
(command (word "PS1='\\\\'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== \0001 octal literals are not supported
PS1='[\0455]'
echo "${PS1@P}"
---
(command (word "PS1='[\\0455]'"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== \u0001 unicode literals not supported
PS1='[\u0001]'
USER=$(whoami)
test "${PS1@P}" = "[${USER}0001]"
echo status=$?
---
(command (word "PS1='[\\u0001]'"))
(command (word "USER=$(whoami)"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"[${USER}0001]\""))
(command (word "echo") (word "status=$?"))
---

=== constant string
PS1='$ '
echo "${PS1@P}"
---
(command (word "PS1='$ '"))
(command (word "echo") (word "\"${PS1@P}\""))
---

=== hostname
# NOTE: This test is not hermetic.  On my machine the short and long host name
# are the same.

PS1='\h '
test "${PS1@P}" = "$(hostname -s) "  # short name
echo status=$?
PS1='\H '
test "${PS1@P}" = "$(hostname) "
echo status=$?
---
(command (word "PS1='\\h '"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"$(hostname -s) \""))
(command (word "echo") (word "status=$?"))
(command (word "PS1='\\H '"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"$(hostname) \""))
(command (word "echo") (word "status=$?"))
---

=== username
PS1='\u '
USER=$(whoami)
test "${PS1@P}" = "${USER} "
echo status=$?
---
(command (word "PS1='\\u '"))
(command (word "USER=$(whoami)"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"${USER} \""))
(command (word "echo") (word "status=$?"))
---

=== current working dir
PS1='\w '
test "${PS1@P}" = "${PWD} "
echo status=$?
---
(command (word "PS1='\\w '"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"${PWD} \""))
(command (word "echo") (word "status=$?"))
---

=== \W is basename of working dir
PS1='\W '
test "${PS1@P}" = "$(basename $PWD) "
echo status=$?
---
(command (word "PS1='\\W '"))
(command (word "test") (word "\"${PS1@P}\"") (word "=") (word "\"$(basename $PWD) \""))
(command (word "echo") (word "status=$?"))
---

=== \t for 24h time (HH:MM:SS)
PS1='foo \t bar'
echo "${PS1@P}" | egrep -q 'foo [0-2][0-9]:[0-5][0-9]:[0-5][0-9] bar'
echo matched=$?
---
(command (word "PS1='foo \\t bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-2][0-9]:[0-5][0-9]:[0-5][0-9] bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \T for 12h time (HH:MM:SS)
PS1='foo \T bar'
echo "${PS1@P}" | egrep -q 'foo [0-1][0-9]:[0-5][0-9]:[0-5][0-9] bar'
echo matched=$?
---
(command (word "PS1='foo \\T bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-1][0-9]:[0-5][0-9]:[0-5][0-9] bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \@ for 12h time (HH:MM AM/PM)
PS1='foo \@ bar'
echo "${PS1@P}" | egrep -q 'foo [0-1][0-9]:[0-5][0-9] (A|P)M bar'
echo matched=$?
---
(command (word "PS1='foo \\@ bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-1][0-9]:[0-5][0-9] (A|P)M bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \A for 24h time (HH:MM)
PS1='foo \A bar'
echo "${PS1@P}" | egrep -q 'foo [0-2][0-9]:[0-5][0-9] bar'
echo matched=$?
---
(command (word "PS1='foo \\A bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-2][0-9]:[0-5][0-9] bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \d for date
PS1='foo \d bar'
echo "${PS1@P}" | egrep -q 'foo [A-Z][a-z]+ [A-Z][a-z]+ [0-9]+ bar'
echo matched=$?
---
(command (word "PS1='foo \\d bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [A-Z][a-z]+ [A-Z][a-z]+ [0-9]+ bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \D{%H:%M} for strftime
PS1='foo \D{%H:%M} bar'
echo "${PS1@P}" | egrep -q 'foo [0-9][0-9]:[0-9][0-9] bar'
echo matched=$?

PS1='foo \D{%H:%M:%S} bar'
echo "${PS1@P}" | egrep -q 'foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9] bar'
echo matched=$?
---
(command (word "PS1='foo \\D{%H:%M} bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-9][0-9]:[0-9][0-9] bar'")))
(command (word "echo") (word "matched=$?"))
(command (word "PS1='foo \\D{%H:%M:%S} bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9] bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \D{} for locale specific strftime
# In bash y.tab.c uses %X when string is empty
# This doesn't seem to match exactly, but meh for now.

PS1='foo \D{} bar'
echo "${PS1@P}" | egrep -q '^foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9]( ..)? bar$'
echo matched=$?
---
(command (word "PS1='foo \\D{} bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'^foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9]( ..)? bar$'")))
(command (word "echo") (word "matched=$?"))
---

=== \s for shell, \v for major.minor version, and \V for full version
PS1='foo \s bar'
echo "${PS1@P}" | egrep -q '^foo (bash|osh) bar$'
echo match=$?

PS1='foo \v bar'
echo "${PS1@P}" | egrep -q '^foo [0-9]+\.[0-9]+ bar$'
echo match=$?

PS1='foo \V bar'
echo "${PS1@P}" | egrep -q '^foo [0-9]+\.[0-9]+\.[0-9]+ bar$'
echo match=$?
---
(command (word "PS1='foo \\s bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'^foo (bash|osh) bar$'")))
(command (word "echo") (word "match=$?"))
(command (word "PS1='foo \\v bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'^foo [0-9]+\\.[0-9]+ bar$'")))
(command (word "echo") (word "match=$?"))
(command (word "PS1='foo \\V bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'^foo [0-9]+\\.[0-9]+\\.[0-9]+ bar$'")))
(command (word "echo") (word "match=$?"))
---

=== \j for number of jobs
set -m # enable job control
PS1='foo \j bar'
echo "${PS1@P}" | egrep -q 'foo 0 bar'
echo matched=$?
sleep 5 &
echo "${PS1@P}" | egrep -q 'foo 1 bar'
echo matched=$?
kill %%
fg
echo "${PS1@P}" | egrep -q 'foo 0 bar'
echo matched=$?
---
(command (word "set") (word "-m"))
(command (word "PS1='foo \\j bar'"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo 0 bar'")))
(command (word "echo") (word "matched=$?"))
(background (command (word "sleep") (word "5")))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo 1 bar'")))
(command (word "echo") (word "matched=$?"))
(command (word "kill") (word "%%"))
(command (word "fg"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "'foo 0 bar'")))
(command (word "echo") (word "matched=$?"))
---

=== \l for TTY device basename
PS1='foo \l bar'
# FIXME this never an actual TTY when using ./test/spec.sh
tty="$(tty)"
if [[ "$tty" == "not a tty" ]]; then
    expected="tty"
else
    expected="$(basename "$tty")"
fi
echo "${PS1@P}" | egrep -q "foo $expected bar"
echo matched=$?
---
(command (word "PS1='foo \\l bar'"))
(command (word "tty=\"$(tty)\""))
(if (cond (cond-binary "==" (cond-term ""$tty"") (cond-term ""not a tty""))) (command (word "expected=\"tty\"")) (command (word "expected=\"$(basename \"$tty\")\"")))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "\"foo $expected bar\"")))
(command (word "echo") (word "matched=$?"))
---

=== \! for history number
set -o history # enable history
PS1='foo \! bar'
history -c # clear history
echo "${PS1@P}" | egrep -q "foo 1 bar"
echo matched=$?
echo "_${PS1@P}" | egrep -q "foo 3 bar"
echo matched=$?
---
(command (word "set") (word "-o") (word "history"))
(command (word "PS1='foo \\! bar'"))
(command (word "history") (word "-c"))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "\"foo 1 bar\"")))
(command (word "echo") (word "matched=$?"))
(pipe (command (word "echo") (word "\"_${PS1@P}\"")) (command (word "egrep") (word "-q") (word "\"foo 3 bar\"")))
(command (word "echo") (word "matched=$?"))
---

=== \# for command number
PS1='foo \# bar'
prev_cmd_num="$(echo "${PS1@P}" | egrep -o 'foo [0-9]+ bar' | sed -E 's/foo ([0-9]+) bar/\1/')"
echo "${PS1@P}" | egrep -q "foo $((prev_cmd_num + 1)) bar"
echo matched=$?
---
(command (word "PS1='foo \\# bar'"))
(command (word "prev_cmd_num=\"$(echo \"${PS1@P}\" | egrep -o 'foo [0-9]+ bar' | sed -E 's/foo ([0-9]+) bar/\\1/')\""))
(pipe (command (word "echo") (word "\"${PS1@P}\"")) (command (word "egrep") (word "-q") (word "\"foo $((prev_cmd_num + 1)) bar\"")))
(command (word "echo") (word "matched=$?"))
---

=== @P with array
$SH -c 'echo ${@@P}' dummy a b c
echo status=$?
$SH -c 'echo ${*@P}' dummy a b c
echo status=$?
$SH -c 'a=(x y); echo ${a@P}' dummy a b c
echo status=$?
---
(command (word "$SH") (word "-c") (word "'echo ${@@P}'") (word "dummy") (word "a") (word "b") (word "c"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo ${*@P}'") (word "dummy") (word "a") (word "b") (word "c"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'a=(x y); echo ${a@P}'") (word "dummy") (word "a") (word "b") (word "c"))
(command (word "echo") (word "status=$?"))
---

=== default PS1
#flags='--norc --noprofile'
flags='--rcfile /dev/null'

$SH $flags -i -c 'echo "_${PS1}_"'
---
(command (word "flags='--rcfile /dev/null'"))
(command (word "$SH") (word "$flags") (word "-i") (word "-c") (word "'echo \"_${PS1}_\"'"))
---

=== Unquoted words
echo unquoted    words
---
(command (word "echo") (word "unquoted") (word "words"))
---

=== Single-quoted
echo 'single   quoted'
---
(command (word "echo") (word "'single   quoted'"))
---

=== Two single-quoted parts
echo 'two single-quoted pa''rts in one token'
---
(command (word "echo") (word "'two single-quoted pa''rts in one token'"))
---

=== Unquoted and single quoted
echo unquoted' and single-quoted'
---
(command (word "echo") (word "unquoted' and single-quoted'"))
---

=== newline inside single-quoted string
echo 'newline
inside single-quoted string'
---
(command (word "echo") (word "'newline\ninside single-quoted string'"))
---

=== Double-quoted
echo "double   quoted"
---
(command (word "echo") (word "\"double   quoted\""))
---

=== Mix of quotes in one word
echo unquoted'  single-quoted'"  double-quoted  "unquoted
---
(command (word "echo") (word "unquoted'  single-quoted'\"  double-quoted  \"unquoted"))
---

=== Var substitution
FOO=bar
echo "==$FOO=="
---
(command (word "FOO=bar"))
(command (word "echo") (word "\"==$FOO==\""))
---

=== Var substitution with braces
FOO=bar
echo foo${FOO}
---
(command (word "FOO=bar"))
(command (word "echo") (word "foo${FOO}"))
---

=== Var substitution with braces, quoted
FOO=bar
echo "foo${FOO}"
---
(command (word "FOO=bar"))
(command (word "echo") (word "\"foo${FOO}\""))
---

=== Var length
FOO=bar
echo "foo${#FOO}"
---
(command (word "FOO=bar"))
(command (word "echo") (word "\"foo${#FOO}\""))
---

=== Storing backslashes and then echoing them
# This is a bug fix; it used to cause problems with unescaping.
one='\'
two='\\'
echo $one $two
echo "$one" "$two"
---
(command (word "one='\\'"))
(command (word "two='\\\\'"))
(command (word "echo") (word "$one") (word "$two"))
(command (word "echo") (word "\"$one\"") (word "\"$two\""))
---

=== Backslash escapes
echo \$ \| \a \b \c \d \\
---
(command (word "echo") (word "\\$") (word "\\|") (word "\\a") (word "\\b") (word "\\c") (word "\\d") (word "\\\\"))
---

=== Backslash escapes inside double quoted string
echo "\$ \\ \\ \p \q"
---
(command (word "echo") (word "\"\\$ \\\\ \\\\ \\p \\q\""))
---

=== C-style backslash escapes inside double quoted string
# mksh and dash implement POSIX incompatible extensions.  $ ` " \ <newline>
# are the only special ones
echo "\a \b"
---
(command (word "echo") (word "\"\\a \\b\""))
---

=== Literal $
echo $
---
(command (word "echo") (word "$"))
---

=== Quoted Literal $
echo $ "$" $
---
(command (word "echo") (word "$") (word "\"$\"") (word "$"))
---

=== Line continuation
echo foo\
$
---
(command (word "echo") (word "foo$"))
---

=== Line continuation inside double quotes
echo "foo\
$"
---
(command (word "echo") (word "\"foo$\""))
---

=== $? split over multiple lines
# Same with $$, etc.  OSH won't do this because $? is a single token.
echo $\
?
---
(command (word "echo") (word "$?"))
---

=== Semicolon
echo separated; echo by semi-colon
---
(semi (command (word "echo") (word "separated")) (command (word "echo") (word "by") (word "semi-colon")))
---

=== No tab escapes within single quotes
# dash and mksh allow this, which is a BUG.
# POSIX says: "Enclosing characters in single-quotes ( '' ) shall preserve the
# literal value of each character within the single-quotes. A single-quote
# cannot occur within single-quotes"
echo 'a\tb'
---
(command (word "echo") (word "'a\\tb'"))
---

=== $''
echo $'foo'
---
(command (word "echo") (word "'foo'"))
---

=== $'' with quotes
echo $'single \' double \"'
---
(command (word "echo") (word "'single '\\'' double \"'"))
---

=== $'' with newlines
echo $'col1\ncol2\ncol3'
---
(command (word "echo") (word "'col1\ncol2\ncol3'"))
---

=== $'' octal escapes don't have leading 0
# echo -e syntax is echo -e \0377
echo -n $'\001' $'\377' | od -A n -c | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "-n") (word "''") (word "''")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== $'' octal escapes with fewer than 3 chars
echo $'\1 \11 \11 \111' | od -A n -c | sed 's/ \+/ /g'
---
(pipe (command (word "echo") (word "' \t \t I'")) (pipe (command (word "od") (word "-A") (word "n") (word "-c")) (command (word "sed") (word "'s/ \\+/ /g'"))))
---

=== OSH allows invalid backslashes
case $SH in dash|mksh) exit ;; esac

w=$'\uZ'
x=$'\u{03bc'
y=$'\z'
echo $w $x $y
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "w='\\uZ'"))
(command (word "x='\\u{03bc'"))
(command (word "y='\\z'"))
(command (word "echo") (word "$w") (word "$x") (word "$y"))
---

=== YSH allows unquoted foo\ bar too
shopt -s ysh:all
touch foo\ bar
ls foo\ bar
---
(command (word "shopt") (word "-s") (word "ysh:all"))
(command (word "touch") (word "foo\\ bar"))
(command (word "ls") (word "foo\\ bar"))
---

=== $"" is a synonym for ""
echo $"foo"
x=x
echo $"foo $x"
---
(command (word "echo") (word "\"foo\""))
(command (word "x=x"))
(command (word "echo") (word "\"foo $x\""))
---

=== printf supports tabs
# This accepts \t by itself, hm.
printf "c1\tc2\nc3\tc4\n"
---
(command (word "printf") (word "\"c1\\tc2\\nc3\\tc4\\n\""))
---

=== $'' supports \cA escape for Ctrl-A - mask with 0x1f
# note: AT&T ksh supports this too

case $SH in dash|ash) exit ;; esac

show_bytes() {
  # -A n - no file offset
  od -A n -t c -t x1
}

# this isn't special
# mksh doesn't like it
#echo -n $'\c' | show_bytes

echo -n $'\c0\c9-' | show_bytes
echo

# control chars are case insensitive
echo -n $'\ca\cz' | show_bytes
echo

echo -n $'\cA\cZ' | show_bytes
echo

echo -n $'\c-\c+\c"' | show_bytes
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(function "show_bytes" (brace-group (command (word "od") (word "-A") (word "n") (word "-t") (word "c") (word "-t") (word "x1"))))
(pipe (command (word "echo") (word "-n") (word "'-'")) (command (word "show_bytes")))
(command (word "echo"))
(pipe (command (word "echo") (word "-n") (word "''")) (command (word "show_bytes")))
(command (word "echo"))
(pipe (command (word "echo") (word "-n") (word "''")) (command (word "show_bytes")))
(command (word "echo"))
(pipe (command (word "echo") (word "-n") (word "'
'")) (command (word "show_bytes")))
---

=== echo `cat OSCFLAGS` "world" > OSCFLAGS (from Alpine imap)
echo hello > OSCFLAGS
echo `cat OSCFLAGS` "world" > OSCFLAGS
#echo $(cat OSCFLAGS) "world" > OSCFLAGS
cat OSCFLAGS
---
(command (word "echo") (word "hello") (redirect ">" "OSCFLAGS"))
(command (word "echo") (word "`cat OSCFLAGS`") (word "\"world\"") (redirect ">" "OSCFLAGS"))
(command (word "cat") (word "OSCFLAGS"))
---

=== subshell + redirect order
echo hello > OSCFLAGS
(echo `cat OSCFLAGS` "world") > OSCFLAGS
cat OSCFLAGS
---
(command (word "echo") (word "hello") (redirect ">" "OSCFLAGS"))
(subshell (command (word "echo") (word "`cat OSCFLAGS`") (word "\"world\""))) (redirect ">" "OSCFLAGS")
(command (word "cat") (word "OSCFLAGS"))
---

=== for word + redirect order
echo hello > OSCFLAGS
for x in `cat OSCFLAGS` world; do
  echo $x
done > OSCFLAGS
cat OSCFLAGS
---
(command (word "echo") (word "hello") (redirect ">" "OSCFLAGS"))
(for (word "x") (in (word "`cat OSCFLAGS`") (word "world")) (command (word "echo") (word "$x"))) (redirect ">" "OSCFLAGS")
(command (word "cat") (word "OSCFLAGS"))
---

=== case word + redirect order
echo hello > OSCFLAGS
case `cat OSCFLAGS` in
  hello)
    echo hello
    ;;
  *)
    echo other
    ;;
esac > OSCFLAGS
cat OSCFLAGS
---
(command (word "echo") (word "hello") (redirect ">" "OSCFLAGS"))
(case (word "`cat OSCFLAGS`") (pattern ((word "hello")) (command (word "echo") (word "hello"))) (pattern ((word "*")) (command (word "echo") (word "other")))) (redirect ">" "OSCFLAGS")
(command (word "cat") (word "OSCFLAGS"))
---

=== [[ + redirect order
case $SH in dash|ash) exit ;; esac

echo hello > OSCFLAGS

[[ `cat OSCFLAGS` = hello ]] > OSCFLAGS
echo status=$?

# it is the empty string!
[[ `cat OSCFLAGS` = '' ]] > OSCFLAGS
echo status=$?
---
(case (word "$SH") (pattern ((word "dash") (word "ash")) (command (word "exit"))))
(command (word "echo") (word "hello") (redirect ">" "OSCFLAGS"))
(cond (cond-binary "=" (cond-term "`cat OSCFLAGS`") (cond-term "hello"))) (redirect ">" "OSCFLAGS")
(command (word "echo") (word "status=$?"))
(cond (cond-binary "=" (cond-term "`cat OSCFLAGS`") (cond-term "''"))) (redirect ">" "OSCFLAGS")
(command (word "echo") (word "status=$?"))
---

=== BASH_REMATCH
[[ foo123 =~ ([a-z]+)([0-9]+) ]]
echo status=$?
argv.py "${BASH_REMATCH[@]}"

[[ failed =~ ([a-z]+)([0-9]+) ]]
echo status=$?
argv.py "${BASH_REMATCH[@]}"  # not cleared!
---
(cond (cond-binary "=~" (cond-term "foo123") (cond-term "([a-z]+)([0-9]+)")))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${BASH_REMATCH[@]}\""))
(cond (cond-binary "=~" (cond-term "failed") (cond-term "([a-z]+)([0-9]+)")))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${BASH_REMATCH[@]}\""))
---

=== Match is unanchored at both ends
[[ 'bar' =~ a ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'bar'") (cond-term "a"))) (command (word "echo") (word "true")))
---

=== Failed match
[[ 'bar' =~ X ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'bar'") (cond-term "X"))) (command (word "echo") (word "true")))
---

=== Regex quoted with \ -- preferred in bash
[[ 'a b' =~ ^(a\ b)$ ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "^(a\ b)$"))) (command (word "echo") (word "true")))
---

=== Regex quoted with single quotes
# bash doesn't like the quotes
[[ 'a b' =~ '^(a b)$' ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "'^(a b)$'"))) (command (word "echo") (word "true")))
---

=== Regex quoted with double quotes
# bash doesn't like the quotes
[[ 'a b' =~ "^(a b)$" ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term ""^(a b)$""))) (command (word "echo") (word "true")))
---

=== Fix single quotes by storing in variable
pat='^(a b)$'
[[ 'a b' =~ $pat ]] && echo true
---
(command (word "pat='^(a b)$'"))
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "$pat"))) (command (word "echo") (word "true")))
---

=== Fix single quotes by storing in variable
pat="^(a b)$"
[[ 'a b' =~ $pat ]] && echo true
---
(command (word "pat=\"^(a b)$\""))
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "$pat"))) (command (word "echo") (word "true")))
---

=== Double quoting pat variable -- again bash doesn't like it.
pat="^(a b)$"
[[ 'a b' =~ "$pat" ]] && echo true
---
(command (word "pat=\"^(a b)$\""))
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term ""$pat""))) (command (word "echo") (word "true")))
---

=== Mixing quoted and unquoted parts
[[ 'a b' =~ 'a 'b ]] && echo true
[[ "a b" =~ "a "'b' ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "'a 'b"))) (command (word "echo") (word "true")))
(and (cond (cond-binary "=~" (cond-term ""a b"") (cond-term ""a "'b'"))) (command (word "echo") (word "true")))
---

=== Omitting ( )
[[ '^a b$' == ^a\ b$ ]] && echo true
---
(and (cond (cond-binary "==" (cond-term "'^a b$'") (cond-term "^a\ b$"))) (command (word "echo") (word "true")))
---

=== Regex with |
[[ 'bar' =~ foo|bar ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'bar'") (cond-term "foo|bar"))) (command (word "echo") (word "true")))
---

=== Regex to match literal brackets []
# bash-completion relies on this, so we're making it match bash.
# zsh understandably differs.
[[ '[]' =~ \[\] ]] && echo true

# Another way to write this.
pat='\[\]'
[[ '[]' =~ $pat ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'[]'") (cond-term "\[\]"))) (command (word "echo") (word "true")))
(command (word "pat='\\[\\]'"))
(and (cond (cond-binary "=~" (cond-term "'[]'") (cond-term "$pat"))) (command (word "echo") (word "true")))
---

=== Regex to match literals . ^ $ etc.
[[ 'x' =~ \. ]] || echo false
[[ '.' =~ \. ]] && echo true

[[ 'xx' =~ \^\$ ]] || echo false
[[ '^$' =~ \^\$ ]] && echo true

[[ 'xxx' =~ \+\*\? ]] || echo false
[[ '*+?' =~ \*\+\? ]] && echo true

[[ 'xx' =~ \{\} ]] || echo false
[[ '{}' =~ \{\} ]] && echo true
---
(or (cond (cond-binary "=~" (cond-term "'x'") (cond-term "\."))) (command (word "echo") (word "false")))
(and (cond (cond-binary "=~" (cond-term "'.'") (cond-term "\."))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=~" (cond-term "'xx'") (cond-term "\^\$"))) (command (word "echo") (word "false")))
(and (cond (cond-binary "=~" (cond-term "'^$'") (cond-term "\^\$"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=~" (cond-term "'xxx'") (cond-term "\+\*\?"))) (command (word "echo") (word "false")))
(and (cond (cond-binary "=~" (cond-term "'*+?'") (cond-term "\*\+\?"))) (command (word "echo") (word "true")))
(or (cond (cond-binary "=~" (cond-term "'xx'") (cond-term "\{\}"))) (command (word "echo") (word "false")))
(and (cond (cond-binary "=~" (cond-term "'{}'") (cond-term "\{\}"))) (command (word "echo") (word "true")))
---

=== Unquoted { is a regex parse error
[[ { =~ { ]] && echo true
echo status=$?
---
(and (cond (cond-binary "=~" (cond-term "{") (cond-term "{"))) (command (word "echo") (word "true")))
(command (word "echo") (word "status=$?"))
---

=== Fatal error inside [[ =~ ]]
# zsh and osh are stricter than bash.  bash treats [[ like a command.

[[ a =~ $(( 1 / 0 )) ]]
echo status=$?
---
(cond (cond-binary "=~" (cond-term "a") (cond-term "$(( 1 / 0 ))")))
(command (word "echo") (word "status=$?"))
---

=== Quoted { and +
[[ { =~ "{" ]] && echo 'yes {'
[[ + =~ "+" ]] && echo 'yes +'
[[ * =~ "*" ]] && echo 'yes *'
[[ ? =~ "?" ]] && echo 'yes ?'
[[ ^ =~ "^" ]] && echo 'yes ^'
[[ $ =~ "$" ]] && echo 'yes $'
[[ '(' =~ '(' ]] && echo 'yes ('
[[ ')' =~ ')' ]] && echo 'yes )'
[[ '|' =~ '|' ]] && echo 'yes |'
[[ '\' =~ '\' ]] && echo 'yes \'
echo ---

[[ . =~ "." ]] && echo 'yes .'
[[ z =~ "." ]] || echo 'no .'
echo ---

# This rule is weird but all shells agree.  I would expect that the - gets
# escaped?  It's an operator?  but it behaves like a-z.
[[ a =~ ["a-z"] ]]; echo "a $?"
[[ - =~ ["a-z"] ]]; echo "- $?"
[[ b =~ ['a-z'] ]]; echo "b $?"
[[ z =~ ['a-z'] ]]; echo "z $?"

echo status=$?
---
(and (cond (cond-binary "=~" (cond-term "{") (cond-term ""{""))) (command (word "echo") (word "'yes {'")))
(and (cond (cond-binary "=~" (cond-term "+") (cond-term ""+""))) (command (word "echo") (word "'yes +'")))
(and (cond (cond-binary "=~" (cond-term "*") (cond-term ""*""))) (command (word "echo") (word "'yes *'")))
(and (cond (cond-binary "=~" (cond-term "?") (cond-term ""?""))) (command (word "echo") (word "'yes ?'")))
(and (cond (cond-binary "=~" (cond-term "^") (cond-term ""^""))) (command (word "echo") (word "'yes ^'")))
(and (cond (cond-binary "=~" (cond-term "$") (cond-term ""$""))) (command (word "echo") (word "'yes $'")))
(and (cond (cond-binary "=~" (cond-term "'('") (cond-term "'('"))) (command (word "echo") (word "'yes ('")))
(and (cond (cond-binary "=~" (cond-term "')'") (cond-term "')'"))) (command (word "echo") (word "'yes )'")))
(and (cond (cond-binary "=~" (cond-term "'|'") (cond-term "'|'"))) (command (word "echo") (word "'yes |'")))
(and (cond (cond-binary "=~" (cond-term "'\'") (cond-term "'\'"))) (command (word "echo") (word "'yes \\'")))
(command (word "echo") (word "---"))
(and (cond (cond-binary "=~" (cond-term ".") (cond-term "".""))) (command (word "echo") (word "'yes .'")))
(or (cond (cond-binary "=~" (cond-term "z") (cond-term "".""))) (command (word "echo") (word "'no .'")))
(command (word "echo") (word "---"))
(semi (cond (cond-binary "=~" (cond-term "a") (cond-term "["a-z"]"))) (command (word "echo") (word "\"a $?\"")))
(semi (cond (cond-binary "=~" (cond-term "-") (cond-term "["a-z"]"))) (command (word "echo") (word "\"- $?\"")))
(semi (cond (cond-binary "=~" (cond-term "b") (cond-term "['a-z']"))) (command (word "echo") (word "\"b $?\"")))
(semi (cond (cond-binary "=~" (cond-term "z") (cond-term "['a-z']"))) (command (word "echo") (word "\"z $?\"")))
(command (word "echo") (word "status=$?"))
---

=== Escaped {
# from bash-completion
[[ '$PA' =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]] && argv.py "${BASH_REMATCH[@]}"
---
(and (cond (cond-binary "=~" (cond-term "'$PA'") (cond-term "^(\$\{?)([A-Za-z0-9_]*)$"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
---

=== Escaped { stored in variable first
# from bash-completion
pat='^(\$\{?)([A-Za-z0-9_]*)$'
[[ '$PA' =~ $pat ]] && argv.py "${BASH_REMATCH[@]}"
---
(command (word "pat='^(\\$\\{?)([A-Za-z0-9_]*)$'"))
(and (cond (cond-binary "=~" (cond-term "'$PA'") (cond-term "$pat"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
---

=== regex with ?
[[ 'c' =~ c? ]] && echo true
[[ '' =~ c? ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'c'") (cond-term "c?"))) (command (word "echo") (word "true")))
(and (cond (cond-binary "=~" (cond-term "''") (cond-term "c?"))) (command (word "echo") (word "true")))
---

=== regex with unprintable characters
# can't have nul byte

# This pattern has literal characters
pat=$'^[\x01\x02]+$'

[[ $'\x01\x02\x01' =~ $pat ]]; echo status=$?
[[ $'a\x01' =~ $pat ]]; echo status=$?

# NOTE: There doesn't appear to be any way to escape these!
pat2='^[\x01\x02]+$'
---
(command (word "pat='^[]+$'"))
(semi (cond (cond-binary "=~" (cond-term "''") (cond-term "$pat"))) (command (word "echo") (word "status=$?")))
(semi (cond (cond-binary "=~" (cond-term "'a'") (cond-term "$pat"))) (command (word "echo") (word "status=$?")))
(command (word "pat2='^[\\x01\\x02]+$'"))
---

=== pattern $f(x)  -- regression
f=fff
[[ fffx =~ $f(x) ]]
echo status=$?
[[ ffx =~ $f(x) ]]
echo status=$?
---
(command (word "f=fff"))
(cond (cond-binary "=~" (cond-term "fffx") (cond-term "$f(x)")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "=~" (cond-term "ffx") (cond-term "$f(x)")))
(command (word "echo") (word "status=$?"))
---

=== pattern a=(1)
[[ a=x =~ a=(x) ]]
echo status=$?
[[ =x =~ a=(x) ]]
echo status=$?
---
(cond (cond-binary "=~" (cond-term "a=x") (cond-term "a=(x)")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "=~" (cond-term "=x") (cond-term "a=(x)")))
(command (word "echo") (word "status=$?"))
---

=== pattern @f(x)
shopt -s parse_at
[[ @fx =~ @f(x) ]]
echo status=$?
[[ fx =~ @f(x) ]]
echo status=$?
---
(command (word "shopt") (word "-s") (word "parse_at"))
(cond (cond-binary "=~" (cond-term "@fx") (cond-term "@f(x)")))
(command (word "echo") (word "status=$?"))
(cond (cond-binary "=~" (cond-term "fx") (cond-term "@f(x)")))
(command (word "echo") (word "status=$?"))
---

=== Bug: Nix idiom with closing ) next to pattern
if [[ ! (" ${params[*]} " =~ " -shared " || " ${params[*]} " =~ " -static ") ]]; then
  echo one
fi

# Reduced idiom
if [[ (foo =~ foo) ]]; then
  echo two
fi
---
(if (cond (cond-expr (cond-or (cond-binary "=~" (cond-term "" ${params[*]} "") (cond-term "" -shared "")) (cond-binary "=~" (cond-term "" ${params[*]} "") (cond-term "" -static ""))))) (command (word "echo") (word "one")))
(if (cond (cond-expr (cond-binary "=~" (cond-term "foo") (cond-term "foo")))) (command (word "echo") (word "two")))
---

=== unquoted (a  b) as pattern, (a  b|c)
if [[ 'a  b' =~ (a  b) ]]; then
  echo one
fi

if [[ 'a b' =~ (a  b) ]]; then
  echo BAD
fi

if [[ 'a b' =~ (a b|c) ]]; then
  echo two
fi

# I think spaces are only allowed within ()

if [[ '  c' =~ (a|  c) ]]; then
  echo three
fi
---
(if (cond (cond-binary "=~" (cond-term "'a  b'") (cond-term "(a  b)"))) (command (word "echo") (word "one")))
(if (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "(a  b)"))) (command (word "echo") (word "BAD")))
(if (cond (cond-binary "=~" (cond-term "'a b'") (cond-term "(a b|c)"))) (command (word "echo") (word "two")))
(if (cond (cond-binary "=~" (cond-term "'  c'") (cond-term "(a|  c)"))) (command (word "echo") (word "three")))
---

=== Multiple adjacent () groups
if [[ 'a-b-c-d' =~ a-(b|  >>)-c-( ;|[de])|ff|gg ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

if [[ ff =~ a-(b|  >>)-c-( ;|[de])|ff|gg ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

# empty group ()

if [[ zz =~ ([a-z]+)() ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

# nested empty group
if [[ zz =~ ([a-z]+)(()z) ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi
---
(if (cond (cond-binary "=~" (cond-term "'a-b-c-d'") (cond-term "a-(b|  >>)-c-( ;|[de])|ff|gg"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
(if (cond (cond-binary "=~" (cond-term "ff") (cond-term "a-(b|  >>)-c-( ;|[de])|ff|gg"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
(if (cond (cond-binary "=~" (cond-term "zz") (cond-term "([a-z]+)()"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
(if (cond (cond-binary "=~" (cond-term "zz") (cond-term "([a-z]+)(()z)"))) (command (word "argv.py") (word "\"${BASH_REMATCH[@]}\"")))
---

=== unquoted [a  b] as pattern, [a  b|c]
$SH <<'EOF'
[[ a =~ [ab] ]] && echo yes
EOF
echo "[ab]=$?"

$SH <<'EOF'
[[ a =~ [a b] ]] && echo yes
EOF
echo "[a b]=$?"

$SH <<'EOF'
[[ a =~ ([a b]) ]] && echo yes
EOF
echo "[a b]=$?"
---
(command (word "$SH") (redirect "<<" "[[ a =~ [ab] ]] && echo yes
"))
(command (word "echo") (word "\"[ab]=$?\""))
(command (word "$SH") (redirect "<<" "[[ a =~ [a b] ]] && echo yes
"))
(command (word "echo") (word "\"[a b]=$?\""))
(command (word "$SH") (redirect "<<" "[[ a =~ ([a b]) ]] && echo yes
"))
(command (word "echo") (word "\"[a b]=$?\""))
---

=== c|a unquoted
if [[ a =~ c|a ]]; then
  echo one
fi
---
(if (cond (cond-binary "=~" (cond-term "a") (cond-term "c|a"))) (command (word "echo") (word "one")))
---

=== Operator chars ; & but not |
# Hm semicolon is still an operator in bash
$SH <<'EOF'
[[ ';' =~ ; ]] && echo semi
EOF
echo semi=$?

$SH <<'EOF'
[[ ';' =~ (;) ]] && echo semi paren
EOF
echo semi paren=$?

echo

$SH <<'EOF'
[[ '&' =~ & ]] && echo amp
EOF
echo amp=$?

# Oh I guess this is not a bug?  regcomp doesn't reject this trivial regex?
$SH <<'EOF'
[[ '|' =~ | ]] && echo pipe1
[[ 'a' =~ | ]] && echo pipe2
EOF
echo pipe=$?

$SH <<'EOF'
[[ '|' =~ a| ]] && echo four
EOF
echo pipe=$?

# This is probably special because > operator is inside foo [[ a > b ]]
$SH <<'EOF'
[[ '<>' =~ <> ]] && echo angle
EOF
echo angle=$?

# Bug: OSH allowed this!
$SH <<'EOF'
[[ $'a\nb' =~ a
b ]] && echo newline
EOF
echo newline=$?
---
(command (word "$SH") (redirect "<<" "[[ ';' =~ ; ]] && echo semi
"))
(command (word "echo") (word "semi=$?"))
(command (word "$SH") (redirect "<<" "[[ ';' =~ (;) ]] && echo semi paren
"))
(command (word "echo") (word "semi") (word "paren=$?"))
(command (word "echo"))
(command (word "$SH") (redirect "<<" "[[ '&' =~ & ]] && echo amp
"))
(command (word "echo") (word "amp=$?"))
(command (word "$SH") (redirect "<<" "[[ '|' =~ | ]] && echo pipe1
[[ 'a' =~ | ]] && echo pipe2
"))
(command (word "echo") (word "pipe=$?"))
(command (word "$SH") (redirect "<<" "[[ '|' =~ a| ]] && echo four
"))
(command (word "echo") (word "pipe=$?"))
(command (word "$SH") (redirect "<<" "[[ '<>' =~ <> ]] && echo angle
"))
(command (word "echo") (word "angle=$?"))
(command (word "$SH") (redirect "<<" "[[ $'a\nb' =~ a
b ]] && echo newline
"))
(command (word "echo") (word "newline=$?"))
---

=== Quotes '' "" $'' $"" in pattern
$SH <<'EOF'
[[ '|' =~ '|' ]] && echo sq
EOF
echo sq=$?

$SH <<'EOF'
[[ '|' =~ "|" ]] && echo dq
EOF
echo dq=$?

$SH <<'EOF'
[[ '|' =~ $'|' ]] && echo dollar-sq
EOF
echo dollar-sq=$?

$SH <<'EOF'
[[ '|' =~ $"|" ]] && echo dollar-dq
EOF
echo dollar-dq=$?
---
(command (word "$SH") (redirect "<<" "[[ '|' =~ '|' ]] && echo sq
"))
(command (word "echo") (word "sq=$?"))
(command (word "$SH") (redirect "<<" "[[ '|' =~ "|" ]] && echo dq
"))
(command (word "echo") (word "dq=$?"))
(command (word "$SH") (redirect "<<" "[[ '|' =~ $'|' ]] && echo dollar-sq
"))
(command (word "echo") (word "dollar-sq=$?"))
(command (word "$SH") (redirect "<<" "[[ '|' =~ $"|" ]] && echo dollar-dq
"))
(command (word "echo") (word "dollar-dq=$?"))
---

=== Unicode in pattern
$SH <<'EOF'
[[  =~  ]] && echo mu
EOF
echo mu=$?
---
(command (word "$SH") (redirect "<<" "[[  =~  ]] && echo mu
"))
(command (word "echo") (word "mu=$?"))
---

=== make a lisp example
str='(hi)'
[[ "${str}" =~ ^^([][{}\(\)^@])|^(~@)|(\"(\\.|[^\\\"])*\")|^(;[^$'\n']*)|^([~\'\`])|^([^][ ~\`\'\";{}\(\)^@\,]+)|^[,]|^[[:space:]]+ ]]
echo status=$?

m=${BASH_REMATCH[0]}
echo m=$m
---
(command (word "str='(hi)'"))
(cond (cond-binary "=~" (cond-term ""${str}"") (cond-term "^^([][{}\(\)^@])|^(~@)|(\"(\\.|[^\\\"])*\")|^(;[^'
']*)|^([~\'\`])|^([^][ ~\`\'\";{}\(\)^@\,]+)|^[,]|^[[:space:]]+")))
(command (word "echo") (word "status=$?"))
(command (word "m=${BASH_REMATCH[0]}"))
(command (word "echo") (word "m=$m"))
---

=== Operators and space lose meaning inside ()
[[ '< >' =~ (< >) ]] && echo true
---
(and (cond (cond-binary "=~" (cond-term "'< >'") (cond-term "(< >)"))) (command (word "echo") (word "true")))
---

=== printf %q newline
case $SH in ash) return ;; esac  # yash and ash don't implement this

newline=$'one\ntwo'
printf '%q\n' "$newline"

quoted="$(printf '%q\n' "$newline")"
restored=$(eval "echo $quoted")
test "$newline" = "$restored" && echo roundtrip-ok
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "newline='one\ntwo'"))
(command (word "printf") (word "'%q\\n'") (word "\"$newline\""))
(command (word "quoted=\"$(printf '%q\\n' \"$newline\")\""))
(command (word "restored=$(eval \"echo $quoted\")"))
(and (command (word "test") (word "\"$newline\"") (word "=") (word "\"$restored\"")) (command (word "echo") (word "roundtrip-ok")))
---

=== printf %q spaces
case $SH in ash) return ;; esac  # yash and ash don't implement this

# bash does a weird thing and uses \

spaces='one two'
printf '%q\n' "$spaces"
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "spaces='one two'"))
(command (word "printf") (word "'%q\\n'") (word "\"$spaces\""))
---

=== printf %q quotes
case $SH in ash) return ;; esac  # yash and ash don't implement %q

quotes=\'\"
printf '%q\n' "$quotes"

quoted="$(printf '%q\n' "$quotes")"
restored=$(eval "echo $quoted")
test "$quotes" = "$restored" && echo roundtrip-ok
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "quotes=\\'\\\""))
(command (word "printf") (word "'%q\\n'") (word "\"$quotes\""))
(command (word "quoted=\"$(printf '%q\\n' \"$quotes\")\""))
(command (word "restored=$(eval \"echo $quoted\")"))
(and (command (word "test") (word "\"$quotes\"") (word "=") (word "\"$restored\"")) (command (word "echo") (word "roundtrip-ok")))
---

=== printf %q unprintable
case $SH in ash) return ;; esac  # yash and ash don't implement this

unprintable=$'\xff'
printf '%q\n' "$unprintable"

# bash and zsh agree
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "unprintable=''"))
(command (word "printf") (word "'%q\\n'") (word "\"$unprintable\""))
---

=== printf %q unicode
case $SH in ash) return ;; esac  # yash and ash don't implement this

unicode=$'\u03bc'
unicode=$'\xce\xbc'  # does the same thing

printf '%q\n' "$unicode"

# OSH issue: we have quotes.  Isn't that OK?
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "unicode=''"))
(command (word "unicode=''"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
---

=== printf %q invalid unicode
case $SH in ash) return ;; esac

# Hm bash/mksh/zsh understand these.  They are doing decoding and error
# recovery!  inspecting the bash source seems to confirm this.
unicode=$'\xce'
printf '%q\n' "$unicode"

unicode=$'\xce\xce\xbc'
printf '%q\n' "$unicode"

unicode=$'\xce\xbc\xce'
printf '%q\n' "$unicode"

case $SH in mksh) return ;; esac  # it prints unprintable chars here!

unicode=$'\xcea'
printf '%q\n' "$unicode"
unicode=$'a\xce'
printf '%q\n' "$unicode"
---
(case (word "$SH") (pattern ((word "ash")) (command (word "return"))))
(command (word "unicode=''"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
(command (word "unicode=''"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
(command (word "unicode=''"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
(case (word "$SH") (pattern ((word "mksh")) (command (word "return"))))
(command (word "unicode='a'"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
(command (word "unicode='a'"))
(command (word "printf") (word "'%q\\n'") (word "\"$unicode\""))
---

=== set
case $SH in zsh) return ;; esac  # zsh doesn't make much sense

zz=$'one\ntwo'

set | grep zz
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "return"))))
(command (word "zz='one\ntwo'"))
(pipe (command (word "set")) (command (word "grep") (word "zz")))
---

=== declare
case $SH in ash|zsh) return ;; esac  # zsh doesn't make much sense

zz=$'one\ntwo'

typeset | grep zz
typeset -p zz
---
(case (word "$SH") (pattern ((word "ash") (word "zsh")) (command (word "return"))))
(command (word "zz='one\ntwo'"))
(pipe (command (word "typeset")) (command (word "grep") (word "zz")))
(command (word "typeset") (word "-p") (word "zz"))
---

=== ${var@Q}
case $SH in zsh|ash) exit ;; esac

zz=$'one\ntwo \u03bc'

# weirdly, quoted and unquoted aren't different
echo ${zz@Q}
echo "${zz@Q}"
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "zz='one\ntwo '"))
(command (word "echo") (word "${zz@Q}"))
(command (word "echo") (word "\"${zz@Q}\""))
---

=== xtrace
zz=$'one\ntwo'
set -x
echo "$zz"
---
(command (word "zz='one\ntwo'"))
(command (word "set") (word "-x"))
(command (word "echo") (word "\"$zz\""))
---

=== Locals don't leak
f() {
  local f_var=f_var
}
f
echo $f_var
---
(function "f" (brace-group (command (word "local") (word "f_var=f_var"))))
(command (word "f"))
(command (word "echo") (word "$f_var"))
---

=== Globals leak
f() {
  f_var=f_var
}
f
echo $f_var
---
(function "f" (brace-group (command (word "f_var=f_var"))))
(command (word "f"))
(command (word "echo") (word "$f_var"))
---

=== Return statement
f() {
  echo one
  return 42
  echo two
}
f
---
(function "f" (brace-group (semi (semi (command (word "echo") (word "one")) (command (word "return") (word "42"))) (command (word "echo") (word "two")))))
(command (word "f"))
---

=== Dynamic Scope
f() {
  echo $g_var
}
g() {
  local g_var=g_var
  f
}
g
---
(function "f" (brace-group (command (word "echo") (word "$g_var"))))
(function "g" (brace-group (semi (command (word "local") (word "g_var=g_var")) (command (word "f")))))
(command (word "g"))
---

=== Dynamic Scope Mutation (wow this is bad)
f() {
  g_var=f_mutation
}
g() {
  local g_var=g_var
  echo "g_var=$g_var"
  f
  echo "g_var=$g_var"
}
g
echo g_var=$g_var
---
(function "f" (brace-group (command (word "g_var=f_mutation"))))
(function "g" (brace-group (semi (semi (semi (command (word "local") (word "g_var=g_var")) (command (word "echo") (word "\"g_var=$g_var\""))) (command (word "f"))) (command (word "echo") (word "\"g_var=$g_var\"")))))
(command (word "g"))
(command (word "echo") (word "g_var=$g_var"))
---

=== Assign local separately
f() {
  local f
  f='new-value'
  echo "[$f]"
}
f
---
(function "f" (brace-group (semi (semi (command (word "local") (word "f")) (command (word "f='new-value'"))) (command (word "echo") (word "\"[$f]\"")))))
(command (word "f"))
---

=== Assign a local and global on same line
myglobal=
f() {
  local mylocal
  mylocal=L myglobal=G
  echo "[$mylocal $myglobal]"
}
f
echo "[$mylocal $myglobal]"
---
(command (word "myglobal="))
(function "f" (brace-group (semi (semi (command (word "local") (word "mylocal")) (command (word "mylocal=L") (word "myglobal=G"))) (command (word "echo") (word "\"[$mylocal $myglobal]\"")))))
(command (word "f"))
(command (word "echo") (word "\"[$mylocal $myglobal]\""))
---

=== Return without args gives previous
f() {
  ( exit 42 )
  return
}
f
echo status=$?
---
(function "f" (brace-group (semi (subshell (command (word "exit") (word "42"))) (command (word "return")))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
---

=== return "" (a lot of disagreement)
f() {
  echo f
  return ""
}

f
echo status=$?
---
(function "f" (brace-group (semi (command (word "echo") (word "f")) (command (word "return") (word "\"\"")))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
---

=== return $empty
f() {
  echo f
  empty=
  return $empty
}

f
echo status=$?
---
(function "f" (brace-group (semi (semi (command (word "echo") (word "f")) (command (word "empty="))) (command (word "return") (word "$empty")))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
---

=== Subshell function
f() ( return 42; )
# BUG: OSH raises invalid control flow!  I think we should just allow 'return'
# but maybe not 'break' etc.
g() ( return 42 )
# bash warns here but doesn't cause an error
# g() ( break )

f
echo status=$?
g
echo status=$?
---
(function "f" (subshell (command (word "return") (word "42"))))
(function "g" (subshell (command (word "return") (word "42"))))
(command (word "f"))
(command (word "echo") (word "status=$?"))
(command (word "g"))
(command (word "echo") (word "status=$?"))
---

=== Scope of global variable when sourced in function (Shell Functions aren't Closures)
set -u

echo >tmp.sh '
g="global"
local L="local"

test_func() {
  echo "g = $g"
  echo "L = $L"
}
'

main() {
  # a becomes local here
  # test_func is defined globally
  . ./tmp.sh
}

main

# a is not defined
test_func
---
(command (word "set") (word "-u"))
(command (word "echo") (word "'\ng=\"global\"\nlocal L=\"local\"\n\ntest_func() {\n  echo \"g = $g\"\n  echo \"L = $L\"\n}\n'") (redirect ">" "tmp.sh"))
(function "main" (brace-group (command (word ".") (word "./tmp.sh"))))
(command (word "main"))
(command (word "test_func"))
---

=== SHELLOPTS is updated when options are changed
echo $SHELLOPTS | grep -q xtrace
echo $?
set -x
echo $SHELLOPTS | grep -q xtrace
echo $?
set +x
echo $SHELLOPTS | grep -q xtrace
echo $?
---
(pipe (command (word "echo") (word "$SHELLOPTS")) (command (word "grep") (word "-q") (word "xtrace")))
(command (word "echo") (word "$?"))
(command (word "set") (word "-x"))
(pipe (command (word "echo") (word "$SHELLOPTS")) (command (word "grep") (word "-q") (word "xtrace")))
(command (word "echo") (word "$?"))
(command (word "set") (word "+x"))
(pipe (command (word "echo") (word "$SHELLOPTS")) (command (word "grep") (word "-q") (word "xtrace")))
(command (word "echo") (word "$?"))
---

=== SHELLOPTS is readonly
SHELLOPTS=x
echo status=$?
---
(command (word "SHELLOPTS=x"))
(command (word "echo") (word "status=$?"))
---

=== SHELLOPTS and BASHOPTS are non-empty
# 2024-06 - tickled by Samuel testing Gentoo

if test -v SHELLOPTS; then
  echo 'shellopts is set'
fi
if test -v BASHOPTS; then
	echo 'bashopts is set'
fi

# bash: braceexpand:hashall etc.

echo shellopts ${SHELLOPTS:?} > /dev/null
echo bashopts ${BASHOPTS:?} > /dev/null
---
(if (command (word "test") (word "-v") (word "SHELLOPTS")) (command (word "echo") (word "'shellopts is set'")))
(if (command (word "test") (word "-v") (word "BASHOPTS")) (command (word "echo") (word "'bashopts is set'")))
(command (word "echo") (word "shellopts") (word "${SHELLOPTS:?}") (redirect ">" "/dev/null"))
(command (word "echo") (word "bashopts") (word "${BASHOPTS:?}") (redirect ">" "/dev/null"))
---

=== SHELLOPTS reflects flags like sh -x
$SH -x -c 'echo $SHELLOPTS' | grep -o xtrace
---
(pipe (command (word "$SH") (word "-x") (word "-c") (word "'echo $SHELLOPTS'")) (command (word "grep") (word "-o") (word "xtrace")))
---

=== export SHELLOPTS does cross-process tracing
$SH -c '
export SHELLOPTS
set -x
echo 1
$SH -c "echo 2"
' 2>&1 | sed 's/.*sh /sh /g'
---
(pipe (command (word "$SH") (word "-c") (word "'\nexport SHELLOPTS\nset -x\necho 1\n$SH -c \"echo 2\"\n'") (redirect ">&" 1)) (command (word "sed") (word "'s/.*sh /sh /g'")))
---

=== export SHELLOPTS does cross-process tracing with bash
# calling bash
$SH -c '
export SHELLOPTS
set -x
#echo SHELLOPTS=$SHELLOPTS
echo 1
bash -c "echo 2"
' 2>&1 | sed 's/.*sh /sh /g'
---
(pipe (command (word "$SH") (word "-c") (word "'\nexport SHELLOPTS\nset -x\n#echo SHELLOPTS=$SHELLOPTS\necho 1\nbash -c \"echo 2\"\n'") (redirect ">&" 1)) (command (word "sed") (word "'s/.*sh /sh /g'")))
---

=== OSH calling bash with SHELLOPTS does not change braceexpand
#echo outside=$SHELLOPTS

# sed pattern to normalize spaces
normalize='s/[ \t]\+/ /g'

bash -c '
#echo bash=$SHELLOPTS
set -o | grep braceexpand | sed "$1"
' unused "$normalize"

env SHELLOPTS= bash -c '
#echo bash2=$SHELLOPTS
set -o | grep braceexpand | sed "$1"
' unused "$normalize"
---
(command (word "normalize='s/[ \\t]\\+/ /g'"))
(command (word "bash") (word "-c") (word "'\n#echo bash=$SHELLOPTS\nset -o | grep braceexpand | sed \"$1\"\n'") (word "unused") (word "\"$normalize\""))
(command (word "env") (word "SHELLOPTS=") (word "bash") (word "-c") (word "'\n#echo bash2=$SHELLOPTS\nset -o | grep braceexpand | sed \"$1\"\n'") (word "unused") (word "\"$normalize\""))
---

=== If shopt --set xtrace is allowed, it should update SHELLOPTS, not BASHOPTS
case $SH in bash) exit ;; esac

shopt --set xtrace
echo SHELLOPTS=$SHELLOPTS
set -x
echo SHELLOPTS=$SHELLOPTS
set +x
echo SHELLOPTS=$SHELLOPTS
---
(case (word "$SH") (pattern ((word "bash")) (command (word "exit"))))
(command (word "shopt") (word "--set") (word "xtrace"))
(command (word "echo") (word "SHELLOPTS=$SHELLOPTS"))
(command (word "set") (word "-x"))
(command (word "echo") (word "SHELLOPTS=$SHELLOPTS"))
(command (word "set") (word "+x"))
(command (word "echo") (word "SHELLOPTS=$SHELLOPTS"))
---

=== shopt -s progcomp hostcomplete are stubs (bash-completion)
shopt -s progcomp hostcomplete
echo status=$?

shopt -u progcomp hostcomplete
echo status=$?
---
(command (word "shopt") (word "-s") (word "progcomp") (word "hostcomplete"))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "-u") (word "progcomp") (word "hostcomplete"))
(command (word "echo") (word "status=$?"))
---

=== $- with -c
# dash's behavior seems most sensible here?
$SH -o nounset -c 'echo $-'
---
(command (word "$SH") (word "-o") (word "nounset") (word "-c") (word "'echo $-'"))
---

=== $- with pipefail
set -o pipefail -o nounset
echo $-
---
(command (word "set") (word "-o") (word "pipefail") (word "-o") (word "nounset"))
(command (word "echo") (word "$-"))
---

=== $- and more options
set -efuC
o=$-
[[ $o == *e* ]]; echo yes
[[ $o == *f* ]]; echo yes
[[ $o == *u* ]]; echo yes
[[ $o == *C* ]]; echo yes
---
(command (word "set") (word "-efuC"))
(command (word "o=$-"))
(semi (cond (cond-binary "==" (cond-term "$o") (cond-term "*e*"))) (command (word "echo") (word "yes")))
(semi (cond (cond-binary "==" (cond-term "$o") (cond-term "*f*"))) (command (word "echo") (word "yes")))
(semi (cond (cond-binary "==" (cond-term "$o") (cond-term "*u*"))) (command (word "echo") (word "yes")))
(semi (cond (cond-binary "==" (cond-term "$o") (cond-term "*C*"))) (command (word "echo") (word "yes")))
---

=== $- with interactive shell
$SH -c 'echo $-' | grep i || echo FALSE
$SH -i -c 'echo $-' | grep -q i && echo TRUE
---
(or (pipe (command (word "$SH") (word "-c") (word "'echo $-'")) (command (word "grep") (word "i"))) (command (word "echo") (word "FALSE")))
(and (pipe (command (word "$SH") (word "-i") (word "-c") (word "'echo $-'")) (command (word "grep") (word "-q") (word "i"))) (command (word "echo") (word "TRUE")))
---

=== pass short options like sh -e
$SH -e -c 'false; echo status=$?'
---
(command (word "$SH") (word "-e") (word "-c") (word "'false; echo status=$?'"))
---

=== pass long options like sh -o errexit
$SH -o errexit -c 'false; echo status=$?'
---
(command (word "$SH") (word "-o") (word "errexit") (word "-c") (word "'false; echo status=$?'"))
---

=== pass shopt options like sh -O nullglob
$SH +O nullglob -c 'echo foo *.nonexistent bar'
$SH -O nullglob -c 'echo foo *.nonexistent bar'
---
(command (word "$SH") (word "+O") (word "nullglob") (word "-c") (word "'echo foo *.nonexistent bar'"))
(command (word "$SH") (word "-O") (word "nullglob") (word "-c") (word "'echo foo *.nonexistent bar'"))
---

=== set -o vi/emacs
set -o vi
echo $?
set -o emacs
echo $?
---
(command (word "set") (word "-o") (word "vi"))
(command (word "echo") (word "$?"))
(command (word "set") (word "-o") (word "emacs"))
(command (word "echo") (word "$?"))
---

=== vi and emacs are mutually exclusive
show() {
  shopt -o -p | egrep 'emacs$|vi$'
  echo ___
};
show

set -o emacs
show

set -o vi
show
---
(function "show" (brace-group (semi (pipe (command (word "shopt") (word "-o") (word "-p")) (command (word "egrep") (word "'emacs$|vi$'"))) (command (word "echo") (word "___")))))
(command (word "show"))
(command (word "set") (word "-o") (word "emacs"))
(command (word "show"))
(command (word "set") (word "-o") (word "vi"))
(command (word "show"))
---

=== interactive shell starts with emacs mode on
case $SH in dash) exit ;; esac
case $SH in bash|*osh) flag='--rcfile /dev/null' ;; esac

code='test -o emacs; echo $?; test -o vi; echo $?'

echo non-interactive
$SH $flag -c "$code"

echo interactive
$SH $flag -i -c "$code"
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(case (word "$SH") (pattern ((word "bash") (word "*osh")) (command (word "flag='--rcfile /dev/null'"))))
(command (word "code='test -o emacs; echo $?; test -o vi; echo $?'"))
(command (word "echo") (word "non-interactive"))
(command (word "$SH") (word "$flag") (word "-c") (word "\"$code\""))
(command (word "echo") (word "interactive"))
(command (word "$SH") (word "$flag") (word "-i") (word "-c") (word "\"$code\""))
---

=== nounset
echo "[$unset]"
set -o nounset
echo "[$unset]"
echo end  # never reached
---
(command (word "echo") (word "\"[$unset]\""))
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "\"[$unset]\""))
(command (word "echo") (word "end"))
---

=== -u is nounset
echo "[$unset]"
set -u
echo "[$unset]"
echo end  # never reached
---
(command (word "echo") (word "\"[$unset]\""))
(command (word "set") (word "-u"))
(command (word "echo") (word "\"[$unset]\""))
(command (word "echo") (word "end"))
---

=== -n for no execution (useful with --ast-output)
# NOTE: set +n doesn't work because nothing is executed!
echo 1
set -n
echo 2
set +n
echo 3
# osh doesn't work because it only checks -n in bin/oil.py?
---
(command (word "echo") (word "1"))
(command (word "set") (word "-n"))
(command (word "echo") (word "2"))
(command (word "set") (word "+n"))
(command (word "echo") (word "3"))
---

=== pipefail
# NOTE: the sleeps are because osh can fail non-deterministically because of a
# bug.  Same problem as PIPESTATUS.
{ sleep 0.01; exit 9; } | { sleep 0.02; exit 2; } | { sleep 0.03; }
echo $?
set -o pipefail
{ sleep 0.01; exit 9; } | { sleep 0.02; exit 2; } | { sleep 0.03; }
echo $?
---
(pipe (brace-group (semi (command (word "sleep") (word "0.01")) (command (word "exit") (word "9")))) (pipe (brace-group (semi (command (word "sleep") (word "0.02")) (command (word "exit") (word "2")))) (brace-group (command (word "sleep") (word "0.03")))))
(command (word "echo") (word "$?"))
(command (word "set") (word "-o") (word "pipefail"))
(pipe (brace-group (semi (command (word "sleep") (word "0.01")) (command (word "exit") (word "9")))) (pipe (brace-group (semi (command (word "sleep") (word "0.02")) (command (word "exit") (word "2")))) (brace-group (command (word "sleep") (word "0.03")))))
(command (word "echo") (word "$?"))
---

=== shopt -p -o prints 'set' options
case $SH in dash|mksh) exit ;; esac

shopt -po nounset
set -o nounset
shopt -po nounset

echo --

shopt -po | egrep -o 'errexit|noglob|nounset'
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-po") (word "nounset"))
(command (word "set") (word "-o") (word "nounset"))
(command (word "shopt") (word "-po") (word "nounset"))
(command (word "echo") (word "--"))
(pipe (command (word "shopt") (word "-po")) (command (word "egrep") (word "-o") (word "'errexit|noglob|nounset'")))
---

=== shopt -o prints 'set' options
case $SH in dash|mksh) exit ;; esac

shopt -o | egrep -o 'errexit|noglob|nounset'
echo --
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(pipe (command (word "shopt") (word "-o")) (command (word "egrep") (word "-o") (word "'errexit|noglob|nounset'")))
(command (word "echo") (word "--"))
---

=== shopt -p prints 'shopt' options
shopt -p nullglob
shopt -s nullglob
shopt -p nullglob
---
(command (word "shopt") (word "-p") (word "nullglob"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "shopt") (word "-p") (word "nullglob"))
---

=== shopt with no flags prints options
cd $TMP

# print specific options.  OSH does it in a different format.
shopt nullglob failglob > one.txt
wc -l one.txt
grep -o nullglob one.txt
grep -o failglob one.txt

# print all options
shopt | grep nullglob | wc -l
---
(command (word "cd") (word "$TMP"))
(command (word "shopt") (word "nullglob") (word "failglob") (redirect ">" "one.txt"))
(command (word "wc") (word "-l") (word "one.txt"))
(command (word "grep") (word "-o") (word "nullglob") (word "one.txt"))
(command (word "grep") (word "-o") (word "failglob") (word "one.txt"))
(pipe (command (word "shopt")) (pipe (command (word "grep") (word "nullglob")) (command (word "wc") (word "-l"))))
---

=== noclobber off
set -o errexit

echo foo > can-clobber
echo status=$?
set +C

echo foo > can-clobber
echo status=$?
set +o noclobber

echo foo > can-clobber
echo status=$?
cat can-clobber
---
(command (word "set") (word "-o") (word "errexit"))
(command (word "echo") (word "foo") (redirect ">" "can-clobber"))
(command (word "echo") (word "status=$?"))
(command (word "set") (word "+C"))
(command (word "echo") (word "foo") (redirect ">" "can-clobber"))
(command (word "echo") (word "status=$?"))
(command (word "set") (word "+o") (word "noclobber"))
(command (word "echo") (word "foo") (redirect ">" "can-clobber"))
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "can-clobber"))
---

=== noclobber on
rm -f no-clobber
set -C

echo foo > no-clobber
echo create=$?

echo overwrite > no-clobber
echo overwrite=$?

echo force >| no-clobber
echo force=$?

cat no-clobber
---
(command (word "rm") (word "-f") (word "no-clobber"))
(command (word "set") (word "-C"))
(command (word "echo") (word "foo") (redirect ">" "no-clobber"))
(command (word "echo") (word "create=$?"))
(command (word "echo") (word "overwrite") (redirect ">" "no-clobber"))
(command (word "echo") (word "overwrite=$?"))
(command (word "echo") (word "force") (redirect ">|" "no-clobber"))
(command (word "echo") (word "force=$?"))
(command (word "cat") (word "no-clobber"))
---

=== noclobber on <>
set -C
echo foo >| $TMP/no-clobber
exec 3<> $TMP/no-clobber
read -n 1 <&3
echo -n . >&3
exec 3>&-
cat $TMP/no-clobber
---
(command (word "set") (word "-C"))
(command (word "echo") (word "foo") (redirect ">|" "$TMP/no-clobber"))
(command (word "exec") (redirect "<>" "$TMP/no-clobber"))
(command (word "read") (word "-n") (word "1") (redirect "<&" 3))
(command (word "echo") (word "-n") (word ".") (redirect ">&" 3))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "$TMP/no-clobber"))
---

=== noclobber on >>
rm -f $TMP/no-clobber

set -C
echo foo >> $TMP/no-clobber
echo status=$?

cat $TMP/no-clobber
---
(command (word "rm") (word "-f") (word "$TMP/no-clobber"))
(command (word "set") (word "-C"))
(command (word "echo") (word "foo") (redirect ">>" "$TMP/no-clobber"))
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "$TMP/no-clobber"))
---

=== noclobber on &> >
case $SH in dash) exit ;; esac

set -C

rm -f $TMP/no-clobber
echo foo > $TMP/no-clobber
echo stdout=$?
echo bar > $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

rm -f $TMP/no-clobber
echo baz &> $TMP/no-clobber
echo both=$?
echo foo &> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "set") (word "-C"))
(command (word "rm") (word "-f") (word "$TMP/no-clobber"))
(command (word "echo") (word "foo") (redirect ">" "$TMP/no-clobber"))
(command (word "echo") (word "stdout=$?"))
(command (word "echo") (word "bar") (redirect ">" "$TMP/no-clobber"))
(command (word "echo") (word "again=$?"))
(command (word "cat") (word "$TMP/no-clobber"))
(command (word "rm") (word "-f") (word "$TMP/no-clobber"))
(command (word "echo") (word "baz") (redirect "&>" "$TMP/no-clobber"))
(command (word "echo") (word "both=$?"))
(command (word "echo") (word "foo") (redirect "&>" "$TMP/no-clobber"))
(command (word "echo") (word "again=$?"))
(command (word "cat") (word "$TMP/no-clobber"))
---

=== noclobber on &>> >>
case $SH in dash) echo 'flaky'; exit ;; esac

set -C

rm -f $TMP/no-clobber
echo foo >> $TMP/no-clobber
echo stdout=$?
echo bar >> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

rm -f $TMP/no-clobber
echo baz &>> $TMP/no-clobber
echo both=$?
echo foo &>> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber
---
(case (word "$SH") (pattern ((word "dash")) (semi (command (word "echo") (word "'flaky'")) (command (word "exit")))))
(command (word "set") (word "-C"))
(command (word "rm") (word "-f") (word "$TMP/no-clobber"))
(command (word "echo") (word "foo") (redirect ">>" "$TMP/no-clobber"))
(command (word "echo") (word "stdout=$?"))
(command (word "echo") (word "bar") (redirect ">>" "$TMP/no-clobber"))
(command (word "echo") (word "again=$?"))
(command (word "cat") (word "$TMP/no-clobber"))
(command (word "rm") (word "-f") (word "$TMP/no-clobber"))
(command (word "echo") (word "baz") (redirect "&>>" "$TMP/no-clobber"))
(command (word "echo") (word "both=$?"))
(command (word "echo") (word "foo") (redirect "&>>" "$TMP/no-clobber"))
(command (word "echo") (word "again=$?"))
(command (word "cat") (word "$TMP/no-clobber"))
---

=== set without args lists variables
__GLOBAL=g
f() {
  local __mylocal=L
  local __OTHERLOCAL=L
  __GLOBAL=mutated
  set | grep '^__'
}
g() {
  local __var_in_parent_scope=D
  f
}
g
---
(command (word "__GLOBAL=g"))
(function "f" (brace-group (semi (semi (semi (command (word "local") (word "__mylocal=L")) (command (word "local") (word "__OTHERLOCAL=L"))) (command (word "__GLOBAL=mutated"))) (pipe (command (word "set")) (command (word "grep") (word "'^__'"))))))
(function "g" (brace-group (semi (command (word "local") (word "__var_in_parent_scope=D")) (command (word "f")))))
(command (word "g"))
---

=== set without args and array variables
declare -a __array
__array=(1 2 '3 4')
set | grep '^__'
---
(command (word "declare") (word "-a") (word "__array"))
(command (word "__array=(1 2 '3 4')"))
(pipe (command (word "set")) (command (word "grep") (word "'^__'")))
---

=== set without args and assoc array variables (not in OSH)
typeset -A __assoc
__assoc['k e y']='v a l'
__assoc[a]=b
set | grep '^__'
---
(command (word "typeset") (word "-A") (word "__assoc"))
(command (word "__assoc['k e y']='v a l'"))
(command (word "__assoc[a]=b"))
(pipe (command (word "set")) (command (word "grep") (word "'^__'")))
---

=== shopt -q
shopt -q nullglob
echo nullglob=$?

# set it
shopt -s nullglob

shopt -q nullglob
echo nullglob=$?

shopt -q nullglob failglob
echo nullglob,failglob=$?

# set it
shopt -s failglob
shopt -q nullglob failglob
echo nullglob,failglob=$?
---
(command (word "shopt") (word "-q") (word "nullglob"))
(command (word "echo") (word "nullglob=$?"))
(command (word "shopt") (word "-s") (word "nullglob"))
(command (word "shopt") (word "-q") (word "nullglob"))
(command (word "echo") (word "nullglob=$?"))
(command (word "shopt") (word "-q") (word "nullglob") (word "failglob"))
(command (word "echo") (word "nullglob,failglob=$?"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "shopt") (word "-q") (word "nullglob") (word "failglob"))
(command (word "echo") (word "nullglob,failglob=$?"))
---

=== shopt -q invalid
shopt -q invalidZZ
echo invalidZZ=$?
---
(command (word "shopt") (word "-q") (word "invalidZZ"))
(command (word "echo") (word "invalidZZ=$?"))
---

=== shopt -s strict:all
n=2

show-strict() {
  shopt -p | grep 'strict_' | head -n $n
  echo -
}

show-strict
shopt -s strict:all
show-strict
shopt -u strict_argv
show-strict
---
(command (word "n=2"))
(function "show-strict" (brace-group (semi (pipe (command (word "shopt") (word "-p")) (pipe (command (word "grep") (word "'strict_'")) (command (word "head") (word "-n") (word "$n")))) (command (word "echo") (word "-")))))
(command (word "show-strict"))
(command (word "shopt") (word "-s") (word "strict:all"))
(command (word "show-strict"))
(command (word "shopt") (word "-u") (word "strict_argv"))
(command (word "show-strict"))
---

=== shopt allows for backward compatibility like bash
# doesn't have to be on, but just for testing
set -o errexit

shopt -p nullglob || true  # bash returns 1 here?  Like -q.

# This should set nullglob, and return 1, which can be ignored
shopt -s nullglob strict_OPTION_NOT_YET_IMPLEMENTED 2>/dev/null || true
echo status=$?

shopt -p nullglob || true
---
(command (word "set") (word "-o") (word "errexit"))
(or (command (word "shopt") (word "-p") (word "nullglob")) (command (word "true")))
(or (command (word "shopt") (word "-s") (word "nullglob") (word "strict_OPTION_NOT_YET_IMPLEMENTED") (redirect ">" "/dev/null")) (command (word "true")))
(command (word "echo") (word "status=$?"))
(or (command (word "shopt") (word "-p") (word "nullglob")) (command (word "true")))
---

=== shopt -p validates option names
shopt -p nullglob invalid failglob
echo status=$?
# same thing as -p, slightly different format in bash
shopt nullglob invalid failglob > $TMP/out.txt
status=$?
sed --regexp-extended 's/\s+/ /' $TMP/out.txt  # make it easier to assert
echo status=$status
---
(command (word "shopt") (word "-p") (word "nullglob") (word "invalid") (word "failglob"))
(command (word "echo") (word "status=$?"))
(command (word "shopt") (word "nullglob") (word "invalid") (word "failglob") (redirect ">" "$TMP/out.txt"))
(command (word "status=$?"))
(command (word "sed") (word "--regexp-extended") (word "'s/\\s+/ /'") (word "$TMP/out.txt"))
(command (word "echo") (word "status=$status"))
---

=== shopt -p -o validates option names
shopt -p -o errexit invalid nounset
echo status=$?
---
(command (word "shopt") (word "-p") (word "-o") (word "errexit") (word "invalid") (word "nounset"))
(command (word "echo") (word "status=$?"))
---

=== stubbed out bash options
shopt -s ignore_shopt_not_impl
for name in foo autocd cdable_vars checkwinsize; do
  shopt -s $name
  echo $?
done
---
(command (word "shopt") (word "-s") (word "ignore_shopt_not_impl"))
(for (word "name") (in (word "foo") (word "autocd") (word "cdable_vars") (word "checkwinsize")) (semi (command (word "shopt") (word "-s") (word "$name")) (command (word "echo") (word "$?"))))
---

=== shopt -s nounset works in YSH, not in bash
case $SH in
  *dash|*mksh)
    echo N-I
    exit
    ;;
esac
shopt -s nounset
echo status=$?

# get rid of extra space in bash output
set -o | grep nounset | sed 's/[ \t]\+/ /g'
---
(case (word "$SH") (pattern ((word "*dash") (word "*mksh")) (semi (command (word "echo") (word "N-I")) (command (word "exit")))))
(command (word "shopt") (word "-s") (word "nounset"))
(command (word "echo") (word "status=$?"))
(pipe (command (word "set") (word "-o")) (pipe (command (word "grep") (word "nounset")) (command (word "sed") (word "'s/[ \\t]\\+/ /g'"))))
---

=== Unimplemented options - print, query, set, unset
case $SH in dash|mksh) exit ;; esac

opt_name=xpg_echo

shopt -p xpg_echo
shopt -q xpg_echo; echo q=$?

shopt -s xpg_echo
shopt -p xpg_echo

shopt -u xpg_echo
shopt -p xpg_echo
echo p=$?  # weird, bash also returns a status

shopt xpg_echo >/dev/null
echo noflag=$?

shopt -o errexit >/dev/null
echo set=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "opt_name=xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(semi (command (word "shopt") (word "-q") (word "xpg_echo")) (command (word "echo") (word "q=$?")))
(command (word "shopt") (word "-s") (word "xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(command (word "shopt") (word "-u") (word "xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(command (word "echo") (word "p=$?"))
(command (word "shopt") (word "xpg_echo") (redirect ">" "/dev/null"))
(command (word "echo") (word "noflag=$?"))
(command (word "shopt") (word "-o") (word "errexit") (redirect ">" "/dev/null"))
(command (word "echo") (word "set=$?"))
---

=== Unimplemented options - OSH shopt -s ignore_shopt_not_impl
case $SH in dash|mksh) exit ;; esac

shopt -s ignore_shopt_not_impl

opt_name=xpg_echo

shopt -p xpg_echo
shopt -q xpg_echo; echo q=$?

shopt -s xpg_echo
shopt -p xpg_echo

shopt -u xpg_echo
shopt -p xpg_echo
echo p=$?  # weird, bash also returns a status

shopt xpg_echo >/dev/null
echo noflag=$?

shopt -o errexit >/dev/null
echo set=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "ignore_shopt_not_impl"))
(command (word "opt_name=xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(semi (command (word "shopt") (word "-q") (word "xpg_echo")) (command (word "echo") (word "q=$?")))
(command (word "shopt") (word "-s") (word "xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(command (word "shopt") (word "-u") (word "xpg_echo"))
(command (word "shopt") (word "-p") (word "xpg_echo"))
(command (word "echo") (word "p=$?"))
(command (word "shopt") (word "xpg_echo") (redirect ">" "/dev/null"))
(command (word "echo") (word "noflag=$?"))
(command (word "shopt") (word "-o") (word "errexit") (redirect ">" "/dev/null"))
(command (word "echo") (word "set=$?"))
---

=== shopt -p exit code (regression)
case $SH in dash|mksh) exit ;; esac

shopt -p > /dev/null
echo status=$?
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-p") (redirect ">" "/dev/null"))
(command (word "echo") (word "status=$?"))
---

=== no-ops not shown by shopt -p
shopt -p | grep xpg
echo --
---
(pipe (command (word "shopt") (word "-p")) (command (word "grep") (word "xpg")))
(command (word "echo") (word "--"))
---

=== sh -c
$SH -c 'echo hi'
---
(command (word "$SH") (word "-c") (word "'echo hi'"))
---

=== empty -c input
# had a bug here
$SH -c ''
---
(command (word "$SH") (word "-c") (word "''"))
---

=== sh +c is accepted
$SH +c 'echo hi'
---
(command (word "$SH") (word "+c") (word "'echo hi'"))
---

=== empty stdin
# had a bug here
echo -n '' | $SH
---
(pipe (command (word "echo") (word "-n") (word "''")) (command (word "$SH")))
---

=== sh - and sh -- stop flag processing
case $SH in zsh) exit ;; esac

echo 'echo foo' > foo.sh

$SH -x -v -- foo.sh

echo -  
echo - >& 2

$SH -x -v - foo.sh
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "echo") (word "'echo foo'") (redirect ">" "foo.sh"))
(command (word "$SH") (word "-x") (word "-v") (word "--") (word "foo.sh"))
(command (word "echo") (word "-"))
(command (word "echo") (word "-") (redirect ">&" 2))
(command (word "$SH") (word "-x") (word "-v") (word "-") (word "foo.sh"))
---

=== shell obeys --help (regression for OSH)
n=$($SH --help | wc -l)
if test $n -gt 0; then
  echo yes
fi
---
(command (word "n=$($SH --help | wc -l)"))
(if (command (word "test") (word "$n") (word "-gt") (word "0")) (command (word "echo") (word "yes")))
---

=== args are passed
$SH -c 'argv.py "$@"' dummy a b
---
(command (word "$SH") (word "-c") (word "'argv.py \"$@\"'") (word "dummy") (word "a") (word "b"))
---

=== args that look like flags are passed after script
script=$TMP/sh1.sh
echo 'argv.py "$@"' > $script
chmod +x $script
$SH $script --help --help -h
---
(command (word "script=$TMP/sh1.sh"))
(command (word "echo") (word "'argv.py \"$@\"'") (redirect ">" "$script"))
(command (word "chmod") (word "+x") (word "$script"))
(command (word "$SH") (word "$script") (word "--help") (word "--help") (word "-h"))
---

=== args that look like flags are passed after -c
$SH -c 'argv.py "$@"' --help --help -h
---
(command (word "$SH") (word "-c") (word "'argv.py \"$@\"'") (word "--help") (word "--help") (word "-h"))
---

=== exit with explicit arg
exit 42
---
(command (word "exit") (word "42"))
---

=== exit with no args
false
exit
---
(command (word "false"))
(command (word "exit"))
---

=== --rcfile in non-interactive shell prints warnings
echo 'echo rc' > rc

$SH --rcfile rc -i </dev/null 2>interactive.txt
grep -q 'warning' interactive.txt
echo warned=$? >&2

$SH --rcfile rc </dev/null 2>non-interactive.txt
grep -q 'warning' non-interactive.txt
echo warned=$? >&2

head *interactive.txt
---
(command (word "echo") (word "'echo rc'") (redirect ">" "rc"))
(command (word "$SH") (word "--rcfile") (word "rc") (word "-i") (redirect "<" "/dev/null") (redirect ">" "interactive.txt"))
(command (word "grep") (word "-q") (word "'warning'") (word "interactive.txt"))
(command (word "echo") (word "warned=$?") (redirect ">&" 2))
(command (word "$SH") (word "--rcfile") (word "rc") (redirect "<" "/dev/null") (redirect ">" "non-interactive.txt"))
(command (word "grep") (word "-q") (word "'warning'") (word "non-interactive.txt"))
(command (word "echo") (word "warned=$?") (redirect ">&" 2))
(command (word "head") (word "*interactive.txt"))
---

=== accepts -l flag
$SH -l -c 'exit 0'
---
(command (word "$SH") (word "-l") (word "-c") (word "'exit 0'"))
---

=== accepts --login flag (dash and mksh don't accept long flags)
$SH --login -c 'exit 0'
---
(command (word "$SH") (word "--login") (word "-c") (word "'exit 0'"))
---

=== osh --eval
case $SH in bash|dash|mksh|zsh) exit ;; esac

echo 'echo one "$@"' > one.sh
echo 'echo fail "$@"; ( exit 42 )' > fail.sh

$SH --eval one.sh \
  -c 'echo status=$? flag -c "$@"' dummy x y z
echo

# Even though errexit is off, the shell exits if the last status of an --eval
# file was non-zero.

$SH --eval one.sh --eval fail.sh \
  -c 'echo status=$? flag -c "$@"' dummy x y z
echo status=$?
---
(case (word "$SH") (pattern ((word "bash") (word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(command (word "echo") (word "'echo one \"$@\"'") (redirect ">" "one.sh"))
(command (word "echo") (word "'echo fail \"$@\"; ( exit 42 )'") (redirect ">" "fail.sh"))
(command (word "$SH") (word "--eval") (word "one.sh") (word "-c") (word "'echo status=$? flag -c \"$@\"'") (word "dummy") (word "x") (word "y") (word "z"))
(command (word "echo"))
(command (word "$SH") (word "--eval") (word "one.sh") (word "--eval") (word "fail.sh") (word "-c") (word "'echo status=$? flag -c \"$@\"'") (word "dummy") (word "x") (word "y") (word "z"))
(command (word "echo") (word "status=$?"))
---

=== Set LC_ALL LC_CTYPE LC_COLLATE LANG - affects glob ?
# note: test/spec-common.sh sets LC_ALL
unset LC_ALL

touch _x_ __

LC_ALL=C       $SH -c 'echo LC_ALL _?_'
LC_ALL=C.UTF-8 $SH -c 'echo LC_ALL _?_'
echo

LC_CTYPE=C       $SH -c 'echo LC_CTYPE _?_'
LC_CTYPE=C.UTF-8 $SH -c 'echo LC_CTYPE _?_'
echo

LC_COLLATE=C       $SH -c 'echo LC_COLLATE _?_'
LC_COLLATE=C.UTF-8 $SH -c 'echo LC_COLLATE _?_'
echo

LANG=C       $SH -c 'echo LANG _?_'
LANG=C.UTF-8 $SH -c 'echo LANG _?_'
---
(command (word "unset") (word "LC_ALL"))
(command (word "touch") (word "_x_") (word "__"))
(command (word "LC_ALL=C") (word "$SH") (word "-c") (word "'echo LC_ALL _?_'"))
(command (word "LC_ALL=C.UTF-8") (word "$SH") (word "-c") (word "'echo LC_ALL _?_'"))
(command (word "echo"))
(command (word "LC_CTYPE=C") (word "$SH") (word "-c") (word "'echo LC_CTYPE _?_'"))
(command (word "LC_CTYPE=C.UTF-8") (word "$SH") (word "-c") (word "'echo LC_CTYPE _?_'"))
(command (word "echo"))
(command (word "LC_COLLATE=C") (word "$SH") (word "-c") (word "'echo LC_COLLATE _?_'"))
(command (word "LC_COLLATE=C.UTF-8") (word "$SH") (word "-c") (word "'echo LC_COLLATE _?_'"))
(command (word "echo"))
(command (word "LANG=C") (word "$SH") (word "-c") (word "'echo LANG _?_'"))
(command (word "LANG=C.UTF-8") (word "$SH") (word "-c") (word "'echo LANG _?_'"))
---

=== LC_CTYPE=invalid
# note: test/spec-common.sh sets LC_ALL
unset LC_ALL

touch _x_ __

{ LC_CTYPE=invalid $SH -c 'echo LC_CTYPE _?_' 
} 2> err.txt

#cat err.txt
wc -l err.txt
---
(command (word "unset") (word "LC_ALL"))
(command (word "touch") (word "_x_") (word "__"))
(brace-group (command (word "LC_CTYPE=invalid") (word "$SH") (word "-c") (word "'echo LC_CTYPE _?_'"))) (redirect ">" "err.txt")
(command (word "wc") (word "-l") (word "err.txt"))
---

=== ./configure idiom
set -o errexit

if command time -f '%e %M' true; then
  echo 'supports -f'
  # BUG: this was wrong
  #time -f '%e %M' true

  # Need 'command time'
  command time -f '%e %M' true
fi

if env time -f '%e %M' true; then
  echo 'env'
  env time -f '%e %M' true
fi
---
(command (word "set") (word "-o") (word "errexit"))
(if (command (word "command") (word "time") (word "-f") (word "'%e %M'") (word "true")) (semi (command (word "echo") (word "'supports -f'")) (command (word "command") (word "time") (word "-f") (word "'%e %M'") (word "true"))))
(if (command (word "env") (word "time") (word "-f") (word "'%e %M'") (word "true")) (semi (command (word "echo") (word "'env'")) (command (word "env") (word "time") (word "-f") (word "'%e %M'") (word "true"))))
---

=== Simple command
echo

#### Command with args
echo word word

#### Command with trailer
echo word word &

#### a & b
echo word_a & echo word_b

#### a & b &
echo word_a & echo word_b &

#### a && b 
echo word_a && echo word_b 

#### a || b 
echo word_a || echo word_b 

#### a && b || c
echo word_a && echo word_b || echo

#### Invalid token
invalid
# TODO: change these to qualifiers!
---
(command (word "echo"))
(command (word "echo") (word "word") (word "word"))
(background (command (word "echo") (word "word") (word "word")))
(background (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b")))
(background (background (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b"))))
(and (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b")))
(or (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b")))
(or (and (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b"))) (command (word "echo")))
(command (word "invalid"))
---

=== Function def
name_a() {
  echo word_a
  echo word_b
}
---
(function "name_a" (brace-group (semi (command (word "echo") (word "word_a")) (command (word "echo") (word "word_b")))))
---

=== builtin
echo hi
---
(command (word "echo") (word "hi"))
---

=== command sub
echo $(expr 3)
---
(command (word "echo") (word "$(expr 3)"))
---

=== command sub with builtin
echo $(echo hi)
---
(command (word "echo") (word "$(echo hi)"))
---

=== pipeline
hostname | wc -l
---
(pipe (command (word "hostname")) (command (word "wc") (word "-l")))
---

=== pipeline with builtin
echo hi | wc -l
---
(pipe (command (word "echo") (word "hi")) (command (word "wc") (word "-l")))
---

=== and-or chains
echo 1 && echo 2 || echo 3 && echo 4
echo --
false || echo A
false || false || echo B
false || false || echo C && echo D || echo E
---
(and (or (and (command (word "echo") (word "1")) (command (word "echo") (word "2"))) (command (word "echo") (word "3"))) (command (word "echo") (word "4")))
(command (word "echo") (word "--"))
(or (command (word "false")) (command (word "echo") (word "A")))
(or (or (command (word "false")) (command (word "false"))) (command (word "echo") (word "B")))
(or (and (or (or (command (word "false")) (command (word "false"))) (command (word "echo") (word "C"))) (command (word "echo") (word "D"))) (command (word "echo") (word "E")))
---

=== here doc with var
v=one
tac <<EOF
$v
"two
EOF
---
(command (word "v=one"))
(command (word "tac") (redirect "<<" "$v
"two
"))
---

=== here doc without var
tac <<"EOF"
$v
"two
EOF
---
(command (word "tac") (redirect "<<" "$v
"two
"))
---

=== here doc with builtin
read var <<EOF
value
EOF
echo "var = $var"
---
(command (word "read") (word "var") (redirect "<<" "value
"))
(command (word "echo") (word "\"var = $var\""))
---

=== Redirect external command
expr 3 > $TMP/expr3.txt
cat $TMP/expr3.txt
---
(command (word "expr") (word "3") (redirect ">" "$TMP/expr3.txt"))
(command (word "cat") (word "$TMP/expr3.txt"))
---

=== Redirect with builtin
echo hi > hi.txt
cat hi.txt
---
(command (word "echo") (word "hi") (redirect ">" "hi.txt"))
(command (word "cat") (word "hi.txt"))
---

=== Here doc with redirect
cat <<EOF >smoke1.txt
one
two
EOF
wc -c smoke1.txt
---
(command (word "cat") (redirect "<<" "one
two
") (redirect ">" "smoke1.txt"))
(command (word "wc") (word "-c") (word "smoke1.txt"))
---

=== "$@" "$*"
fun () {
  argv.py "$@" "$*"
}
fun "a b" "c d"
---
(function "fun" (brace-group (command (word "argv.py") (word "\"$@\"") (word "\"$*\""))))
(command (word "fun") (word "\"a b\"") (word "\"c d\""))
---

=== $@ $*
fun() {
  argv.py $@ $*
}
fun "a b" "c d"
---
(function "fun" (brace-group (command (word "argv.py") (word "$@") (word "$*"))))
(command (word "fun") (word "\"a b\"") (word "\"c d\""))
---

=== failed command
ls /nonexistent-zzZZ
---
(command (word "ls") (word "/nonexistent-zzZZ"))
---

=== subshell
(echo 1; echo 2)
---
(subshell (semi (command (word "echo") (word "1")) (command (word "echo") (word "2"))))
---

=== for loop
for i in a b c
do
  echo $i
done
---
(for (word "i") (in (word "a") (word "b") (word "c")) (command (word "echo") (word "$i")))
---

=== vars
a=5
echo $a ${a} "$a ${a}"
---
(command (word "a=5"))
(command (word "echo") (word "$a") (word "${a}") (word "\"$a ${a}\""))
---

=== osh-native duplicates stdin - is this a test harness issue?
echo $0 | grep -o sh
---
(pipe (command (word "echo") (word "$0")) (command (word "grep") (word "-o") (word "sh")))
---

=== Subshell exit code
( false; )
echo $?
---
(subshell (command (word "false")))
(command (word "echo") (word "$?"))
---

=== Subshell with redirects
( echo 1 ) > a.txt
( env echo 2 ) > b.txt
( env echo 3; ) > c.txt  # Sentence in LST
( echo 4; echo 5 ) > d.txt
echo status=$?
cat a.txt b.txt c.txt d.txt
---
(subshell (command (word "echo") (word "1"))) (redirect ">" "a.txt")
(subshell (command (word "env") (word "echo") (word "2"))) (redirect ">" "b.txt")
(subshell (command (word "env") (word "echo") (word "3"))) (redirect ">" "c.txt")
(subshell (semi (command (word "echo") (word "4")) (command (word "echo") (word "5")))) (redirect ">" "d.txt")
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "a.txt") (word "b.txt") (word "c.txt") (word "d.txt"))
---

=== More eval 'local v='
case $SH in mksh) exit ;; esac

set -u

f() {
  # The temp env messes it up
  tmp1= local x=x
  tmp2= eval 'local y=y'

  # similar to eval
  tmp3= . $REPO_ROOT/spec/testdata/define-local-var-z.sh

  # Bug does not appear with only eval
  #eval 'local v=hello'

  #declare -p v
  echo x=$x
  echo y=$y
  echo z=$z
}

f 
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "set") (word "-u"))
(function "f" (brace-group (semi (semi (semi (semi (semi (command (word "tmp1=") (word "local") (word "x=x")) (command (word "tmp2=") (word "eval") (word "'local y=y'"))) (command (word "tmp3=") (word ".") (word "$REPO_ROOT/spec/testdata/define-local-var-z.sh"))) (command (word "echo") (word "x=$x"))) (command (word "echo") (word "y=$y"))) (command (word "echo") (word "z=$z")))))
(command (word "f"))
---

=== Temp bindings with local
f() {
  local x=x
  tmp='' local tx=tx

  # Hm both y and ty persist in bash/zsh
  eval 'local y=y'
  tmp='' eval 'local ty=ty'

  # Why does this have an effect in OSH?  Oh because 'unset' is a special
  # builtin
  if true; then
    x='X' unset x
    tx='TX' unset tx
    y='Y' unset y
    ty='TY' unset ty
  fi

  #unset y
  #unset ty

  echo x=$x
  echo tx=$tx
  echo y=$y
  echo ty=$ty
}

f
---
(function "f" (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (command (word "local") (word "x=x")) (command (word "tmp=''") (word "local") (word "tx=tx"))) (command (word "eval") (word "'local y=y'"))) (command (word "tmp=''") (word "eval") (word "'local ty=ty'"))) (if (command (word "true")) (semi (semi (semi (command (word "x='X'") (word "unset") (word "x")) (command (word "tx='TX'") (word "unset") (word "tx"))) (command (word "y='Y'") (word "unset") (word "y"))) (command (word "ty='TY'") (word "unset") (word "ty"))))) (command (word "echo") (word "x=$x"))) (command (word "echo") (word "tx=$tx"))) (command (word "echo") (word "y=$y"))) (command (word "echo") (word "ty=$ty")))))
(command (word "f"))
---

=== Temp bindings with unset
# key point:
# unset looks up the stack
# local doesn't though

x=42
unset x
echo x=$x

echo ---

x=42
tmp= unset x
echo x=$x

x=42
tmp= eval 'unset x'
echo x=$x

echo ---

shadow() {
  x=42
  x=tmp unset x
  echo x=$x
  
  x=42
  x=tmp eval 'unset x'
  echo x=$x
}

shadow

echo ---

case $SH in
  bash) set -o posix ;;
esac
shadow

# Now shadow

# unset is a special builtin
# type unset
---
(command (word "x=42"))
(command (word "unset") (word "x"))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "---"))
(command (word "x=42"))
(command (word "tmp=") (word "unset") (word "x"))
(command (word "echo") (word "x=$x"))
(command (word "x=42"))
(command (word "tmp=") (word "eval") (word "'unset x'"))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "---"))
(function "shadow" (brace-group (semi (semi (semi (semi (semi (command (word "x=42")) (command (word "x=tmp") (word "unset") (word "x"))) (command (word "echo") (word "x=$x"))) (command (word "x=42"))) (command (word "x=tmp") (word "eval") (word "'unset x'"))) (command (word "echo") (word "x=$x")))))
(command (word "shadow"))
(command (word "echo") (word "---"))
(case (word "$SH") (pattern ((word "bash")) (command (word "set") (word "-o") (word "posix"))))
(command (word "shadow"))
---

=== FOO=bar $unset - temp binding, then empty argv from unquoted unset var (#2411)
foo=alive! $unset
echo $foo
---
(command (word "foo=alive!") (word "$unset"))
(command (word "echo") (word "$foo"))
---

=== Fatal error
# http://landley.net/notes.html#20-06-2020

abc=${a?bc} echo hello; echo blah
---
(semi (command (word "abc=${a?bc}") (word "echo") (word "hello")) (command (word "echo") (word "blah")))
---

=== setting readonly var (bash is only one where it's non-fatal)
# https://landley.net/notes-2020.html#20-06-2020

readonly abc=123
abc=def
echo status=$?
---
(command (word "readonly") (word "abc=123"))
(command (word "abc=def"))
(command (word "echo") (word "status=$?"))
---

=== readonly with temp binding
# http://landley.net/notes.html#20-06-2020

# temp binding
readonly abc=123
abc=def echo one
echo status=$?

echo potato < /does/not/exist || echo hello
---
(command (word "readonly") (word "abc=123"))
(command (word "abc=def") (word "echo") (word "one"))
(command (word "echo") (word "status=$?"))
(or (command (word "echo") (word "potato") (redirect "<" "/does/not/exist")) (command (word "echo") (word "hello")))
---

=== Failed redirect in assignment, vs. export
abc=def > /does/not/exist1
echo abc=$abc

export abc=def > /does/not/exist2
echo abc=$abc
---
(command (word "abc=def") (redirect ">" "/does/not/exist1"))
(command (word "echo") (word "abc=$abc"))
(command (word "export") (word "abc=def") (redirect ">" "/does/not/exist2"))
(command (word "echo") (word "abc=$abc"))
---

=== Evaluation order of redirect and ${undef?error}
# http://landley.net/notes.html#12-06-2020

rm -f walrus
$SH -c 'X=${x?bc} > walrus'
if test -f walrus; then echo 'exists1'; fi

rm -f walrus
$SH -c '>walrus echo ${a?bc}'
test -f walrus
if test -f walrus; then echo 'exists2'; fi
---
(command (word "rm") (word "-f") (word "walrus"))
(command (word "$SH") (word "-c") (word "'X=${x?bc} > walrus'"))
(if (command (word "test") (word "-f") (word "walrus")) (command (word "echo") (word "'exists1'")))
(command (word "rm") (word "-f") (word "walrus"))
(command (word "$SH") (word "-c") (word "'>walrus echo ${a?bc}'"))
(command (word "test") (word "-f") (word "walrus"))
(if (command (word "test") (word "-f") (word "walrus")) (command (word "echo") (word "'exists2'")))
---

=== Function def in pipeline
# http://landley.net/notes.html#26-05-2020

echo hello | potato() { echo abc; } | echo ha
---
(pipe (command (word "echo") (word "hello")) (pipe (function "potato" (brace-group (command (word "echo") (word "abc")))) (command (word "echo") (word "ha"))))
---

=== dynamic glob - http://landley.net/notes.html#08-05-2020
touch foo
X='*'; echo $X
echo "*"*".?z"
---
(command (word "touch") (word "foo"))
(semi (command (word "X='*'")) (command (word "echo") (word "$X")))
(command (word "echo") (word "\"*\"*\".?z\""))
---

=== no shebang
cat > snork << 'EOF'
echo hello $BLAH
EOF

chmod +x snork
$SH -c 'BLAH=123; ./snork'
$SH -c 'BLAH=123; exec ./snork'
$SH -c 'BLAH=123 exec ./snork'
---
(command (word "cat") (redirect ">" "snork") (redirect "<<" "echo hello $BLAH
"))
(command (word "chmod") (word "+x") (word "snork"))
(command (word "$SH") (word "-c") (word "'BLAH=123; ./snork'"))
(command (word "$SH") (word "-c") (word "'BLAH=123; exec ./snork'"))
(command (word "$SH") (word "-c") (word "'BLAH=123 exec ./snork'"))
---

=== IFS
IFS=x; X=abxcd; echo ${X/bxc/g}

X=a=\"\$a\"; echo ${X//a/{x,y,z}}
---
(semi (semi (command (word "IFS=x")) (command (word "X=abxcd"))) (command (word "echo") (word "${X/bxc/g}")))
(semi (command (word "X=a=\\\"\\$a\\\"")) (command (word "echo") (word "${X//a/{x,y,z}}")))
---

=== shift is fatal at top level?
# http://landley.net/notes.html#08-04-2020

# This makes a difference for zsh, but not for bash?
#set -o posix

$SH -c 'shift; echo hello'
---
(command (word "$SH") (word "-c") (word "'shift; echo hello'"))
---

=== var and func - http://landley.net/notes.html#19-03-2020
potato() { echo hello; }
potato=42
echo $potato

potato
---
(function "potato" (brace-group (command (word "echo") (word "hello"))))
(command (word "potato=42"))
(command (word "echo") (word "$potato"))
(command (word "potato"))
---

=== IFS - http://landley.net/notes.html#05-03-2020
case $SH in zsh) exit ;; esac

IFS=x
chicken() { for i in "$@"; do echo =$i=; done;}
chicken one abc dxf ghi

echo ---
myfunc() { "$SH" -c 'IFS=x; for i in $@; do echo =$i=; done' blah "$@"; }
myfunc one "" two
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "IFS=x"))
(function "chicken" (brace-group (for (word "i") (in (word "\"$@\"")) (command (word "echo") (word "=$i=")))))
(command (word "chicken") (word "one") (word "abc") (word "dxf") (word "ghi"))
(command (word "echo") (word "---"))
(function "myfunc" (brace-group (command (word "\"$SH\"") (word "-c") (word "'IFS=x; for i in $@; do echo =$i=; done'") (word "blah") (word "\"$@\""))))
(command (word "myfunc") (word "one") (word "\"\"") (word "two"))
---

=== IFS=x and '' and unquoted $@ - reduction of case above - copied into spec/word-split
setopt SH_WORD_SPLIT
#set -x

set -- one "" two

IFS=x

argv.py $@

for i in $@; do
  echo -$i-
done
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "set") (word "--") (word "one") (word "\"\"") (word "two"))
(command (word "IFS=x"))
(command (word "argv.py") (word "$@"))
(for (word "i") (in (word "$@")) (command (word "echo") (word "-$i-")))
---

=== for loop parsing - http://landley.net/notes.html#04-03-2020
$SH -c '
for i
in one two three
do echo $i;
done
'
echo $?

$SH -c 'for i; in one two three; do echo $i; done'
test $? -ne 0 && echo cannot-parse
---
(command (word "$SH") (word "-c") (word "'\nfor i\nin one two three\ndo echo $i;\ndone\n'"))
(command (word "echo") (word "$?"))
(command (word "$SH") (word "-c") (word "'for i; in one two three; do echo $i; done'"))
(and (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "cannot-parse")))
---

=== Parsing $(( ))
# http://landley.net/notes.html#15-03-2020
$SH -c 'echo $((echo hello))'
if test $? -ne 0; then echo fail; fi
---
(command (word "$SH") (word "-c") (word "'echo $((echo hello))'"))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "fail")))
---

=== IFS - http://landley.net/notes.html#15-02-2020 (TODO: osh)
IFS=x
A=xabcxx
for i in $A; do echo =$i=; done
echo

unset IFS
A="   abc   def   "
for i in ""$A""; do echo =$i=; done
---
(command (word "IFS=x"))
(command (word "A=xabcxx"))
(for (word "i") (in (word "$A")) (command (word "echo") (word "=$i=")))
(command (word "echo"))
(command (word "unset") (word "IFS"))
(command (word "A=\"   abc   def   \""))
(for (word "i") (in (word "\"\"$A\"\"")) (command (word "echo") (word "=$i=")))
---

=== IFS 2 - copied into spec/word-split
# this one appears different between osh and bash
A="   abc   def   "; for i in ""x""$A""; do echo =$i=; done
---
(semi (command (word "A=\"   abc   def   \"")) (for (word "i") (in (word "\"\"x\"\"$A\"\"")) (command (word "echo") (word "=$i="))))
---

=== IFS 3
IFS=x; X="onextwoxxthree"; y=$X; echo $y
---
(semi (semi (semi (command (word "IFS=x")) (command (word "X=\"onextwoxxthree\""))) (command (word "y=$X"))) (command (word "echo") (word "$y")))
---

=== IFS 4
setopt SH_WORD_SPLIT

IFS=x

func1() {
  echo /$*/
  for i in $*; do echo -$i-; done
}
func1 "" ""

echo

func2() {
  echo /"$*"/
  for i in =$*=; do echo -$i-; done
}
func2 "" ""
---
(command (word "setopt") (word "SH_WORD_SPLIT"))
(command (word "IFS=x"))
(function "func1" (brace-group (semi (command (word "echo") (word "/$*/")) (for (word "i") (in (word "$*")) (command (word "echo") (word "-$i-"))))))
(command (word "func1") (word "\"\"") (word "\"\""))
(command (word "echo"))
(function "func2" (brace-group (semi (command (word "echo") (word "/\"$*\"/")) (for (word "i") (in (word "=$*=")) (command (word "echo") (word "-$i-"))))))
(command (word "func2") (word "\"\"") (word "\"\""))
---

=== IFS 5
cc() { for i in $*; do echo -$i-; done;}; cc "" "" "" "" ""
cc() { echo =$1$2=;}; cc "" ""
---
(semi (function "cc" (brace-group (for (word "i") (in (word "$*")) (command (word "echo") (word "-$i-"))))) (command (word "cc") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\"") (word "\"\"")))
(semi (function "cc" (brace-group (command (word "echo") (word "=$1$2=")))) (command (word "cc") (word "\"\"") (word "\"\"")))
---

=== Can't parse extra }
$SH -c 'for i in a"$@"b;do echo =$i=;done;}' 123 456 789
---
(command (word "$SH") (word "-c") (word "'for i in a\"$@\"b;do echo =$i=;done;}'") (word "123") (word "456") (word "789"))
---

=== Pipeline - http://landley.net/notes-2019.html#16-12-2019
echo hello | { read i; echo $i;} | { read i; echo $i;} | cat
echo hello | while read i; do echo -=$i=- | sed s/=/@/g ; done | cat
---
(pipe (command (word "echo") (word "hello")) (pipe (brace-group (semi (command (word "read") (word "i")) (command (word "echo") (word "$i")))) (pipe (brace-group (semi (command (word "read") (word "i")) (command (word "echo") (word "$i")))) (command (word "cat")))))
(pipe (command (word "echo") (word "hello")) (pipe (while (command (word "read") (word "i")) (pipe (command (word "echo") (word "-=$i=-")) (command (word "sed") (word "s/=/@/g")))) (command (word "cat"))))
---

=== @Q
# http://landley.net/notes.html#24-06-2020

# Fix these
case $SH in dash|mksh|zsh) exit ;; esac

xx() { echo "${*@Q}";}; xx a b c d
xx() { echo "${@@Q}";}; xx a b c d
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(semi (function "xx" (brace-group (command (word "echo") (word "\"${*@Q}\"")))) (command (word "xx") (word "a") (word "b") (word "c") (word "d")))
(semi (function "xx" (brace-group (command (word "echo") (word "\"${@@Q}\"")))) (command (word "xx") (word "a") (word "b") (word "c") (word "d")))
---

=== extglob $IFS 1
# @extglob
# http://landley.net/notes.html#12-06-2020
shopt -s extglob

touch abc\)d
echo ab+(c?d)

IFS=c ABC="c?d"
echo ab+($ABC)

ABC='*'
echo $ABC
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "touch") (word "abc\\)d"))
(command (word "echo") (word "ab+(c?d)"))
(command (word "IFS=c") (word "ABC=\"c?d\""))
(command (word "echo") (word "ab+($ABC)"))
(command (word "ABC='*'"))
(command (word "echo") (word "$ABC"))
---

=== extglob $IFS 2
# @extglob
# http://landley.net/notes.html#17-05-2020

shopt -s extglob  # required for bash, not osh
IFS=x; ABC=cxd; for i in +($ABC); do echo =$i=; done
---
(command (word "shopt") (word "-s") (word "extglob"))
(semi (semi (command (word "IFS=x")) (command (word "ABC=cxd"))) (for (word "i") (in (word "+($ABC)")) (command (word "echo") (word "=$i="))))
---

=== char class / extglob
# @extglob
# http://landley.net/notes.html#14-05-2020
shopt -s extglob

touch l; echo [hello"]"

touch b
echo [$(echo abc)]

touch +
echo [+()]
echo [+(])
---
(command (word "shopt") (word "-s") (word "extglob"))
(semi (command (word "touch") (word "l")) (command (word "echo") (word "[hello\"]\"")))
(command (word "touch") (word "b"))
(command (word "echo") (word "[$(echo abc)]"))
(command (word "touch") (word "+"))
(command (word "echo") (word "[+()]"))
(command (word "echo") (word "[+(])"))
---

=== patsub of $* - http://landley.net/notes.html#23-04-2020
chicken() { echo ${*/b c/ghi}; }; chicken a b c d
---
(semi (function "chicken" (brace-group (command (word "echo") (word "${*/b c/ghi}")))) (command (word "chicken") (word "a") (word "b") (word "c") (word "d")))
---

=== Brace Expansion
# http://landley.net/notes.html#04-01-2020

HOME=/home/foo

echo {~,~root}/pwd
echo \{~,~root}/pwd
echo ""{~,~root}/pwd
---
(command (word "HOME=/home/foo"))
(command (word "echo") (word "{~,~root}/pwd"))
(command (word "echo") (word "\\{~,~root}/pwd"))
(command (word "echo") (word "\"\"{~,~root}/pwd"))
---

=== {abc}<<< - http://landley.net/notes-2019.html#09-12-2019
{ echo; } {abc}<<< walrus
cat <&$abc
---
(brace-group (command (word "echo"))) (redirect "<<<" "walrus")
(command (word "cat") (redirect "<&" "$abc"))
---

=== slice of @ and @ - http://landley.net/notes.html#23-04-2020
IFS=x; X=x; eval abc=a${X}b

chicken() { for i in "${@:3:5}"; do echo =$i=; done; } ; chicken ab cd ef gh ij kl mn op qr

chicken() { for i in "${*:3:5}"; do echo =$i=; done; } ; chicken ab cd ef gh ij kl mn op qr
---
(semi (semi (command (word "IFS=x")) (command (word "X=x"))) (command (word "eval") (word "abc=a${X}b")))
(semi (function "chicken" (brace-group (for (word "i") (in (word "\"${@:3:5}\"")) (command (word "echo") (word "=$i="))))) (command (word "chicken") (word "ab") (word "cd") (word "ef") (word "gh") (word "ij") (word "kl") (word "mn") (word "op") (word "qr")))
(semi (function "chicken" (brace-group (for (word "i") (in (word "\"${*:3:5}\"")) (command (word "echo") (word "=$i="))))) (command (word "chicken") (word "ab") (word "cd") (word "ef") (word "gh") (word "ij") (word "kl") (word "mn") (word "op") (word "qr")))
---

=== declare -i -l -u errors can be silenced - ignore_flags_not_impl
declare -i foo=2+3
echo status=$?
echo foo=$foo
echo

shopt -s ignore_flags_not_impl
declare -i bar=2+3
echo status=$?
echo bar=$bar
---
(command (word "declare") (word "-i") (word "foo=2+3"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "foo=$foo"))
(command (word "echo"))
(command (word "shopt") (word "-s") (word "ignore_flags_not_impl"))
(command (word "declare") (word "-i") (word "bar=2+3"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "bar=$bar"))
---

=== declare -i with +=
declare s
s='1 '
s+=' 2 '  # string append

declare -i i
i='1 '
i+=' 2 '  # arith add

declare -i j
j=x  # treated like zero
j+=' 2 '  # arith add

echo "[$s]"
echo [$i]
echo [$j]
---
(command (word "declare") (word "s"))
(command (word "s='1 '"))
(command (word "s+=' 2 '"))
(command (word "declare") (word "-i") (word "i"))
(command (word "i='1 '"))
(command (word "i+=' 2 '"))
(command (word "declare") (word "-i") (word "j"))
(command (word "j=x"))
(command (word "j+=' 2 '"))
(command (word "echo") (word "\"[$s]\""))
(command (word "echo") (word "[$i]"))
(command (word "echo") (word "[$j]"))
---

=== declare -i with arithmetic inside strings (Nix, issue 864)
# example
# https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh#L379

declare -i s
s='1 + 2'
echo s=$s

declare -a array=(1 2 3)
declare -i item
item='array[1+1]'
echo item=$item
---
(command (word "declare") (word "-i") (word "s"))
(command (word "s='1 + 2'"))
(command (word "echo") (word "s=$s"))
(command (word "declare") (word "-a") (word "array=(1 2 3)"))
(command (word "declare") (word "-i") (word "item"))
(command (word "item='array[1+1]'"))
(command (word "echo") (word "item=$item"))
---

=== append in arith context
declare s
(( s='1 '))
(( s+=' 2 '))  # arith add
declare -i i
(( i='1 ' ))
(( i+=' 2 ' ))
declare -i j
(( j='x ' ))  # treated like zero
(( j+=' 2 ' ))
echo "$s|$i|$j"
---
(command (word "declare") (word "s"))
(arith (word " s='1 '"))
(arith (word " s+=' 2 '"))
(command (word "declare") (word "-i") (word "i"))
(arith (word " i='1 ' "))
(arith (word " i+=' 2 ' "))
(command (word "declare") (word "-i") (word "j"))
(arith (word " j='x ' "))
(arith (word " j+=' 2 ' "))
(command (word "echo") (word "\"$s|$i|$j\""))
---

=== declare array vs. string: mixing -a +a and () ''
# dynamic parsing of first argument.
declare +a 'xyz1=1'
declare +a 'xyz2=(2 3)'
declare -a 'xyz3=4'
declare -a 'xyz4=(5 6)'
argv.py "${xyz1}" "${xyz2}" "${xyz3[@]}" "${xyz4[@]}"
---
(command (word "declare") (word "+a") (word "'xyz1=1'"))
(command (word "declare") (word "+a") (word "'xyz2=(2 3)'"))
(command (word "declare") (word "-a") (word "'xyz3=4'"))
(command (word "declare") (word "-a") (word "'xyz4=(5 6)'"))
(command (word "argv.py") (word "\"${xyz1}\"") (word "\"${xyz2}\"") (word "\"${xyz3[@]}\"") (word "\"${xyz4[@]}\""))
---

=== declare array vs. associative array
# Hm I don't understand why the array only has one element.  I guess because
# index 0 is used twice?
declare -a 'array=([a]=b [c]=d)'
declare -A 'assoc=([a]=b [c]=d)'
argv.py "${#array[@]}" "${!array[@]}" "${array[@]}"
argv.py "${#assoc[@]}" "${!assoc[@]}" "${assoc[@]}"
---
(command (word "declare") (word "-a") (word "'array=([a]=b [c]=d)'"))
(command (word "declare") (word "-A") (word "'assoc=([a]=b [c]=d)'"))
(command (word "argv.py") (word "\"${#array[@]}\"") (word "\"${!array[@]}\"") (word "\"${array[@]}\""))
(command (word "argv.py") (word "\"${#assoc[@]}\"") (word "\"${!assoc[@]}\"") (word "\"${assoc[@]}\""))
---

=== declare -l -u
declare -l lower=FOO
declare -u upper=foo

echo $lower
echo $upper

# other:
# -t trace
# -I inherit attributes
---
(command (word "declare") (word "-l") (word "lower=FOO"))
(command (word "declare") (word "-u") (word "upper=foo"))
(command (word "echo") (word "$lower"))
(command (word "echo") (word "$upper"))
---

=== $SHELL is set to what is in /etc/passwd
sh=$(which $SH)

unset SHELL

prog='
if test -n "$SHELL"; then
  # the exact value is different on CI, so do not assert
  echo SHELL is set
  echo SHELL=$SHELL >&2
fi
'

$SH -c "$prog"

$SH -i -c "$prog"

# make it a login shell
$SH -l -c "$prog"
---
(command (word "sh=$(which $SH)"))
(command (word "unset") (word "SHELL"))
(command (word "prog='\nif test -n \"$SHELL\"; then\n  # the exact value is different on CI, so do not assert\n  echo SHELL is set\n  echo SHELL=$SHELL >&2\nfi\n'"))
(command (word "$SH") (word "-c") (word "\"$prog\""))
(command (word "$SH") (word "-i") (word "-c") (word "\"$prog\""))
(command (word "$SH") (word "-l") (word "-c") (word "\"$prog\""))
---

=== $PWD is set
# Just test that it has a slash for now.
echo $PWD | grep -q /
echo status=$?
---
(pipe (command (word "echo") (word "$PWD")) (command (word "grep") (word "-q") (word "/")))
(command (word "echo") (word "status=$?"))
---

=== $PWD is not only set, but exported
env | grep -q PWD
echo status=$?
---
(pipe (command (word "env")) (command (word "grep") (word "-q") (word "PWD")))
(command (word "echo") (word "status=$?"))
---

=== $PATH is set if unset at startup
# WORKAROUND for Python version of bin/osh -- we can't run bin/oils_for_unix.py
# because it a shebang #!/usr/bin/env python2
# This test is still useful for the C++ oils-for-unix.

case $SH in
  */bin/osh)
    echo yes
    echo yes
    exit
    ;;
esac

# Get absolute path before changing PATH
sh=$(which $SH)

old_path=$PATH
unset PATH

$sh -c 'echo $PATH' > path.txt

PATH=$old_path

# looks like PATH=/usr/bin:/bin for mksh, but more complicated for others
# cat path.txt

# should contain /usr/bin
if egrep -q '(^|:)/usr/bin($|:)' path.txt; then
  echo yes
fi

# should contain /bin
if egrep -q '(^|:)/bin($|:)' path.txt ; then
  echo yes
fi
---
(case (word "$SH") (pattern ((word "*/bin/osh")) (semi (semi (command (word "echo") (word "yes")) (command (word "echo") (word "yes"))) (command (word "exit")))))
(command (word "sh=$(which $SH)"))
(command (word "old_path=$PATH"))
(command (word "unset") (word "PATH"))
(command (word "$sh") (word "-c") (word "'echo $PATH'") (redirect ">" "path.txt"))
(command (word "PATH=$old_path"))
(if (command (word "egrep") (word "-q") (word "'(^|:)/usr/bin($|:)'") (word "path.txt")) (command (word "echo") (word "yes")))
(if (command (word "egrep") (word "-q") (word "'(^|:)/bin($|:)'") (word "path.txt")) (command (word "echo") (word "yes")))
---

=== $HOME is NOT set
case $SH in *zsh) echo 'zsh sets HOME'; exit ;; esac

home=$(echo $HOME)
test "$home" = ""
echo status=$?

env | grep HOME
echo status=$?

# not in interactive shell either
$SH -i -c 'echo $HOME' | grep /
echo status=$?
---
(case (word "$SH") (pattern ((word "*zsh")) (semi (command (word "echo") (word "'zsh sets HOME'")) (command (word "exit")))))
(command (word "home=$(echo $HOME)"))
(command (word "test") (word "\"$home\"") (word "=") (word "\"\""))
(command (word "echo") (word "status=$?"))
(pipe (command (word "env")) (command (word "grep") (word "HOME")))
(command (word "echo") (word "status=$?"))
(pipe (command (word "$SH") (word "-i") (word "-c") (word "'echo $HOME'")) (command (word "grep") (word "/")))
(command (word "echo") (word "status=$?"))
---

=== Vars set interactively only: $HISTFILE
case $SH in dash|mksh|zsh) exit ;; esac

$SH --norc --rcfile /dev/null -c 'echo histfile=${HISTFILE:+yes}'
$SH --norc --rcfile /dev/null -i -c 'echo histfile=${HISTFILE:+yes}'
---
(case (word "$SH") (pattern ((word "dash") (word "mksh") (word "zsh")) (command (word "exit"))))
(command (word "$SH") (word "--norc") (word "--rcfile") (word "/dev/null") (word "-c") (word "'echo histfile=${HISTFILE:+yes}'"))
(command (word "$SH") (word "--norc") (word "--rcfile") (word "/dev/null") (word "-i") (word "-c") (word "'echo histfile=${HISTFILE:+yes}'"))
---

=== Some vars are set, even without startup file, or env: PATH, PWD
flags=''
case $SH in
  dash) exit ;;
  bash*)
    flags='--noprofile --norc --rcfile /devnull'
    ;;
  osh)
    flags='--rcfile /devnull'
    ;;
esac

sh_path=$(which $SH)

case $sh_path in
  */bin/osh)
    # Hack for running with Python2
    export PYTHONPATH="$REPO_ROOT:$REPO_ROOT/vendor"
    sh_prefix="$(which python2) $REPO_ROOT/bin/oils_for_unix.py osh"
    ;;
  *)
    sh_prefix=$sh_path
    ;;
esac

#echo PATH=$PATH


# mksh has typeset, not declare
# bash exports PWD, but not PATH PS4

/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p PATH PWD PS4' >&2
echo path pwd ps4 $?

/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p SHELLOPTS' >&2
echo shellopts $?

# bash doesn't set HOME, mksh and zsh do
/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p HOME PS1' >&2
echo home ps1 $?

# IFS is set, but not exported
/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p IFS' >&2
echo ifs $?
---
(command (word "flags=''"))
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))) (pattern ((word "bash*")) (command (word "flags='--noprofile --norc --rcfile /devnull'"))) (pattern ((word "osh")) (command (word "flags='--rcfile /devnull'"))))
(command (word "sh_path=$(which $SH)"))
(case (word "$sh_path") (pattern ((word "*/bin/osh")) (semi (command (word "export") (word "PYTHONPATH=\"$REPO_ROOT:$REPO_ROOT/vendor\"")) (command (word "sh_prefix=\"$(which python2) $REPO_ROOT/bin/oils_for_unix.py osh\"")))) (pattern ((word "*")) (command (word "sh_prefix=$sh_path"))))
(command (word "/usr/bin/env") (word "-i") (word "PYTHONPATH=$PYTHONPATH") (word "$sh_prefix") (word "$flags") (word "-c") (word "'typeset -p PATH PWD PS4'") (redirect ">&" 2))
(command (word "echo") (word "path") (word "pwd") (word "ps4") (word "$?"))
(command (word "/usr/bin/env") (word "-i") (word "PYTHONPATH=$PYTHONPATH") (word "$sh_prefix") (word "$flags") (word "-c") (word "'typeset -p SHELLOPTS'") (redirect ">&" 2))
(command (word "echo") (word "shellopts") (word "$?"))
(command (word "/usr/bin/env") (word "-i") (word "PYTHONPATH=$PYTHONPATH") (word "$sh_prefix") (word "$flags") (word "-c") (word "'typeset -p HOME PS1'") (redirect ">&" 2))
(command (word "echo") (word "home") (word "ps1") (word "$?"))
(command (word "/usr/bin/env") (word "-i") (word "PYTHONPATH=$PYTHONPATH") (word "$sh_prefix") (word "$flags") (word "-c") (word "'typeset -p IFS'") (redirect ">&" 2))
(command (word "echo") (word "ifs") (word "$?"))
---

=== UID EUID PPID can't be changed
# bash makes these 3 read-only
{
  UID=xx $SH -c 'echo uid=$UID'

  EUID=xx $SH -c 'echo euid=$EUID'

  PPID=xx $SH -c 'echo ppid=$PPID'

} > out.txt

# bash shows that vars are readonly
# zsh shows other errors
# cat out.txt
#echo

grep '=xx' out.txt
echo status=$?
---
(brace-group (semi (semi (command (word "UID=xx") (word "$SH") (word "-c") (word "'echo uid=$UID'")) (command (word "EUID=xx") (word "$SH") (word "-c") (word "'echo euid=$EUID'"))) (command (word "PPID=xx") (word "$SH") (word "-c") (word "'echo ppid=$PPID'")))) (redirect ">" "out.txt")
(command (word "grep") (word "'=xx'") (word "out.txt"))
(command (word "echo") (word "status=$?"))
---

=== HOSTNAME OSTYPE can be changed
case $SH in zsh) exit ;; esac

#$SH -c 'echo hostname=$HOSTNAME'

HOSTNAME=x $SH -c 'echo hostname=$HOSTNAME'
OSTYPE=x $SH -c 'echo ostype=$OSTYPE'
echo

#PS4=x $SH -c 'echo ps4=$PS4'

# OPTIND is special
#OPTIND=xx $SH -c 'echo optind=$OPTIND'
---
(case (word "$SH") (pattern ((word "zsh")) (command (word "exit"))))
(command (word "HOSTNAME=x") (word "$SH") (word "-c") (word "'echo hostname=$HOSTNAME'"))
(command (word "OSTYPE=x") (word "$SH") (word "-c") (word "'echo ostype=$OSTYPE'"))
(command (word "echo"))
---

=== $1 .. $9 are scoped, while $0 is not
fun() {
  case $0 in
    *sh)
      echo 'sh'
      ;;
    *sh-*)  # bash-4.4 is OK
      echo 'sh'
      ;;
  esac

  echo $1 $2
}
fun a b
---
(function "fun" (brace-group (semi (case (word "$0") (pattern ((word "*sh")) (command (word "echo") (word "'sh'"))) (pattern ((word "*sh-*")) (command (word "echo") (word "'sh'")))) (command (word "echo") (word "$1") (word "$2")))))
(command (word "fun") (word "a") (word "b"))
---

=== $?
echo $?  # starts out as 0
sh -c 'exit 33'
echo $?
---
(command (word "echo") (word "$?"))
(command (word "sh") (word "-c") (word "'exit 33'"))
(command (word "echo") (word "$?"))
---

=== $#
set -- 1 2 3 4
echo $#
---
(command (word "set") (word "--") (word "1") (word "2") (word "3") (word "4"))
(command (word "echo") (word "$#"))
---

=== $$ looks like a PID
echo $$ | egrep -q '[0-9]+'  # Test that it has decimal digits
echo status=$?
---
(pipe (command (word "echo") (word "$$")) (command (word "egrep") (word "-q") (word "'[0-9]+'")))
(command (word "echo") (word "status=$?"))
---

=== $$ doesn't change with subshell or command sub
# Just test that it has decimal digits
set -o errexit
die() {
  echo 1>&2 "$@"; exit 1
}
parent=$$
test -n "$parent" || die "empty PID in parent"
( child=$$
  test -n "$child" || die "empty PID in subshell"
  test "$parent" = "$child" || die "should be equal: $parent != $child"
  echo 'subshell OK'
)
echo $( child=$$
        test -n "$child" || die "empty PID in command sub"
        test "$parent" = "$child" || die "should be equal: $parent != $child"
        echo 'command sub OK'
      )
exit 3  # make sure we got here
---
(command (word "set") (word "-o") (word "errexit"))
(function "die" (brace-group (semi (command (word "echo") (word "\"$@\"") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "parent=$$"))
(or (command (word "test") (word "-n") (word "\"$parent\"")) (command (word "die") (word "\"empty PID in parent\"")))
(subshell (semi (semi (semi (command (word "child=$$")) (or (command (word "test") (word "-n") (word "\"$child\"")) (command (word "die") (word "\"empty PID in subshell\"")))) (or (command (word "test") (word "\"$parent\"") (word "=") (word "\"$child\"")) (command (word "die") (word "\"should be equal: $parent != $child\"")))) (command (word "echo") (word "'subshell OK'"))))
(command (word "echo") (word "$(child=$$\ntest -n \"$child\" || die \"empty PID in command sub\"\ntest \"$parent\" = \"$child\" || die \"should be equal: $parent != $child\"\necho 'command sub OK')"))
(command (word "exit") (word "3"))
---

=== $BASHPID DOES change with subshell and command sub
set -o errexit
die() {
  echo 1>&2 "$@"; exit 1
}
parent=$BASHPID
test -n "$parent" || die "empty BASHPID in parent"
( child=$BASHPID
  test -n "$child" || die "empty BASHPID in subshell"
  test "$parent" != "$child" || die "should not be equal: $parent = $child"
  echo 'subshell OK'
)
echo $( child=$BASHPID
        test -n "$child" || die "empty BASHPID in command sub"
        test "$parent" != "$child" ||
          die "should not be equal: $parent = $child"
        echo 'command sub OK'
      )
exit 3  # make sure we got here

# mksh also implements BASHPID!
---
(command (word "set") (word "-o") (word "errexit"))
(function "die" (brace-group (semi (command (word "echo") (word "\"$@\"") (redirect ">&" 2)) (command (word "exit") (word "1")))))
(command (word "parent=$BASHPID"))
(or (command (word "test") (word "-n") (word "\"$parent\"")) (command (word "die") (word "\"empty BASHPID in parent\"")))
(subshell (semi (semi (semi (command (word "child=$BASHPID")) (or (command (word "test") (word "-n") (word "\"$child\"")) (command (word "die") (word "\"empty BASHPID in subshell\"")))) (or (command (word "test") (word "\"$parent\"") (word "!=") (word "\"$child\"")) (command (word "die") (word "\"should not be equal: $parent = $child\"")))) (command (word "echo") (word "'subshell OK'"))))
(command (word "echo") (word "$(child=$BASHPID\ntest -n \"$child\" || die \"empty BASHPID in command sub\"\ntest \"$parent\" != \"$child\" || die \"should not be equal: $parent = $child\"\necho 'command sub OK')"))
(command (word "exit") (word "3"))
---

=== Background PID $! looks like a PID
sleep 0.01 &
pid=$!
wait
echo $pid | egrep '[0-9]+' >/dev/null
echo status=$?
---
(background (command (word "sleep") (word "0.01")))
(command (word "pid=$!"))
(command (word "wait"))
(pipe (command (word "echo") (word "$pid")) (command (word "egrep") (word "'[0-9]+'") (redirect ">" "/dev/null")))
(command (word "echo") (word "status=$?"))
---

=== $PPID
echo $PPID | egrep '[0-9]+'
---
(pipe (command (word "echo") (word "$PPID")) (command (word "egrep") (word "'[0-9]+'")))
---

=== $PIPESTATUS
echo hi | sh -c 'cat; exit 33' | wc -l >/dev/null
argv.py "${PIPESTATUS[@]}"
---
(pipe (command (word "echo") (word "hi")) (pipe (command (word "sh") (word "-c") (word "'cat; exit 33'")) (command (word "wc") (word "-l") (redirect ">" "/dev/null"))))
(command (word "argv.py") (word "\"${PIPESTATUS[@]}\""))
---

=== $RANDOM
expr $0 : '.*/osh$' && exit 99  # Disabled because of spec-runner.sh issue
echo $RANDOM | egrep '[0-9]+'
---
(and (command (word "expr") (word "$0") (word ":") (word "'.*/osh$'")) (command (word "exit") (word "99")))
(pipe (command (word "echo") (word "$RANDOM")) (command (word "egrep") (word "'[0-9]+'")))
---

=== $UID and $EUID
# These are both bash-specific.
set -o errexit
echo $UID | egrep -o '[0-9]+' >/dev/null
echo $EUID | egrep -o '[0-9]+' >/dev/null
echo status=$?
---
(command (word "set") (word "-o") (word "errexit"))
(pipe (command (word "echo") (word "$UID")) (command (word "egrep") (word "-o") (word "'[0-9]+'") (redirect ">" "/dev/null")))
(pipe (command (word "echo") (word "$EUID")) (command (word "egrep") (word "-o") (word "'[0-9]+'") (redirect ">" "/dev/null")))
(command (word "echo") (word "status=$?"))
---

=== $OSTYPE is non-empty
test -n "$OSTYPE"
echo status=$?
---
(command (word "test") (word "-n") (word "\"$OSTYPE\""))
(command (word "echo") (word "status=$?"))
---

=== $HOSTNAME
test "$HOSTNAME" = "$(hostname)"
echo status=$?
---
(command (word "test") (word "\"$HOSTNAME\"") (word "=") (word "\"$(hostname)\""))
(command (word "echo") (word "status=$?"))
---

=== $LINENO is the current line, not line of function call
echo $LINENO  # first line
g() {
  argv.py $LINENO  # line 3
}
f() {
  argv.py $LINENO  # line 6
  g
  argv.py $LINENO  # line 8
}
f
---
(command (word "echo") (word "$LINENO"))
(function "g" (brace-group (command (word "argv.py") (word "$LINENO"))))
(function "f" (brace-group (semi (semi (command (word "argv.py") (word "$LINENO")) (command (word "g"))) (command (word "argv.py") (word "$LINENO")))))
(command (word "f"))
---

=== $LINENO in "bare" redirect arg (bug regression)
filename=$TMP/bare3
rm -f $filename
> $TMP/bare$LINENO
test -f $filename && echo written
echo $LINENO
---
(command (word "filename=$TMP/bare3"))
(command (word "rm") (word "-f") (word "$filename"))
(command (redirect ">" "$TMP/bare$LINENO"))
(and (command (word "test") (word "-f") (word "$filename")) (command (word "echo") (word "written")))
(command (word "echo") (word "$LINENO"))
---

=== $LINENO in redirect arg (bug regression)
filename=$TMP/lineno_regression3
rm -f $filename
echo x > $TMP/lineno_regression$LINENO
test -f $filename && echo written
echo $LINENO
---
(command (word "filename=$TMP/lineno_regression3"))
(command (word "rm") (word "-f") (word "$filename"))
(command (word "echo") (word "x") (redirect ">" "$TMP/lineno_regression$LINENO"))
(and (command (word "test") (word "-f") (word "$filename")) (command (word "echo") (word "written")))
(command (word "echo") (word "$LINENO"))
---

=== $LINENO in [[
echo one
[[ $LINENO -eq 2 ]] && echo OK
---
(command (word "echo") (word "one"))
(and (cond (cond-binary "-eq" (cond-term "$LINENO") (cond-term "2"))) (command (word "echo") (word "OK")))
---

=== $LINENO in ((
echo one
(( x = LINENO ))
echo $x
---
(command (word "echo") (word "one"))
(arith (word " x = LINENO "))
(command (word "echo") (word "$x"))
---

=== $LINENO in for loop
# hm bash doesn't take into account the word break.  That's OK; we won't either.
echo one
for x in \
  $LINENO zzz; do
  echo $x
done
---
(command (word "echo") (word "one"))
(for (word "x") (in (word "$LINENO") (word "zzz")) (command (word "echo") (word "$x")))
---

=== $LINENO in other for loops
set -- a b c
for x; do
  echo $LINENO $x
done
---
(command (word "set") (word "--") (word "a") (word "b") (word "c"))
(for (word "x") (in (word "\"$@\"")) (command (word "echo") (word "$LINENO") (word "$x")))
---

=== $LINENO in for (( loop
# This is a real edge case that I'm not sure we care about.  We would have to
# change the span ID inside the loop to make it really correct.
echo one
for (( i = 0; i < $LINENO; i++ )); do
  echo $i
done
---
(command (word "echo") (word "one"))
(arith-for (init (word "i = 0")) (test (word "i < $LINENO")) (step (word "i++ ")) (command (word "echo") (word "$i")))
---

=== $LINENO for assignment
a1=$LINENO a2=$LINENO
b1=$LINENO b2=$LINENO
echo $a1 $a2
echo $b1 $b2
---
(command (word "a1=$LINENO") (word "a2=$LINENO"))
(command (word "b1=$LINENO") (word "b2=$LINENO"))
(command (word "echo") (word "$a1") (word "$a2"))
(command (word "echo") (word "$b1") (word "$b2"))
---

=== $LINENO in case
case $LINENO in
  1) echo 'got line 1' ;;
  *) echo line=$LINENO
esac
---
(case (word "$LINENO") (pattern ((word "1")) (command (word "echo") (word "'got line 1'"))) (pattern ((word "*")) (command (word "echo") (word "line=$LINENO"))))
---

=== $_ with simple command and evaluation
name=world
echo "hi $name"
echo "$_"
---
(command (word "name=world"))
(command (word "echo") (word "\"hi $name\""))
(command (word "echo") (word "\"$_\""))
---

=== $_ and ${_}
case $SH in dash|mksh) exit ;; esac

_var=value

: 42
echo $_ $_var ${_}var

: 'foo'"bar"
echo $_
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "_var=value"))
(command (word ":") (word "42"))
(command (word "echo") (word "$_") (word "$_var") (word "${_}var"))
(command (word ":") (word "'foo'\"bar\""))
(command (word "echo") (word "$_"))
---

=== $_ with word splitting
case $SH in dash|mksh) exit ;; esac

setopt shwordsplit  # for ZSH

x='with spaces'
: $x
echo $_
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "setopt") (word "shwordsplit"))
(command (word "x='with spaces'"))
(command (word ":") (word "$x"))
(command (word "echo") (word "$_"))
---

=== $_ with pipeline and subshell
case $SH in dash|mksh) exit ;; esac

shopt -s lastpipe

seq 3 | echo last=$_

echo pipeline=$_

( echo subshell=$_ )
echo done=$_
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "lastpipe"))
(pipe (command (word "seq") (word "3")) (command (word "echo") (word "last=$_")))
(command (word "echo") (word "pipeline=$_"))
(subshell (command (word "echo") (word "subshell=$_")))
(command (word "echo") (word "done=$_"))
---

=== $_ with && and ||
case $SH in dash|mksh) exit ;; esac

echo hi && echo last=$_
echo and=$_

echo hi || echo last=$_
echo or=$_
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(and (command (word "echo") (word "hi")) (command (word "echo") (word "last=$_")))
(command (word "echo") (word "and=$_"))
(or (command (word "echo") (word "hi")) (command (word "echo") (word "last=$_")))
(command (word "echo") (word "or=$_"))
---

=== $_ is not reset with (( and [[
# bash is inconsistent because it does it for pipelines and assignments, but
# not (( and [[

case $SH in dash|mksh) exit ;; esac

echo simple
(( a = 2 + 3 ))
echo "(( $_"

[[ a == *.py ]]
echo "[[ $_"
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "echo") (word "simple"))
(arith (word " a = 2 + 3 "))
(command (word "echo") (word "\"(( $_\""))
(cond (cond-binary "==" (cond-term "a") (cond-term "*.py")))
(command (word "echo") (word "\"[[ $_\""))
---

=== $_ with assignments, arrays, etc.
case $SH in dash|mksh) exit ;; esac

: foo
echo "colon [$_]"

s=bar
echo "bare assign [$_]"

# zsh uses declare; bash uses s=bar
declare s=bar
echo "declare [$_]"

# zsh remains s:declare, bash resets it
a=(1 2)
echo "array [$_]"

# zsh sets it to declare, bash uses the LHS a
declare a=(1 2)
echo "declare array [$_]"

declare -g d=(1 2)
echo "declare flag [$_]"
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word ":") (word "foo"))
(command (word "echo") (word "\"colon [$_]\""))
(command (word "s=bar"))
(command (word "echo") (word "\"bare assign [$_]\""))
(command (word "declare") (word "s=bar"))
(command (word "echo") (word "\"declare [$_]\""))
(command (word "a=(1 2)"))
(command (word "echo") (word "\"array [$_]\""))
(command (word "declare") (word "a=(1 2)"))
(command (word "echo") (word "\"declare array [$_]\""))
(command (word "declare") (word "-g") (word "d=(1 2)"))
(command (word "echo") (word "\"declare flag [$_]\""))
---

=== $_ with loop
case $SH in dash|mksh) exit ;; esac

# zsh resets it when in a loop

echo init
echo begin=$_
for x in 1 2 3; do
  echo prev=$_
done
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "echo") (word "init"))
(command (word "echo") (word "begin=$_"))
(for (word "x") (in (word "1") (word "2") (word "3")) (command (word "echo") (word "prev=$_")))
---

=== $_ is not undefined on first use
set -e

x=$($SH -u -c 'echo prev=$_')
echo status=$?

# bash and mksh set $_ to $0 at first; zsh is empty
#echo "$x"
---
(command (word "set") (word "-e"))
(command (word "x=$($SH -u -c 'echo prev=$_')"))
(command (word "echo") (word "status=$?"))
---

=== BASH_VERSION / OILS_VERSION
case $SH in
  bash*)
    # BASH_VERSION=zz

    echo $BASH_VERSION | egrep -o '4\.4\.0' > /dev/null
    echo matched=$?
    ;;
  *osh)
    # note: version string is mutable like in bash.  I guess that's useful for
    # testing?  We might want a strict mode to eliminate that?

    echo $OILS_VERSION | egrep -o '[0-9]+\.[0-9]+\.' > /dev/null
    echo matched=$?
    ;;
  *)
    echo 'no version'
    ;;
esac
---
(case (word "$SH") (pattern ((word "bash*")) (semi (pipe (command (word "echo") (word "$BASH_VERSION")) (command (word "egrep") (word "-o") (word "'4\\.4\\.0'") (redirect ">" "/dev/null"))) (command (word "echo") (word "matched=$?")))) (pattern ((word "*osh")) (semi (pipe (command (word "echo") (word "$OILS_VERSION")) (command (word "egrep") (word "-o") (word "'[0-9]+\\.[0-9]+\\.'") (redirect ">" "/dev/null"))) (command (word "echo") (word "matched=$?")))) (pattern ((word "*")) (command (word "echo") (word "'no version'"))))
---

=== $SECONDS
# most likely 0 seconds, but in CI I've seen 1 second
echo $SECONDS | awk '/[0-9]+/ { print "ok" }'
---
(pipe (command (word "echo") (word "$SECONDS")) (command (word "awk") (word "'/[0-9]+/ { print \"ok\" }'")))
---

=== Parsing shell words \r \v
# frontend/lexer_def.py has rules for this

tab=$(python2 -c 'print "argv.py -\t-"')
cr=$(python2 -c 'print "argv.py -\r-"')
vert=$(python2 -c 'print "argv.py -\v-"')
ff=$(python2 -c 'print "argv.py -\f-"')

$SH -c "$tab"
$SH -c "$cr"
$SH -c "$vert"
$SH -c "$ff"
---
(command (word "tab=$(python2 -c 'print \"argv.py -\\t-\"')"))
(command (word "cr=$(python2 -c 'print \"argv.py -\\r-\"')"))
(command (word "vert=$(python2 -c 'print \"argv.py -\\v-\"')"))
(command (word "ff=$(python2 -c 'print \"argv.py -\\f-\"')"))
(command (word "$SH") (word "-c") (word "\"$tab\""))
(command (word "$SH") (word "-c") (word "\"$cr\""))
(command (word "$SH") (word "-c") (word "\"$vert\""))
(command (word "$SH") (word "-c") (word "\"$ff\""))
---

=== \r in arith expression is allowed by some shells, but not most!
arith=$(python2 -c 'print "argv.py $(( 1 +\n2))"')
arith_cr=$(python2 -c 'print "argv.py $(( 1 +\r\n2))"')

$SH -c "$arith"
if test $? -ne 0; then
  echo 'failed'
fi

$SH -c "$arith_cr"
if test $? -ne 0; then
  echo 'failed'
fi
---
(command (word "arith=$(python2 -c 'print \"argv.py $(( 1 +\\n2))\"')"))
(command (word "arith_cr=$(python2 -c 'print \"argv.py $(( 1 +\\r\\n2))\"')"))
(command (word "$SH") (word "-c") (word "\"$arith\""))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'failed'")))
(command (word "$SH") (word "-c") (word "\"$arith_cr\""))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'failed'")))
---

=== whitespace in string to integer conversion
tab=$(python2 -c 'print "\t42\t"')
cr=$(python2 -c 'print "\r42\r"')

$SH -c 'echo $(( $1 + 1 ))' dummy0 "$tab"
if test $? -ne 0; then
  echo 'failed'
fi

$SH -c 'echo $(( $1 + 1 ))' dummy0 "$cr"
if test $? -ne 0; then
  echo 'failed'
fi
---
(command (word "tab=$(python2 -c 'print \"\\t42\\t\"')"))
(command (word "cr=$(python2 -c 'print \"\\r42\\r\"')"))
(command (word "$SH") (word "-c") (word "'echo $(( $1 + 1 ))'") (word "dummy0") (word "\"$tab\""))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'failed'")))
(command (word "$SH") (word "-c") (word "'echo $(( $1 + 1 ))'") (word "dummy0") (word "\"$cr\""))
(if (command (word "test") (word "$?") (word "-ne") (word "0")) (command (word "echo") (word "'failed'")))
---

=== \r at end of line is not special
# hm I wonder if Windows ports have rules for this?

cr=$(python2 -c 'print "argv.py -\r"')

$SH -c "$cr"
---
(command (word "cr=$(python2 -c 'print \"argv.py -\\r\"')"))
(command (word "$SH") (word "-c") (word "\"$cr\""))
---

=== Default IFS does not include \r \v \f
# dash and zsh don't have echo -e
tab=$(python2 -c 'print "-\t-"')
cr=$(python2 -c 'print "-\r-"')
vert=$(python2 -c 'print "-\v-"')
ff=$(python2 -c 'print "-\f-"')

$SH -c 'argv.py $1' dummy0 "$tab"
$SH -c 'argv.py $1' dummy0 "$cr"
$SH -c 'argv.py $1' dummy0 "$vert"
$SH -c 'argv.py $1' dummy0 "$ff"
---
(command (word "tab=$(python2 -c 'print \"-\\t-\"')"))
(command (word "cr=$(python2 -c 'print \"-\\r-\"')"))
(command (word "vert=$(python2 -c 'print \"-\\v-\"')"))
(command (word "ff=$(python2 -c 'print \"-\\f-\"')"))
(command (word "$SH") (word "-c") (word "'argv.py $1'") (word "dummy0") (word "\"$tab\""))
(command (word "$SH") (word "-c") (word "'argv.py $1'") (word "dummy0") (word "\"$cr\""))
(command (word "$SH") (word "-c") (word "'argv.py $1'") (word "dummy0") (word "\"$vert\""))
(command (word "$SH") (word "-c") (word "'argv.py $1'") (word "dummy0") (word "\"$ff\""))
---

=== TODO: SETUP should be shared
typeset -A a
a=(aa b foo bar a+1 c)

#### retrieve key
typeset -A a
a=(aa b foo bar a+1 c)
echo ${a[aa]}
---
(command (word "typeset") (word "-A") (word "a"))
(command (word "a=(aa b foo bar a+1 c)"))
(command (word "typeset") (word "-A") (word "a"))
(command (word "a=(aa b foo bar a+1 c)"))
(command (word "echo") (word "${a[aa]}"))
---

=== set key
typeset -A a
a=(aa b foo bar a+1 c)
a[X]=XX
argv.py "${a[@]}"
# What order is this?
---
(command (word "typeset") (word "-A") (word "a"))
(command (word "a=(aa b foo bar a+1 c)"))
(command (word "a[X]=XX"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== iterate over keys
typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
for k in "${(@k)assoc}"; do
  echo "$k: $assoc[$k]"
done
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=(k1 v1 k2 v2 k3 v3)"))
(for (word "k") (in (word "\"${(@k)assoc}\"")) (command (word "echo") (word "\"$k: $assoc[$k]\"")))
---

=== get length
typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
echo ${#assoc} ${#assoc[k1]}
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=(k1 v1 k2 v2 k3 v3)"))
(command (word "echo") (word "${#assoc}") (word "${#assoc[k1]}"))
---

=== index by integer does not work
typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
argv.py "${assoc[1]}"
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=(k1 v1 k2 v2 k3 v3)"))
(command (word "argv.py") (word "\"${assoc[1]}\""))
---

=== git-completion snippet
# copied directly from git completion - 2024-04

if false; then
  unset ${(M)${(k)parameters[@]}:#__gitcomp_builtin_*} 2>/dev/null
fi
echo status=$?
---
(if (command (word "false")) (command (word "unset") (word "${(M)${(k)parameters[@]}:#__gitcomp_builtin_*}") (redirect ">" "/dev/null")))
(command (word "echo") (word "status=$?"))
---

=== asdf snippet
# copied directly from asdf - 2024-04

if false; then
  ASDF_DIR=${(%):-%x}
fi
---
(if (command (word "false")) (command (word "ASDF_DIR=${(%):-%x}")))
---

=== zsh var sub is rejected at runtime
eval 'echo z ${(m)foo} z'
echo status=$?

eval 'echo ${x:-${(m)foo}}'
echo status=$?

# double quoted
eval 'echo "${(m)foo}"'
echo status=$?
---
(command (word "eval") (word "'echo z ${(m)foo} z'"))
(command (word "echo") (word "status=$?"))
(command (word "eval") (word "'echo ${x:-${(m)foo}}'"))
(command (word "echo") (word "status=$?"))
(command (word "eval") (word "'echo \"${(m)foo}\"'"))
(command (word "echo") (word "status=$?"))
---
