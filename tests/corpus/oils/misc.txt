================================================================================
alias.test.sh: Usage of builtins
================================================================================

shopt -s expand_aliases || true
alias -- foo=echo
echo status=$?
foo x
unalias -- foo
foo x

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Basic alias
================================================================================

shopt -s expand_aliases  # bash requires this
alias hi='echo hello world'
hi || echo 'should not run this'
echo hi  # second word is not
'hi' || echo 'expected failure'

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: define and use alias on a single line
================================================================================

shopt -s expand_aliases
alias e=echo; e one  # this is not alias-expanded because we parse lines at once
e two; e three

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias can override builtin
================================================================================

shopt -s expand_aliases
alias echo='echo foo'
echo bar

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: defining multiple aliases, then unalias
================================================================================

shopt -s expand_aliases  # bash requires this
x=x
y=y
alias echo-x='echo $x' echo-y='echo $y'
echo status=$?
echo-x X
echo-y Y
unalias echo-x echo-y
echo status=$?
echo-x X || echo undefined
echo-y Y || echo undefined

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias not defined
================================================================================

alias e='echo' nonexistentZ
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: unalias not defined
================================================================================

alias e=echo ll='ls -l'
unalias e nonexistentZ ll
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: unalias -a
================================================================================


alias foo=bar
alias spam=eggs

alias | egrep 'foo|spam' | wc -l

unalias -a

alias
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: List aliases by providing names
================================================================================


alias e=echo ll='ls -l'
alias e ll

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias without args lists all aliases
================================================================================

alias ex=exit ll='ls -l'
alias | grep -E 'ex=|ll='  # need to grep because mksh/zsh have builtin aliases
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: unalias without args is a usage error
================================================================================

unalias
if test "$?" != 0; then echo usage-error; fi

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias with trailing space causes alias expansion on second word
================================================================================

shopt -s expand_aliases  # bash requires this

alias hi='echo hello world '
alias punct='!!!'

hi punct

alias hi='echo hello world'  # No trailing space

hi punct

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Recursive alias expansion of first word
================================================================================

shopt -s expand_aliases  # bash requires this
alias hi='e_ hello world'
alias e_='echo __'
hi   # first hi is expanded to echo hello world; then echo is expanded.  gah.

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Recursive alias expansion of SECOND word
================================================================================

shopt -s expand_aliases  # bash requires this
alias one='ONE '
alias two='TWO '
alias e_='echo one '
e_ two hello world

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Expansion of alias with variable
================================================================================

shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x'  # nothing is evaluated here
x=y
echo-x hi

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias must be an unquoted word, no expansions allowed
================================================================================

shopt -s expand_aliases  # bash requires this
alias echo_alias_='echo'
cmd=echo_alias_
echo_alias_ X  # this works
$cmd X  # this fails because it's quoted
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: first and second word are the same alias, but no trailing space
================================================================================

shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x'  # nothing is evaluated here
echo-x echo-x

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: first and second word are the same alias, with trailing space
================================================================================

shopt -s expand_aliases  # bash requires this
x=x
alias echo-x='echo $x '  # nothing is evaluated here
echo-x echo-x

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Invalid syntax of alias
================================================================================

shopt -s expand_aliases  # bash requires this
alias echo_alias_= 'echo --; echo'  # bad space here
echo_alias_ x

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Dynamic alias definition
================================================================================

shopt -s expand_aliases  # bash requires this
x=x
name='echo_alias_'
val='=echo'
alias "$name$val"
echo_alias_ X

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias name with punctuation
================================================================================

# NOTE: / is not OK in bash, but OK in other shells.  Must less restrictive
# than var names.
shopt -s expand_aliases  # bash requires this
alias e_+.~x='echo'
e_+.~x X

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Syntax error after expansion
================================================================================

shopt -s expand_aliases  # bash requires this
alias e_=';; oops'
e_ x

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Loop split across alias and arg works
================================================================================

shopt -s expand_aliases  # bash requires this
alias e_='for i in 1 2 3; do echo $i;'
e_ done

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias with a quote in the middle is a syntax error
================================================================================

shopt -s expand_aliases
alias e_='echo "'
var=x
e_ '${var}"'

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias with internal newlines
================================================================================

shopt -s expand_aliases
alias e_='echo 1
echo 2
echo 3'
var='echo foo'
e_ ${var}

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias trailing newline
================================================================================

shopt -s expand_aliases
alias e_='echo 1
echo 2
echo 3
'
var='echo foo'
e_ ${var}

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Two aliases in pipeline
================================================================================

shopt -s expand_aliases
alias SEQ='seq '
alias THREE='3 '
alias WC='wc '
SEQ THREE | WC -l

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias not respected inside $()
================================================================================

# This could be parsed correctly, but it is only defined in a child process.
shopt -s expand_aliases
echo $(alias sayhi='echo hello')
sayhi

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias can be defined and used on a single line
================================================================================

shopt -s expand_aliases
alias sayhi='echo hello'; sayhi same line
sayhi other line

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias is respected inside eval
================================================================================

shopt -s expand_aliases
eval "alias sayhi='echo hello'
sayhi inside"
sayhi outside

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias with redirects works
================================================================================

shopt -s expand_aliases
alias e_=echo
>$TMP/alias1.txt e_ 1
e_ >$TMP/alias2.txt 2
e_ 3 >$TMP/alias3.txt
cat $TMP/alias1.txt $TMP/alias2.txt $TMP/alias3.txt

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias with environment bindings works
================================================================================

shopt -s expand_aliases
alias p_=printenv.py
FOO=1 printenv.py FOO
FOO=2 p_ FOO

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias with line continuation in the middle
================================================================================

shopt -s expand_aliases
alias e_='echo '
alias one='ONE '
alias two='TWO '
alias three='THREE'  # no trailing space
e_ one \
  two one \
  two three two \
  one

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias used in subshell and command sub
================================================================================

# This spec seems to be contradictoary?
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_03_01
# "When used as specified by this volume of POSIX.1-2017, alias definitions
# shall not be inherited by separate invocations of the shell or by the utility
# execution environments invoked by the shell; see Shell Execution
# Environment."
shopt -s expand_aliases
alias echo_='echo [ '
( echo_ subshell; )
echo $(echo_ commandsub)

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias used in here doc
================================================================================

shopt -s expand_aliases
alias echo_='echo [ '
cat <<EOF
$(echo_ ])
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: here doc inside alias
================================================================================

shopt -s expand_aliases
alias c='cat <<EOF
$(echo hi)
EOF
'
c

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Corner case: alias inside LHS array arithmetic expression
================================================================================

shopt -s expand_aliases
alias zero='echo 0'
a[$(zero)]=ZERO
a[1]=ONE
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias that is pipeline
================================================================================

shopt -s expand_aliases
alias t1='echo hi|wc -c'
t1

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias that is && || ;
================================================================================

shopt -s expand_aliases
alias t1='echo one && echo two && echo 3 | wc -l;
echo four'
t1

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias and command sub (bug regression)
================================================================================

cd $TMP
shopt -s expand_aliases
echo foo bar > tmp.txt
alias a=argv.py
a `cat tmp.txt`

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias and arithmetic
================================================================================

shopt -s expand_aliases
alias a=argv.py
a $((1 + 2))

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: Alias and PS4
================================================================================

# dash enters an infinite loop!
case $SH in
  dash)
    exit 1
    ;;
esac

set -x
PS4='+$(echo trace) '
shopt -s expand_aliases
alias a=argv.py
a foo bar

--------------------------------------------------------------------------------

(program)

================================================================================
alias.test.sh: alias with word of multiple lines
================================================================================

shopt -s expand_aliases

alias ll='ls -l'
ll '1
  2
  3'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Append string to string
================================================================================

s='abc'
s+=d
echo $s

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Append array to array
================================================================================

a=(x y )
a+=(t 'u v')
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Append string to undefined variable
================================================================================


s+=foo
echo s=$s

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

t+=foo
echo t=$t
t+=foo
echo t=$t

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Append to array to undefined variable
================================================================================


y+=(c d)
argv.py "${y[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: error: s+=(my array)
================================================================================

s='abc'
s+=(d e f)
argv.py "${s[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: error: myarray+=s
================================================================================


# They treat this as implicit index 0.  We disallow this on the LHS, so we will
# also disallow it on the RHS.
a=(x y )
a+=z
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: typeset s+=(my array)
================================================================================

typeset s='abc'
echo $s

typeset s+=(d e f)
echo status=$?
argv.py "${s[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: error: typeset myarray+=s
================================================================================

typeset a=(x y)
argv.py "${a[@]}"
typeset a+=s
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: error: append used like env prefix
================================================================================

# This should be an error in other shells but it's not.
A=a
A+=a printenv.py A

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: myarray[1]+=s - Append to element
================================================================================

# They treat this as implicit index 0.  We disallow this on the LHS, so we will
# also disallow it on the RHS.
a=(x y )
a[1]+=z
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: myarray[-1]+=s - Append to last element
================================================================================

# Works in bash, but not mksh.  It seems like bash is doing the right thing.
# a[-1] is allowed on the LHS.  mksh doesn't have negative indexing?
a=(1 '2 3')
a[-1]+=' 4'
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Try to append list to element
================================================================================

# bash - runtime error: cannot assign list to array number
# mksh - a[-1]+: is not an identifier
# osh - parse error -- could be better!
a=(1 '2 3')
a[-1]+=(4 5)
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Strings have value semantics, not reference semantics
================================================================================

s1='abc'
s2=$s1
s1+='d'
echo $s1 $s2

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: typeset s+=
================================================================================


typeset s+=foo
echo s=$s

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

typeset t+=foo
echo t=$t
typeset t+=foo
echo t=$t

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: typeset s${dyn}+=
================================================================================


dyn=x

typeset s${dyn}+=foo
echo sx=$sx

# bash and mksh agree that this does NOT respect set -u.
# I think that's a mistake, but += is a legacy construct, so let's copy it.

set -u

typeset t${dyn}+=foo
echo tx=$tx
typeset t${dyn}+=foo
echo tx=$tx

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: export readonly +=
================================================================================


export e+=foo
echo e=$e

readonly r+=bar
echo r=$r

set -u

export e+=foo
echo e=$e

#readonly r+=foo
#echo r=$e

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: local +=
================================================================================


f() {
  local s+=foo
  echo s=$s

  set -u
  local s+=foo
  echo s=$s
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: assign builtin appending array: declare d+=(d e)
================================================================================


declare d+=(d e)
echo "${d[@]}"
declare d+=(c l)
echo "${d[@]}"

readonly r+=(r e)
echo "${r[@]}"
# can't do this again

f() {
  local l+=(l o)
  echo "${l[@]}"

  local l+=(c a)
  echo "${l[@]}"
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: export+=array disallowed (strict_array)
================================================================================

shopt -s strict_array

export e+=(e x)
echo "${e[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
append.test.sh: Type mismatching of lhs+=rhs should not cause a crash
================================================================================

case $SH in mksh|zsh) exit ;; esac
s=
a=()
declare -A d=([lemon]=yellow)

s+=(1)
s+=([melon]=green)

a+=lime
a+=([1]=banana)

d+=orange
d+=(0)

true

--------------------------------------------------------------------------------

(program)

================================================================================
arg-parse.test.sh: true extra
================================================================================

true extra

--------------------------------------------------------------------------------

(program)

================================================================================
arg-parse.test.sh: shift 1 extra
================================================================================

$SH -c '
set -- a b c
shift 1 extra
'
if test $? -eq 0; then
  echo fail
fi

--------------------------------------------------------------------------------

(program)

================================================================================
arg-parse.test.sh: continue 1 extra, break, etc.
================================================================================

$SH -c '
for i in foo; do
  continue 1 extra
done
echo status=$?
'
if test $? -eq 0; then
  echo fail
fi

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait with nothing to wait for
================================================================================

wait

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait -n with arguments - arguments are respected
================================================================================

case $SH in dash|mksh) exit ;; esac

echo x &

# here, you can't tell if it's -n or the other
wait -n $!
echo status=$?

# by the bash error, you can tell which is preferred
wait -n $! bad 2>err.txt
echo status=$?
echo

n=$(wc -l < err.txt)
if test "$n" -gt 0; then
  echo 'got error lines'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait -n with nothing to wait for
================================================================================

# The 127 is STILL overloaded.  Copying bash for now.
wait -n

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait with jobspec syntax %nonexistent
================================================================================

wait %nonexistent

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait with invalid PID
================================================================================

wait 12345678

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait with invalid arg
================================================================================

wait zzz

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait for N parallel jobs
================================================================================


for i in 3 2 1; do
  { sleep 0.0$i; exit $i; } &
done
wait

# status is lost
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait for N parallel jobs and check failure
================================================================================


set -o errexit

pids=''
for i in 3 2 1; do
  { sleep 0.0$i; echo $i; exit $i; } &
  pids="$pids $!"
done

for pid in $pids; do
  set +o errexit
  wait $pid
  status=$?
  set -o errexit

  echo status=$status
done

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Builtin in background
================================================================================

echo async &
wait

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: External command in background
================================================================================

sleep 0.01 &
wait

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Start background pipeline, wait $pid
================================================================================

echo hi | { exit 99; } &
echo status=$?
wait $!
echo status=$?
echo --

pids=''
for i in 3 2 1; do
  sleep 0.0$i | echo i=$i | ( exit $i ) &
  pids="$pids $!"
done
#echo "PIDS $pids"

for pid in $pids; do
  wait $pid
  echo status=$?
done

# Not cleaned up
if false; then
  echo 'DEBUG'
  jobs --debug
fi

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Start background pipeline, wait %job_spec
================================================================================

case $SH in mksh) exit ;; esac  # flakiness?

echo hi | { exit 99; } &
echo status=$?
wait %1
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Wait for job and PIPESTATUS
================================================================================


# foreground
{ echo hi; exit 55; } | false
echo fore status=$? pipestatus=${PIPESTATUS[@]}

# background
{ echo hi; exit 44; } | false &
echo back status=$? pipestatus=${PIPESTATUS[@]}

# wait for pipeline
wait %+
#wait %1
#wait $!
echo wait status=$? pipestatus=${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Wait for job and PIPESTATUS - cat
================================================================================


# foreground
exit 55 | ( cat; exit 99 )
echo fore status=$? pipestatus=${PIPESTATUS[@]}

# background
exit 44 | ( cat; exit 88 ) &
echo back status=$? pipestatus=${PIPESTATUS[@]}

# wait for pipeline
wait %+
#wait %1
#wait $!
echo wait status=$? pipestatus=${PIPESTATUS[@]}
echo

# wait for non-pipeline
( exit 77 ) &
wait %+
echo wait status=$? pipestatus=${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Brace group in background, wait all
================================================================================

{ sleep 0.09; exit 9; } &
{ sleep 0.07; exit 7; } &
wait  # wait for all gives 0
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Wait on background process PID
================================================================================

{ sleep 0.09; exit 9; } &
pid1=$!
{ sleep 0.07; exit 7; } &
pid2=$!
wait $pid2
echo "status=$?"
wait $pid1
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Wait on multiple specific IDs returns last status
================================================================================

{ sleep 0.08; exit 8; } &
jid1=$!
{ sleep 0.09; exit 9; } &
jid2=$!
{ sleep 0.07; exit 7; } &
jid3=$!
wait $jid1 $jid2 $jid3  # NOTE: not using %1 %2 %3 syntax on purpose
echo "status=$?"  # third job I think

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: wait -n
================================================================================

case $SH in dash|mksh) return ;; esac

{ sleep 0.09; exit 9; } &
{ sleep 0.03; exit 3; } &
wait -n
echo "status=$?"
wait -n
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Async for loop
================================================================================

for i in 1 2 3; do
  echo $i
  sleep 0.0$i
done &
wait

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Background process doesn't affect parent
================================================================================

echo ${foo=1}
echo $foo
echo ${bar=2} &
wait
echo $bar  # bar is NOT SET in the parent process

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Background process and then a singleton pipeline
================================================================================


# This was inspired by #416, although that symptom there was timing, so it's
# technically not a regression test.  It's hard to test timing.

{ sleep 0.1; exit 42; } &
echo begin
! true
echo end
wait $!
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: jobs prints one line per job
================================================================================

sleep 0.1 & 
sleep 0.1 | cat & 

# dash doesn't print if it's not a terminal?
jobs | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: jobs -p prints one line per job
================================================================================

sleep 0.1 &
sleep 0.1 | cat &

jobs -p > tmp.txt

cat tmp.txt | wc -l  # 2 lines, one for each job
cat tmp.txt | wc -w  # each line is a single "word"

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: No stderr spew when shell is not interactive
================================================================================


# in interactive shell, this prints 'Process' or 'Pipeline'
sleep 0.01 &
sleep 0.01 | cat &
wait

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: YSH wait --all
================================================================================

case $SH in dash|bash|mksh) exit ;; esac

sleep 0.01 &
(exit 55) &
true &
wait
echo wait $?

sleep 0.01 &
(exit 44) &
true &
wait --all
echo wait --all $?

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: YSH wait --verbose
================================================================================

case $SH in dash|bash|mksh) exit ;; esac

sleep 0.01 &
(exit 55) &
wait --verbose
echo wait $?

(exit 44) &
sleep 0.01 &
wait --all --verbose
echo wait --all $?

--------------------------------------------------------------------------------

(program)

================================================================================
background.test.sh: Signal message for killed background job
================================================================================

case $SH in dash|mksh) exit ;; esac

sleep 1 &
kill -HUP $!
wait $! 2>err.txt
echo status=$?
grep -o "Hangup" err.txt

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [bash_unset] local-unset / dynamic-unset for localvar
================================================================================

unlocal() { unset -v "$1"; }

f1() {
  local v=local
  unset v
  echo "[$1,local,(unset)] v: ${v-(unset)}"
}
v=global
f1 global

f1() {
  local v=local
  unlocal v
  echo "[$1,local,(unlocal)] v: ${v-(unset)}"
}
v=global
f1 'global'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [bash_unset] local-unset / dynamic-unset for localvar (mutated from tempenv)
================================================================================

unlocal() { unset -v "$1"; }

f1() {
  local v=local
  unset v
  echo "[$1,local,(unset)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

f1() {
  local v=local
  unlocal v
  echo "[$1,local,(unlocal)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [bash_unset] local-unset / dynamic-unset for tempenv
================================================================================

unlocal() { unset -v "$1"; }

f1() {
  unset v
  echo "[$1,(unset)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

f1() {
  unlocal v
  echo "[$1,(unlocal)] v: ${v-(unset)}"
}
v=global
v=tempenv f1 'global,tempenv'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [bash_unset] function call with tempenv vs tempenv-eval
================================================================================

unlocal() { unset -v "$1"; }

f5() {
  echo "[$1] v: ${v-(unset)}"
  local v
  echo "[$1,local] v: ${v-(unset)}"
  ( unset v
    echo "[$1,local+unset] v: ${v-(unset)}" )
  ( unlocal v
    echo "[$1,local+unlocal] v: ${v-(unset)}" )
}
v=global
f5 'global'
v=tempenv f5 'global,tempenv'
v=tempenv eval 'f5 "global,tempenv,(eval)"'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [bash_unset] localvar-inherit from tempenv
================================================================================

f1() {
  local v
  echo "[$1,(local)] v: ${v-(unset)}"
}
f2() {
  f1 "$1,(func)"
}
f3() {
  local v=local
  f1 "$1,local,(func)"
}
v=global

f1 'global'
v=tempenv f1 'global,tempenv'
(export v=global; f1 'xglobal')

f2 'global'
v=tempenv f2 'global,tempenv'
(export v=global; f2 'xglobal')

f3 'global'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [compat_array] ${arr} is ${arr[0]}
================================================================================

case ${SH##*/} in dash|ash) exit 1 ;; esac # dash/ash does not have arrays
case ${SH##*/} in osh) shopt -s compat_array ;; esac
case ${SH##*/} in zsh) setopt KSH_ARRAYS ;; esac
arr=(foo bar baz)
argv.py "$arr" "${arr}"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [compat_array] scalar write to arrays
================================================================================

case ${SH##*/} in
(dash|ash) exit 1;; # dash/ash does not have arrays
(osh) shopt -s compat_array;;
(zsh) setopt KSH_ARRAYS;;
esac

a=(1 0 0)
: $(( a++ ))
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [compat_array] scalar write to associative arrays
================================================================================

case ${SH##*/} in
(dash|ash|yash|mksh) exit 1;; # dash/ash/yash/mksh does not have associative arrays
(osh) shopt -s compat_array;;
(zsh) setopt KSH_ARRAYS;;
esac

declare -A d=()
d['0']=1
d['foo']=hello
d['bar']=world
((d++))
argv.py ${d['0']} ${d['foo']} ${d['bar']}

--------------------------------------------------------------------------------

(program)

================================================================================
ble-features.test.sh: [compat_array] ${alpha@a}
================================================================================

declare -A alpha=(['1']=2)
echo type=${alpha@a}
shopt -s compat_array
echo type=${alpha@a}

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: one level
================================================================================

a='b=123'
echo $((a))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: two levels
================================================================================

a='b=c' c='d=123'
echo $((a))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: short circuit &&, ||
================================================================================

# Note: mksh R52 has a bug. Even though it supports a short circuit like
#   "echo $((cond&&(a=1)))", it doesn't work with "x=a=1; echo
#   $((cond&&x))". It is fixed at least in mksh R57.
# Note: "busybox sh" doesn't support short circuit.
a=b=123
echo $((1||a)):$((b))
echo $((0||a)):$((b))
c=d=321
echo $((0&&c)):$((d))
echo $((1&&c)):$((d))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: short circuit ?:
================================================================================

# Note: "busybox sh" behaves strangely.
y=a=123 n=a=321
echo $((1?(y):(n))):$((a))
echo $((0?(y):(n))):$((a))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: side effects
================================================================================

# In Zsh and Busybox sh, the side effect of inner arithmetic
# evaluations seems to take effect only after the whole evaluation.
a='b=c' c='d=123'
echo $((a,d)):$((d))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: recursion
================================================================================

loop='i<=100&&(s+=i,i++,loop)' s=0 i=0
echo $((a=loop,s))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: recursive arith: array elements
================================================================================

text[1]='d=123'
text[2]='text[1]'
text[3]='text[2]'
echo $((a=text[3]))

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: dynamic arith varname: assign
================================================================================

vec2_set () {
  local this=$1 x=$2 y=$3
  : $(( ${this}_x = $2 ))
  : $(( ${this}_y = y ))
}
vec2_set a 3 4
vec2_set b 5 12
echo a_x=$a_x a_y=$a_y
echo b_x=$b_x b_y=$b_y

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: dynamic arith varname: read
================================================================================


vec2_load() {
  local this=$1
  x=$(( ${this}_x ))
  : $(( y = ${this}_y ))
}
a_x=12 a_y=34
vec2_load a
echo x=$x y=$y

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: dynamic arith varname: copy/add
================================================================================

shopt -s eval_unsafe_arith  # for RHS

vec2_copy () {
  local this=$1 rhs=$2
  : $(( ${this}_x = $(( ${rhs}_x )) ))
  : $(( ${this}_y = ${rhs}_y ))
}
vec2_add () {
  local this=$1 rhs=$2
  : $(( ${this}_x += $(( ${rhs}_x )) ))
  : $(( ${this}_y += ${rhs}_y ))
}
a_x=3 a_y=4
b_x=4 b_y=20
vec2_copy c a
echo c_x=$c_x c_y=$c_y
vec2_add c b
echo c_x=$c_x c_y=$c_y

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: is-array with ${var@a}
================================================================================

case $SH in mksh|ash|dash|yash) exit 1 ;; esac

function ble/is-array { [[ ${!1@a} == *a* ]]; }

ble/is-array undef
echo undef $?

string=''
ble/is-array string
echo string $?

array=(one two three)
ble/is-array array
echo array $?

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Sparse array with big index
================================================================================


# TODO: more InternalStringArray idioms / stress tests ?

a=()

if false; then
  # This takes too long!  # From Zulip
  i=$(( 0x0100000000000000 ))
else
  # smaller number that's OK
  i=$(( 0x0100000 ))
fi

a[i]=1

echo len=${#a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: shift unshift reverse
================================================================================


case $SH in mksh|ash) exit ;; esac

# https://github.com/akinomyoga/ble.sh/blob/79beebd928cf9f6506a687d395fd450d027dc4cd/src/util.sh#L578-L582

# @fn ble/array#unshift arr value...
function ble/array#unshift {
  builtin eval -- "$1=(\"\${@:2}\" \"\${$1[@]}\")"
}
# @fn ble/array#shift arr count
function ble/array#shift {
  # Note: Bash 4.3  ${arr[@]:${2:-1}}  offset='${2'
  # length='-1' 
  builtin eval -- "$1=(\"\${$1[@]:$((${2:-1}))}\")"
}
# @fn ble/array#reverse arr
function ble/array#reverse {
  builtin eval "
  set -- \"\${$1[@]}\"; $1=()
  local e$1 i$1=\$#
  for e$1; do $1[--i$1]=\"\$e$1\"; done"
}

a=( {1..6} )
echo "${a[@]}"

ble/array#shift a 1
echo "${a[@]}"

ble/array#shift a 2
echo "${a[@]}"

echo ---

ble/array#unshift a 99
echo "${a[@]}"

echo ---

# doesn't work in zsh!
ble/array#reverse a
echo "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: shopt -u expand_aliases and eval
================================================================================

case $SH in zsh|mksh|ash|dash|yash) exit ;; esac

alias echo=false

function f {
  shopt -u expand_aliases
  eval -- "$1"
  shopt -s expand_aliases
}

f 'echo hello'

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [40] BUG: a=(declare v); "${a[@]}" fails
================================================================================

case $SH in ash|dash)  exit 99 ;; esac
a=(typeset v=1)
v=x
"${a[@]}"
echo "v=$v"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [40] BUG: a=declare; "$a" v=1 fails
================================================================================

case $SH in ash|dash)  exit 99 ;; esac
a=typeset
v=x
"$a" v=1
echo "v=$v"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [49] BUG: \return 0 does not work
================================================================================

f0() { return 3;          echo unexpected; return 0; }
f1() { \return 3;         echo unexpected; return 0; }
f0; echo "status=$?"
f1; echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [49] BUG: \return 0 does not work (other variations)
================================================================================

f2() { builtin return 3;  echo unexpected; return 0; }
f3() { \builtin return 3; echo unexpected; return 0; }
f4() { command return 3;  echo unexpected; return 0; }
f2; echo "status=$?"
f3; echo "status=$?"
f4; echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [52] BUG: \builtin local v=1 fails
================================================================================

case $SH in ash|dash|yash) exit 99 ;; esac
v=x
case $SH in
mksh) f1() { \builtin typeset v=1; echo "l:v=$v"; } ;;
*)    f1() { \builtin local   v=1; echo "l:v=$v"; } ;;
esac
f1
echo "g:v=$v"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [53] BUG: a[1 + 1]=2, etc. fails
================================================================================

case $SH in ash|dash|yash) exit 99 ;; esac
a=()

a[1]=x
eval 'a[5&3]=hello'
echo "status=$?, a[1]=${a[1]}"

a[2]=x
eval 'a[1 + 1]=hello'
echo "status=$?, a[2]=${a[2]}"

a[3]=x
eval 'a[1|2]=hello'
echo "status=$?, a[3]=${a[3]}"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [53] - LHS array parsing a[1 + 2]=3 (see spec/array-assign for more)
================================================================================

case $SH in zsh|ash) exit ;; esac

a[1 + 2]=7
a[3|4]=8
a[(1+2)*3]=9

typeset -p a

# Dynamic parsing
expr='1 + 2'
a[expr]=55

b=(42)
expr='b[0]'
a[3 + $expr - 4]=66

typeset -p a

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [56] BUG: declare -p unset does not print any error message
================================================================================

typeset -p nonexistent

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [57] BUG: variable v is invisible after IFS= eval 'local v=...'
================================================================================

v=x
case $SH in
mksh) f() { IFS= eval 'typeset v=1'; echo "l:$v"; } ;;
*)    f() { IFS= eval 'local   v=1'; echo "l:$v"; } ;;
esac
f
echo "g:$v"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [57] - Variable v should be visible after IFS= eval 'local v=...'
================================================================================


set -u

f() {
  # The temp env messes it up
  IFS= eval "local v=\"\$*\""

  # Bug does not appear with only eval
  # eval "local v=\"\$*\""

  #declare -p v
  echo v=$v

  # test -v v; echo "v defined $?"
}

f h e l l o

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [59] N-I: arr=s should set RHS to arr[0]
================================================================================

case $SH in ash|dash) exit 99 ;; esac
a=(1 2 3)
a=v
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
ble-idioms.test.sh: Issue #1069 [59] - Assigning Str to BashArray/BashAssoc should not remove BashArray/BashAssoc
================================================================================

case $SH in zsh|ash) exit ;; esac

a=(1 2 3)
a=99
typeset -p a

typeset -A A=([k]=v)
A=99
typeset -p A

--------------------------------------------------------------------------------

(program)

================================================================================
ble-unset.test.sh: [bash_unset] nested context by tempenv-eval
================================================================================

f1() {
  local v=local1
  echo "[$1,local1] v: ${v-(unset)}"
  v=tempenv2 eval '
    echo "[$1,local1,tempenv2,(eval)] v: ${v-(unset)}"
    local v=local2
    echo "[$1,local1,tempenv2,(eval),local2] v: ${v-(unset)}"
  '
  echo "[$1,local1] v: ${v-(unset)} (after)"
}
v=global
v=tempenv1 f1 global,tempenv1

--------------------------------------------------------------------------------

(program)

================================================================================
ble-unset.test.sh: [bash_unset] local-unset / dynamic-unset for localvar on nested-context
================================================================================

unlocal() { unset -v "$1"; }

f2() {
  local v=local1
  v=tempenv2 eval '
    local v=local2
    (unset v  ; echo "[$1,local1,tempenv2,(eval),local2,(unset)] v: ${v-(unset)}")
    (unlocal v; echo "[$1,local1,tempenv2,(eval),local2,(unlocal)] v: ${v-(unset)}")
  '
}
v=global
v=tempenv1 f2 global,tempenv1

--------------------------------------------------------------------------------

(program)

================================================================================
ble-unset.test.sh: [bash_unset] dynamic-unset for nested localvars
================================================================================

unlocal() { unset -v "$1"; }

f3() {
  local v=local1
  v=tempenv2 eval '
    local v=local2
    v=tempenv3 eval "
      local v=local3
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)}\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 1)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 2)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 3)\"
      unlocal v
      echo \"[\$1/local1,tempenv2/local2,tempenv3/local3] v: \${v-(unset)} (unlocal 4)\"
    "
  '
}
v=global
v=tempenv1 f3 global,tempenv1

--------------------------------------------------------------------------------

(program)

================================================================================
ble-unset.test.sh: [bash_unset] dynamic-unset for nested tempenvs
================================================================================

unlocal() { unset -v "$1"; }

f4_unlocal() {
  v=tempenv2 eval '
    v=tempenv3 eval "
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)}\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 1)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 2)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 3)\"
      unlocal v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unlocal 4)\"
    "
  '
}
v=global
v=tempenv1 f4_unlocal global,tempenv1

--------------------------------------------------------------------------------

(program)

================================================================================
ble-unset.test.sh: [bash_unset] local-unset for nested tempenvs
================================================================================

f4_unset() {
  v=tempenv2 eval '
    v=tempenv3 eval "
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)}\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 1)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 2)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 3)\"
      unset v
      echo \"[\$1,tempenv2,tempenv3] v: \${v-(unset)} (unset 4)\"
    "
  '
}
v=global
v=tempenv1 f4_unset global,tempenv1

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: Blog Post Example
================================================================================

paths=`tr '\n' ':' | sed -e 's/:$//'`<<EOPATHS
/foo
/bar
/baz
EOPATHS
echo "$paths"

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: Blog Post Example Fix
================================================================================

paths=`tr '\n' ':' | sed -e 's/:$//'<<EOPATHS
/foo
/bar
/baz
EOPATHS`
echo "$paths"

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: Rewrite of Blog Post Example
================================================================================

paths=$(tr '\n' ':' | sed -e 's/:$//' <<EOPATHS
/foo
/bar
/baz
EOPATHS
)
echo "$paths"

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: Simpler example
================================================================================

foo=`cat`<<EOM
hello world
EOM
echo "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: ` after here doc delimiter
================================================================================

foo=`cat <<EOM
hello world
EOM`
echo "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
blog-other1.test.sh: ` on its own line
================================================================================

foo=`cat <<EOM
hello world
EOM
`
echo "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${##}
================================================================================

set -- $(seq 25)
echo ${##}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${###}
================================================================================

set -- $(seq 25)
echo ${###}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${####}
================================================================================

set -- $(seq 25)
echo ${####}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${##2}
================================================================================

set -- $(seq 25)
echo ${##2}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${###2}
================================================================================

set -- $(seq 25)
echo ${###2}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${1####}
================================================================================

set -- '####'
echo ${1####}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${1#'###'}
================================================================================

set -- '####'
echo ${1#'###'}

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: ${#1#'###'}
================================================================================

set -- '####'
echo ${#1#'###'}
# dash and zsh accept; mksh/bash/osh don't.

--------------------------------------------------------------------------------

(program)

================================================================================
blog1.test.sh: Julia example from spec/oil-user-feedback
================================================================================


case $SH in dash|mksh|zsh) exit ;; esac

git-branch-merged() {
  cat <<EOF
  foo
* bar
  baz
  master
EOF
}

shopt -s lastpipe  # required for bash, not OSH

branches=()  # dangerous when set -e is on
git-branch-merged | while read -r line; do
  line=${line# *}  # strip leading spaces
  if [[ $line != 'master' && ! ${line:0:1} == '*' ]]; then
    branches+=("$line")
  fi
done

if [[ ${#branches[@]} -eq 0 ]]; then
  echo "No merged branches"
else
  echo git branch -D "${branches[@]}"
fi

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a
================================================================================

[ -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a
================================================================================

[ -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a
================================================================================

[ -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a -a
================================================================================

[ -a -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a -a -a
================================================================================

[ -a -a -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a -a -a -a
================================================================================

[ -a -a -a -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a -a -a -a -a
================================================================================

[ -a -a -a -a -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
blog2.test.sh: -a -a -a -a -a -a -a -a
================================================================================

[ -a -a -a -a -a -a -a -a ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: test builtin - Unexpected trailing word '--' (#2409)
================================================================================


# Minimal repro of sqsh build error
set -- -o; test $# -ne 0 -a "$1" != "--"
echo status=$?

# Now hardcode $1
test $# -ne 0 -a "-o" != "--"
echo status=$?

# Remove quotes around -o
test $# -ne 0 -a -o != "--"
echo status=$?

# How about a different flag?
set -- -z; test $# -ne 0 -a "$1" != "--"
echo status=$?

# A non-flag?
set -- z; test $# -ne 0 -a "$1" != "--"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: test builtin: ( = ) is confusing: equality test or non-empty string test
================================================================================


# here it's equality
test '(' = ')'
echo status=$?

# here it's like -n =
test 0 -eq 0 -a '(' = ')'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: test builtin: ( == ) is confusing: equality test or non-empty string test
================================================================================


# here it's equality
test '(' == ')'
echo status=$?

# here it's like -n ==
test 0 -eq 0 -a '(' == ')'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: Allowed: [[ = ]] and [[ == ]]
================================================================================


[[ = ]]
echo status=$?
[[ == ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: test builtin: ( x ) behavior is the same in both cases
================================================================================


test '(' x ')'
echo status=$?

test 0 -eq 0 -a '(' x ')'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: [ -f = ] and [ -f == ]
================================================================================


[ -f = ]
echo status=$?
[ -f == ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bool-parse.test.sh: [[ -f -f ]] and [[ -f == ]]
================================================================================

[[ -f -f ]]
echo status=$?

[[ -f == ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: echo keyword
================================================================================

echo done

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: if/else
================================================================================

if false; then
  echo THEN
else
  echo ELSE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: Turn an array into an integer.
================================================================================

a=(1 2 3)
(( a = 42 )) 
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: assign readonly -- one line
================================================================================

readonly x=1; x=2; echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: assign readonly -- multiple lines
================================================================================

readonly x=1
x=2
echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: assign readonly -- multiple lines -- set -o posix
================================================================================

set -o posix
readonly x=1
x=2
echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: unset readonly -- one line
================================================================================

readonly x=1; unset x; echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: unset readonly -- multiple lines
================================================================================

readonly x=1
unset x
echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: file with NUL byte
================================================================================

echo -e 'echo one \0 echo two' > tmp.sh
$SH tmp.sh

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: fastlex: PS1 format string that's incomplete / with NUL byte
================================================================================

case $SH in bash) exit ;; esac

x=$'\\D{%H:%M'  # leave off trailing }
echo x=${x@P}

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: 'echo' and printf fail on writing to full disk
================================================================================


# Inspired by https://blog.sunfishcode.online/bugs-in-hello-world/

echo hi > /dev/full
echo status=$?

printf '%s\n' hi > /dev/full
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: other builtins fail on writing to full disk
================================================================================


type echo > /dev/full
echo status=$?

# other random builtin
ulimit -a > /dev/full
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: subshell while running a script (regression)
================================================================================

# Ensures that spawning a subshell doesn't cause a seek on the file input stream
# representing the current script (issue #1233).
cat >tmp.sh <<'EOF'
echo start
(:)
echo end
EOF
$SH tmp.sh

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: for loop (issue #1446)
================================================================================

case $SH in dash|mksh|ash) exit ;; esac

for (( n=0; n<(3-(1)); n++ )) ; do echo $n; done

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: for loop 2 (issue #1446)
================================================================================

case $SH in dash|mksh|ash) exit ;; esac


for (( n=0; n<(3- (1)); n++ )) ; do echo $n; done

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: autoconf word split (#1449)
================================================================================


mysed() {
  for line in "$@"; do
    echo "[$line]"
  done
}

sedinputs="f1 f2"
sedscript='my sed command'

# Parsed and evaluated correctly: with word_part.EscapedLiteral \"

x=$(eval "mysed -n \"\$sedscript\" $sedinputs")
echo '--- $()'
echo "$x"

# With backticks, the \" gets lost somehow

x=`eval "mysed -n \"\$sedscript\" $sedinputs"`
echo '--- backticks'
echo "$x"


# Test it in a case statement

case `eval "mysed -n \"\$sedscript\" $sedinputs"` in 
  (*'[my sed command]'*)
    echo 'NOT SPLIT'
    ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: autoconf arithmetic - relaxed eval_unsafe_arith (#1450)
================================================================================


as_fn_arith ()
{
    as_val=$(( $* ))
}
as_fn_arith 1 + 1
echo $as_val

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: command execution $(echo 42 | tee PWNED) not allowed
================================================================================


rm -f PWNED

x='a[$(echo 42 | tee PWNED)]=1'
echo $(( x ))

if test -f PWNED; then
  cat PWNED
else
  echo NOPE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: process sub <(echo 42 | tee PWNED) not allowed
================================================================================


rm -f PWNED

x='a[<(echo 42 | tee PWNED)]=1'
echo $(( x ))

if test -f PWNED; then
  cat PWNED
else
  echo NOPE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: unset doesn't allow command execution
================================================================================


typeset -a a  # for mksh
a=(42)
echo len=${#a[@]}

unset -v 'a[$(echo 0 | tee PWNED)]'
echo len=${#a[@]}

if test -f PWNED; then
  echo PWNED
  cat PWNED
else
  echo NOPE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: printf integer size bug
================================================================================


# from Koiche on Zulip

printf '%x\n' 2147483648
printf '%u\n' 2147483648

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: (( status bug
================================================================================

case $SH in dash|ash) exit ;; esac

# from Koiche on Zulip

(( 1 << 32 ))
echo status=$?

(( 1 << 32 )) && echo yes

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: autotools as_fn_arith bug in configure
================================================================================


# Causes 'grep -e' check to infinite loop.
# Reduced from a configure script.

as_fn_arith() {
  as_val=$(( $* ))
}

as_fn_arith 0 + 1
echo as_val=$as_val

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: OSH can use ARGV name
================================================================================

case $SH in dash|ash) exit ;; esac

foo() {
  if test -v ARGV; then
    echo 'BUG local'
  fi
  ARGV=( a b )
  echo len=${#ARGV[@]}
}

if test -v ARGV; then
  echo 'BUG global'
fi
foo

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: Crash in {1..10} - issue #2296
================================================================================


{1..10}

--------------------------------------------------------------------------------

(program)

================================================================================
bugs.test.sh: Crash after changing $[] to be alias of $(( ))
================================================================================

echo $[i + 1]
case foo in
  foo) echo hello ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub-ksh.test.sh: ${ echo hi;}
================================================================================


x=${ echo hi;}
echo "[$x]"
echo

# trailing space allowed
x=${ echo one; echo two; }
echo "[$x]"
echo

myfunc() {
  echo ' 3 '
  echo ' 4 5 '
}

x=${ myfunc;}
echo "[$x]"
echo

# SYNTAX ERROR
x=${myfunc;}
echo "[$x]"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub-ksh.test.sh: for loop / case
================================================================================


x=${ for i in a b; do echo -$i-; done; }
echo "$x"

y=${|for i in a b; do REPLY+="-$i-"; done; }
echo "$y"

echo

x2=${ case foo in foo) echo sh-case ;; esac; }
echo "$x2"

y2=${|case foo in foo) REPLY=sh-case ;; esac; }
echo "$y2"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: case
================================================================================

foo=a; case $foo in [0-9]) echo number;; [a-z]) echo letter ;; esac

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: case in subshell
================================================================================

# Hm this subhell has to know about the closing ) and stuff like that.
# case_clause is a compound_command, which is a command.  And a subshell
# takes a compound_list, which is a list of terms, which has and_ors in them
# ... which eventually boils down to a command.
echo $(foo=a; case $foo in [0-9]) echo number;; [a-z]) echo letter ;; esac)

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command sub word part
================================================================================

# "The token shall not be delimited by the end of the substitution."
foo=FOO; echo $(echo $foo)bar$(echo $foo)

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Backtick
================================================================================

foo=FOO; echo `echo $foo`bar`echo $foo`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Backtick 2
================================================================================

echo `echo -n l; echo -n s`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Nested backticks
================================================================================

# Inner `` are escaped!  Not sure how to do triple..  Seems like an unlikely
# use case.  Not sure if I even want to support this!
echo X > $TMP/000000-first
echo `\`echo -n l; echo -n s\` $TMP | grep 000000-first`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Making command out of command sub should work
================================================================================

# Works in bash and dash!
$(echo ec)$(echo ho) split builtin

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command sub with here doc
================================================================================

echo $(<<EOF tac
one
two
EOF
)

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Here doc with pipeline
================================================================================

<<EOF tac | tr '\n' 'X'
one
two
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command Sub word split
================================================================================

argv.py $(echo 'hi there') "$(echo 'hi there')"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command Sub trailing newline removed
================================================================================

s=$(python2 -c 'print("ab\ncd\n")')
argv.py "$s"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command Sub trailing whitespace not removed
================================================================================

s=$(python2 -c 'print("ab\ncd\n ")')
argv.py "$s"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command Sub and exit code
================================================================================

# A command resets the exit code, but an assignment doesn't.
echo $(echo x; exit 33)
echo $?
x=$(echo x; exit 33)
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Command Sub in local sets exit code
================================================================================

# A command resets the exit code, but an assignment doesn't.
f() {
  echo $(echo x; exit 33)
  echo $?
  local x=$(echo x; exit 33)
  echo $?
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Double Quotes in Command Sub in Double Quotes
================================================================================

# virtualenv's bin/activate uses this.
# This is weird!  Double quotes within `` is different than double quotes
# within $()!  All shells agree.
# I think this is related to the nested backticks case!
echo "x $(echo hi)"
echo "x $(echo "hi")"
echo "x $(echo \"hi\")"
echo "x `echo hi`"
echo "x `echo "hi"`"
echo "x `echo \"hi\"`"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Escaped quote in [[ ]]
================================================================================

file=$TMP/command-sub-dbracket
#rm -f $file
echo "123 `[[ $(echo \\" > $file) ]]` 456";
cat $file

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting " within ``
================================================================================

echo 1 `echo \"`
#echo 2 `echo \\"`
#echo 3 `echo \\\"`
#echo 4 `echo \\\\"`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting $ within ``
================================================================================

echo 1 `echo $`
echo 2 `echo \$`
echo 3 `echo \\$`
echo 4 `echo \\\$`
echo 5 `echo \\\\$`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting $ within `` within double quotes
================================================================================

echo "1 `echo $`"
echo "2 `echo \$`"
echo "3 `echo \\$`"
echo "4 `echo \\\$`"
echo "5 `echo \\\\$`"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting \ within ``
================================================================================

# You need FOUR backslashes to make a literal \.
echo [1 `echo \ `]
echo [2 `echo \\ `]
echo [3 `echo \\\\ `]

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting \ within `` within double quotes
================================================================================

echo "[1 `echo \ `]"
echo "[2 `echo \\ `]"
echo "[3 `echo \\\\ `]"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting ( within ``
================================================================================

echo 1 `echo \(`
echo 2 `echo \\(`
echo 3 `echo \\ \\(`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting ( within `` within double quotes
================================================================================

echo "1 `echo \(`"
echo "2 `echo \\(`"
echo "3 `echo \\ \\(`"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting non-special characters within ``
================================================================================

echo [1 `echo \z]`
echo [2 `echo \\z]`
echo [3 `echo \\\z]`
echo [4 `echo \\\\z]`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting non-special characters within `` within double quotes
================================================================================

echo "[1 `echo \z`]"
echo "[2 `echo \\z`]"
echo "[3 `echo \\\z`]"
echo "[4 `echo \\\\z`]"

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Quoting double quotes within backticks
================================================================================

echo \"foo\"   # for comparison
echo `echo \"foo\"`
echo `echo \\"foo\\"`

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: More levels of double quotes in backticks
================================================================================


# Shells don't agree here, some of them give you form feeds!
# There are two levels of processing I don't understand.

#echo BUG
#exit

echo `echo \\\"foo\\\"` -
echo `echo \\\\"foo\\\\"` -
echo `echo \\\\\"foo\\\\\"` -

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Syntax errors with double quotes within backticks
================================================================================


# bash does print syntax errors but somehow it exits 0

$SH -c 'echo `echo "`'
echo status=$?
$SH -c 'echo `echo \\\\"`'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command-sub.test.sh: Empty command sub $() (command::NoOp)
================================================================================


# IMPORTANT: catch assert() failure in child process!!!
shopt -s command_sub_errexit

echo -$()- ".$()."

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Command block
================================================================================

PATH=/bin

{ which ls; }

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Permission denied
================================================================================

touch $TMP/text-file
$TMP/text-file

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Not a dir
================================================================================

$TMP/not-a-dir/text-file

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Name too long
================================================================================

./0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: External programs don't have _OVM in environment
================================================================================

# bug fix for leakage
env | grep _OVM
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: File with no shebang is executed
================================================================================

# most shells execute /bin/sh; bash may execute itself
echo 'echo hi' > $TMP/no-shebang
chmod +x $TMP/no-shebang
$SH -c '$TMP/no-shebang'

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: File with relative path and no shebang is executed
================================================================================

cd $TMP
echo 'echo hi' > no-shebang
chmod +x no-shebang
"$SH" -c './no-shebang'

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: File in relative subdirectory and no shebang is executed
================================================================================

cd $TMP
mkdir -p test-no-shebang
echo 'echo hi' > test-no-shebang/script
chmod +x test-no-shebang/script
"$SH" -c 'test-no-shebang/script'

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: $PATH lookup
================================================================================

cd $TMP
mkdir -p one two
echo 'echo one' > one/mycmd
echo 'echo two' > two/mycmd
chmod +x one/mycmd two/mycmd

PATH='one:two'
mycmd

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: filling $PATH cache, then insert the same command earlier in cache
================================================================================

cd $TMP
PATH="one:two:$PATH"
mkdir -p one two
rm -f one/* two/*
echo 'echo two' > two/mycmd
chmod +x two/mycmd
mycmd

# Insert earlier in the path
echo 'echo one' > one/mycmd
chmod +x one/mycmd
mycmd  # still runs the cached 'two'

# clear the cache
hash -r
mycmd  # now it runs the new 'one'

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: filling $PATH cache, then deleting command
================================================================================

cd $TMP
PATH="one:two:$PATH"
mkdir -p one two
rm -f one/mycmd two/mycmd

echo 'echo two' > two/mycmd
chmod +x two/mycmd
mycmd
echo status=$?

# Insert earlier in the path
echo 'echo one' > one/mycmd
chmod +x one/mycmd
rm two/mycmd
mycmd  # still runs the cached 'two'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Non-executable on $PATH
================================================================================


# shells differ in whether they actually execve('one/cmd') and get EPERM

mkdir -p one two
PATH="one:two:$PATH"

rm -f one/mycmd two/mycmd
echo 'echo one' > one/mycmd
echo 'echo two' > two/mycmd

# only make the second one executable
chmod +x two/mycmd
mycmd
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: hash without args prints the cache
================================================================================

whoami >/dev/null
hash
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: hash with args
================================================================================

hash whoami
echo status=$?
hash | grep -o /whoami  # prints it twice
hash _nonexistent_
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: hash -r doesn't allow additional args
================================================================================

hash -r whoami >/dev/null  # avoid weird output with mksh
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
command_.test.sh: Executing command with same name as directory in PATH (#2429)
================================================================================


# Make the following directory structure. File type and permission bits are
# given on the left.
# [drwxr-xr-x]  _tmp
# +-- [drwxr-xr-x]  bin
# | \-- [-rwxr-xr-x]  hello
# +-- [drwxr-xr-x]  notbin
# | \-- [-rw-r--r--]  hello
# \-- [drwxr-xr-x]  dir
#     \-- [drwxr-xr-x]  hello
mkdir -p _tmp/bin
mkdir -p _tmp/bin2
mkdir -p _tmp/notbin
mkdir -p _tmp/dir/hello
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/notbin/hello
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/bin/hello
chmod +x _tmp/bin/hello

DIR=$PWD/_tmp/dir
BIN=$PWD/_tmp/bin
NOTBIN=$PWD/_tmp/notbin

# The command resolution will search the path for matching *files* (not
# directories) WITH the execute bit set.

# Should find executable hello right away and run it
PATH="$BIN:$PATH" hello
echo status=$?

hash -r  # Needed to clear the PATH cache

# Will see hello dir, skip it and then find&run the hello exe
PATH="$DIR:$BIN:$PATH" hello
echo status=$?

hash -r  # Needed to clear the PATH cache

# Will see hello (non-executable) file, skip it and then find&run the hello exe
PATH="$NOTBIN:$BIN:$PATH" hello
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
comments.test.sh: comment
================================================================================

echo foo #comment

--------------------------------------------------------------------------------

(program)

================================================================================
comments.test.sh: not a comment without leading space x
================================================================================

echo foo#not_comment

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ glob matching, [[ has no glob expansion
================================================================================

[[ foo.py == *.py ]] && echo true
[[ foo.p  == *.py ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ glob matching with escapes
================================================================================

[[ 'foo.*' == *."*" ]] && echo true
# note that the pattern arg to fnmatch should be '*.\*'

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: equality
================================================================================

[[ '*.py' == '*.py' ]] && echo true
[[ foo.py == '*.py' ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ glob matching with unquoted var
================================================================================

pat=*.py
[[ foo.py == $pat ]] && echo true
[[ foo.p  == $pat ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ regex matching
================================================================================

# mksh doesn't have this syntax of regex matching.  I guess it comes from perl?
regex='.*\.py'
[[ foo.py =~ $regex ]] && echo true
[[ foo.p  =~ $regex ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ regex syntax error
================================================================================

# hm, it doesn't show any error, but it exits 2.
[[ foo.py =~ * ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ has no word splitting
================================================================================

var='one two'
[[ 'one two' == $var ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ has quote joining
================================================================================

var='one two'
[[ 'one 'tw"o" == $var ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ empty string is false
================================================================================

[[ 'a' ]] && echo true
[[ ''  ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: && chain
================================================================================

[[ t && t && '' ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: || chain
================================================================================

[[ '' || '' || t ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ compound expressions
================================================================================

# Notes on whitespace:
# - 1 and == need space seprating them, but ! and ( don't.
# - [[ needs whitesapce after it, but ]] doesn't need whitespace before it!
[[ ''||! (1 == 2)&&(2 == 2)]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: precedence of && and || inside [[
================================================================================

[[ True || '' && '' ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: precedence of && and || in a command context
================================================================================

if test True || test '' && test ''; then
  echo YES
else
  echo "NO precedence"
fi

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: Octal literals with -eq
================================================================================

shopt -u strict_arith || true
decimal=15
octal=017   # = 15 (decimal)
[[ $decimal -eq $octal ]] && echo true
[[ $decimal -eq ZZZ$octal ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: Hex literals with -eq
================================================================================

shopt -u strict_arith || true
decimal=15
hex=0x0f    # = 15 (decimal)
[[ $decimal -eq $hex ]] && echo true
[[ $decimal -eq ZZZ$hex ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: > on strings
================================================================================

# NOTE: < doesn't need space, even though == does?  That's silly.
[[ b>a ]] && echo true
[[ b<a ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: != on strings
================================================================================

# NOTE: b!=a does NOT work
[[ b != a ]] && echo true
[[ a != a ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: -eq on strings
================================================================================

# This is lame behavior: it does a conversion to 0 first for any string
shopt -u strict_arith || true
[[ a -eq a ]] && echo true
[[ a -eq b ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ compare with literal -f (compare with test-builtin.test.sh)
================================================================================

var=-f
[[ $var == -f ]] && echo true
[[ '-f' == $var ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ with unquoted empty var (compare with test-builtin.test.sh)
================================================================================

empty=''
[[ $empty == '' ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ at runtime doesn't work
================================================================================

dbracket=[[
$dbracket foo == foo ]]

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ with env prefix doesn't work
================================================================================

FOO=bar [[ foo == foo ]]

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ over multiple lines is OK
================================================================================

# Hm it seems you can't split anywhere?
[[ foo == foo
&& bar == bar
]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: User array compared to "$@" (broken unless shopt -s strict_array)
================================================================================

# Both are coerced to string!  It treats it more like an  UNQUOTED ${a[@]}.

a=('1 3' 5)
b=(1 2 3)
set -- 1 '3 5'
[[ "$@" = "${a[@]}" ]] && echo true
[[ "$@" = "${b[@]}" ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: Array coerces to string (shopt -s strict_array to disallow)
================================================================================

a=('1 3' 5)
[[ '1 3 5' = "${a[@]}" ]] && echo true
[[ '1 3 4' = "${a[@]}" ]] || echo false

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: (( array1 == array2 )) doesn't work
================================================================================

a=('1 3' 5)
b=('1 3' 5)
c=('1' '3 5')
d=('1' '3 6')

# shells EXPAND a and b first
(( a == b ))
echo status=$?

(( a == c ))
echo status=$?

(( a == d ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: Quotes don't matter in comparison
================================================================================

[[ '3' = 3 ]] && echo true
[[ '3' -eq 3 ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: -eq does dynamic arithmetic parsing (not supported in OSH)
================================================================================

[[ 1+2 -eq 3 ]] && echo true
expr='1+2'
[[ $expr -eq 3 ]] && echo true  # must be dynamically parsed

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: -eq coercion produces weird results
================================================================================

shopt -u strict_arith || true
[[ '' -eq 0 ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ '(' ]] is treated as literal
================================================================================

[[ '(' ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: empty ! is treated as literal
================================================================================

[[ '!' ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ -z '>' ]]
================================================================================

[[ -z '>' ]] || echo false  # -z is operator

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: test whether ']]' is empty
================================================================================

[[ ']]' ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: tilde expansion in [[
================================================================================

HOME=/home/bob
[[ ~ == /home/bob ]]
echo status=$?

[[ ~ == */bob ]]
echo status=$?

[[ ~ == */z ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: more tilde expansion
================================================================================

[[ ~ ]]
echo status=$?
HOME=''
[[ ~ ]]
echo status=$?
[[ -n ~ ]]
echo unary=$?

[[ ~ == ~ ]]
echo status=$?

[[ $HOME == ~ ]]
echo fnmatch=$?
[[ ~ == $HOME ]]
echo fnmatch=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: tilde expansion with =~ (confusing)
================================================================================

case $SH in mksh) exit ;; esac

HOME=foo
[[ ~ =~ $HOME ]]
echo regex=$?
[[ $HOME =~ ~ ]]
echo regex=$?

HOME='^a$'  # looks like regex
[[ ~ =~ $HOME ]]
echo regex=$?
[[ $HOME =~ ~ ]]
echo regex=$?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: [[ ]] with redirect
================================================================================

[[ $(stdout_stderr.py) == STDOUT ]] 2>$TMP/x.txt
echo $?
echo --
cat $TMP/x.txt

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: special chars
================================================================================

[[ ^ == ^ ]]
echo caret $?
[[ '!' == ! ]]
echo bang $?

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: \(\) in pattern (regression)
================================================================================

if [[ 'foo()' == *\(\) ]]; then echo match1; fi
if [[ 'foo()' == *'()' ]]; then echo match2; fi
if [[ 'foo()' == '*()' ]]; then echo match3; fi

shopt -s extglob

if [[ 'foo()' == *\(\) ]]; then echo match1; fi
if [[ 'foo()' == *'()' ]]; then echo match2; fi
if [[ 'foo()' == '*()' ]]; then echo match3; fi

--------------------------------------------------------------------------------

(program)

================================================================================
dbracket.test.sh: negative numbers - zero, decimal, octal, hex, base N
================================================================================


[[ -0 -eq 0 ]]; echo zero=$?

[[ -42 -eq -42 ]]; echo decimal=$?

# note: mksh doesn't do octal conversion
[[ -0123 -eq -83 ]]; echo octal=$?

[[ -0xff -eq -255 ]]; echo hex=$?

[[ -64#a -eq -10 ]]; echo baseN=$?

--------------------------------------------------------------------------------

(program)

================================================================================
divergence.test.sh: xz package: dirprefix="${line##*([}"
================================================================================


# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/alpine.20xz.20-.20.22.24.7Bline.23.23*.28.5B.7D.22.20interpreted.20as.20extended.20glob/with/519718284

# NOTE: spec/extglob-match shows that bash respects it
#
# echo 'strip ##' ${x##@(foo)}

shopt -s extglob


dirprefix="${line##*([}"
echo "-$dirprefix-"

# Now try with real data
line='*([foo'
dirprefix="${line##*([}"
echo "-$dirprefix-"

--------------------------------------------------------------------------------

(program)

================================================================================
divergence.test.sh: !( as negation and subshell versus extended glob - #2463
================================================================================


have_icu_uc=false
have_icu_i18n=false

if !($have_icu_uc && $have_icu_i18n); then
  echo one
fi
echo two

--------------------------------------------------------------------------------

(program)

================================================================================
divergence.test.sh: Changing PATH will invalidate PATH cache
================================================================================


mkdir -p _tmp/bin
mkdir -p _tmp/bin2
printf '#!/usr/bin/env sh\necho hi\n' >_tmp/bin/hello
printf '#!/usr/bin/env sh\necho hey\n' >_tmp/bin2/hello
chmod +x _tmp/bin/hello
chmod +x _tmp/bin2/hello

BIN=$PWD/_tmp/bin
BIN2=$PWD/_tmp/bin2

# Will find _tmp/bin/hello
PATH="$BIN:$PATH" hello
echo status=$?

# Should invalidate cache and then find _tmp/bin2/hello
PATH="$BIN2:$PATH" hello
echo status=$?

# Same when PATH= and export PATH=
PATH="$BIN:$PATH"
hello
echo status=$?
PATH="$BIN2:$PATH"
hello
echo status=$?

export PATH="$BIN:$PATH"
hello
echo status=$?
export PATH="$BIN2:$PATH"
hello
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
divergence.test.sh: builtin cat crashes a subshell (#2530)
================================================================================


((/usr/bin/cat </dev/zero; echo $? >&7) | true) 7>&1

((cat </dev/zero; echo $? >&7) | true) 7>&1

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( )) result
================================================================================

(( 1 )) && echo True
(( 0 )) || echo False

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: negative number is true
================================================================================

(( -1 )) && echo True

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( )) in if statement
================================================================================

if (( 3 > 2)); then
  echo True
fi

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( ))
================================================================================

# What is the difference with this and let?  One difference: spaces are allowed.
(( x = 1 ))
(( y = x + 2 ))
echo $x $y

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( )) with arrays
================================================================================

a=(4 5 6)
(( sum = a[0] + a[1] + a[2] ))
echo $sum

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( )) with error
================================================================================

(( a = 0 )) || echo false
(( b = 1 )) && echo true
(( c = -1 )) && echo true
echo $((a + b + c))

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: bash and mksh: V in (( a[K] = V )) gets coerced to integer
================================================================================

shopt -u strict_arith || true
K=key
V=value
typeset -a a
(( a[K] = V ))

# not there!
echo a[\"key\"]=${a[$K]}

echo keys = ${!a[@]}
echo values = ${a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: bash: K in (( A[K] = V )) is a constant string
================================================================================

K=5
V=42
typeset -A A
(( A[K] = V ))

echo A["5"]=${A["5"]}
echo keys = ${!A[@]}
echo values = ${A[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: BUG: (( V = A[K] )) doesn't retrieve the right value
================================================================================

typeset -A A
K=5
V=42
A["$K"]=$V
A["K"]=oops
A[K]=oops2

# We don't neither 42 nor "oops".  Bad!
(( V = A[K] ))

echo V=$V

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: bash: V in (( A["K"] = V )) gets coerced to integer
================================================================================

shopt -u strict_arith || true
K=key
V=value
typeset -A A || exit 1
(( A["K"] = V ))

# not there!
echo A[\"key\"]=${A[$K]}

echo keys = ${!A[@]}
echo values = ${A[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: literal strings inside (( ))
================================================================================

declare -A A
A['x']=42
(( x = A['x'] ))
(( A['y'] = 'y' ))  # y is a variable, gets coerced to 0
echo $x ${A['y']}

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: (( )) with redirect
================================================================================

(( a = $(stdout_stderr.py 42) + 10 )) 2>$TMP/x.txt
echo $a
echo --
cat $TMP/x.txt

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: Assigning whole raray (( b = a ))
================================================================================

a=(4 5 6)
(( b = a ))

echo "${a[@]}"

# OSH doesn't like this
echo "${b[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: set associative array
================================================================================

declare -A A=(['foo']=bar ['spam']=42)
(( x = A['spam'] ))
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
dparen.test.sh: Example of incrementing associative array entry with var key (ble.sh)
================================================================================

declare -A A=(['foo']=42)
key='foo'

# note: in bash, (( A[\$key] += 1 )) works the same way.

set -- 1 2
(( A[$key] += $2 ))

echo foo=${A['foo']}

--------------------------------------------------------------------------------

(program)

================================================================================
empty-bodies.test.sh: Empty case/esac
================================================================================

case foo in
esac
echo empty

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: Truncating 'exit' status
================================================================================


$SH -c 'exit 255'
echo status=$?

$SH -c 'exit 256'
echo status=$?

$SH -c 'exit 257'
echo status=$?

echo ===

$SH -c 'exit -1'
echo status=$?

$SH -c 'exit -2'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: Truncating 'return' status
================================================================================

f() { return 255; }; f
echo status=$?

f() { return 256; }; f
echo status=$?

f() { return 257; }; f
echo status=$?

echo ===

f() { return -1; }; f
echo status=$?

f() { return -2; }; f
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: subshell OverflowError https://github.com/oilshell/oil/issues/996
================================================================================


# We have to capture stderr here 

filter_err() {
  # check for bash/dash/mksh messages, and unwanted Python OverflowError
  egrep -o 'Illegal number|bad number|return: can only|expected a small integer|OverflowError'
  return 0
}

# true; disables subshell optimization!

# exit status too big, but integer isn't
$SH -c 'true; ( return 2147483647; )' 2>err.txt
echo status=$?
cat err.txt | filter_err

# now integer is too big
$SH -c 'true; ( return 2147483648; )' 2> err.txt
echo status=$?
cat err.txt | filter_err

# even bigger
$SH -c 'true; ( return 2147483649; )' 2> err.txt
echo status=$?
cat err.txt | filter_err

echo
echo '--- negative ---'

# negative vlaues
$SH -c 'true; ( return -2147483648; )' 2>err.txt
echo status=$?
cat err.txt | filter_err

# negative vlaues
$SH -c 'true; ( return -2147483649; )' 2>err.txt
echo status=$?
cat err.txt | filter_err

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: func subshell OverflowError https://github.com/oilshell/oil/issues/996
================================================================================


# We have to capture stderr here 

filter_err() {
  # check for bash/dash/mksh messages, and unwanted Python OverflowError
  egrep -o 'Illegal number|bad number|return: can only|expected a small integer|OverflowError'
  return 0
}

# exit status too big, but integer isn't
$SH -c 'f() ( return 2147483647; ); f' 2>err.txt
echo status=$?
cat err.txt | filter_err

# now integer is too big
$SH -c 'f() ( return 2147483648; ); f' 2> err.txt
echo status=$?
cat err.txt | filter_err

# even bigger
$SH -c 'f() ( return 2147483649; ); f' 2> err.txt
echo status=$?
cat err.txt | filter_err

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: If empty command
================================================================================

if ''; then echo TRUE; else echo FALSE; fi

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: If subshell true
================================================================================

if `true`; then echo TRUE; else echo FALSE; fi

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: If subshell true WITH OUTPUT is different
================================================================================

if `sh -c 'echo X; true'`; then echo TRUE; else echo FALSE; fi

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: If subshell true WITH ARGUMENT
================================================================================

if `true` X; then echo TRUE; else echo FALSE; fi

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: If subshell false -- exit code is propagated in a weird way (strict_argv prevents)
================================================================================

if `false`; then echo TRUE; else echo FALSE; fi

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: Exit code when command sub evaluates to empty str, e.g. `false` (#2416)
================================================================================


# OSH had a bug here
`true`; echo $?
`false`; echo $?
$(true); echo $?
$(false); echo $?
echo ---

# OSH and others agree on these
eval true; echo $?
eval false; echo $?
`echo true`; echo $?
`echo false`; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
exit-status.test.sh: More test cases with empty argv
================================================================================


true $(false)
echo status=$?

$(exit 42)
echo status=$?

$(exit 42) $(exit 43)
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
explore-parsing.test.sh: Length of length of ARGS!
================================================================================

fun() { echo ${##}; }
fun 0 1 2 3 4 5 6 7 8 

--------------------------------------------------------------------------------

(program)

================================================================================
explore-parsing.test.sh: Length of length of ARGS!  2 digit
================================================================================

fun() { echo ${##}; }
fun 0 1 2 3 4 5 6 7 8 9

--------------------------------------------------------------------------------

(program)

================================================================================
explore-parsing.test.sh: Is \r considered whitespace?
================================================================================

echo -e 'echo\rTEST' > myscript
$SH myscript

--------------------------------------------------------------------------------

(program)

================================================================================
explore-parsing.test.sh: readonly +
================================================================================


# dash and bash validate this!  But not set +

readonly + >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
explore-parsing.test.sh: set +
================================================================================

set + >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${FUNCNAME[@]} array
================================================================================

g() {
  argv.py "${FUNCNAME[@]}"
}
f() {
  argv.py "${FUNCNAME[@]}"
  g
  argv.py "${FUNCNAME[@]}"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: FUNCNAME with source (scalar or array)
================================================================================

cd $REPO_ROOT

# Comments on bash quirk:
# https://github.com/oilshell/oil/pull/656#issuecomment-599162211

f() {
  . spec/testdata/echo-funcname.sh
}
g() {
  f
}

g
echo -----

. spec/testdata/echo-funcname.sh
echo -----

argv.py "${FUNCNAME[@]}"

# Show bash inconsistency.  FUNCNAME doesn't behave like a normal array.
case $SH in 
  (bash)
    echo -----
    a=('A')
    argv.py '  @' "${a[@]}"
    argv.py '  0' "${a[0]}"
    argv.py '${}' "${a}"
    argv.py '  $' "$a"
    ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: BASH_SOURCE and BASH_LINENO scalar or array (e.g. for virtualenv)
================================================================================

cd $REPO_ROOT

# https://github.com/pypa/virtualenv/blob/master/virtualenv_embedded/activate.sh
# https://github.com/akinomyoga/ble.sh/blob/6f6c2e5/ble.pp#L374

argv.py "$BASH_SOURCE"  # SimpleVarSub
argv.py "${BASH_SOURCE}"  # BracedVarSub
argv.py "$BASH_LINENO"  # SimpleVarSub
argv.py "${BASH_LINENO}"  # BracedVarSub
argv.py "$FUNCNAME"  # SimpleVarSub
argv.py "${FUNCNAME}"  # BracedVarSub
echo __
source spec/testdata/bash-source-string.sh

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${FUNCNAME} with prefix/suffix operators
================================================================================


check() {
  argv.py "${#FUNCNAME}"
  argv.py "${FUNCNAME::1}"
  argv.py "${FUNCNAME:1}"
}
check

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: operators on FUNCNAME
================================================================================

check() {
  argv.py "${FUNCNAME}"
  argv.py "${#FUNCNAME}"
  argv.py "${FUNCNAME::1}"
  argv.py "${FUNCNAME:1}"
}
check

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${FUNCNAME} and "set -u" (OSH regression)
================================================================================

set -u
argv.py "$FUNCNAME"

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: $((BASH_LINENO)) (scalar form in arith)
================================================================================

check() {
  echo $((BASH_LINENO))
}
check

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${BASH_SOURCE[@]} with source and function name
================================================================================

cd $REPO_ROOT

argv.py "${BASH_SOURCE[@]}"
source spec/testdata/bash-source-simple.sh
f

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${BASH_SOURCE[@]} with line numbers
================================================================================

cd $REPO_ROOT

$SH spec/testdata/bash-source.sh

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: ${BASH_LINENO[@]} is a stack of line numbers for function calls
================================================================================

# note: it's CALLS, not DEFINITIONS.
g() {
  argv.py G "${BASH_LINENO[@]}"
}
f() {
  argv.py 'begin F' "${BASH_LINENO[@]}"
  g  # line 6
  argv.py 'end F' "${BASH_LINENO[@]}"
}
argv.py ${BASH_LINENO[@]}
f  # line 9

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: Locations with temp frame
================================================================================


cd $REPO_ROOT

$SH spec/testdata/bash-source-pushtemp.sh

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: Locations when sourcing
================================================================================


cd $REPO_ROOT

# like above test case, but we source

# bash location doesn't make sense:
# - It says 'source' happens at line 1 of bash-source-pushtemp.  Well I think
# - It really happens at line 2 of '-c' !    I guess that's to line up
#   with the 'main' frame

$SH -c 'true;
source spec/testdata/bash-source-pushtemp.sh'

--------------------------------------------------------------------------------

(program)

================================================================================
introspect.test.sh: Sourcing inside function grows the debug stack
================================================================================


cd $REPO_ROOT

$SH spec/testdata/bash-source-source.sh

--------------------------------------------------------------------------------

(program)

================================================================================
let.test.sh: let
================================================================================

# NOTE: no spaces are allowed.  How is this tokenized?
let x=1
let y=x+2
let z=y*3  # zsh treats this as a glob; bash doesn't
let z2='y*3'  # both are OK with this
echo $x $y $z $z2

--------------------------------------------------------------------------------

(program)

================================================================================
let.test.sh: let with ()
================================================================================

let x=( 1 )
let y=( x + 2 )
let z=( y * 3 )
echo $x $y $z

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: pass array by reference
================================================================================

show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
shadock=(ga bu zo meu)
show_value shadock 2

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: mutate array by reference
================================================================================

set1() {
  local -n array_name=$1
  local val=$2
  array_name[1]=$val
}
shadock=(a b c d)
set1 shadock ZZZ
echo ${shadock[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: pass assoc array by reference
================================================================================

show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
days=([monday]=eggs [tuesday]=bread [sunday]=jam)
show_value days sunday

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: pass local array by reference, relying on DYNAMIC SCOPING
================================================================================

show_value() {
  local -n array_name=$1
  local idx=$2
  echo "${array_name[$idx]}"
}
caller() {
  local shadock=(ga bu zo meu)
  show_value shadock 2
}
caller

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: flag -n and +n
================================================================================

x=foo

ref=x

echo ref=$ref

typeset -n ref
echo ref=$ref

# mutate underlying var
x=bar
echo ref=$ref

typeset +n ref
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: mutating through nameref: ref=
================================================================================

x=XX
y=YY

ref=x
ref=y
echo 1 ref=$ref

# now it's a reference
typeset -n ref

echo 2 ref=$ref  # prints YY

ref=XXXX
echo 3 ref=$ref  # it actually prints y, which is XXXX

# now Y is mutated!
echo 4 y=$y

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: flag -n combined ${!ref} -- bash INVERTS
================================================================================

foo=FOO  # should NOT use this

x=foo
ref=x

echo ref=$ref
echo "!ref=${!ref}"

echo 'NOW A NAMEREF'

typeset -n ref
echo ref=$ref
echo "!ref=${!ref}"

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: named ref with $# doesn't work
================================================================================

set -- one two three

ref='#'
echo ref=$ref
typeset -n ref
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: named ref with $# and shopt -s strict_nameref
================================================================================

shopt -s strict_nameref

ref='#'
echo ref=$ref
typeset -n ref
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: named ref with 1 $1 etc.
================================================================================

set -- one two three

x=X

ref='1'
echo ref=$ref
typeset -n ref
echo ref=$ref

# BUG: This is really assigning '1', which is INVALID
# with strict_nameref that degrades!!!
ref2='$1'
echo ref2=$ref2
typeset -n ref2
echo ref2=$ref2

x=foo

ref3='x'
echo ref3=$ref3
typeset -n ref3
echo ref3=$ref3

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: assign to invalid ref
================================================================================

ref=1   # mksh makes this READ-ONLY!  Because it's not valid.

echo ref=$ref
typeset -n ref
echo ref=$ref

ref=foo
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: assign to invalid ref with strict_nameref
================================================================================

case $SH in *bash|*mksh) exit ;; esac

shopt -s strict_nameref

ref=1

echo ref=$ref
typeset -n ref
echo ref=$ref

ref=foo
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: name ref on Undef cell
================================================================================

typeset  -n ref

# This is technically incorrect: an undefined name shouldn't evaluate to empty
# string.  mksh doesn't allow it.
echo ref=$ref

echo nounset
set -o nounset
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: assign to empty nameref and invalid nameref
================================================================================

typeset -n ref
echo ref=$ref

# this is a no-op in bash, should be stricter
ref=x
echo ref=$ref

typeset -n ref2=undef
echo ref2=$ref2
ref2=x
echo ref2=$ref2

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: -n attribute before it has a value
================================================================================

typeset -n ref

echo ref=$ref

# Now that it's a string, it still has the -n attribute
x=XX
ref=x
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: -n attribute on array is hard error, not a warning
================================================================================

x=X
typeset -n ref #=x
echo hi

# bash prints warning: REMOVES the nameref attribute here!
ref=(x y)
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: exported nameref
================================================================================

x=foo
typeset -n -x ref=x

# hm bash ignores it but mksh doesn't.  maybe disallow it.
printenv.py x ref
echo ---
export x
printenv.py x ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: readonly nameref doesn't prevent assigning through it
================================================================================


# hm bash also ignores -r when -n is set

x=XX
typeset -n -r ref=x

echo ref=$ref

# it feels like I shouldn't be able to mutate this?
ref=XXXX
echo ref=$ref

x=X
echo x=$x

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: readonly var can't be assigned through nameref
================================================================================


x=X
typeset -n -r ref=x

echo ref=$ref

# it feels like I shouldn't be able to mutate this?
ref=XX
echo ref=$ref

# now the underling variable is immutable
typeset -r x

ref=XXX
echo ref=$ref
echo x=$x

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: unset nameref
================================================================================

x=X
typeset -n ref=x
echo ref=$ref

# this works
unset ref
echo ref=$ref
echo x=$x

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: Chain of namerefs
================================================================================

x=foo
typeset -n ref=x
typeset -n ref_to_ref=ref
echo ref_to_ref=$ref_to_ref
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: Mutually recursive namerefs detected on READ
================================================================================

typeset -n ref1=ref2
typeset -n ref2=ref1
echo defined
echo ref1=$ref1
echo ref2=$ref1

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: Mutually recursive namerefs detected on WRITE
================================================================================

typeset -n ref1=ref2
typeset -n ref2=ref1  # not detected here
echo defined $?
ref1=z  # detected here
echo mutated $?

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: Dynamic scope with namerefs
================================================================================


f3() {
  local -n ref=$1
  ref=x
}

f2() {
  f3 "$@"
}

f1() {
  local F1=F1
  echo F1=$F1
  f2 F1
  echo F1=$F1
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: change reference itself
================================================================================

x=XX
y=YY
typeset -n ref=x
echo ref=$ref
echo x=$x
echo y=$y

echo ----
typeset -n ref=y
echo ref=$ref
echo x=$x
echo y=$y
echo ----
ref=z
echo ref=$ref
echo x=$x
echo y=$y

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: a[2] in nameref
================================================================================


typeset -n ref='a[2]'
a=(zero one two three)
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: a[expr] in nameref
================================================================================


# this confuses code and data
typeset -n ref='a[$(echo 2) + 1]'
a=(zero one two three)
echo ref=$ref

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: a[@] in nameref
================================================================================


# this confuses code and data
typeset -n ref='a[@]'
a=('A B' C)
argv.py ref "$ref"  # READ through ref works
ref=(X Y Z)    # WRITE through doesn't work
echo status=$?
argv.py 'ref[@]' "${ref[@]}"
argv.py ref "$ref"  # JOINING mangles the array?
argv.py 'a[@]' "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: mutate through nameref: ref[0]=
================================================================================


# This is DIFFERENT than the nameref itself being 'array[0]' !

array=(X Y Z)
typeset -n ref=array
ref[0]=xx
echo ${array[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: bad mutation through nameref: ref[0]= where ref is array[0]
================================================================================

array=(X Y Z)
typeset -n ref='array[0]'
ref[0]=foo  # error in bash: 'array[0]': not a valid identifier
echo status=$?
echo ${array[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: @ in nameref isn't supported, unlike in ${!ref}
================================================================================


set -- A B
typeset -n ref='@'  # bash gives an error here
echo status=$?

echo ref=$ref  # bash doesn't give an error here
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
nameref.test.sh: Unquoted assoc reference on RHS
================================================================================

typeset -A bashup_ev_r
bashup_ev_r['foo']=bar

p() {
  local s=foo
  local -n e=bashup_ev["$s"] f=bashup_ev_r["$s"]
  # Different!
  #local e=bashup_ev["$s"] f=bashup_ev_r["$s"]
  argv.py "$f"
}
p

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes with echo -e
================================================================================

case $SH in dash) exit ;; esac

show_hex() { od -A n -t c -t x1; }

echo -e '\0-' | show_hex
#echo -e '\x00-'
#echo -e '\000-'

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: printf - literal NUL in format string
================================================================================

case $SH in dash|ash) return ;; esac

# Show both printable and hex
show_hex() { od -A n -t c -t x1; }

printf $'x\U0z' | show_hex
echo ---

printf $'x\U00z' | show_hex
echo ---

printf $'\U0z' | show_hex

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: printf - \0 escape shows NUL byte
================================================================================

show_hex() { od -A n -t c -t x1; }

printf '\0\n' | show_hex

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: printf - NUL byte in value (OSH and zsh agree)
================================================================================

case $SH in dash) exit ;; esac
show_hex() { od -A n -t c -t x1; }

nul=$'\0'
echo "$nul" | show_hex
printf '%s\n' "$nul" | show_hex

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes with echo $'\0' (OSH and zsh agree)
================================================================================

case $SH in dash) exit ;; esac
show_hex() { od -A n -t c -t x1; }

# OSH agrees with ZSH -- so you have the ability to print NUL bytes without
# legacy echo -e

echo $'\0' | show_hex

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes and IFS splitting
================================================================================

case $SH in dash) exit ;; esac

argv.py $(echo -e '\0')
argv.py "$(echo -e '\0')"
argv.py $(echo -e 'a\0b')
argv.py "$(echo -e 'a\0b')"

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes with test -n
================================================================================


case $SH in dash) exit ;; esac

# zsh is buggy here, weird
test -n $''
echo status=$?

test -n $'\0'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes with test -f
================================================================================


case $SH in dash) exit ;; esac


test -f $'\0'
echo status=$?

touch foo
test -f $'foo\0'
echo status=$?

test -f $'foo\0bar'
echo status=$?

test -f $'foobar'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: NUL bytes with ${#s} (OSH and zsh agree)
================================================================================


case $SH in dash) exit ;; esac

empty=$''
nul=$'\0'

echo empty=${#empty}
echo nul=${#nul}

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Compare \x00 byte versus \x01 byte - command sub
================================================================================


# https://stackoverflow.com/questions/32722007/is-skipping-ignoring-nul-bytes-on-process-substitution-standardized
# bash contains a warning!

show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '.\001.')
echo len=${#s}
show_bytes "$s"

s=$(printf '.\000.')
echo len=${#s}
show_bytes "$s"

s=$(printf '\000')
echo len=${#s} 
show_bytes "$s"

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Compare \x00 byte versus \x01 byte - read builtin
================================================================================


# Hm same odd behavior

show_string() {
  read s
  echo len=${#s}
  echo -n "$s" | od -A n -t x1
}

printf '.\001.' | show_string

printf '.\000.' | show_string

printf '\000' | show_string

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Compare \x00 byte versus \x01 byte - read -n
================================================================================

case $SH in dash) exit ;; esac

show_string() {
  read -n 3 s
  echo len=${#s}
  echo -n "$s" | od -A n -t x1
}


printf '.\001.' | show_string

printf '.\000.' | show_string

printf '\000' | show_string

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Compare \x00 byte versus \x01 byte - mapfile builtin
================================================================================

case $SH in dash|mksh|zsh|ash) exit ;; esac

{ 
  printf '.\000.\n'
  printf '.\000.\n'
} |
{ mapfile LINES
  echo len=${#LINES[@]}
  for line in ${LINES[@]}; do
    echo -n "$line" | od -A n -t x1
  done
}

# bash is INCONSISTENT:
# - it TRUNCATES at \0, with 'mapfile'
# - rather than just IGNORING \0, with 'read'

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Strip ops # ## % %% with NUL bytes
================================================================================


show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '\000.\000')
echo len=${#s}
show_bytes "$s"

echo ---

t=${s#?}
echo len=${#t}
show_bytes "$t"

t=${s##?}
echo len=${#t}
show_bytes "$t"

t=${s%?}
echo len=${#t}
show_bytes "$t"

t=${s%%?}
echo len=${#t}
show_bytes "$t"

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Issue 2269 Reduction
================================================================================


show_bytes() {
  echo -n "$1" | od -A n -t x1
}

s=$(printf '\000x')
echo len=${#s}
show_bytes "$s"

# strip one char from the front
s=${s#?}
echo len=${#s}
show_bytes "$s"

echo ---

s=$(printf '\001x')
echo len=${#s}
show_bytes "$s"

# strip one char from the front
s=${s#?}
echo len=${#s}
show_bytes "$s"

--------------------------------------------------------------------------------

(program)

================================================================================
nul-bytes.test.sh: Issue 2269 - Do NUL bytes match ? in ${a#?}
================================================================================


# https://github.com/oils-for-unix/oils/issues/2269

escape_arg() {
	a="$1"
	until [ -z "$a" ]; do
		case "$a" in
		(\'*) printf "'\"'\"'";;
		(*) printf %.1s "$a";;
		esac
		a="${a#?}"
    echo len=${#a} >&2
	done
}

# encode
phrase="$(escape_arg "that's it!")"
echo escaped "$phrase"

# decode
eval "printf '%s\\n' '$phrase'"

echo ---

# harder input: NUL surrounded with ::
arg="$(printf ':\000:')" 
#echo "arg=$arg"

case $SH in
  zsh) echo 'writes binary data' ;;
  *) echo escaped "$(escape_arg "$arg")" ;;
esac
#echo "arg=$arg"

--------------------------------------------------------------------------------

(program)

================================================================================
osh-bugs.test.sh: YSH $[expr_sub] in OSH should not do dynamic globbing
================================================================================


touch {foo,bar}.txt

shopt -s parse_ysh_expr_sub
echo $["*.txt"]

--------------------------------------------------------------------------------

(program)

================================================================================
osh-bugs.test.sh: SHELLOPTS bug with ysh:ugprade
================================================================================


cd $REPO_ROOT/spec/testdata/bug-shellopts

#shopt -p no_init_globals

$SH -o ysh:upgrade ./top-level.ysh

#echo ---
#$SH -e -c 'echo SHELLOPTS=$SHELLOPTS'
#$SH -e -o ysh:upgrade -c 'echo SHELLOPTS=$SHELLOPTS'

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: (( closed with ) ) after multiple lines is command - #2337
================================================================================


(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
) )

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: $(( closed with ) ) after multiple lines is command - #2337
================================================================================


echo $(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
) )

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: (( closed with )) after multiple lines is parse error - #2337
================================================================================


$SH -c '
(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
))
'
if test $? -ne 0; then
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: $(( closed with )) after multiple lines is parse error - #2337
================================================================================


$SH -c '
echo $(( echo 1
echo 2
(( x ))
: $(( x ))
echo 3
))
'
if test $? -ne 0; then
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: (((grep example - 4+ instances in regtest/aports - #2337
================================================================================


# https://oilshell.zulipchat.com/#narrow/channel/502349-osh/topic/.28.28.28.20not.20parsed.20like.20bash/with/518874141

# spaces help
good() {
  cputype=`( ( (grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`
}

bad() {
  cputype=`(((grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`
  #echo cputype=$cputype
}

good
bad

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: ((gzip example - zdiff package - #2337
================================================================================


# https://github.com/git-for-windows/git-sdk-64/blob/main/usr/bin/zdiff#L136

gzip_status=$(
  exec 4>&1
  (gzip -cdfq -- "$file1" 4>&-; echo $? >&4) 3>&- |
      ((gzip -cdfq -- "$file2" 4>&-
        echo $? >&4) 3>&- 5<&- </dev/null |
       eval "$cmp" /dev/fd/5 - >&3) 5<&0
)
echo bye

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: ((pkg-config example - postfix package - #2337
================================================================================


icu_cppflags=`((pkg-config --cflags icu-uc icu-i18n) ||
                  (pkgconf --cflags icu-uc icu-i18n) ||
                  (icu-config --cppflags)) 2>/dev/null`
echo bye

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: ((test example - liblo package - #2337
================================================================================


if ! ((test x"$i" = x-g) || (test x"$i" = x-O2)); then
    CF="$CF $i"
fi
echo bye

--------------------------------------------------------------------------------

(program)

================================================================================
paren-ambiguity.test.sh: $((which example - command sub versus arith sub - gnunet-gtk package
================================================================================


        gtk_update_icon_cache_bin="$((which gtk-update-icon-cache ||
echo /opt/gnome/bin/gtk-update-icon-cache)2>/dev/null)"

echo bye

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: Long Token - 65535 bytes
================================================================================


python2 -c 'print("echo -n %s" % ("x" * 65535))' > tmp.sh
$SH tmp.sh > out
wc --bytes out

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: Token that's too long for Oils - 65536 bytes
================================================================================


python2 -c 'print("echo -n %s" % ("x" * 65536))' > tmp.sh
$SH tmp.sh > out
echo status=$?
wc --bytes out

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: $% is not a parse error
================================================================================

echo $%

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: Bad braced var sub -- not allowed
================================================================================

echo ${%}

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: Bad var sub caught at parse time
================================================================================

if test -f /; then
  echo ${%}
else
  echo ok
fi

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: Invalid for loop variable name
================================================================================

for i.j in a b c; do
  echo hi
done
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: bad var name globally isn't parsed like an assignment
================================================================================

# bash and dash disagree on exit code.
FOO-BAR=foo

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: bad var name in export
================================================================================

# bash and dash disagree on exit code.
export FOO-BAR=foo

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: bad var name in local
================================================================================

# bash and dash disagree on exit code.
f() {
  local FOO-BAR=foo
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: interactive parse error (regression)
================================================================================

flags=''
case $SH in
  bash*|*osh)
    flags='--rcfile /dev/null'
    ;;
esac  
$SH $flags -i -c 'var=)'

--------------------------------------------------------------------------------

(program)

================================================================================
parse-errors.test.sh: echo =word is allowed
================================================================================

echo =word

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Empty for loop is allowed
================================================================================

set -- a b
for x in; do
  echo hi
  echo $x
done

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Empty for loop without in.  Do can be on the same line I guess.
================================================================================

set -- a b
for x do
  echo hi
  echo $x
done

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Empty case statement
================================================================================

case foo in
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Last case without ;;
================================================================================

foo=a
case $foo in
  a) echo A ;;
  b) echo B  
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Only case without ;;
================================================================================

foo=a
case $foo in
  a) echo A
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Case with optional (
================================================================================

foo=a
case $foo in
  (a) echo A ;;
  (b) echo B  
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Empty action is allowed for last case
================================================================================

foo=b
case $foo in
  a) echo A ;;
  b)
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Case with | pattern
================================================================================

foo=a
case $foo in
  a|b) echo A ;;
  c)
esac

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Command substitution in default
================================================================================

echo ${x:-$(ls -d /bin)}

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Arithmetic expansion
================================================================================

x=3
while [ $x -gt 0 ]
do
  echo $x
  x=$(($x-1))
done

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Newlines in compound lists
================================================================================

x=3
while
  # a couple of <newline>s

  # a list
  date && ls -d /bin || echo failed; cat tests/hello.txt
  # a couple of <newline>s

  # another list
  wc tests/hello.txt > _tmp/posix-compound.txt & true

do
  # 2 lists
  ls -d /bin
  cat tests/hello.txt
  x=$(($x-1))
  [ $x -eq 0 ] && break
done
# Not testing anything but the status since output is complicated

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: Multiple here docs on one line
================================================================================

cat <<EOF1; cat <<EOF2
one
EOF1
two
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
posix.test.sh: cat here doc; echo; cat here doc
================================================================================

cat <<EOF1; echo two; cat <<EOF2
one
EOF1
three
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
print-source-code.test.sh: typeset -f prints function source code
================================================================================

: prefix; myfunc() { echo serialized; }

code=$(typeset -f myfunc)

$SH -c "$code; myfunc"

--------------------------------------------------------------------------------

(program)

================================================================================
print-source-code.test.sh: typeset -f with function keyword (ksh style)
================================================================================

: prefix; function myfunc {
	echo serialized
}

code=$(typeset -f myfunc)

$SH -c "$code; myfunc"

--------------------------------------------------------------------------------

(program)

================================================================================
print-source-code.test.sh: typeset -f prints function source code - nested functions
================================================================================

outer() {
  echo outer
  : prefix; inner() {
    echo inner
  }
}

code=$(typeset -f outer)

if false; then
  echo ---
  echo $code
  echo ---
fi

$SH -c "$code; outer; inner"

--------------------------------------------------------------------------------

(program)

================================================================================
print-source-code.test.sh: non-{ } function bodies can be serialized (rare)
================================================================================


# TODO: we can add more of these

f() ( echo 'subshell body' )

code=$(typeset -f f)

$SH -c "$code; f"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: sh -i
================================================================================

# Notes:
# - OSH prompt goes to stdout and bash goes to stderr
# - This test seems to fail on the system bash, but succeeds with spec-bin/bash
echo 'echo foo' | PS1='[prompt] ' $SH --rcfile /dev/null -i >out.txt 2>err.txt
fgrep -q '[prompt]' out.txt err.txt
echo match=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \[\] are non-printing
================================================================================

PS1='\[foo\]\$'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: literal escapes
================================================================================

PS1='\a\e\r\n'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: special case for $
================================================================================

# NOTE: This might be broken for # but it's hard to tell since we don't have
# root.  Could inject __TEST_EUID or something.
PS1='$'
echo "${PS1@P}"
PS1='\$'
echo "${PS1@P}"
PS1='\\$'
echo "${PS1@P}"
PS1='\\\$'
echo "${PS1@P}"
PS1='\\\\$'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: PS1 evaluation order
================================================================================

x='\'
y='h'
PS1='$x$y'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: PS1 evaluation order 2
================================================================================

foo=foo_value
dir=$TMP/'$foo'  # Directory name with a dollar!
mkdir -p $dir
cd $dir
PS1='\w $foo'
test "${PS1@P}" = "$PWD foo_value"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \1004
================================================================================

PS1='\1004$'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \001 octal literals are supported
================================================================================

PS1='[\045]'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \555 is beyond max octal byte of \377 and wrapped to m
================================================================================

PS1='\555$'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \x55 hex literals not supported
================================================================================

PS1='[\x55]'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: Single backslash
================================================================================

PS1='\'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: Escaped backslash
================================================================================

PS1='\\'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \0001 octal literals are not supported
================================================================================

PS1='[\0455]'
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \u0001 unicode literals not supported
================================================================================

PS1='[\u0001]'
USER=$(whoami)
test "${PS1@P}" = "[${USER}0001]"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: constant string
================================================================================

PS1='$ '
echo "${PS1@P}"

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: hostname
================================================================================


# NOTE: This test is not hermetic.  On my machine the short and long host name
# are the same.

PS1='\h '
test "${PS1@P}" = "$(hostname -s) "  # short name
echo status=$?
PS1='\H '
test "${PS1@P}" = "$(hostname) "
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: username
================================================================================

PS1='\u '
USER=$(whoami)
test "${PS1@P}" = "${USER} "
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: current working dir
================================================================================

PS1='\w '
test "${PS1@P}" = "${PWD} "
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \W is basename of working dir
================================================================================

PS1='\W '
test "${PS1@P}" = "$(basename $PWD) "
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \t for 24h time (HH:MM:SS)
================================================================================

PS1='foo \t bar'
echo "${PS1@P}" | egrep -q 'foo [0-2][0-9]:[0-5][0-9]:[0-5][0-9] bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \T for 12h time (HH:MM:SS)
================================================================================

PS1='foo \T bar'
echo "${PS1@P}" | egrep -q 'foo [0-1][0-9]:[0-5][0-9]:[0-5][0-9] bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \@ for 12h time (HH:MM AM/PM)
================================================================================

PS1='foo \@ bar'
echo "${PS1@P}" | egrep -q 'foo [0-1][0-9]:[0-5][0-9] (A|P)M bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \A for 24h time (HH:MM)
================================================================================

PS1='foo \A bar'
echo "${PS1@P}" | egrep -q 'foo [0-2][0-9]:[0-5][0-9] bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \d for date
================================================================================

PS1='foo \d bar'
echo "${PS1@P}" | egrep -q 'foo [A-Z][a-z]+ [A-Z][a-z]+ [0-9]+ bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \D{%H:%M} for strftime
================================================================================

PS1='foo \D{%H:%M} bar'
echo "${PS1@P}" | egrep -q 'foo [0-9][0-9]:[0-9][0-9] bar'
echo matched=$?

PS1='foo \D{%H:%M:%S} bar'
echo "${PS1@P}" | egrep -q 'foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9] bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \D{} for locale specific strftime
================================================================================


# In bash y.tab.c uses %X when string is empty
# This doesn't seem to match exactly, but meh for now.

PS1='foo \D{} bar'
echo "${PS1@P}" | egrep -q '^foo [0-9][0-9]:[0-9][0-9]:[0-9][0-9]( ..)? bar$'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \s for shell, \v for major.minor version, and \V for full version
================================================================================

PS1='foo \s bar'
echo "${PS1@P}" | egrep -q '^foo (bash|osh) bar$'
echo match=$?

PS1='foo \v bar'
echo "${PS1@P}" | egrep -q '^foo [0-9]+\.[0-9]+ bar$'
echo match=$?

PS1='foo \V bar'
echo "${PS1@P}" | egrep -q '^foo [0-9]+\.[0-9]+\.[0-9]+ bar$'
echo match=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \j for number of jobs
================================================================================

set -m # enable job control
PS1='foo \j bar'
echo "${PS1@P}" | egrep -q 'foo 0 bar'
echo matched=$?
sleep 5 &
echo "${PS1@P}" | egrep -q 'foo 1 bar'
echo matched=$?
kill %%
fg
echo "${PS1@P}" | egrep -q 'foo 0 bar'
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \l for TTY device basename
================================================================================

PS1='foo \l bar'
# FIXME this never an actual TTY when using ./test/spec.sh
tty="$(tty)"
if [[ "$tty" == "not a tty" ]]; then
    expected="tty"
else
    expected="$(basename "$tty")"
fi
echo "${PS1@P}" | egrep -q "foo $expected bar"
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \! for history number
================================================================================

set -o history # enable history
PS1='foo \! bar'
history -c # clear history
echo "${PS1@P}" | egrep -q "foo 1 bar"
echo matched=$?
echo "_${PS1@P}" | egrep -q "foo 3 bar"
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: \# for command number
================================================================================

PS1='foo \# bar'
prev_cmd_num="$(echo "${PS1@P}" | egrep -o 'foo [0-9]+ bar' | sed -E 's/foo ([0-9]+) bar/\1/')"
echo "${PS1@P}" | egrep -q "foo $((prev_cmd_num + 1)) bar"
echo matched=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: @P with array
================================================================================

$SH -c 'echo ${@@P}' dummy a b c
echo status=$?
$SH -c 'echo ${*@P}' dummy a b c
echo status=$?
$SH -c 'a=(x y); echo ${a@P}' dummy a b c
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
prompt.test.sh: default PS1
================================================================================

#flags='--norc --noprofile'
flags='--rcfile /dev/null'

$SH $flags -i -c 'echo "_${PS1}_"'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Unquoted words
================================================================================

echo unquoted    words

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Single-quoted
================================================================================

echo 'single   quoted'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Two single-quoted parts
================================================================================

echo 'two single-quoted pa''rts in one token'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Unquoted and single quoted
================================================================================

echo unquoted' and single-quoted'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: newline inside single-quoted string
================================================================================

echo 'newline
inside single-quoted string'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Double-quoted
================================================================================

echo "double   quoted"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Mix of quotes in one word
================================================================================

echo unquoted'  single-quoted'"  double-quoted  "unquoted

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Var substitution
================================================================================

FOO=bar
echo "==$FOO=="

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Var substitution with braces
================================================================================

FOO=bar
echo foo${FOO}

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Var substitution with braces, quoted
================================================================================

FOO=bar
echo "foo${FOO}"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Var length
================================================================================

FOO=bar
echo "foo${#FOO}"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Storing backslashes and then echoing them
================================================================================

# This is a bug fix; it used to cause problems with unescaping.
one='\'
two='\\'
echo $one $two
echo "$one" "$two"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Backslash escapes
================================================================================

echo \$ \| \a \b \c \d \\

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Backslash escapes inside double quoted string
================================================================================

echo "\$ \\ \\ \p \q"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: C-style backslash escapes inside double quoted string
================================================================================

# mksh and dash implement POSIX incompatible extensions.  $ ` " \ <newline>
# are the only special ones
echo "\a \b"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Literal $
================================================================================

echo $

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Quoted Literal $
================================================================================

echo $ "$" $

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Line continuation
================================================================================

echo foo\
$

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Line continuation inside double quotes
================================================================================

echo "foo\
$"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $? split over multiple lines
================================================================================

# Same with $$, etc.  OSH won't do this because $? is a single token.
echo $\
?

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: Semicolon
================================================================================

echo separated; echo by semi-colon

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: No tab escapes within single quotes
================================================================================

# dash and mksh allow this, which is a BUG.
# POSIX says: "Enclosing characters in single-quotes ( '' ) shall preserve the
# literal value of each character within the single-quotes. A single-quote
# cannot occur within single-quotes"
echo 'a\tb'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $''
================================================================================

echo $'foo'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $'' with quotes
================================================================================

echo $'single \' double \"'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $'' with newlines
================================================================================

echo $'col1\ncol2\ncol3'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $'' octal escapes don't have leading 0
================================================================================

# echo -e syntax is echo -e \0377
echo -n $'\001' $'\377' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $'' octal escapes with fewer than 3 chars
================================================================================

echo $'\1 \11 \11 \111' | od -A n -c | sed 's/ \+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: OSH allows invalid backslashes
================================================================================

case $SH in dash|mksh) exit ;; esac

w=$'\uZ'
x=$'\u{03bc'
y=$'\z'
echo $w $x $y

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: YSH allows unquoted foo\ bar too
================================================================================

shopt -s ysh:all
touch foo\ bar
ls foo\ bar

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $"" is a synonym for ""
================================================================================

echo $"foo"
x=x
echo $"foo $x"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: printf supports tabs
================================================================================

# This accepts \t by itself, hm.
printf "c1\tc2\nc3\tc4\n"

--------------------------------------------------------------------------------

(program)

================================================================================
quote.test.sh: $'' supports \cA escape for Ctrl-A - mask with 0x1f
================================================================================


# note: AT&T ksh supports this too

case $SH in dash|ash) exit ;; esac

show_bytes() {
  # -A n - no file offset
  od -A n -t c -t x1
}

# this isn't special
# mksh doesn't like it
#echo -n $'\c' | show_bytes

echo -n $'\c0\c9-' | show_bytes
echo

# control chars are case insensitive
echo -n $'\ca\cz' | show_bytes
echo

echo -n $'\cA\cZ' | show_bytes
echo

echo -n $'\c-\c+\c"' | show_bytes

--------------------------------------------------------------------------------

(program)

================================================================================
redir-order.test.sh: echo `cat OSCFLAGS` "world" > OSCFLAGS (from Alpine imap)
================================================================================


echo hello > OSCFLAGS
echo `cat OSCFLAGS` "world" > OSCFLAGS
#echo $(cat OSCFLAGS) "world" > OSCFLAGS
cat OSCFLAGS

--------------------------------------------------------------------------------

(program)

================================================================================
redir-order.test.sh: subshell + redirect order
================================================================================


echo hello > OSCFLAGS
(echo `cat OSCFLAGS` "world") > OSCFLAGS
cat OSCFLAGS

--------------------------------------------------------------------------------

(program)

================================================================================
redir-order.test.sh: for word + redirect order
================================================================================


echo hello > OSCFLAGS
for x in `cat OSCFLAGS` world; do
  echo $x
done > OSCFLAGS
cat OSCFLAGS

--------------------------------------------------------------------------------

(program)

================================================================================
redir-order.test.sh: case word + redirect order
================================================================================


echo hello > OSCFLAGS
case `cat OSCFLAGS` in
  hello)
    echo hello
    ;;
  *)
    echo other
    ;;
esac > OSCFLAGS
cat OSCFLAGS

--------------------------------------------------------------------------------

(program)

================================================================================
redir-order.test.sh: [[ + redirect order
================================================================================

case $SH in dash|ash) exit ;; esac

echo hello > OSCFLAGS

[[ `cat OSCFLAGS` = hello ]] > OSCFLAGS
echo status=$?

# it is the empty string!
[[ `cat OSCFLAGS` = '' ]] > OSCFLAGS
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: BASH_REMATCH
================================================================================

[[ foo123 =~ ([a-z]+)([0-9]+) ]]
echo status=$?
argv.py "${BASH_REMATCH[@]}"

[[ failed =~ ([a-z]+)([0-9]+) ]]
echo status=$?
argv.py "${BASH_REMATCH[@]}"  # not cleared!

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Match is unanchored at both ends
================================================================================

[[ 'bar' =~ a ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Failed match
================================================================================

[[ 'bar' =~ X ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex quoted with \ -- preferred in bash
================================================================================

[[ 'a b' =~ ^(a\ b)$ ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex quoted with single quotes
================================================================================

# bash doesn't like the quotes
[[ 'a b' =~ '^(a b)$' ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex quoted with double quotes
================================================================================

# bash doesn't like the quotes
[[ 'a b' =~ "^(a b)$" ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Fix single quotes by storing in variable
================================================================================

pat='^(a b)$'
[[ 'a b' =~ $pat ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Fix single quotes by storing in variable
================================================================================

pat="^(a b)$"
[[ 'a b' =~ $pat ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Double quoting pat variable -- again bash doesn't like it.
================================================================================

pat="^(a b)$"
[[ 'a b' =~ "$pat" ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Mixing quoted and unquoted parts
================================================================================

[[ 'a b' =~ 'a 'b ]] && echo true
[[ "a b" =~ "a "'b' ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Omitting ( )
================================================================================

[[ '^a b$' == ^a\ b$ ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex with |
================================================================================

[[ 'bar' =~ foo|bar ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex to match literal brackets []
================================================================================


# bash-completion relies on this, so we're making it match bash.
# zsh understandably differs.
[[ '[]' =~ \[\] ]] && echo true

# Another way to write this.
pat='\[\]'
[[ '[]' =~ $pat ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Regex to match literals . ^ $ etc.
================================================================================

[[ 'x' =~ \. ]] || echo false
[[ '.' =~ \. ]] && echo true

[[ 'xx' =~ \^\$ ]] || echo false
[[ '^$' =~ \^\$ ]] && echo true

[[ 'xxx' =~ \+\*\? ]] || echo false
[[ '*+?' =~ \*\+\? ]] && echo true

[[ 'xx' =~ \{\} ]] || echo false
[[ '{}' =~ \{\} ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Unquoted { is a regex parse error
================================================================================

[[ { =~ { ]] && echo true
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Fatal error inside [[ =~ ]]
================================================================================


# zsh and osh are stricter than bash.  bash treats [[ like a command.

[[ a =~ $(( 1 / 0 )) ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Quoted { and +
================================================================================

[[ { =~ "{" ]] && echo 'yes {'
[[ + =~ "+" ]] && echo 'yes +'
[[ * =~ "*" ]] && echo 'yes *'
[[ ? =~ "?" ]] && echo 'yes ?'
[[ ^ =~ "^" ]] && echo 'yes ^'
[[ $ =~ "$" ]] && echo 'yes $'
[[ '(' =~ '(' ]] && echo 'yes ('
[[ ')' =~ ')' ]] && echo 'yes )'
[[ '|' =~ '|' ]] && echo 'yes |'
[[ '\' =~ '\' ]] && echo 'yes \'
echo ---

[[ . =~ "." ]] && echo 'yes .'
[[ z =~ "." ]] || echo 'no .'
echo ---

# This rule is weird but all shells agree.  I would expect that the - gets
# escaped?  It's an operator?  but it behaves like a-z.
[[ a =~ ["a-z"] ]]; echo "a $?"
[[ - =~ ["a-z"] ]]; echo "- $?"
[[ b =~ ['a-z'] ]]; echo "b $?"
[[ z =~ ['a-z'] ]]; echo "z $?"

echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Escaped {
================================================================================

# from bash-completion
[[ '$PA' =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]] && argv.py "${BASH_REMATCH[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Escaped { stored in variable first
================================================================================

# from bash-completion
pat='^(\$\{?)([A-Za-z0-9_]*)$'
[[ '$PA' =~ $pat ]] && argv.py "${BASH_REMATCH[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: regex with ?
================================================================================

[[ 'c' =~ c? ]] && echo true
[[ '' =~ c? ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: regex with unprintable characters
================================================================================

# can't have nul byte

# This pattern has literal characters
pat=$'^[\x01\x02]+$'

[[ $'\x01\x02\x01' =~ $pat ]]; echo status=$?
[[ $'a\x01' =~ $pat ]]; echo status=$?

# NOTE: There doesn't appear to be any way to escape these!
pat2='^[\x01\x02]+$'

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: pattern $f(x)  -- regression
================================================================================

f=fff
[[ fffx =~ $f(x) ]]
echo status=$?
[[ ffx =~ $f(x) ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: pattern a=(1)
================================================================================

[[ a=x =~ a=(x) ]]
echo status=$?
[[ =x =~ a=(x) ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: pattern @f(x)
================================================================================

shopt -s parse_at
[[ @fx =~ @f(x) ]]
echo status=$?
[[ fx =~ @f(x) ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Bug: Nix idiom with closing ) next to pattern
================================================================================


if [[ ! (" ${params[*]} " =~ " -shared " || " ${params[*]} " =~ " -static ") ]]; then
  echo one
fi

# Reduced idiom
if [[ (foo =~ foo) ]]; then
  echo two
fi

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: unquoted (a  b) as pattern, (a  b|c)
================================================================================


if [[ 'a  b' =~ (a  b) ]]; then
  echo one
fi

if [[ 'a b' =~ (a  b) ]]; then
  echo BAD
fi

if [[ 'a b' =~ (a b|c) ]]; then
  echo two
fi

# I think spaces are only allowed within ()

if [[ '  c' =~ (a|  c) ]]; then
  echo three
fi

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Multiple adjacent () groups
================================================================================


if [[ 'a-b-c-d' =~ a-(b|  >>)-c-( ;|[de])|ff|gg ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

if [[ ff =~ a-(b|  >>)-c-( ;|[de])|ff|gg ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

# empty group ()

if [[ zz =~ ([a-z]+)() ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

# nested empty group
if [[ zz =~ ([a-z]+)(()z) ]]; then
  argv.py "${BASH_REMATCH[@]}"
fi

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: unquoted [a  b] as pattern, [a  b|c]
================================================================================


$SH <<'EOF'
[[ a =~ [ab] ]] && echo yes
EOF
echo "[ab]=$?"

$SH <<'EOF'
[[ a =~ [a b] ]] && echo yes
EOF
echo "[a b]=$?"

$SH <<'EOF'
[[ a =~ ([a b]) ]] && echo yes
EOF
echo "[a b]=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: c|a unquoted
================================================================================


if [[ a =~ c|a ]]; then
  echo one
fi

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Operator chars ; & but not |
================================================================================


# Hm semicolon is still an operator in bash
$SH <<'EOF'
[[ ';' =~ ; ]] && echo semi
EOF
echo semi=$?

$SH <<'EOF'
[[ ';' =~ (;) ]] && echo semi paren
EOF
echo semi paren=$?

echo

$SH <<'EOF'
[[ '&' =~ & ]] && echo amp
EOF
echo amp=$?

# Oh I guess this is not a bug?  regcomp doesn't reject this trivial regex?
$SH <<'EOF'
[[ '|' =~ | ]] && echo pipe1
[[ 'a' =~ | ]] && echo pipe2
EOF
echo pipe=$?

$SH <<'EOF'
[[ '|' =~ a| ]] && echo four
EOF
echo pipe=$?

# This is probably special because > operator is inside foo [[ a > b ]]
$SH <<'EOF'
[[ '<>' =~ <> ]] && echo angle
EOF
echo angle=$?

# Bug: OSH allowed this!
$SH <<'EOF'
[[ $'a\nb' =~ a
b ]] && echo newline
EOF
echo newline=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Quotes '' "" $'' $"" in pattern
================================================================================


$SH <<'EOF'
[[ '|' =~ '|' ]] && echo sq
EOF
echo sq=$?

$SH <<'EOF'
[[ '|' =~ "|" ]] && echo dq
EOF
echo dq=$?

$SH <<'EOF'
[[ '|' =~ $'|' ]] && echo dollar-sq
EOF
echo dollar-sq=$?

$SH <<'EOF'
[[ '|' =~ $"|" ]] && echo dollar-dq
EOF
echo dollar-dq=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Unicode in pattern
================================================================================


$SH <<'EOF'
[[  =~  ]] && echo mu
EOF
echo mu=$?

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: make a lisp example
================================================================================


str='(hi)'
[[ "${str}" =~ ^^([][{}\(\)^@])|^(~@)|(\"(\\.|[^\\\"])*\")|^(;[^$'\n']*)|^([~\'\`])|^([^][ ~\`\'\";{}\(\)^@\,]+)|^[,]|^[[:space:]]+ ]]
echo status=$?

m=${BASH_REMATCH[0]}
echo m=$m

--------------------------------------------------------------------------------

(program)

================================================================================
regex.test.sh: Operators and space lose meaning inside ()
================================================================================

[[ '< >' =~ (< >) ]] && echo true

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q newline
================================================================================

case $SH in ash) return ;; esac  # yash and ash don't implement this

newline=$'one\ntwo'
printf '%q\n' "$newline"

quoted="$(printf '%q\n' "$newline")"
restored=$(eval "echo $quoted")
test "$newline" = "$restored" && echo roundtrip-ok

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q spaces
================================================================================

case $SH in ash) return ;; esac  # yash and ash don't implement this

# bash does a weird thing and uses \

spaces='one two'
printf '%q\n' "$spaces"

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q quotes
================================================================================

case $SH in ash) return ;; esac  # yash and ash don't implement %q

quotes=\'\"
printf '%q\n' "$quotes"

quoted="$(printf '%q\n' "$quotes")"
restored=$(eval "echo $quoted")
test "$quotes" = "$restored" && echo roundtrip-ok

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q unprintable
================================================================================

case $SH in ash) return ;; esac  # yash and ash don't implement this

unprintable=$'\xff'
printf '%q\n' "$unprintable"

# bash and zsh agree

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q unicode
================================================================================

case $SH in ash) return ;; esac  # yash and ash don't implement this

unicode=$'\u03bc'
unicode=$'\xce\xbc'  # does the same thing

printf '%q\n' "$unicode"

# OSH issue: we have quotes.  Isn't that OK?

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: printf %q invalid unicode
================================================================================

case $SH in ash) return ;; esac

# Hm bash/mksh/zsh understand these.  They are doing decoding and error
# recovery!  inspecting the bash source seems to confirm this.
unicode=$'\xce'
printf '%q\n' "$unicode"

unicode=$'\xce\xce\xbc'
printf '%q\n' "$unicode"

unicode=$'\xce\xbc\xce'
printf '%q\n' "$unicode"

case $SH in mksh) return ;; esac  # it prints unprintable chars here!

unicode=$'\xcea'
printf '%q\n' "$unicode"
unicode=$'a\xce'
printf '%q\n' "$unicode"

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: set
================================================================================

case $SH in zsh) return ;; esac  # zsh doesn't make much sense

zz=$'one\ntwo'

set | grep zz

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: declare
================================================================================

case $SH in ash|zsh) return ;; esac  # zsh doesn't make much sense

zz=$'one\ntwo'

typeset | grep zz
typeset -p zz

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: ${var@Q}
================================================================================

case $SH in zsh|ash) exit ;; esac

zz=$'one\ntwo \u03bc'

# weirdly, quoted and unquoted aren't different
echo ${zz@Q}
echo "${zz@Q}"

--------------------------------------------------------------------------------

(program)

================================================================================
serialize.test.sh: xtrace
================================================================================

zz=$'one\ntwo'
set -x
echo "$zz"

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Locals don't leak
================================================================================

f() {
  local f_var=f_var
}
f
echo $f_var

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Globals leak
================================================================================

f() {
  f_var=f_var
}
f
echo $f_var

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Return statement
================================================================================

f() {
  echo one
  return 42
  echo two
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Dynamic Scope
================================================================================

f() {
  echo $g_var
}
g() {
  local g_var=g_var
  f
}
g

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Dynamic Scope Mutation (wow this is bad)
================================================================================

f() {
  g_var=f_mutation
}
g() {
  local g_var=g_var
  echo "g_var=$g_var"
  f
  echo "g_var=$g_var"
}
g
echo g_var=$g_var

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Assign local separately
================================================================================

f() {
  local f
  f='new-value'
  echo "[$f]"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Assign a local and global on same line
================================================================================

myglobal=
f() {
  local mylocal
  mylocal=L myglobal=G
  echo "[$mylocal $myglobal]"
}
f
echo "[$mylocal $myglobal]"

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Return without args gives previous
================================================================================

f() {
  ( exit 42 )
  return
}
f
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: return "" (a lot of disagreement)
================================================================================

f() {
  echo f
  return ""
}

f
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: return $empty
================================================================================

f() {
  echo f
  empty=
  return $empty
}

f
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Subshell function
================================================================================


f() ( return 42; )
# BUG: OSH raises invalid control flow!  I think we should just allow 'return'
# but maybe not 'break' etc.
g() ( return 42 )
# bash warns here but doesn't cause an error
# g() ( break )

f
echo status=$?
g
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-func.test.sh: Scope of global variable when sourced in function (Shell Functions aren't Closures)
================================================================================

set -u

echo >tmp.sh '
g="global"
local L="local"

test_func() {
  echo "g = $g"
  echo "L = $L"
}
'

main() {
  # a becomes local here
  # test_func is defined globally
  . ./tmp.sh
}

main

# a is not defined
test_func

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: SHELLOPTS is updated when options are changed
================================================================================

echo $SHELLOPTS | grep -q xtrace
echo $?
set -x
echo $SHELLOPTS | grep -q xtrace
echo $?
set +x
echo $SHELLOPTS | grep -q xtrace
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: SHELLOPTS is readonly
================================================================================

SHELLOPTS=x
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: SHELLOPTS and BASHOPTS are non-empty
================================================================================


# 2024-06 - tickled by Samuel testing Gentoo

if test -v SHELLOPTS; then
  echo 'shellopts is set'
fi
if test -v BASHOPTS; then
	echo 'bashopts is set'
fi

# bash: braceexpand:hashall etc.

echo shellopts ${SHELLOPTS:?} > /dev/null
echo bashopts ${BASHOPTS:?} > /dev/null

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: SHELLOPTS reflects flags like sh -x
================================================================================


$SH -x -c 'echo $SHELLOPTS' | grep -o xtrace

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: export SHELLOPTS does cross-process tracing
================================================================================


$SH -c '
export SHELLOPTS
set -x
echo 1
$SH -c "echo 2"
' 2>&1 | sed 's/.*sh /sh /g'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: export SHELLOPTS does cross-process tracing with bash
================================================================================


# calling bash
$SH -c '
export SHELLOPTS
set -x
#echo SHELLOPTS=$SHELLOPTS
echo 1
bash -c "echo 2"
' 2>&1 | sed 's/.*sh /sh /g'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: OSH calling bash with SHELLOPTS does not change braceexpand
================================================================================


#echo outside=$SHELLOPTS

# sed pattern to normalize spaces
normalize='s/[ \t]\+/ /g'

bash -c '
#echo bash=$SHELLOPTS
set -o | grep braceexpand | sed "$1"
' unused "$normalize"

env SHELLOPTS= bash -c '
#echo bash2=$SHELLOPTS
set -o | grep braceexpand | sed "$1"
' unused "$normalize"

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: If shopt --set xtrace is allowed, it should update SHELLOPTS, not BASHOPTS
================================================================================

case $SH in bash) exit ;; esac

shopt --set xtrace
echo SHELLOPTS=$SHELLOPTS
set -x
echo SHELLOPTS=$SHELLOPTS
set +x
echo SHELLOPTS=$SHELLOPTS

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options-bash.test.sh: shopt -s progcomp hostcomplete are stubs (bash-completion)
================================================================================


shopt -s progcomp hostcomplete
echo status=$?

shopt -u progcomp hostcomplete
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: $- with -c
================================================================================

# dash's behavior seems most sensible here?
$SH -o nounset -c 'echo $-'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: $- with pipefail
================================================================================

set -o pipefail -o nounset
echo $-

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: $- and more options
================================================================================

set -efuC
o=$-
[[ $o == *e* ]]; echo yes
[[ $o == *f* ]]; echo yes
[[ $o == *u* ]]; echo yes
[[ $o == *C* ]]; echo yes

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: $- with interactive shell
================================================================================

$SH -c 'echo $-' | grep i || echo FALSE
$SH -i -c 'echo $-' | grep -q i && echo TRUE

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: pass short options like sh -e
================================================================================

$SH -e -c 'false; echo status=$?'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: pass long options like sh -o errexit
================================================================================

$SH -o errexit -c 'false; echo status=$?'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: pass shopt options like sh -O nullglob
================================================================================

$SH +O nullglob -c 'echo foo *.nonexistent bar'
$SH -O nullglob -c 'echo foo *.nonexistent bar'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: set -o vi/emacs
================================================================================

set -o vi
echo $?
set -o emacs
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: vi and emacs are mutually exclusive
================================================================================

show() {
  shopt -o -p | egrep 'emacs$|vi$'
  echo ___
};
show

set -o emacs
show

set -o vi
show

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: interactive shell starts with emacs mode on
================================================================================

case $SH in dash) exit ;; esac
case $SH in bash|*osh) flag='--rcfile /dev/null' ;; esac

code='test -o emacs; echo $?; test -o vi; echo $?'

echo non-interactive
$SH $flag -c "$code"

echo interactive
$SH $flag -i -c "$code"

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: nounset
================================================================================

echo "[$unset]"
set -o nounset
echo "[$unset]"
echo end  # never reached

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: -u is nounset
================================================================================

echo "[$unset]"
set -u
echo "[$unset]"
echo end  # never reached

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: -n for no execution (useful with --ast-output)
================================================================================

# NOTE: set +n doesn't work because nothing is executed!
echo 1
set -n
echo 2
set +n
echo 3
# osh doesn't work because it only checks -n in bin/oil.py?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: pipefail
================================================================================

# NOTE: the sleeps are because osh can fail non-deterministically because of a
# bug.  Same problem as PIPESTATUS.
{ sleep 0.01; exit 9; } | { sleep 0.02; exit 2; } | { sleep 0.03; }
echo $?
set -o pipefail
{ sleep 0.01; exit 9; } | { sleep 0.02; exit 2; } | { sleep 0.03; }
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -p -o prints 'set' options
================================================================================

case $SH in dash|mksh) exit ;; esac

shopt -po nounset
set -o nounset
shopt -po nounset

echo --

shopt -po | egrep -o 'errexit|noglob|nounset'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -o prints 'set' options
================================================================================

case $SH in dash|mksh) exit ;; esac

shopt -o | egrep -o 'errexit|noglob|nounset'
echo --

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -p prints 'shopt' options
================================================================================

shopt -p nullglob
shopt -s nullglob
shopt -p nullglob

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt with no flags prints options
================================================================================

cd $TMP

# print specific options.  OSH does it in a different format.
shopt nullglob failglob > one.txt
wc -l one.txt
grep -o nullglob one.txt
grep -o failglob one.txt

# print all options
shopt | grep nullglob | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber off
================================================================================

set -o errexit

echo foo > can-clobber
echo status=$?
set +C

echo foo > can-clobber
echo status=$?
set +o noclobber

echo foo > can-clobber
echo status=$?
cat can-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber on
================================================================================


rm -f no-clobber
set -C

echo foo > no-clobber
echo create=$?

echo overwrite > no-clobber
echo overwrite=$?

echo force >| no-clobber
echo force=$?

cat no-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber on <>
================================================================================

set -C
echo foo >| $TMP/no-clobber
exec 3<> $TMP/no-clobber
read -n 1 <&3
echo -n . >&3
exec 3>&-
cat $TMP/no-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber on >>
================================================================================

rm -f $TMP/no-clobber

set -C
echo foo >> $TMP/no-clobber
echo status=$?

cat $TMP/no-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber on &> >
================================================================================

case $SH in dash) exit ;; esac

set -C

rm -f $TMP/no-clobber
echo foo > $TMP/no-clobber
echo stdout=$?
echo bar > $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

rm -f $TMP/no-clobber
echo baz &> $TMP/no-clobber
echo both=$?
echo foo &> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: noclobber on &>> >>
================================================================================

case $SH in dash) echo 'flaky'; exit ;; esac

set -C

rm -f $TMP/no-clobber
echo foo >> $TMP/no-clobber
echo stdout=$?
echo bar >> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

rm -f $TMP/no-clobber
echo baz &>> $TMP/no-clobber
echo both=$?
echo foo &>> $TMP/no-clobber
echo again=$?
cat $TMP/no-clobber

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: set without args lists variables
================================================================================

__GLOBAL=g
f() {
  local __mylocal=L
  local __OTHERLOCAL=L
  __GLOBAL=mutated
  set | grep '^__'
}
g() {
  local __var_in_parent_scope=D
  f
}
g

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: set without args and array variables
================================================================================

declare -a __array
__array=(1 2 '3 4')
set | grep '^__'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: set without args and assoc array variables (not in OSH)
================================================================================

typeset -A __assoc
__assoc['k e y']='v a l'
__assoc[a]=b
set | grep '^__'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -q
================================================================================

shopt -q nullglob
echo nullglob=$?

# set it
shopt -s nullglob

shopt -q nullglob
echo nullglob=$?

shopt -q nullglob failglob
echo nullglob,failglob=$?

# set it
shopt -s failglob
shopt -q nullglob failglob
echo nullglob,failglob=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -q invalid
================================================================================

shopt -q invalidZZ
echo invalidZZ=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -s strict:all
================================================================================

n=2

show-strict() {
  shopt -p | grep 'strict_' | head -n $n
  echo -
}

show-strict
shopt -s strict:all
show-strict
shopt -u strict_argv
show-strict

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt allows for backward compatibility like bash
================================================================================


# doesn't have to be on, but just for testing
set -o errexit

shopt -p nullglob || true  # bash returns 1 here?  Like -q.

# This should set nullglob, and return 1, which can be ignored
shopt -s nullglob strict_OPTION_NOT_YET_IMPLEMENTED 2>/dev/null || true
echo status=$?

shopt -p nullglob || true

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -p validates option names
================================================================================

shopt -p nullglob invalid failglob
echo status=$?
# same thing as -p, slightly different format in bash
shopt nullglob invalid failglob > $TMP/out.txt
status=$?
sed --regexp-extended 's/\s+/ /' $TMP/out.txt  # make it easier to assert
echo status=$status

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -p -o validates option names
================================================================================

shopt -p -o errexit invalid nounset
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: stubbed out bash options
================================================================================

shopt -s ignore_shopt_not_impl
for name in foo autocd cdable_vars checkwinsize; do
  shopt -s $name
  echo $?
done

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -s nounset works in YSH, not in bash
================================================================================

case $SH in
  *dash|*mksh)
    echo N-I
    exit
    ;;
esac
shopt -s nounset
echo status=$?

# get rid of extra space in bash output
set -o | grep nounset | sed 's/[ \t]\+/ /g'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: Unimplemented options - print, query, set, unset
================================================================================

case $SH in dash|mksh) exit ;; esac

opt_name=xpg_echo

shopt -p xpg_echo
shopt -q xpg_echo; echo q=$?

shopt -s xpg_echo
shopt -p xpg_echo

shopt -u xpg_echo
shopt -p xpg_echo
echo p=$?  # weird, bash also returns a status

shopt xpg_echo >/dev/null
echo noflag=$?

shopt -o errexit >/dev/null
echo set=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: Unimplemented options - OSH shopt -s ignore_shopt_not_impl
================================================================================

case $SH in dash|mksh) exit ;; esac

shopt -s ignore_shopt_not_impl

opt_name=xpg_echo

shopt -p xpg_echo
shopt -q xpg_echo; echo q=$?

shopt -s xpg_echo
shopt -p xpg_echo

shopt -u xpg_echo
shopt -p xpg_echo
echo p=$?  # weird, bash also returns a status

shopt xpg_echo >/dev/null
echo noflag=$?

shopt -o errexit >/dev/null
echo set=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: shopt -p exit code (regression)
================================================================================

case $SH in dash|mksh) exit ;; esac

shopt -p > /dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-options.test.sh: no-ops not shown by shopt -p
================================================================================


shopt -p | grep xpg
echo --

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: sh -c
================================================================================

$SH -c 'echo hi'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: empty -c input
================================================================================

# had a bug here
$SH -c ''

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: sh +c is accepted
================================================================================

$SH +c 'echo hi'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: empty stdin
================================================================================

# had a bug here
echo -n '' | $SH

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: sh - and sh -- stop flag processing
================================================================================

case $SH in zsh) exit ;; esac

echo 'echo foo' > foo.sh

$SH -x -v -- foo.sh

echo -  
echo - >& 2

$SH -x -v - foo.sh

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: shell obeys --help (regression for OSH)
================================================================================

n=$($SH --help | wc -l)
if test $n -gt 0; then
  echo yes
fi

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: args are passed
================================================================================

$SH -c 'argv.py "$@"' dummy a b

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: args that look like flags are passed after script
================================================================================

script=$TMP/sh1.sh
echo 'argv.py "$@"' > $script
chmod +x $script
$SH $script --help --help -h

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: args that look like flags are passed after -c
================================================================================

$SH -c 'argv.py "$@"' --help --help -h

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: exit with explicit arg
================================================================================

exit 42

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: exit with no args
================================================================================

false
exit

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: --rcfile in non-interactive shell prints warnings
================================================================================

echo 'echo rc' > rc

$SH --rcfile rc -i </dev/null 2>interactive.txt
grep -q 'warning' interactive.txt
echo warned=$? >&2

$SH --rcfile rc </dev/null 2>non-interactive.txt
grep -q 'warning' non-interactive.txt
echo warned=$? >&2

head *interactive.txt

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: accepts -l flag
================================================================================

$SH -l -c 'exit 0'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: accepts --login flag (dash and mksh don't accept long flags)
================================================================================

$SH --login -c 'exit 0'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: osh --eval
================================================================================

case $SH in bash|dash|mksh|zsh) exit ;; esac

echo 'echo one "$@"' > one.sh
echo 'echo fail "$@"; ( exit 42 )' > fail.sh

$SH --eval one.sh \
  -c 'echo status=$? flag -c "$@"' dummy x y z
echo

# Even though errexit is off, the shell exits if the last status of an --eval
# file was non-zero.

$SH --eval one.sh --eval fail.sh \
  -c 'echo status=$? flag -c "$@"' dummy x y z
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: Set LC_ALL LC_CTYPE LC_COLLATE LANG - affects glob ?
================================================================================


# note: test/spec-common.sh sets LC_ALL
unset LC_ALL

touch _x_ __

LC_ALL=C       $SH -c 'echo LC_ALL _?_'
LC_ALL=C.UTF-8 $SH -c 'echo LC_ALL _?_'
echo

LC_CTYPE=C       $SH -c 'echo LC_CTYPE _?_'
LC_CTYPE=C.UTF-8 $SH -c 'echo LC_CTYPE _?_'
echo

LC_COLLATE=C       $SH -c 'echo LC_COLLATE _?_'
LC_COLLATE=C.UTF-8 $SH -c 'echo LC_COLLATE _?_'
echo

LANG=C       $SH -c 'echo LANG _?_'
LANG=C.UTF-8 $SH -c 'echo LANG _?_'

--------------------------------------------------------------------------------

(program)

================================================================================
sh-usage.test.sh: LC_CTYPE=invalid
================================================================================


# note: test/spec-common.sh sets LC_ALL
unset LC_ALL

touch _x_ __

{ LC_CTYPE=invalid $SH -c 'echo LC_CTYPE _?_' 
} 2> err.txt

#cat err.txt
wc -l err.txt

--------------------------------------------------------------------------------

(program)

================================================================================
shell-bugs.test.sh: ./configure idiom
================================================================================

set -o errexit

if command time -f '%e %M' true; then
  echo 'supports -f'
  # BUG: this was wrong
  #time -f '%e %M' true

  # Need 'command time'
  command time -f '%e %M' true
fi

if env time -f '%e %M' true; then
  echo 'env'
  env time -f '%e %M' true
fi

--------------------------------------------------------------------------------

(program)

================================================================================
shell-grammar.test.sh: Simple command
================================================================================

echo

#### Command with args
echo word word

#### Command with trailer
echo word word &

#### a & b
echo word_a & echo word_b

#### a & b &
echo word_a & echo word_b &

#### a && b 
echo word_a && echo word_b 

#### a || b 
echo word_a || echo word_b 

#### a && b || c
echo word_a && echo word_b || echo

#### Invalid token
invalid
# TODO: change these to qualifiers!

--------------------------------------------------------------------------------

(program)

================================================================================
shell-grammar.test.sh: Function def
================================================================================

name_a() {
  echo word_a
  echo word_b
}

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: builtin
================================================================================

echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: command sub
================================================================================

echo $(expr 3)

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: command sub with builtin
================================================================================

echo $(echo hi)

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: pipeline
================================================================================

hostname | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: pipeline with builtin
================================================================================

echo hi | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: and-or chains
================================================================================

echo 1 && echo 2 || echo 3 && echo 4
echo --
false || echo A
false || false || echo B
false || false || echo C && echo D || echo E

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: here doc with var
================================================================================

v=one
tac <<EOF
$v
"two
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: here doc without var
================================================================================

tac <<"EOF"
$v
"two
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: here doc with builtin
================================================================================

read var <<EOF
value
EOF
echo "var = $var"

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: Redirect external command
================================================================================

expr 3 > $TMP/expr3.txt
cat $TMP/expr3.txt

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: Redirect with builtin
================================================================================

echo hi > hi.txt
cat hi.txt

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: Here doc with redirect
================================================================================

cat <<EOF >smoke1.txt
one
two
EOF
wc -c smoke1.txt

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: "$@" "$*"
================================================================================

fun () {
  argv.py "$@" "$*"
}
fun "a b" "c d"

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: $@ $*
================================================================================

fun() {
  argv.py $@ $*
}
fun "a b" "c d"

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: failed command
================================================================================

ls /nonexistent-zzZZ

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: subshell
================================================================================

(echo 1; echo 2)

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: for loop
================================================================================

for i in a b c
do
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
smoke.test.sh: vars
================================================================================

a=5
echo $a ${a} "$a ${a}"

--------------------------------------------------------------------------------

(program)

================================================================================
spec-harness-bug.test.sh: osh-native duplicates stdin - is this a test harness issue?
================================================================================


echo $0 | grep -o sh

--------------------------------------------------------------------------------

(program)

================================================================================
subshell.test.sh: Subshell exit code
================================================================================

( false; )
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
subshell.test.sh: Subshell with redirects
================================================================================

( echo 1 ) > a.txt
( env echo 2 ) > b.txt
( env echo 3; ) > c.txt  # Sentence in LST
( echo 4; echo 5 ) > d.txt
echo status=$?
cat a.txt b.txt c.txt d.txt

--------------------------------------------------------------------------------

(program)

================================================================================
temp-binding.test.sh: More eval 'local v='
================================================================================

case $SH in mksh) exit ;; esac

set -u

f() {
  # The temp env messes it up
  tmp1= local x=x
  tmp2= eval 'local y=y'

  # similar to eval
  tmp3= . $REPO_ROOT/spec/testdata/define-local-var-z.sh

  # Bug does not appear with only eval
  #eval 'local v=hello'

  #declare -p v
  echo x=$x
  echo y=$y
  echo z=$z
}

f 

--------------------------------------------------------------------------------

(program)

================================================================================
temp-binding.test.sh: Temp bindings with local
================================================================================


f() {
  local x=x
  tmp='' local tx=tx

  # Hm both y and ty persist in bash/zsh
  eval 'local y=y'
  tmp='' eval 'local ty=ty'

  # Why does this have an effect in OSH?  Oh because 'unset' is a special
  # builtin
  if true; then
    x='X' unset x
    tx='TX' unset tx
    y='Y' unset y
    ty='TY' unset ty
  fi

  #unset y
  #unset ty

  echo x=$x
  echo tx=$tx
  echo y=$y
  echo ty=$ty
}

f

--------------------------------------------------------------------------------

(program)

================================================================================
temp-binding.test.sh: Temp bindings with unset
================================================================================


# key point:
# unset looks up the stack
# local doesn't though

x=42
unset x
echo x=$x

echo ---

x=42
tmp= unset x
echo x=$x

x=42
tmp= eval 'unset x'
echo x=$x

echo ---

shadow() {
  x=42
  x=tmp unset x
  echo x=$x
  
  x=42
  x=tmp eval 'unset x'
  echo x=$x
}

shadow

echo ---

case $SH in
  bash) set -o posix ;;
esac
shadow

# Now shadow

# unset is a special builtin
# type unset

--------------------------------------------------------------------------------

(program)

================================================================================
temp-binding.test.sh: FOO=bar $unset - temp binding, then empty argv from unquoted unset var (#2411)
================================================================================

foo=alive! $unset
echo $foo

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Fatal error
================================================================================

# http://landley.net/notes.html#20-06-2020

abc=${a?bc} echo hello; echo blah

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: setting readonly var (bash is only one where it's non-fatal)
================================================================================

# https://landley.net/notes-2020.html#20-06-2020

readonly abc=123
abc=def
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: readonly with temp binding
================================================================================

# http://landley.net/notes.html#20-06-2020

# temp binding
readonly abc=123
abc=def echo one
echo status=$?

echo potato < /does/not/exist || echo hello

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Failed redirect in assignment, vs. export
================================================================================


abc=def > /does/not/exist1
echo abc=$abc

export abc=def > /does/not/exist2
echo abc=$abc

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Evaluation order of redirect and ${undef?error}
================================================================================

# http://landley.net/notes.html#12-06-2020

rm -f walrus
$SH -c 'X=${x?bc} > walrus'
if test -f walrus; then echo 'exists1'; fi

rm -f walrus
$SH -c '>walrus echo ${a?bc}'
test -f walrus
if test -f walrus; then echo 'exists2'; fi

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Function def in pipeline
================================================================================

# http://landley.net/notes.html#26-05-2020

echo hello | potato() { echo abc; } | echo ha

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: dynamic glob - http://landley.net/notes.html#08-05-2020
================================================================================

touch foo
X='*'; echo $X
echo "*"*".?z"

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: no shebang
================================================================================

cat > snork << 'EOF'
echo hello $BLAH
EOF

chmod +x snork
$SH -c 'BLAH=123; ./snork'
$SH -c 'BLAH=123; exec ./snork'
$SH -c 'BLAH=123 exec ./snork'

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS
================================================================================


IFS=x; X=abxcd; echo ${X/bxc/g}

X=a=\"\$a\"; echo ${X//a/{x,y,z}}

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: shift is fatal at top level?
================================================================================

# http://landley.net/notes.html#08-04-2020

# This makes a difference for zsh, but not for bash?
#set -o posix

$SH -c 'shift; echo hello'

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: var and func - http://landley.net/notes.html#19-03-2020
================================================================================

potato() { echo hello; }
potato=42
echo $potato

potato

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS - http://landley.net/notes.html#05-03-2020
================================================================================

case $SH in zsh) exit ;; esac

IFS=x
chicken() { for i in "$@"; do echo =$i=; done;}
chicken one abc dxf ghi

echo ---
myfunc() { "$SH" -c 'IFS=x; for i in $@; do echo =$i=; done' blah "$@"; }
myfunc one "" two

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS=x and '' and unquoted $@ - reduction of case above - copied into spec/word-split
================================================================================


setopt SH_WORD_SPLIT
#set -x

set -- one "" two

IFS=x

argv.py $@

for i in $@; do
  echo -$i-
done

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: for loop parsing - http://landley.net/notes.html#04-03-2020
================================================================================


$SH -c '
for i
in one two three
do echo $i;
done
'
echo $?

$SH -c 'for i; in one two three; do echo $i; done'
test $? -ne 0 && echo cannot-parse

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Parsing $(( ))
================================================================================

# http://landley.net/notes.html#15-03-2020
$SH -c 'echo $((echo hello))'
if test $? -ne 0; then echo fail; fi

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS - http://landley.net/notes.html#15-02-2020 (TODO: osh)
================================================================================


IFS=x
A=xabcxx
for i in $A; do echo =$i=; done
echo

unset IFS
A="   abc   def   "
for i in ""$A""; do echo =$i=; done

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS 2 - copied into spec/word-split
================================================================================

# this one appears different between osh and bash
A="   abc   def   "; for i in ""x""$A""; do echo =$i=; done

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS 3
================================================================================

IFS=x; X="onextwoxxthree"; y=$X; echo $y

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS 4
================================================================================


setopt SH_WORD_SPLIT

IFS=x

func1() {
  echo /$*/
  for i in $*; do echo -$i-; done
}
func1 "" ""

echo

func2() {
  echo /"$*"/
  for i in =$*=; do echo -$i-; done
}
func2 "" ""

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: IFS 5
================================================================================

cc() { for i in $*; do echo -$i-; done;}; cc "" "" "" "" ""
cc() { echo =$1$2=;}; cc "" ""

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Can't parse extra }
================================================================================


$SH -c 'for i in a"$@"b;do echo =$i=;done;}' 123 456 789

--------------------------------------------------------------------------------

(program)

================================================================================
toysh-posix.test.sh: Pipeline - http://landley.net/notes-2019.html#16-12-2019
================================================================================

echo hello | { read i; echo $i;} | { read i; echo $i;} | cat
echo hello | while read i; do echo -=$i=- | sed s/=/@/g ; done | cat

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: @Q
================================================================================

# http://landley.net/notes.html#24-06-2020

# Fix these
case $SH in dash|mksh|zsh) exit ;; esac

xx() { echo "${*@Q}";}; xx a b c d
xx() { echo "${@@Q}";}; xx a b c d

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: extglob $IFS 1
================================================================================

# http://landley.net/notes.html#12-06-2020
shopt -s extglob

touch abc\)d
echo ab+(c?d)

IFS=c ABC="c?d"
echo ab+($ABC)

ABC='*'
echo $ABC

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: extglob $IFS 2
================================================================================

# http://landley.net/notes.html#17-05-2020

shopt -s extglob  # required for bash, not osh
IFS=x; ABC=cxd; for i in +($ABC); do echo =$i=; done

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: char class / extglob
================================================================================

# http://landley.net/notes.html#14-05-2020
shopt -s extglob

touch l; echo [hello"]"

touch b
echo [$(echo abc)]

touch +
echo [+()]
echo [+(])

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: patsub of $* - http://landley.net/notes.html#23-04-2020
================================================================================

chicken() { echo ${*/b c/ghi}; }; chicken a b c d

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: Brace Expansion
================================================================================

# http://landley.net/notes.html#04-01-2020

HOME=/home/foo

echo {~,~root}/pwd
echo \{~,~root}/pwd
echo ""{~,~root}/pwd

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: {abc}<<< - http://landley.net/notes-2019.html#09-12-2019
================================================================================

{ echo; } {abc}<<< walrus
cat <&$abc

--------------------------------------------------------------------------------

(program)

================================================================================
toysh.test.sh: slice of @ and @ - http://landley.net/notes.html#23-04-2020
================================================================================

IFS=x; X=x; eval abc=a${X}b

chicken() { for i in "${@:3:5}"; do echo =$i=; done; } ; chicken ab cd ef gh ij kl mn op qr

chicken() { for i in "${*:3:5}"; do echo =$i=; done; } ; chicken ab cd ef gh ij kl mn op qr

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare -i -l -u errors can be silenced - ignore_flags_not_impl
================================================================================


declare -i foo=2+3
echo status=$?
echo foo=$foo
echo

shopt -s ignore_flags_not_impl
declare -i bar=2+3
echo status=$?
echo bar=$bar

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare -i with +=
================================================================================

declare s
s='1 '
s+=' 2 '  # string append

declare -i i
i='1 '
i+=' 2 '  # arith add

declare -i j
j=x  # treated like zero
j+=' 2 '  # arith add

echo "[$s]"
echo [$i]
echo [$j]

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare -i with arithmetic inside strings (Nix, issue 864)
================================================================================


# example
# https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh#L379

declare -i s
s='1 + 2'
echo s=$s

declare -a array=(1 2 3)
declare -i item
item='array[1+1]'
echo item=$item

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: append in arith context
================================================================================

declare s
(( s='1 '))
(( s+=' 2 '))  # arith add
declare -i i
(( i='1 ' ))
(( i+=' 2 ' ))
declare -i j
(( j='x ' ))  # treated like zero
(( j+=' 2 ' ))
echo "$s|$i|$j"

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare array vs. string: mixing -a +a and () ''
================================================================================

# dynamic parsing of first argument.
declare +a 'xyz1=1'
declare +a 'xyz2=(2 3)'
declare -a 'xyz3=4'
declare -a 'xyz4=(5 6)'
argv.py "${xyz1}" "${xyz2}" "${xyz3[@]}" "${xyz4[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare array vs. associative array
================================================================================

# Hm I don't understand why the array only has one element.  I guess because
# index 0 is used twice?
declare -a 'array=([a]=b [c]=d)'
declare -A 'assoc=([a]=b [c]=d)'
argv.py "${#array[@]}" "${!array[@]}" "${array[@]}"
argv.py "${#assoc[@]}" "${!assoc[@]}" "${assoc[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
type-compat.test.sh: declare -l -u
================================================================================


declare -l lower=FOO
declare -u upper=foo

echo $lower
echo $upper

# other:
# -t trace
# -I inherit attributes

--------------------------------------------------------------------------------

(program)

================================================================================
vars-bash.test.sh: $SHELL is set to what is in /etc/passwd
================================================================================


sh=$(which $SH)

unset SHELL

prog='
if test -n "$SHELL"; then
  # the exact value is different on CI, so do not assert
  echo SHELL is set
  echo SHELL=$SHELL >&2
fi
'

$SH -c "$prog"

$SH -i -c "$prog"

# make it a login shell
$SH -l -c "$prog"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $PWD is set
================================================================================

# Just test that it has a slash for now.
echo $PWD | grep -q /
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $PWD is not only set, but exported
================================================================================

env | grep -q PWD
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $PATH is set if unset at startup
================================================================================


# WORKAROUND for Python version of bin/osh -- we can't run bin/oils_for_unix.py
# because it a shebang #!/usr/bin/env python2
# This test is still useful for the C++ oils-for-unix.

case $SH in
  */bin/osh)
    echo yes
    echo yes
    exit
    ;;
esac

# Get absolute path before changing PATH
sh=$(which $SH)

old_path=$PATH
unset PATH

$sh -c 'echo $PATH' > path.txt

PATH=$old_path

# looks like PATH=/usr/bin:/bin for mksh, but more complicated for others
# cat path.txt

# should contain /usr/bin
if egrep -q '(^|:)/usr/bin($|:)' path.txt; then
  echo yes
fi

# should contain /bin
if egrep -q '(^|:)/bin($|:)' path.txt ; then
  echo yes
fi

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $HOME is NOT set
================================================================================

case $SH in *zsh) echo 'zsh sets HOME'; exit ;; esac

home=$(echo $HOME)
test "$home" = ""
echo status=$?

env | grep HOME
echo status=$?

# not in interactive shell either
$SH -i -c 'echo $HOME' | grep /
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: Vars set interactively only: $HISTFILE
================================================================================

case $SH in dash|mksh|zsh) exit ;; esac

$SH --norc --rcfile /dev/null -c 'echo histfile=${HISTFILE:+yes}'
$SH --norc --rcfile /dev/null -i -c 'echo histfile=${HISTFILE:+yes}'

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: Some vars are set, even without startup file, or env: PATH, PWD
================================================================================


flags=''
case $SH in
  dash) exit ;;
  bash*)
    flags='--noprofile --norc --rcfile /devnull'
    ;;
  osh)
    flags='--rcfile /devnull'
    ;;
esac

sh_path=$(which $SH)

case $sh_path in
  */bin/osh)
    # Hack for running with Python2
    export PYTHONPATH="$REPO_ROOT:$REPO_ROOT/vendor"
    sh_prefix="$(which python2) $REPO_ROOT/bin/oils_for_unix.py osh"
    ;;
  *)
    sh_prefix=$sh_path
    ;;
esac

#echo PATH=$PATH


# mksh has typeset, not declare
# bash exports PWD, but not PATH PS4

/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p PATH PWD PS4' >&2
echo path pwd ps4 $?

/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p SHELLOPTS' >&2
echo shellopts $?

# bash doesn't set HOME, mksh and zsh do
/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p HOME PS1' >&2
echo home ps1 $?

# IFS is set, but not exported
/usr/bin/env -i PYTHONPATH=$PYTHONPATH $sh_prefix $flags -c 'typeset -p IFS' >&2
echo ifs $?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: UID EUID PPID can't be changed
================================================================================


# bash makes these 3 read-only
{
  UID=xx $SH -c 'echo uid=$UID'

  EUID=xx $SH -c 'echo euid=$EUID'

  PPID=xx $SH -c 'echo ppid=$PPID'

} > out.txt

# bash shows that vars are readonly
# zsh shows other errors
# cat out.txt
#echo

grep '=xx' out.txt
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: HOSTNAME OSTYPE can be changed
================================================================================

case $SH in zsh) exit ;; esac

#$SH -c 'echo hostname=$HOSTNAME'

HOSTNAME=x $SH -c 'echo hostname=$HOSTNAME'
OSTYPE=x $SH -c 'echo ostype=$OSTYPE'
echo

#PS4=x $SH -c 'echo ps4=$PS4'

# OPTIND is special
#OPTIND=xx $SH -c 'echo optind=$OPTIND'

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $1 .. $9 are scoped, while $0 is not
================================================================================

fun() {
  case $0 in
    *sh)
      echo 'sh'
      ;;
    *sh-*)  # bash-4.4 is OK
      echo 'sh'
      ;;
  esac

  echo $1 $2
}
fun a b

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $?
================================================================================

echo $?  # starts out as 0
sh -c 'exit 33'
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $#
================================================================================

set -- 1 2 3 4
echo $#

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $$ looks like a PID
================================================================================

echo $$ | egrep -q '[0-9]+'  # Test that it has decimal digits
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $$ doesn't change with subshell or command sub
================================================================================

# Just test that it has decimal digits
set -o errexit
die() {
  echo 1>&2 "$@"; exit 1
}
parent=$$
test -n "$parent" || die "empty PID in parent"
( child=$$
  test -n "$child" || die "empty PID in subshell"
  test "$parent" = "$child" || die "should be equal: $parent != $child"
  echo 'subshell OK'
)
echo $( child=$$
        test -n "$child" || die "empty PID in command sub"
        test "$parent" = "$child" || die "should be equal: $parent != $child"
        echo 'command sub OK'
      )
exit 3  # make sure we got here

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $BASHPID DOES change with subshell and command sub
================================================================================

set -o errexit
die() {
  echo 1>&2 "$@"; exit 1
}
parent=$BASHPID
test -n "$parent" || die "empty BASHPID in parent"
( child=$BASHPID
  test -n "$child" || die "empty BASHPID in subshell"
  test "$parent" != "$child" || die "should not be equal: $parent = $child"
  echo 'subshell OK'
)
echo $( child=$BASHPID
        test -n "$child" || die "empty BASHPID in command sub"
        test "$parent" != "$child" ||
          die "should not be equal: $parent = $child"
        echo 'command sub OK'
      )
exit 3  # make sure we got here

# mksh also implements BASHPID!

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: Background PID $! looks like a PID
================================================================================

sleep 0.01 &
pid=$!
wait
echo $pid | egrep '[0-9]+' >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $PPID
================================================================================

echo $PPID | egrep '[0-9]+'

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $PIPESTATUS
================================================================================

echo hi | sh -c 'cat; exit 33' | wc -l >/dev/null
argv.py "${PIPESTATUS[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $RANDOM
================================================================================

expr $0 : '.*/osh$' && exit 99  # Disabled because of spec-runner.sh issue
echo $RANDOM | egrep '[0-9]+'

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $UID and $EUID
================================================================================

# These are both bash-specific.
set -o errexit
echo $UID | egrep -o '[0-9]+' >/dev/null
echo $EUID | egrep -o '[0-9]+' >/dev/null
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $OSTYPE is non-empty
================================================================================

test -n "$OSTYPE"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $HOSTNAME
================================================================================

test "$HOSTNAME" = "$(hostname)"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO is the current line, not line of function call
================================================================================

echo $LINENO  # first line
g() {
  argv.py $LINENO  # line 3
}
f() {
  argv.py $LINENO  # line 6
  g
  argv.py $LINENO  # line 8
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in "bare" redirect arg (bug regression)
================================================================================

filename=$TMP/bare3
rm -f $filename
> $TMP/bare$LINENO
test -f $filename && echo written
echo $LINENO

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in redirect arg (bug regression)
================================================================================

filename=$TMP/lineno_regression3
rm -f $filename
echo x > $TMP/lineno_regression$LINENO
test -f $filename && echo written
echo $LINENO

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in [[
================================================================================

echo one
[[ $LINENO -eq 2 ]] && echo OK

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in ((
================================================================================

echo one
(( x = LINENO ))
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in for loop
================================================================================

# hm bash doesn't take into account the word break.  That's OK; we won't either.
echo one
for x in \
  $LINENO zzz; do
  echo $x
done

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in other for loops
================================================================================

set -- a b c
for x; do
  echo $LINENO $x
done

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in for (( loop
================================================================================

# This is a real edge case that I'm not sure we care about.  We would have to
# change the span ID inside the loop to make it really correct.
echo one
for (( i = 0; i < $LINENO; i++ )); do
  echo $i
done

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO for assignment
================================================================================

a1=$LINENO a2=$LINENO
b1=$LINENO b2=$LINENO
echo $a1 $a2
echo $b1 $b2

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $LINENO in case
================================================================================

case $LINENO in
  1) echo 'got line 1' ;;
  *) echo line=$LINENO
esac

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with simple command and evaluation
================================================================================


name=world
echo "hi $name"
echo "$_"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ and ${_}
================================================================================

case $SH in dash|mksh) exit ;; esac

_var=value

: 42
echo $_ $_var ${_}var

: 'foo'"bar"
echo $_

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with word splitting
================================================================================

case $SH in dash|mksh) exit ;; esac

setopt shwordsplit  # for ZSH

x='with spaces'
: $x
echo $_

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with pipeline and subshell
================================================================================

case $SH in dash|mksh) exit ;; esac

shopt -s lastpipe

seq 3 | echo last=$_

echo pipeline=$_

( echo subshell=$_ )
echo done=$_

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with && and ||
================================================================================

case $SH in dash|mksh) exit ;; esac

echo hi && echo last=$_
echo and=$_

echo hi || echo last=$_
echo or=$_

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ is not reset with (( and [[
================================================================================


# bash is inconsistent because it does it for pipelines and assignments, but
# not (( and [[

case $SH in dash|mksh) exit ;; esac

echo simple
(( a = 2 + 3 ))
echo "(( $_"

[[ a == *.py ]]
echo "[[ $_"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with assignments, arrays, etc.
================================================================================

case $SH in dash|mksh) exit ;; esac

: foo
echo "colon [$_]"

s=bar
echo "bare assign [$_]"

# zsh uses declare; bash uses s=bar
declare s=bar
echo "declare [$_]"

# zsh remains s:declare, bash resets it
a=(1 2)
echo "array [$_]"

# zsh sets it to declare, bash uses the LHS a
declare a=(1 2)
echo "declare array [$_]"

declare -g d=(1 2)
echo "declare flag [$_]"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ with loop
================================================================================


case $SH in dash|mksh) exit ;; esac

# zsh resets it when in a loop

echo init
echo begin=$_
for x in 1 2 3; do
  echo prev=$_
done

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $_ is not undefined on first use
================================================================================

set -e

x=$($SH -u -c 'echo prev=$_')
echo status=$?

# bash and mksh set $_ to $0 at first; zsh is empty
#echo "$x"

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: BASH_VERSION / OILS_VERSION
================================================================================

case $SH in
  bash*)
    # BASH_VERSION=zz

    echo $BASH_VERSION | egrep -o '4\.4\.0' > /dev/null
    echo matched=$?
    ;;
  *osh)
    # note: version string is mutable like in bash.  I guess that's useful for
    # testing?  We might want a strict mode to eliminate that?

    echo $OILS_VERSION | egrep -o '[0-9]+\.[0-9]+\.' > /dev/null
    echo matched=$?
    ;;
  *)
    echo 'no version'
    ;;
esac

--------------------------------------------------------------------------------

(program)

================================================================================
vars-special.test.sh: $SECONDS
================================================================================


# most likely 0 seconds, but in CI I've seen 1 second
echo $SECONDS | awk '/[0-9]+/ { print "ok" }'

--------------------------------------------------------------------------------

(program)

================================================================================
whitespace.test.sh: Parsing shell words \r \v
================================================================================


# frontend/lexer_def.py has rules for this

tab=$(python2 -c 'print "argv.py -\t-"')
cr=$(python2 -c 'print "argv.py -\r-"')
vert=$(python2 -c 'print "argv.py -\v-"')
ff=$(python2 -c 'print "argv.py -\f-"')

$SH -c "$tab"
$SH -c "$cr"
$SH -c "$vert"
$SH -c "$ff"

--------------------------------------------------------------------------------

(program)

================================================================================
whitespace.test.sh: \r in arith expression is allowed by some shells, but not most!
================================================================================


arith=$(python2 -c 'print "argv.py $(( 1 +\n2))"')
arith_cr=$(python2 -c 'print "argv.py $(( 1 +\r\n2))"')

$SH -c "$arith"
if test $? -ne 0; then
  echo 'failed'
fi

$SH -c "$arith_cr"
if test $? -ne 0; then
  echo 'failed'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
whitespace.test.sh: whitespace in string to integer conversion
================================================================================


tab=$(python2 -c 'print "\t42\t"')
cr=$(python2 -c 'print "\r42\r"')

$SH -c 'echo $(( $1 + 1 ))' dummy0 "$tab"
if test $? -ne 0; then
  echo 'failed'
fi

$SH -c 'echo $(( $1 + 1 ))' dummy0 "$cr"
if test $? -ne 0; then
  echo 'failed'
fi

--------------------------------------------------------------------------------

(program)

================================================================================
whitespace.test.sh: \r at end of line is not special
================================================================================


# hm I wonder if Windows ports have rules for this?

cr=$(python2 -c 'print "argv.py -\r"')

$SH -c "$cr"

--------------------------------------------------------------------------------

(program)

================================================================================
whitespace.test.sh: Default IFS does not include \r \v \f
================================================================================


# dash and zsh don't have echo -e
tab=$(python2 -c 'print "-\t-"')
cr=$(python2 -c 'print "-\r-"')
vert=$(python2 -c 'print "-\v-"')
ff=$(python2 -c 'print "-\f-"')

$SH -c 'argv.py $1' dummy0 "$tab"
$SH -c 'argv.py $1' dummy0 "$cr"
$SH -c 'argv.py $1' dummy0 "$vert"
$SH -c 'argv.py $1' dummy0 "$ff"

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-assoc.test.sh: TODO: SETUP should be shared
================================================================================

typeset -A a
a=(aa b foo bar a+1 c)

#### retrieve key
typeset -A a
a=(aa b foo bar a+1 c)
echo ${a[aa]}

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-assoc.test.sh: set key
================================================================================

typeset -A a
a=(aa b foo bar a+1 c)
a[X]=XX
argv.py "${a[@]}"
# What order is this?

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-assoc.test.sh: iterate over keys
================================================================================

typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
for k in "${(@k)assoc}"; do
  echo "$k: $assoc[$k]"
done

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-assoc.test.sh: get length
================================================================================

typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
echo ${#assoc} ${#assoc[k1]}

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-assoc.test.sh: index by integer does not work
================================================================================

typeset -A assoc
assoc=(k1 v1 k2 v2 k3 v3)
argv.py "${assoc[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-idioms.test.sh: git-completion snippet
================================================================================


# copied directly from git completion - 2024-04

if false; then
  unset ${(M)${(k)parameters[@]}:#__gitcomp_builtin_*} 2>/dev/null
fi
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-idioms.test.sh: asdf snippet
================================================================================


# copied directly from asdf - 2024-04

if false; then
  ASDF_DIR=${(%):-%x}
fi

--------------------------------------------------------------------------------

(program)

================================================================================
zsh-idioms.test.sh: zsh var sub is rejected at runtime
================================================================================


eval 'echo z ${(m)foo} z'
echo status=$?

eval 'echo ${x:-${(m)foo}}'
echo status=$?

# double quoted
eval 'echo "${(m)foo}"'
echo status=$?

--------------------------------------------------------------------------------

(program)
