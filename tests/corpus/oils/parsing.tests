# Converted from Oils corpus: parsing.txt

=== Multiple right brackets inside expression
a=(1 2 3)
echo ${a[a[0]]} ${a[a[a[0]]]}
---
(command (word "a=(1 2 3)"))
(command (word "echo") (word "${a[a[0]]}") (word "${a[a[a[0]]]}"))
---

=== Slicing of string with constants
s='abcd'
echo ${s:0} ${s:0:4} ${s:1:1}
---
(command (word "s='abcd'"))
(command (word "echo") (word "${s:0}") (word "${s:0:4}") (word "${s:1:1}"))
---

=== Slicing of string with variables
s='abcd'
zero=0
one=1
echo ${s:$zero} ${s:$zero:4} ${s:$one:$one}
---
(command (word "s='abcd'"))
(command (word "zero=0"))
(command (word "one=1"))
(command (word "echo") (word "${s:$zero}") (word "${s:$zero:4}") (word "${s:$one:$one}"))
---

=== Array index on LHS of assignment
a=(1 2 3)
zero=0
a[zero+5-4]=X
echo ${a[@]}
---
(command (word "a=(1 2 3)"))
(command (word "zero=0"))
(command (word "a[zero+5-4]=X"))
(command (word "echo") (word "${a[@]}"))
---

=== Array index on LHS with indices
a=(1 2 3)
a[a[1]]=X
echo ${a[@]}
---
(command (word "a=(1 2 3)"))
(command (word "a[a[1]]=X"))
(command (word "echo") (word "${a[@]}"))
---

=== Slicing of string with expressions
# mksh accepts ${s:0} and ${s:$zero} but not ${s:zero}
# zsh says unrecognized modifier 'z'
s='abcd'
zero=0
echo ${s:zero} ${s:zero+0} ${s:zero+1:zero+1}
---
(command (word "s='abcd'"))
(command (word "zero=0"))
(command (word "echo") (word "${s:zero}") (word "${s:zero+0}") (word "${s:zero+1:zero+1}"))
---

=== Ambiguous colon in slice
s='abcd'
echo $(( 0 < 1 ? 2 : 0 ))  # evaluates to 2
echo ${s: 0 < 1 ? 2 : 0 : 1}  # 2:1 -- TRICKY THREE COLONS
---
(command (word "s='abcd'"))
(command (word "echo") (word "$(( 0 < 1 ? 2 : 0 ))"))
(command (word "echo") (word "${s: 0 < 1 ? 2 : 0 : 1}"))
---

=== Triple parens should be disambiguated
# The first paren is part of the math, parens 2 and 3 are a single token ending
# arith sub.
((a=1 + (2*3)))
echo $a $((1 + (2*3)))
---
(arith (word "a=1 + (2*3)"))
(command (word "echo") (word "$a") (word "$((1 + (2*3)))"))
---

=== Quadruple parens should be disambiguated
((a=1 + (2 * (3+4))))
echo $a $((1 + (2 * (3+4))))
---
(arith (word "a=1 + (2 * (3+4))"))
(command (word "echo") (word "$a") (word "$((1 + (2 * (3+4))))"))
---

=== $[ is a synonym for $((
echo $[1+2] $[3 * 4]
---
(command (word "echo") (word "$[1+2]") (word "$[3 * 4]"))
---

=== $[$var is a synonym for $(($var (#2426)
var=1
echo $[$var+2]
---
(command (word "var=1"))
(command (word "echo") (word "$[$var+2]"))
---

=== $[$undefined] is a synonym for $(($undefined (#2566)
a[0]=$[1+3]
b[0]=$[b[0]]
c[0]=$[b[0]]
echo ${c[0]}
---
(command (word "a[0]=$[1+3]"))
(command (word "b[0]=$[b[0]]"))
(command (word "c[0]=$[b[0]]"))
(command (word "echo") (word "${c[0]}"))
---

=== Empty expression (( ))  $(( ))
(( ))
echo status=$?

echo $(( ))

#echo $[]
---
(arith (word " "))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "$(( ))"))
---

=== Empty expression for (( ))
for (( ; ; )); do
  echo one
  break
done
---
(arith-for (init (word "1")) (test (word "1")) (step (word "1")) (semi (command (word "echo") (word "one")) (command (word "break"))))
---

=== Empty expression in ${a[@]: : }
a=(a b c d e f)

# space required here -- see spec/var-op-slice
echo slice ${a[@]: }
echo status=$?
echo

echo slice ${a[@]: : }
echo status=$?
echo

# zsh doesn't accept this
echo slice ${a[@]:: }
echo status=$?
---
(command (word "a=(a b c d e f)"))
(command (word "echo") (word "slice") (word "${a[@]: }"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "echo") (word "slice") (word "${a[@]: : }"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "echo") (word "slice") (word "${a[@]:: }"))
(command (word "echo") (word "status=$?"))
---

=== Empty expression a[]
a=(1 2 3)

a[]=42
echo status=$?
echo ${a[@]}

echo ${a[]}
echo status=$?
---
(command (word "a=(1 2 3)"))
(command (word "a[]=42"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "${a[@]}"))
(command (word "echo") (word "${a[]}"))
(command (word "echo") (word "status=$?"))
---

=== Double quotes
echo $(( "1 + 2" * 3 ))
echo $(( "1+2" * 3 ))
---
(command (word "echo") (word "$(( \"1 + 2\" * 3 ))"))
(command (word "echo") (word "$(( \"1+2\" * 3 ))"))
---

=== Single quotes
echo $(( '1' + '2' * 3 ))
echo status=$?

echo $(( '1 + 2' * 3 ))
echo status=$?
---
(command (word "echo") (word "$(( '1' + '2' * 3 ))"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "$(( '1 + 2' * 3 ))"))
(command (word "echo") (word "status=$?"))
---

=== Substitutions
x='1 + 2'
echo $(( $x * 3 ))
echo $(( "$x" * 3 ))
---
(command (word "x='1 + 2'"))
(command (word "echo") (word "$(( $x * 3 ))"))
(command (word "echo") (word "$(( \"$x\" * 3 ))"))
---

=== Variable references
x='1'
echo $(( x + 2 * 3 ))
echo status=$?

# Expression like values are evaluated first (this is unlike double quotes)
x='1 + 2'
echo $(( x * 3 ))
echo status=$?
---
(command (word "x='1'"))
(command (word "echo") (word "$(( x + 2 * 3 ))"))
(command (word "echo") (word "status=$?"))
(command (word "x='1 + 2'"))
(command (word "echo") (word "$(( x * 3 ))"))
(command (word "echo") (word "status=$?"))
---

=== Side Effect in Array Indexing
a=(4 5 6)
echo "${a[b=2]} b=$b"
---
(command (word "a=(4 5 6)"))
(command (word "echo") (word "\"${a[b=2]} b=$b\""))
---

=== Add one to var
i=1
echo $(($i+1))
---
(command (word "i=1"))
(command (word "echo") (word "$(($i+1))"))
---

=== $ is optional
i=1
echo $((i+1))
---
(command (word "i=1"))
(command (word "echo") (word "$((i+1))"))
---

=== SimpleVarSub within arith
j=0
echo $(($j + 42))
---
(command (word "j=0"))
(command (word "echo") (word "$(($j + 42))"))
---

=== BracedVarSub within ArithSub
echo $((${j:-5} + 1))
---
(command (word "echo") (word "$((${j:-5} + 1))"))
---

=== Arith word part
foo=1; echo $((foo+1))bar$(($foo+1))
---
(semi (command (word "foo=1")) (command (word "echo") (word "$((foo+1))bar$(($foo+1))")))
---

=== Arith sub with word parts
# Making 13 from two different kinds of sub.  Geez.
echo $((1 + $(echo 1)${undefined:-3}))
---
(command (word "echo") (word "$((1 + $(echo 1)${undefined:-3}))"))
---

=== Constant with quotes like '1'
# NOTE: Compare with [[.  That is a COMMAND level expression, while this is a
# WORD level expression.
echo $(('1' + 2))
---
(command (word "echo") (word "$(('1' + 2))"))
---

=== Arith sub within arith sub
# This is unnecessary but works in all shells.
echo $((1 + $((2 + 3)) + 4))
---
(command (word "echo") (word "$((1 + $((2 + 3)) + 4))"))
---

=== Backticks within arith sub
# This is unnecessary but works in all shells.
echo $((`echo 1` + 2))
---
(command (word "echo") (word "$((`echo 1` + 2))"))
---

=== Invalid string to int
# bash, mksh, and zsh all treat strings that don't look like numbers as zero.
shopt -u strict_arith || true
s=foo
echo $((s+5))
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "s=foo"))
(command (word "echo") (word "$((s+5))"))
---

=== Invalid string to int with strict_arith
shopt -s strict_arith || true
s=foo
echo $s
echo $((s+5))
echo 'should not get here'
---
(or (command (word "shopt") (word "-s") (word "strict_arith")) (command (word "true")))
(command (word "s=foo"))
(command (word "echo") (word "$s"))
(command (word "echo") (word "$((s+5))"))
(command (word "echo") (word "'should not get here'"))
---

=== Integer constant parsing
echo $(( 0x12A ))
echo $(( 0x0A ))
echo $(( 0777 ))
echo $(( 0010 ))
echo $(( 24#ag7 ))
---
(command (word "echo") (word "$(( 0x12A ))"))
(command (word "echo") (word "$(( 0x0A ))"))
(command (word "echo") (word "$(( 0777 ))"))
(command (word "echo") (word "$(( 0010 ))"))
(command (word "echo") (word "$(( 24#ag7 ))"))
---

=== Integer constant validation
check() {
  $SH -c "shopt --set strict_arith; echo $1"
  echo status=$?
}

check '$(( 0x1X ))'
check '$(( 09 ))'
check '$(( 2#A ))'
check '$(( 02#0110 ))'
---
(function "check" (brace-group (semi (command (word "$SH") (word "-c") (word "\"shopt --set strict_arith; echo $1\"")) (command (word "echo") (word "status=$?")))))
(command (word "check") (word "'$(( 0x1X ))'"))
(command (word "check") (word "'$(( 09 ))'"))
(command (word "check") (word "'$(( 2#A ))'"))
(command (word "check") (word "'$(( 02#0110 ))'"))
---

=== Newline in the middle of expression
echo $((1
+ 2))
---
(command (word "echo") (word "$((1\n+ 2))"))
---

=== Ternary operator
a=1
b=2
echo $((a>b?5:10))
---
(command (word "a=1"))
(command (word "b=2"))
(command (word "echo") (word "$((a>b?5:10))"))
---

=== Preincrement
a=4
echo $((++a))
echo $a
---
(command (word "a=4"))
(command (word "echo") (word "$((++a))"))
(command (word "echo") (word "$a"))
---

=== Postincrement
a=4
echo $((a++))
echo $a
---
(command (word "a=4"))
(command (word "echo") (word "$((a++))"))
(command (word "echo") (word "$a"))
---

=== Increment undefined variables
shopt -u strict_arith || true
(( undef1++ ))
(( ++undef2 ))
echo "[$undef1][$undef2]"
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(arith (word " undef1++ "))
(arith (word " ++undef2 "))
(command (word "echo") (word "\"[$undef1][$undef2]\""))
---

=== Increment and decrement array elements
shopt -u strict_arith || true
a=(5 6 7 8)
(( a[0]++, ++a[1], a[2]--, --a[3] ))
(( undef[0]++, ++undef[1], undef[2]--, --undef[3] ))
echo "${a[@]}" - "${undef[@]}"
---
(or (command (word "shopt") (word "-u") (word "strict_arith")) (command (word "true")))
(command (word "a=(5 6 7 8)"))
(arith (word " a[0]++, ++a[1], a[2]--, --a[3] "))
(arith (word " undef[0]++, ++undef[1], undef[2]--, --undef[3] "))
(command (word "echo") (word "\"${a[@]}\"") (word "-") (word "\"${undef[@]}\""))
---

=== Increment undefined variables with nounset
set -o nounset
(( undef1++ ))
(( ++undef2 ))
echo "[$undef1][$undef2]"
---
(command (word "set") (word "-o") (word "nounset"))
(arith (word " undef1++ "))
(arith (word " ++undef2 "))
(command (word "echo") (word "\"[$undef1][$undef2]\""))
---

=== Comma operator (borrowed from C)
a=1
b=2
echo $((a,(b+1)))
---
(command (word "a=1"))
(command (word "b=2"))
(command (word "echo") (word "$((a,(b+1)))"))
---

=== Augmented assignment
a=4
echo $((a+=1))
echo $a
---
(command (word "a=4"))
(command (word "echo") (word "$((a+=1))"))
(command (word "echo") (word "$a"))
---

=== Comparison Ops
echo $(( 1 == 1 ))
echo $(( 1 != 1 ))
echo $(( 1 < 1 ))
echo $(( 1 <= 1 ))
echo $(( 1 > 1 ))
echo $(( 1 >= 1 ))
---
(command (word "echo") (word "$(( 1 == 1 ))"))
(command (word "echo") (word "$(( 1 != 1 ))"))
(command (word "echo") (word "$(( 1 < 1 ))"))
(command (word "echo") (word "$(( 1 <= 1 ))"))
(command (word "echo") (word "$(( 1 > 1 ))"))
(command (word "echo") (word "$(( 1 >= 1 ))"))
---

=== Logical Ops
echo $((1 || 2))
echo $((1 && 2))
echo $((!(1 || 2)))
---
(command (word "echo") (word "$((1 || 2))"))
(command (word "echo") (word "$((1 && 2))"))
(command (word "echo") (word "$((!(1 || 2)))"))
---

=== Logical Ops Short Circuit
x=11
(( 1 || (x = 22) ))
echo $x
(( 0 || (x = 33) ))
echo $x
(( 0 && (x = 44) ))
echo $x
(( 1 && (x = 55) ))
echo $x
---
(command (word "x=11"))
(arith (word " 1 || (x = 22) "))
(command (word "echo") (word "$x"))
(arith (word " 0 || (x = 33) "))
(command (word "echo") (word "$x"))
(arith (word " 0 && (x = 44) "))
(command (word "echo") (word "$x"))
(arith (word " 1 && (x = 55) "))
(command (word "echo") (word "$x"))
---

=== Bitwise ops
echo $((1|2))
echo $((1&2))
echo $((1^2))
echo $((~(1|2)))
---
(command (word "echo") (word "$((1|2))"))
(command (word "echo") (word "$((1&2))"))
(command (word "echo") (word "$((1^2))"))
(command (word "echo") (word "$((~(1|2)))"))
---

=== Unary minus and plus
a=1
b=3
echo $((- a + + b))
---
(command (word "a=1"))
(command (word "b=3"))
(command (word "echo") (word "$((- a + + b))"))
---

=== No floating point
echo $((1 + 2.3))
---
(command (word "echo") (word "$((1 + 2.3))"))
---

=== Array indexing in arith
# zsh does 1-based indexing!
array=(1 2 3 4)
echo $((array[1] + array[2]*3))
---
(command (word "array=(1 2 3 4)"))
(command (word "echo") (word "$((array[1] + array[2]*3))"))
---

=== Constants in base 36
echo $((36#a))-$((36#z))
---
(command (word "echo") (word "$((36#a))-$((36#z))"))
---

=== Constants in bases 2 to 64
# This is a truly bizarre syntax.  Oh it comes from zsh... which allows 36.
echo $((64#a))-$((64#z)), $((64#A))-$((64#Z)), $((64#@)), $(( 64#_ ))
---
(command (word "echo") (word "$((64#a))-$((64#z)),") (word "$((64#A))-$((64#Z)),") (word "$((64#@)),") (word "$(( 64#_ ))"))
---

=== Multiple digit constants with base N
echo $((10#0123)), $((16#1b))
---
(command (word "echo") (word "$((10#0123)),") (word "$((16#1b))"))
---

=== Dynamic base constants
base=16
echo $(( ${base}#a ))
---
(command (word "base=16"))
(command (word "echo") (word "$(( ${base}#a ))"))
---

=== Octal constant
echo $(( 011 ))
---
(command (word "echo") (word "$(( 011 ))"))
---

=== Dynamic octal constant
zero=0
echo $(( ${zero}11 ))
---
(command (word "zero=0"))
(command (word "echo") (word "$(( ${zero}11 ))"))
---

=== Dynamic hex constants
zero=0
echo $(( ${zero}xAB ))
---
(command (word "zero=0"))
(command (word "echo") (word "$(( ${zero}xAB ))"))
---

=== Hex constant with capital X
echo $(( 0XAA ))
---
(command (word "echo") (word "$(( 0XAA ))"))
---

=== Dynamic var names - result of runtime parse/eval
foo=5
x=oo
echo $(( foo + f$x + 1 ))
---
(command (word "foo=5"))
(command (word "x=oo"))
(command (word "echo") (word "$(( foo + f$x + 1 ))"))
---

=== Recursive name evaluation is a result of runtime parse/eval
foo=5
bar=foo
spam=bar
eggs=spam
echo $((foo+1)) $((bar+1)) $((spam+1)) $((eggs+1))
---
(command (word "foo=5"))
(command (word "bar=foo"))
(command (word "spam=bar"))
(command (word "eggs=spam"))
(command (word "echo") (word "$((foo+1))") (word "$((bar+1))") (word "$((spam+1))") (word "$((eggs+1))"))
---

=== nounset with arithmetic
set -o nounset
x=$(( y + 5 ))
echo "should not get here: x=${x:-<unset>}"
---
(command (word "set") (word "-o") (word "nounset"))
(command (word "x=$(( y + 5 ))"))
(command (word "echo") (word "\"should not get here: x=${x:-<unset>}\""))
---

=== 64-bit integer doesn't overflow
a=$(( 1 << 31 ))
echo $a

b=$(( a + a ))
echo $b

c=$(( b + a ))
echo $c

x=$(( 1 << 62 ))
y=$(( x - 1 ))
echo "max positive = $(( x + y ))"

#echo "overflow $(( x + x ))"
---
(command (word "a=$(( 1 << 31 ))"))
(command (word "echo") (word "$a"))
(command (word "b=$(( a + a ))"))
(command (word "echo") (word "$b"))
(command (word "c=$(( b + a ))"))
(command (word "echo") (word "$c"))
(command (word "x=$(( 1 << 62 ))"))
(command (word "y=$(( x - 1 ))"))
(command (word "echo") (word "\"max positive = $(( x + y ))\""))
---

=== More 64-bit ops
case $SH in dash) exit ;; esac

#shopt -s strict_arith

# This overflows - the extra 9 puts it above 2**31
#echo $(( 12345678909 ))

[[ 12345678909 = $(( 1 << 30 )) ]]
echo eq=$?
[[ 12345678909 = 12345678909 ]]
echo eq=$?

# Try both [ and [[
[ 12345678909 -gt $(( 1 << 30 )) ]
echo greater=$?
[[ 12345678909 -gt $(( 1 << 30 )) ]]
echo greater=$?

[[ 12345678909 -ge $(( 1 << 30 )) ]]
echo ge=$?
[[ 12345678909 -ge 12345678909 ]]
echo ge=$?

[[ 12345678909 -le $(( 1 << 30 )) ]]
echo le=$?
[[ 12345678909 -le 12345678909 ]]
echo le=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(cond (cond-binary "=" (cond-term "12345678909") (cond-term "$(( 1 << 30 ))")))
(command (word "echo") (word "eq=$?"))
(cond (cond-binary "=" (cond-term "12345678909") (cond-term "12345678909")))
(command (word "echo") (word "eq=$?"))
(command (word "[") (word "12345678909") (word "-gt") (word "$(( 1 << 30 ))") (word "]"))
(command (word "echo") (word "greater=$?"))
(cond (cond-binary "-gt" (cond-term "12345678909") (cond-term "$(( 1 << 30 ))")))
(command (word "echo") (word "greater=$?"))
(cond (cond-binary "-ge" (cond-term "12345678909") (cond-term "$(( 1 << 30 ))")))
(command (word "echo") (word "ge=$?"))
(cond (cond-binary "-ge" (cond-term "12345678909") (cond-term "12345678909")))
(command (word "echo") (word "ge=$?"))
(cond (cond-binary "-le" (cond-term "12345678909") (cond-term "$(( 1 << 30 ))")))
(command (word "echo") (word "le=$?"))
(cond (cond-binary "-le" (cond-term "12345678909") (cond-term "12345678909")))
(command (word "echo") (word "le=$?"))
---

=== Invalid LValue
a=9
(( (a + 2) = 3 ))
echo $a
---
(command (word "a=9"))
(arith (word " (a + 2) = 3 "))
(command (word "echo") (word "$a"))
---

=== Invalid LValue that looks like array
(( 1[2] = 3 ))
echo "status=$?"
---
(arith (word " 1[2] = 3 "))
(command (word "echo") (word "\"status=$?\""))
---

=== Invalid LValue: two sets of brackets
(( a[1][2] = 3 ))
echo "status=$?"
#   shells treat this as a NON-fatal error
---
(arith (word " a[1][2] = 3 "))
(command (word "echo") (word "\"status=$?\""))
---

=== Operator Precedence
echo $(( 1 + 2*3 - 8/2 ))
---
(command (word "echo") (word "$(( 1 + 2*3 - 8/2 ))"))
---

=== Exponentiation with **
echo $(( 3 ** 0 ))
echo $(( 3 ** 1 ))
echo $(( 3 ** 2 ))
---
(command (word "echo") (word "$(( 3 ** 0 ))"))
(command (word "echo") (word "$(( 3 ** 1 ))"))
(command (word "echo") (word "$(( 3 ** 2 ))"))
---

=== Exponentiation operator has buggy precedence
# NOTE: All shells agree on this, but R and Python give -9, which is more
# mathematically correct.
echo $(( -3 ** 2 ))
---
(command (word "echo") (word "$(( -3 ** 2 ))"))
---

=== Negative exponent
# bash explicitly disallows negative exponents!
echo $(( 2**-1 * 5 ))
---
(command (word "echo") (word "$(( 2**-1 * 5 ))"))
---

=== Comment not allowed in the middle of multiline arithmetic
echo $((
1 +
2 + \
3
))
echo $((
1 + 2  # not a comment
))
(( a = 3 + 4  # comment
))
echo [$a]
---
(command (word "echo") (word "$((\n1 +\n2 + 3\n))"))
(command (word "echo") (word "$((\n1 + 2  # not a comment\n))"))
(arith (word " a = 3 + 4  # comment\n"))
(command (word "echo") (word "[$a]"))
---

=== Add integer to indexed array (a[0] decay)
declare -a array=(1 2 3)
echo $((array + 5))
---
(command (word "declare") (word "-a") (word "array=(1 2 3)"))
(command (word "echo") (word "$((array + 5))"))
---

=== Add integer to associative array (a[0] decay)
typeset -A assoc
assoc[0]=42
echo $((assoc + 5))
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc[0]=42"))
(command (word "echo") (word "$((assoc + 5))"))
---

=== Double subscript
a=(1 2 3)
echo $(( a[1] ))
echo $(( a[1][1] ))
---
(command (word "a=(1 2 3)"))
(command (word "echo") (word "$(( a[1] ))"))
(command (word "echo") (word "$(( a[1][1] ))"))
---

=== result of ArithSub -- array[0] decay
a=(4 5 6)
echo declared
b=$(( a ))
echo $b
---
(command (word "a=(4 5 6)"))
(command (word "echo") (word "declared"))
(command (word "b=$(( a ))"))
(command (word "echo") (word "$b"))
---

=== result of ArithSub -- assoc[0] decay
declare -A A=(['foo']=bar ['spam']=eggs)
echo declared
b=$(( A ))
echo $b
---
(command (word "declare") (word "-A") (word "A=(['foo']=bar ['spam']=eggs)"))
(command (word "echo") (word "declared"))
(command (word "b=$(( A ))"))
(command (word "echo") (word "$b"))
---

=== comma operator
a=(4 5 6)

# zsh and osh can't evaluate the array like that
# which is consistent with their behavior on $(( a ))

echo $(( a, last = a[2], 42 ))
echo last=$last
---
(command (word "a=(4 5 6)"))
(command (word "echo") (word "$(( a, last = a[2], 42 ))"))
(command (word "echo") (word "last=$last"))
---

=== assignment with dynamic var name
foo=bar
echo $(( x$foo = 42 ))
echo xbar=$xbar
---
(command (word "foo=bar"))
(command (word "echo") (word "$(( x$foo = 42 ))"))
(command (word "echo") (word "xbar=$xbar"))
---

=== array assignment with dynamic array name
foo=bar
echo $(( x$foo[5] = 42 ))
echo 'xbar[5]='${xbar[5]}
---
(command (word "foo=bar"))
(command (word "echo") (word "$(( x$foo[5] = 42 ))"))
(command (word "echo") (word "'xbar[5]='${xbar[5]}"))
---

=== unary assignment with dynamic var name
foo=bar
xbar=42
echo $(( x$foo++ ))
echo xbar=$xbar
---
(command (word "foo=bar"))
(command (word "xbar=42"))
(command (word "echo") (word "$(( x$foo++ ))"))
(command (word "echo") (word "xbar=$xbar"))
---

=== unary array assignment with dynamic var name
foo=bar
xbar[5]=42
echo $(( x$foo[5]++ ))
echo 'xbar[5]='${xbar[5]}
---
(command (word "foo=bar"))
(command (word "xbar[5]=42"))
(command (word "echo") (word "$(( x$foo[5]++ ))"))
(command (word "echo") (word "'xbar[5]='${xbar[5]}"))
---

=== Dynamic parsing of arithmetic
e=1+2
echo $(( e + 3 ))
[[ e -eq 3 ]] && echo true
[ e -eq 3 ]
echo status=$?
---
(command (word "e=1+2"))
(command (word "echo") (word "$(( e + 3 ))"))
(and (cond (cond-binary "-eq" (cond-term "e") (cond-term "3"))) (command (word "echo") (word "true")))
(command (word "[") (word "e") (word "-eq") (word "3") (word "]"))
(command (word "echo") (word "status=$?"))
---

=== Dynamic parsing on empty string
a=''
echo $(( a ))

a2=' '
echo $(( a2 ))
---
(command (word "a=''"))
(command (word "echo") (word "$(( a ))"))
(command (word "a2=' '"))
(command (word "echo") (word "$(( a2 ))"))
---

=== nested ternary (bug fix)
echo $((1?2?3:4:5))
---
(command (word "echo") (word "$((1?2?3:4:5))"))
---

=== 1 ? a=1 : b=2 ( bug fix)
echo $((1 ? a=1 : 42 ))
echo a=$a

# this does NOT work
#echo $((1 ? a=1 : b=2 ))
---
(command (word "echo") (word "$((1 ? a=1 : 42 ))"))
(command (word "echo") (word "a=$a"))
---

=== Invalid constant
echo $((a + x42))
echo status=$?

# weird asymmetry -- the above is a syntax error, but this isn't
$SH -c 'echo $((a + 42x))'
echo status=$?

# regression
echo $((a + 42x))
echo status=$?
---
(command (word "echo") (word "$((a + x42))"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'echo $((a + 42x))'"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "$((a + 42x))"))
(command (word "echo") (word "status=$?"))
---

=== Negative numbers with integer division /
echo $(( 10 / 3))
echo $((-10 / 3))
echo $(( 10 / -3))
echo $((-10 / -3))

echo ---

a=20
: $(( a /= 3 ))
echo $a

a=-20
: $(( a /= 3 ))
echo $a

a=20
: $(( a /= -3 ))
echo $a

a=-20
: $(( a /= -3 ))
echo $a
---
(command (word "echo") (word "$(( 10 / 3))"))
(command (word "echo") (word "$((-10 / 3))"))
(command (word "echo") (word "$(( 10 / -3))"))
(command (word "echo") (word "$((-10 / -3))"))
(command (word "echo") (word "---"))
(command (word "a=20"))
(command (word ":") (word "$(( a /= 3 ))"))
(command (word "echo") (word "$a"))
(command (word "a=-20"))
(command (word ":") (word "$(( a /= 3 ))"))
(command (word "echo") (word "$a"))
(command (word "a=20"))
(command (word ":") (word "$(( a /= -3 ))"))
(command (word "echo") (word "$a"))
(command (word "a=-20"))
(command (word ":") (word "$(( a /= -3 ))"))
(command (word "echo") (word "$a"))
---

=== Negative numbers with %
echo $(( 10 % 3))
echo $((-10 % 3))
echo $(( 10 % -3))
echo $((-10 % -3))
---
(command (word "echo") (word "$(( 10 % 3))"))
(command (word "echo") (word "$((-10 % 3))"))
(command (word "echo") (word "$(( 10 % -3))"))
(command (word "echo") (word "$((-10 % -3))"))
---

=== Negative numbers with bit shift
echo $(( 5 << 1 ))
echo $(( 5 << 0 ))
$SH -c 'echo $(( 5 << -1 ))'  # implementation defined - OSH fails
echo ---

echo $(( 16 >> 1 ))
echo $(( 16 >> 0 ))
$SH -c 'echo $(( 16 >> -1 ))'  # not sure why this is zero
$SH -c 'echo $(( 16 >> -2 ))'  # also 0
echo ---
---
(command (word "echo") (word "$(( 5 << 1 ))"))
(command (word "echo") (word "$(( 5 << 0 ))"))
(command (word "$SH") (word "-c") (word "'echo $(( 5 << -1 ))'"))
(command (word "echo") (word "---"))
(command (word "echo") (word "$(( 16 >> 1 ))"))
(command (word "echo") (word "$(( 16 >> 0 ))"))
(command (word "$SH") (word "-c") (word "'echo $(( 16 >> -1 ))'"))
(command (word "$SH") (word "-c") (word "'echo $(( 16 >> -2 ))'"))
(command (word "echo") (word "---"))
---

=== undef[0]
case $SH in dash) exit ;; esac

echo ARITH $(( undef[0] ))
echo status=$?
echo

(( undef[0] ))
echo status=$?
echo

echo UNDEF ${undef[0]}
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "echo") (word "ARITH") (word "$(( undef[0] ))"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(arith (word " undef[0] "))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "echo") (word "UNDEF") (word "${undef[0]}"))
(command (word "echo") (word "status=$?"))
---

=== undef[0] with nounset
case $SH in dash) exit ;; esac

set -o nounset
echo UNSET $(( undef[0] ))
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "set") (word "-o") (word "nounset"))
(command (word "echo") (word "UNSET") (word "$(( undef[0] ))"))
(command (word "echo") (word "status=$?"))
---

=== s[0] with string abc
case $SH in dash) exit ;; esac

s='abc'
echo abc $(( s[0] )) $(( s[1] ))
echo status=$?
echo

(( s[0] ))
echo status=$?
echo
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "s='abc'"))
(command (word "echo") (word "abc") (word "$(( s[0] ))") (word "$(( s[1] ))"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(arith (word " s[0] "))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
---

=== s[0] with string 42
case $SH in dash) exit ;; esac

s='42'
echo 42 $(( s[0] )) $(( s[1] ))
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "s='42'"))
(command (word "echo") (word "42") (word "$(( s[0] ))") (word "$(( s[1] ))"))
(command (word "echo") (word "status=$?"))
---

=== s[0] with string '12 34'
s='12 34'
echo '12 34' $(( s[0] )) $(( s[1] ))
echo status=$?
---
(command (word "s='12 34'"))
(command (word "echo") (word "'12 34'") (word "$(( s[0] ))") (word "$(( s[1] ))"))
(command (word "echo") (word "status=$?"))
---

=== Indexed LHS without spaces, and +=
a[1]=x
echo status=$?
argv.py "${a[@]}"

a[0+2]=y
#a[2|3]=y  # zsh doesn't allow this
argv.py "${a[@]}"

# += does appending
a[0+2]+=z
argv.py "${a[@]}"
---
(command (word "a[1]=x"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "a[0+2]=y"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "a[0+2]+=z"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Indexed LHS with spaces
case $SH in zsh|ash) exit ;; esac

a[1 * 1]=x
a[ 1 + 2 ]=z
echo status=$?

argv.py "${a[@]}"
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a[1 * 1]=x"))
(command (word "a[ 1 + 2 ]=z"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Nested a[i[0]]=0
case $SH in zsh|ash) exit ;; esac

i=(0 1 2)

a[i[0]]=0
a[ i[1] ]=1
a[ i[2] ]=2
a[ i[1]+i[2] ]=3

argv.py "${a[@]}"
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "i=(0 1 2)"))
(command (word "a[i[0]]=0"))
(command (word "a[ i[1] ]=1"))
(command (word "a[ i[2] ]=2"))
(command (word "a[ i[1]+i[2] ]=3"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Multiple LHS array words
case $SH in zsh|ash) exit ;; esac

a=(0 1 2)
b=(3 4 5)

#declare -p a b

HOME=/home/spec-test

# empty string, and tilde sub
a[0 + 1]=  b[2 + 0]=~/src

typeset -p a b

echo ---

# In bash, this bad prefix binding prints an error, but nothing fails
a[0 + 1]='foo' argv.py b[2 + 0]='bar'
echo status=$?

typeset -p a b
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a=(0 1 2)"))
(command (word "b=(3 4 5)"))
(command (word "HOME=/home/spec-test"))
(command (word "a[0 + 1]=") (word "b[2 + 0]=~/src"))
(command (word "typeset") (word "-p") (word "a") (word "b"))
(command (word "echo") (word "---"))
(command (word "a[0 + 1]='foo'") (word "argv.py") (word "b[2") (word "+") (word "0]='bar'"))
(command (word "echo") (word "status=$?"))
(command (word "typeset") (word "-p") (word "a") (word "b"))
---

=== LHS array is protected with shopt -s eval_unsafe_arith, e.g. 'a[$(echo 2)]'
case $SH in zsh|ash) exit ;; esac

a=(0 1 2)
b=(3 4 5)
typeset -p b

expr='a[$(echo 2)]' 

echo 'get' "${b[expr]}"

b[expr]=zzz

echo 'set' "${b[expr]}"
typeset -p b
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a=(0 1 2)"))
(command (word "b=(3 4 5)"))
(command (word "typeset") (word "-p") (word "b"))
(command (word "expr='a[$(echo 2)]'"))
(command (word "echo") (word "'get'") (word "\"${b[expr]}\""))
(command (word "b[expr]=zzz"))
(command (word "echo") (word "'set'") (word "\"${b[expr]}\""))
(command (word "typeset") (word "-p") (word "b"))
---

=== file named a[ is  not executed
case $SH in zsh|ash) exit ;; esac

PATH=".:$PATH"

for name in 'a[' 'a[5'; do
  echo "echo hi from $name: \$# args: \$@" > "$name"
  chmod +x "$name"
done

# this does not executed a[5
a[5 + 1]=
a[5 / 1]=y
echo len=${#a[@]}

# Not detected as assignment because there's a non-arith character
# bash and mksh both give a syntax error
a[5 # 1]=
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "PATH=\".:$PATH\""))
(for (word "name") (in (word "'a['") (word "'a[5'")) (semi (command (word "echo") (word "\"echo hi from $name: \\$# args: \\$@\"") (redirect ">" ""$name"")) (command (word "chmod") (word "+x") (word "\"$name\""))))
(command (word "a[5 + 1]="))
(command (word "a[5 / 1]=y"))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "a[5 # 1]="))
---

=== More fragments like a[  a[5  a[5 +  a[5 + 3]
for name in 'a[' 'a[5'; do
  echo "echo hi from $name: \$# args: \$@" > "$name"
  chmod +x "$name"
done

# syntax error in bash
$SH -c 'a['
echo "a[ status=$?"

$SH -c 'a[5'
echo "a[5 status=$?"

# 1 arg +
$SH -c 'a[5 +'
echo "a[5 + status=$?"

# 2 args
$SH -c 'a[5 + 3]'
echo "a[5 + 3] status=$?"

$SH -c 'a[5 + 3]='
echo "a[5 + 3]= status=$?"

$SH -c 'a[5 + 3]+'
echo "a[5 + 3]+ status=$?"

$SH -c 'a[5 + 3]+='
echo "a[5 + 3]+= status=$?"

# mksh doesn't issue extra parse errors
# and it doesn't turn a[5 + 3] and a[5 + 3]+ into commands!
---
(for (word "name") (in (word "'a['") (word "'a[5'")) (semi (command (word "echo") (word "\"echo hi from $name: \\$# args: \\$@\"") (redirect ">" ""$name"")) (command (word "chmod") (word "+x") (word "\"$name\""))))
(command (word "$SH") (word "-c") (word "'a['"))
(command (word "echo") (word "\"a[ status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5'"))
(command (word "echo") (word "\"a[5 status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5 +'"))
(command (word "echo") (word "\"a[5 + status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5 + 3]'"))
(command (word "echo") (word "\"a[5 + 3] status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5 + 3]='"))
(command (word "echo") (word "\"a[5 + 3]= status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5 + 3]+'"))
(command (word "echo") (word "\"a[5 + 3]+ status=$?\""))
(command (word "$SH") (word "-c") (word "'a[5 + 3]+='"))
(command (word "echo") (word "\"a[5 + 3]+= status=$?\""))
---

=== Are quotes allowed?
# double quotes allowed in bash
a["1"]=2
echo status=$? len=${#a[@]}

a['2']=3
echo status=$? len=${#a[@]}

# allowed in bash
a[2 + "3"]=5
echo status=$? len=${#a[@]}

a[3 + '4']=5
echo status=$? len=${#a[@]}
---
(command (word "a[\"1\"]=2"))
(command (word "echo") (word "status=$?") (word "len=${#a[@]}"))
(command (word "a['2']=3"))
(command (word "echo") (word "status=$?") (word "len=${#a[@]}"))
(command (word "a[2 + \"3\"]=5"))
(command (word "echo") (word "status=$?") (word "len=${#a[@]}"))
(command (word "a[3 + '4']=5"))
(command (word "echo") (word "status=$?") (word "len=${#a[@]}"))
---

=== Tricky parsing - a[ a[0]=1 ]=X  a[ a[0]+=1 ]+=X
case $SH in zsh|mksh|ash) exit ;; esac

# the nested [] means we can't use regular language lookahead?

echo assign=$(( z[0] = 42 ))

a[a[0]=1]=X
declare -p a

a[ a[2]=3 ]=Y
declare -p a

echo ---

a[ a[0]+=1 ]+=X
declare -p a
---
(case (word "$SH") (pattern ((word "zsh") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "echo") (word "assign=$(( z[0] = 42 ))"))
(command (word "a[a[0]=1]=X"))
(command (word "declare") (word "-p") (word "a"))
(command (word "a[ a[2]=3 ]=Y"))
(command (word "declare") (word "-p") (word "a"))
(command (word "echo") (word "---"))
(command (word "a[ a[0]+=1 ]+=X"))
(command (word "declare") (word "-p") (word "a"))
---

=== argv.py a[1 + 2]=
case $SH in zsh|ash) exit ;; esac

# This tests that the worse parser doesn't unconditinoally treat a[ as special

a[1 + 2]= argv.py a[1 + 2]=
echo status=$?

a[1 + 2]+= argv.py a[1 + 2]+=
echo status=$?

argv.py a[3 + 4]=

argv.py a[3 + 4]+=
---
(case (word "$SH") (pattern ((word "zsh") (word "ash")) (command (word "exit"))))
(command (word "a[1 + 2]=") (word "argv.py") (word "a[1") (word "+") (word "2]="))
(command (word "echo") (word "status=$?"))
(command (word "a[1 + 2]+=") (word "argv.py") (word "a[1") (word "+") (word "2]+="))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "a[3") (word "+") (word "4]="))
(command (word "argv.py") (word "a[3") (word "+") (word "4]+="))
---

=== declare builtin doesn't allow spaces
case $SH in zsh|mksh|ash) exit ;; esac

# OSH doesn't allow this
declare a[a[0]=1]=X
declare -p a

# neither bash nor OSH allow this
declare a[ a[2]=3 ]=Y
declare -p a
---
(case (word "$SH") (pattern ((word "zsh") (word "mksh") (word "ash")) (command (word "exit"))))
(command (word "declare") (word "a[a[0]=1]=X"))
(command (word "declare") (word "-p") (word "a"))
(command (word "declare") (word "a[") (word "a[2]=3") (word "]=Y"))
(command (word "declare") (word "-p") (word "a"))
---

=== Literal syntax ([x]=y)
declare -A a
a=([aa]=b [foo]=bar ['a+1']=c)
echo ${a["aa"]}
echo ${a["foo"]}
echo ${a["a+1"]}
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([aa]=b [foo]=bar ['a+1']=c)"))
(command (word "echo") (word "${a[\"aa\"]}"))
(command (word "echo") (word "${a[\"foo\"]}"))
(command (word "echo") (word "${a[\"a+1\"]}"))
---

=== set associative array to indexed array literal (very surprising bash behavior)
declare -A assoc=([k1]=foo [k2]='spam eggs')
declare -p assoc

# Bash 5.1 assoc=(key value). Bash 5.0 (including the currently tested 4.4)
# does not implement this.

assoc=(foo 'spam eggs')
declare -p assoc
---
(command (word "declare") (word "-A") (word "assoc=([k1]=foo [k2]='spam eggs')"))
(command (word "declare") (word "-p") (word "assoc"))
(command (word "assoc=(foo 'spam eggs')"))
(command (word "declare") (word "-p") (word "assoc"))
---

=== Can initialize assoc array with the "(key value ...)" sequence
declare -A A=(1 2 3)
echo status=$?
declare -p A
---
(command (word "declare") (word "-A") (word "A=(1 2 3)"))
(command (word "echo") (word "status=$?"))
(command (word "declare") (word "-p") (word "A"))
---

=== create empty assoc array, put, then get
declare -A A  # still undefined
argv.py "${A[@]}"
argv.py "${!A[@]}"
A['foo']=bar
echo ${A['foo']}
---
(command (word "declare") (word "-A") (word "A"))
(command (word "argv.py") (word "\"${A[@]}\""))
(command (word "argv.py") (word "\"${!A[@]}\""))
(command (word "A['foo']=bar"))
(command (word "echo") (word "${A['foo']}"))
---

=== Empty value (doesn't use EmptyWord?)
declare -A A=(["k"]= )
argv.py "${A["k"]}"
---
(command (word "declare") (word "-A") (word "A=([\"k\"]=)"))
(command (word "argv.py") (word "\"${A[\"k\"]}\""))
---

=== retrieve keys with !
declare -A a
var='x'
a["$var"]=b
a['foo']=bar
a['a+1']=c
for key in "${!a[@]}"; do
  echo $key
done | sort
---
(command (word "declare") (word "-A") (word "a"))
(command (word "var='x'"))
(command (word "a[\"$var\"]=b"))
(command (word "a['foo']=bar"))
(command (word "a['a+1']=c"))
(pipe (for (word "key") (in (word "\"${!a[@]}\"")) (command (word "echo") (word "$key"))) (command (word "sort")))
---

=== retrieve values with ${A[@]}
declare -A A
var='x'
A["$var"]=b
A['foo']=bar
A['a+1']=c
for val in "${A[@]}"; do
  echo $val
done | sort
---
(command (word "declare") (word "-A") (word "A"))
(command (word "var='x'"))
(command (word "A[\"$var\"]=b"))
(command (word "A['foo']=bar"))
(command (word "A['a+1']=c"))
(pipe (for (word "val") (in (word "\"${A[@]}\"")) (command (word "echo") (word "$val"))) (command (word "sort")))
---

=== coerce to string with ${A[*]}, etc.
declare -A A
A['X X']=xx
A['Y Y']=yy
argv.py "${A[*]}"
argv.py "${!A[*]}"

argv.py ${A[@]}
argv.py ${!A[@]}
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A['X X']=xx"))
(command (word "A['Y Y']=yy"))
(command (word "argv.py") (word "\"${A[*]}\""))
(command (word "argv.py") (word "\"${!A[*]}\""))
(command (word "argv.py") (word "${A[@]}"))
(command (word "argv.py") (word "${!A[@]}"))
---

=== ${A[@]/b/B}
# but ${!A[@]/b/B} doesn't work
declare -A A
A['aa']=bbb
A['bb']=ccc
A['cc']=ddd
for val in "${A[@]//b/B}"; do
  echo $val
done | sort
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A['aa']=bbb"))
(command (word "A['bb']=ccc"))
(command (word "A['cc']=ddd"))
(pipe (for (word "val") (in (word "\"${A[@]//b/B}\"")) (command (word "echo") (word "$val"))) (command (word "sort")))
---

=== ${A[@]#prefix}
declare -A A
A['aa']=one
A['bb']=two
A['cc']=three
for val in "${A[@]#t}"; do
  echo $val
done | sort
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A['aa']=one"))
(command (word "A['bb']=two"))
(command (word "A['cc']=three"))
(pipe (for (word "val") (in (word "\"${A[@]#t}\"")) (command (word "echo") (word "$val"))) (command (word "sort")))
---

=== ${assoc} is like ${assoc[0]}
declare -A a

a=([aa]=b [foo]=bar ['a+1']=c)
echo a="${a}"

a=([0]=zzz)
echo a="${a}"

a=(['0']=yyy)
echo a="${a}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([aa]=b [foo]=bar ['a+1']=c)"))
(command (word "echo") (word "a=\"${a}\""))
(command (word "a=([0]=zzz)"))
(command (word "echo") (word "a=\"${a}\""))
(command (word "a=(['0']=yyy)"))
(command (word "echo") (word "a=\"${a}\""))
---

=== length ${#a[@]}
declare -A a
a["x"]=1
a["y"]=2
a["z"]=3
echo "${#a[@]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[\"x\"]=1"))
(command (word "a[\"y\"]=2"))
(command (word "a[\"z\"]=3"))
(command (word "echo") (word "\"${#a[@]}\""))
---

=== lookup with ${a[0]} -- "0" is a string
declare -A a
a["0"]=a
a["1"]=b
a["2"]=c
echo 0 "${a[0]}" 1 "${a[1]}" 2 "${a[2]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[\"0\"]=a"))
(command (word "a[\"1\"]=b"))
(command (word "a[\"2\"]=c"))
(command (word "echo") (word "0") (word "\"${a[0]}\"") (word "1") (word "\"${a[1]}\"") (word "2") (word "\"${a[2]}\""))
---

=== lookup with double quoted strings "mykey"
declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a["aa"]}" "${a["foo"]}" "${a["a+1"]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[\"aa\"]=b"))
(command (word "a[\"foo\"]=bar"))
(command (word "a['a+1']=c"))
(command (word "echo") (word "\"${a[\"aa\"]}\"") (word "\"${a[\"foo\"]}\"") (word "\"${a[\"a+1\"]}\""))
---

=== lookup with single quoted string
declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a['a+1']}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[\"aa\"]=b"))
(command (word "a[\"foo\"]=bar"))
(command (word "a['a+1']=c"))
(command (word "echo") (word "\"${a['a+1']}\""))
---

=== lookup with unquoted $key and quoted "$i$i"
declare -A A
A["aa"]=b
A["foo"]=bar

key=foo
echo ${A[$key]}
i=a
echo ${A["$i$i"]}   # note: ${A[$i$i]} doesn't work in OSH
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A[\"aa\"]=b"))
(command (word "A[\"foo\"]=bar"))
(command (word "key=foo"))
(command (word "echo") (word "${A[$key]}"))
(command (word "i=a"))
(command (word "echo") (word "${A[\"$i$i\"]}"))
---

=== lookup by unquoted string doesn't work in OSH because it's a variable
declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a[a+1]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[\"aa\"]=b"))
(command (word "a[\"foo\"]=bar"))
(command (word "a['a+1']=c"))
(command (word "echo") (word "\"${a[a+1]}\""))
---

=== bash bug: "i+1" and i+1 are the same key
i=1
array=(5 6 7)
echo array[i]="${array[i]}"
echo array[i+1]="${array[i+1]}"

# arithmetic does NOT work here in bash.  These are unquoted strings!
declare -A assoc
assoc[i]=$i
assoc[i+1]=$i+1

assoc["i"]=string
assoc["i+1"]=string+1

echo assoc[i]="${assoc[i]}" 
echo assoc[i+1]="${assoc[i+1]}"

echo assoc[i]="${assoc["i"]}" 
echo assoc[i+1]="${assoc["i+1"]}"
---
(command (word "i=1"))
(command (word "array=(5 6 7)"))
(command (word "echo") (word "array[i]=\"${array[i]}\""))
(command (word "echo") (word "array[i+1]=\"${array[i+1]}\""))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc[i]=$i"))
(command (word "assoc[i+1]=$i+1"))
(command (word "assoc[\"i\"]=string"))
(command (word "assoc[\"i+1\"]=string+1"))
(command (word "echo") (word "assoc[i]=\"${assoc[i]}\""))
(command (word "echo") (word "assoc[i+1]=\"${assoc[i+1]}\""))
(command (word "echo") (word "assoc[i]=\"${assoc[\"i\"]}\""))
(command (word "echo") (word "assoc[i+1]=\"${assoc[\"i+1\"]}\""))
---

=== Array stored in associative array gets converted to string (without strict_array)
array=('1 2' 3)
declare -A d
d['key']="${array[@]}"
argv.py "${d['key']}"
---
(command (word "array=('1 2' 3)"))
(command (word "declare") (word "-A") (word "d"))
(command (word "d['key']=\"${array[@]}\""))
(command (word "argv.py") (word "\"${d['key']}\""))
---

=== Indexed array as key of associative array coerces to string (without shopt -s strict_array)
declare -a array=(1 2 3)
declare -A assoc
assoc[42]=43
assoc["${array[@]}"]=foo

echo "${assoc["${array[@]}"]}"
for entry in "${!assoc[@]}"; do
  echo $entry
done | sort
---
(command (word "declare") (word "-a") (word "array=(1 2 3)"))
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc[42]=43"))
(command (word "assoc[\"${array[@]}\"]=foo"))
(command (word "echo") (word "\"${assoc[\"${array[@]}\"]}\""))
(pipe (for (word "entry") (in (word "\"${!assoc[@]}\"")) (command (word "echo") (word "$entry"))) (command (word "sort")))
---

=== Append to associative array value A['x']+='suffix'
declare -A A
A['x']='foo'
A['x']+='bar'
A['x']+='bar'
argv.py "${A["x"]}"
---
(command (word "declare") (word "-A") (word "A"))
(command (word "A['x']='foo'"))
(command (word "A['x']+='bar'"))
(command (word "A['x']+='bar'"))
(command (word "argv.py") (word "\"${A[\"x\"]}\""))
---

=== Slice of associative array doesn't make sense in bash
declare -A a
a[xx]=1
a[yy]=2
a[zz]=3
a[aa]=4
a[bb]=5
#argv.py ${a["xx"]}
argv.py ${a[@]: 0: 3}
argv.py ${a[@]: 1: 3}
argv.py ${a[@]: 2: 3}
argv.py ${a[@]: 3: 3}
argv.py ${a[@]: 4: 3}
argv.py ${a[@]: 5: 3}
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a[xx]=1"))
(command (word "a[yy]=2"))
(command (word "a[zz]=3"))
(command (word "a[aa]=4"))
(command (word "a[bb]=5"))
(command (word "argv.py") (word "${a[@]: 0: 3}"))
(command (word "argv.py") (word "${a[@]: 1: 3}"))
(command (word "argv.py") (word "${a[@]: 2: 3}"))
(command (word "argv.py") (word "${a[@]: 3: 3}"))
(command (word "argv.py") (word "${a[@]: 4: 3}"))
(command (word "argv.py") (word "${a[@]: 5: 3}"))
---

=== bash variable can have an associative array part and a string part
# and $assoc is equivalent to ${assoc[0]}, just like regular arrays
declare -A assoc
assoc[1]=1
assoc[2]=2
echo ${assoc[1]} ${assoc[2]} ${assoc}
assoc[0]=zero
echo ${assoc[1]} ${assoc[2]} ${assoc}
assoc=string
echo ${assoc[1]} ${assoc[2]} ${assoc}
---
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc[1]=1"))
(command (word "assoc[2]=2"))
(command (word "echo") (word "${assoc[1]}") (word "${assoc[2]}") (word "${assoc}"))
(command (word "assoc[0]=zero"))
(command (word "echo") (word "${assoc[1]}") (word "${assoc[2]}") (word "${assoc}"))
(command (word "assoc=string"))
(command (word "echo") (word "${assoc[1]}") (word "${assoc[2]}") (word "${assoc}"))
---

=== Associative array expressions inside (( )) with keys that look like numbers
declare -A assoc
assoc[0]=42
(( var = ${assoc[0]} ))
echo $var
(( var = assoc[0] ))
echo $var
---
(command (word "declare") (word "-A") (word "assoc"))
(command (word "assoc[0]=42"))
(arith (word " var = ${assoc[0]} "))
(command (word "echo") (word "$var"))
(arith (word " var = assoc[0] "))
(command (word "echo") (word "$var"))
---

=== (( A[5] += 42 ))
declare -A A
(( A[5] = 10 ))
(( A[5] += 6 ))
echo ${A[5]}
---
(command (word "declare") (word "-A") (word "A"))
(arith (word " A[5] = 10 "))
(arith (word " A[5] += 6 "))
(command (word "echo") (word "${A[5]}"))
---

=== (( A[5] += 42 )) with empty cell
shopt -u strict_arith  # default zero cell
declare -A A
(( A[5] += 6 ))
echo ${A[5]}
---
(command (word "shopt") (word "-u") (word "strict_arith"))
(command (word "declare") (word "-A") (word "A"))
(arith (word " A[5] += 6 "))
(command (word "echo") (word "${A[5]}"))
---

=== setting key to itself (from bash-bug mailing list)
declare -A foo
foo=(["key"]="value1")
echo ${foo["key"]}
foo=(["key"]="${foo["key"]} value2")
echo ${foo["key"]}
---
(command (word "declare") (word "-A") (word "foo"))
(command (word "foo=([\"key\"]=\"value1\")"))
(command (word "echo") (word "${foo[\"key\"]}"))
(command (word "foo=([\"key\"]=\"${foo[\"key\"]} value2\")"))
(command (word "echo") (word "${foo[\"key\"]}"))
---

=== readonly associative array can't be modified
declare -Ar A
A['x']=1
echo status=$?
---
(command (word "declare") (word "-Ar") (word "A"))
(command (word "A['x']=1"))
(command (word "echo") (word "status=$?"))
---

=== associative array and brace expansion
declare -A A=([k1]=v [k2]=-{a,b}-)
echo ${A["k1"]}
echo ${A["k2"]}
---
(command (word "declare") (word "-A") (word "A=([k1]=v [k2]=-{a,b}-)"))
(command (word "echo") (word "${A[\"k1\"]}"))
(command (word "echo") (word "${A[\"k2\"]}"))
---

=== declare -A A=() allowed
set -o nounset
shopt -s strict_arith || true

declare -A ASSOC=()
echo len=${#ASSOC[@]}

# Check that it really can be used like an associative array
ASSOC['k']='32'
echo len=${#ASSOC[@]}

# bash allows a variable to be an associative array AND unset, while OSH
# doesn't
set +o nounset
declare -A u
echo unset len=${#u[@]}
---
(command (word "set") (word "-o") (word "nounset"))
(or (command (word "shopt") (word "-s") (word "strict_arith")) (command (word "true")))
(command (word "declare") (word "-A") (word "ASSOC=()"))
(command (word "echo") (word "len=${#ASSOC[@]}"))
(command (word "ASSOC['k']='32'"))
(command (word "echo") (word "len=${#ASSOC[@]}"))
(command (word "set") (word "+o") (word "nounset"))
(command (word "declare") (word "-A") (word "u"))
(command (word "echo") (word "unset") (word "len=${#u[@]}"))
---

=== unset -v and assoc array
shopt -s eval_unsafe_arith || true

show-len() {
  echo len=${#assoc[@]}
}

declare -A assoc=(['K']=val)
show-len

unset -v 'assoc["K"]'
show-len

declare -A assoc=(['K']=val)
show-len
key=K
unset -v 'assoc[$key]'
show-len

declare -A assoc=(['K']=val)
show-len
unset -v 'assoc[$(echo K)]'
show-len

# ${prefix} doesn't work here, even though it does in arithmetic
#declare -A assoc=(['K']=val)
#show-len
#prefix=as
#unset -v '${prefix}soc[$key]'
#show-len
---
(or (command (word "shopt") (word "-s") (word "eval_unsafe_arith")) (command (word "true")))
(function "show-len" (brace-group (command (word "echo") (word "len=${#assoc[@]}"))))
(command (word "declare") (word "-A") (word "assoc=(['K']=val)"))
(command (word "show-len"))
(command (word "unset") (word "-v") (word "'assoc[\"K\"]'"))
(command (word "show-len"))
(command (word "declare") (word "-A") (word "assoc=(['K']=val)"))
(command (word "show-len"))
(command (word "key=K"))
(command (word "unset") (word "-v") (word "'assoc[$key]'"))
(command (word "show-len"))
(command (word "declare") (word "-A") (word "assoc=(['K']=val)"))
(command (word "show-len"))
(command (word "unset") (word "-v") (word "'assoc[$(echo K)]'"))
(command (word "show-len"))
---

=== nameref and assoc array
show-values() {
  echo values: ${A[@]}
}

declare -A A=(['K']=val)
show-values

declare -n ref='A["K"]'
echo before $ref
ref='val2'
echo after $ref
show-values

echo ---

key=K
declare -n ref='A[$key]'
echo before $ref
ref='val3'
echo after $ref
show-values
---
(function "show-values" (brace-group (command (word "echo") (word "values:") (word "${A[@]}"))))
(command (word "declare") (word "-A") (word "A=(['K']=val)"))
(command (word "show-values"))
(command (word "declare") (word "-n") (word "ref='A[\"K\"]'"))
(command (word "echo") (word "before") (word "$ref"))
(command (word "ref='val2'"))
(command (word "echo") (word "after") (word "$ref"))
(command (word "show-values"))
(command (word "echo") (word "---"))
(command (word "key=K"))
(command (word "declare") (word "-n") (word "ref='A[$key]'"))
(command (word "echo") (word "before") (word "$ref"))
(command (word "ref='val3'"))
(command (word "echo") (word "after") (word "$ref"))
(command (word "show-values"))
---

=== ${!ref} and assoc array
show-values() {
  echo values: ${A[@]}
}

declare -A A=(['K']=val)
show-values

declare ref='A["K"]'
echo ref ${!ref}

key=K
declare ref='A[$key]'
echo ref ${!ref}
---
(function "show-values" (brace-group (command (word "echo") (word "values:") (word "${A[@]}"))))
(command (word "declare") (word "-A") (word "A=(['K']=val)"))
(command (word "show-values"))
(command (word "declare") (word "ref='A[\"K\"]'"))
(command (word "echo") (word "ref") (word "${!ref}"))
(command (word "key=K"))
(command (word "declare") (word "ref='A[$key]'"))
(command (word "echo") (word "ref") (word "${!ref}"))
---

=== printf -v and assoc array
show-values() {
  echo values: ${assoc[@]}
}

declare -A assoc=(['K']=val)
show-values

printf -v 'assoc["K"]' '/%s/' val2
show-values

key=K
printf -v 'assoc[$key]' '/%s/' val3
show-values

# Somehow bash doesn't allow this
#prefix=as
#printf -v '${prefix}soc[$key]' '/%s/' val4
#show-values
---
(function "show-values" (brace-group (command (word "echo") (word "values:") (word "${assoc[@]}"))))
(command (word "declare") (word "-A") (word "assoc=(['K']=val)"))
(command (word "show-values"))
(command (word "printf") (word "-v") (word "'assoc[\"K\"]'") (word "'/%s/'") (word "val2"))
(command (word "show-values"))
(command (word "key=K"))
(command (word "printf") (word "-v") (word "'assoc[$key]'") (word "'/%s/'") (word "val3"))
(command (word "show-values"))
---

=== bash bug: (( A["$key"] = 1 )) doesn't work
key='\'
declare -A A
#A["$key"]=1

# Works in both
#A["$key"]=42

# Works in bash only
#(( A[\$key] = 42 ))

(( A["$key"] = 42 ))

argv.py "${!A[@]}"
argv.py "${A[@]}"
---
(command (word "key='\\'"))
(command (word "declare") (word "-A") (word "A"))
(arith (word " A[\"$key\"] = 42 "))
(command (word "argv.py") (word "\"${!A[@]}\""))
(command (word "argv.py") (word "\"${A[@]}\""))
---

=== Implicit increment of keys
declare -a arr=( [30]=a b [40]=x y)
argv.py "${!arr[@]}"
argv.py "${arr[@]}"
---
(command (word "declare") (word "-a") (word "arr=([30]=a b [40]=x y)"))
(command (word "argv.py") (word "\"${!arr[@]}\""))
(command (word "argv.py") (word "\"${arr[@]}\""))
---

=== test -v assoc[key]
typeset -A assoc
assoc=([empty]='' [k]=v)

echo 'no quotes'

test -v assoc[empty]
echo empty=$?

test -v assoc[k]
echo k=$?

test -v assoc[nonexistent]
echo nonexistent=$?

echo

# Now with quotes
echo 'quotes'

test -v assoc["empty"]
echo empty=$?

test -v assoc['k']
echo k=$?

test -v assoc['nonexistent'] 
echo nonexistent=$?
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=([empty]='' [k]=v)"))
(command (word "echo") (word "'no quotes'"))
(command (word "test") (word "-v") (word "assoc[empty]"))
(command (word "echo") (word "empty=$?"))
(command (word "test") (word "-v") (word "assoc[k]"))
(command (word "echo") (word "k=$?"))
(command (word "test") (word "-v") (word "assoc[nonexistent]"))
(command (word "echo") (word "nonexistent=$?"))
(command (word "echo"))
(command (word "echo") (word "'quotes'"))
(command (word "test") (word "-v") (word "assoc[\"empty\"]"))
(command (word "echo") (word "empty=$?"))
(command (word "test") (word "-v") (word "assoc['k']"))
(command (word "echo") (word "k=$?"))
(command (word "test") (word "-v") (word "assoc['nonexistent']"))
(command (word "echo") (word "nonexistent=$?"))
---

=== test -v with dynamic parsing
typeset -A assoc
assoc=([empty]='' [k]=v)

key=empty
test -v 'assoc[$key]'
echo empty=$?

key=k
test -v 'assoc[$key]'
echo k=$?

key=nonexistent
test -v 'assoc[$key]'
echo nonexistent=$?
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=([empty]='' [k]=v)"))
(command (word "key=empty"))
(command (word "test") (word "-v") (word "'assoc[$key]'"))
(command (word "echo") (word "empty=$?"))
(command (word "key=k"))
(command (word "test") (word "-v") (word "'assoc[$key]'"))
(command (word "echo") (word "k=$?"))
(command (word "key=nonexistent"))
(command (word "test") (word "-v") (word "'assoc[$key]'"))
(command (word "echo") (word "nonexistent=$?"))
---

=== [[ -v assoc[key] ]]
typeset -A assoc
assoc=([empty]='' [k]=v)

echo 'no quotes'

[[ -v assoc[empty] ]]
echo empty=$?

[[ -v assoc[k] ]]
echo k=$?

[[ -v assoc[nonexistent] ]]
echo nonexistent=$?

echo

# Now with quotes
echo 'quotes'

[[ -v assoc["empty"] ]]
echo empty=$?

[[ -v assoc['k'] ]]
echo k=$?

[[ -v assoc['nonexistent'] ]]
echo nonexistent=$?

echo

echo 'vars'

key=empty
[[ -v assoc[$key] ]]
echo empty=$?

key=k
[[ -v assoc[$key] ]]
echo k=$?

key=nonexistent
[[ -v assoc[$key] ]]
echo nonexistent=$?
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=([empty]='' [k]=v)"))
(command (word "echo") (word "'no quotes'"))
(cond (cond-unary "-v" (cond-term "assoc[empty]")))
(command (word "echo") (word "empty=$?"))
(cond (cond-unary "-v" (cond-term "assoc[k]")))
(command (word "echo") (word "k=$?"))
(cond (cond-unary "-v" (cond-term "assoc[nonexistent]")))
(command (word "echo") (word "nonexistent=$?"))
(command (word "echo"))
(command (word "echo") (word "'quotes'"))
(cond (cond-unary "-v" (cond-term "assoc["empty"]")))
(command (word "echo") (word "empty=$?"))
(cond (cond-unary "-v" (cond-term "assoc['k']")))
(command (word "echo") (word "k=$?"))
(cond (cond-unary "-v" (cond-term "assoc['nonexistent']")))
(command (word "echo") (word "nonexistent=$?"))
(command (word "echo"))
(command (word "echo") (word "'vars'"))
(command (word "key=empty"))
(cond (cond-unary "-v" (cond-term "assoc[$key]")))
(command (word "echo") (word "empty=$?"))
(command (word "key=k"))
(cond (cond-unary "-v" (cond-term "assoc[$key]")))
(command (word "echo") (word "k=$?"))
(command (word "key=nonexistent"))
(cond (cond-unary "-v" (cond-term "assoc[$key]")))
(command (word "echo") (word "nonexistent=$?"))
---

=== [[ -v assoc[key] ]] syntax errors
typeset -A assoc
assoc=([empty]='' [k]=v)

[[ -v assoc[empty] ]]
echo empty=$?

[[ -v assoc[k] ]]
echo k=$?

[[ -v assoc[k]z ]]
echo typo=$?
---
(command (word "typeset") (word "-A") (word "assoc"))
(command (word "assoc=([empty]='' [k]=v)"))
(cond (cond-unary "-v" (cond-term "assoc[empty]")))
(command (word "echo") (word "empty=$?"))
(cond (cond-unary "-v" (cond-term "assoc[k]")))
(command (word "echo") (word "k=$?"))
(cond (cond-unary "-v" (cond-term "assoc[k]z")))
(command (word "echo") (word "typo=$?"))
---

=== BashAssoc a+=()
declare -A a=([apple]=red [orange]=orange)
a+=([lemon]=yellow [banana]=yellow)
echo "apple is ${a['apple']}"
echo "orange is ${a['orange']}"
echo "lemon is ${a['lemon']}"
echo "banana is ${a['banana']}"
---
(command (word "declare") (word "-A") (word "a=([apple]=red [orange]=orange)"))
(command (word "a+=([lemon]=yellow [banana]=yellow)"))
(command (word "echo") (word "\"apple is ${a['apple']}\""))
(command (word "echo") (word "\"orange is ${a['orange']}\""))
(command (word "echo") (word "\"lemon is ${a['lemon']}\""))
(command (word "echo") (word "\"banana is ${a['banana']}\""))
---

=== BashAssoc ${a[@]@Q}
declare -A a=()
a['symbol1']=\'\'
a['symbol2']='"'
a['symbol3']='()<>&|'
a['symbol4']='[]*?'
echo "[${a[@]@Q}]"
echo "[${a[*]@Q}]"
---
(command (word "declare") (word "-A") (word "a=()"))
(command (word "a['symbol1']=\\'\\'"))
(command (word "a['symbol2']='\"'"))
(command (word "a['symbol3']='()<>&|'"))
(command (word "a['symbol4']='[]*?'"))
(command (word "echo") (word "\"[${a[@]@Q}]\""))
(command (word "echo") (word "\"[${a[*]@Q}]\""))
---

=== "${a[@]}" and "${a[*]}"
a=(1 '2 3')
argv.py "${a[@]}" "${a[*]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[@]}\"") (word "\"${a[*]}\""))
---

=== ${a[@]} and ${a[*]}
a=(1 '2 3')
argv.py ${a[@]} ${a[*]}
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "${a[@]}") (word "${a[*]}"))
---

=== 4 ways to interpolate empty array
argv.py 1 "${a[@]}" 2 ${a[@]} 3 "${a[*]}" 4 ${a[*]} 5
---
(command (word "argv.py") (word "1") (word "\"${a[@]}\"") (word "2") (word "${a[@]}") (word "3") (word "\"${a[*]}\"") (word "4") (word "${a[*]}") (word "5"))
---

=== empty array
empty=()
argv.py "${empty[@]}"
---
(command (word "empty=()"))
(command (word "argv.py") (word "\"${empty[@]}\""))
---

=== Empty array with :-
empty=()
argv.py ${empty[@]:-not one} "${empty[@]:-not one}"
---
(command (word "empty=()"))
(command (word "argv.py") (word "${empty[@]:-not one}") (word "\"${empty[@]:-not one}\""))
---

=== Assignment Causes Array Decay
set -- x y z
argv.py "[$@]"
var="[$@]"
argv.py "$var"
---
(command (word "set") (word "--") (word "x") (word "y") (word "z"))
(command (word "argv.py") (word "\"[$@]\""))
(command (word "var=\"[$@]\""))
(command (word "argv.py") (word "\"$var\""))
---

=== Array Decay with IFS
IFS=x
set -- x y z
var="[$@]"
argv.py "$var"
---
(command (word "IFS=x"))
(command (word "set") (word "--") (word "x") (word "y") (word "z"))
(command (word "var=\"[$@]\""))
(command (word "argv.py") (word "\"$var\""))
---

=== User arrays decay
declare -a a b
a=(x y z)
b="${a[@]}"  # this collapses to a string
c=("${a[@]}")  # this preserves the array
c[1]=YYY  # mutate a copy -- doesn't affect the original
argv.py "${a[@]}"
argv.py "${b}"
argv.py "${c[@]}"
---
(command (word "declare") (word "-a") (word "a") (word "b"))
(command (word "a=(x y z)"))
(command (word "b=\"${a[@]}\""))
(command (word "c=(\"${a[@]}\")"))
(command (word "c[1]=YYY"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "argv.py") (word "\"${b}\""))
(command (word "argv.py") (word "\"${c[@]}\""))
---

=== strict_array: $array is not valid in OSH, is ${array[0]} in ksh/bash
shopt -s strict_array

a=(1 '2 3')
echo $a
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "a=(1 '2 3')"))
(command (word "echo") (word "$a"))
---

=== strict_array: ${array} is not valid in OSH, is ${array[0]} in ksh/bash
shopt -s strict_array

a=(1 '2 3')
echo ${a}
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "a=(1 '2 3')"))
(command (word "echo") (word "${a}"))
---

=== Assign to array index without initialization
a[5]=5
a[6]=6
echo "${a[@]}" ${#a[@]}
---
(command (word "a[5]=5"))
(command (word "a[6]=6"))
(command (word "echo") (word "\"${a[@]}\"") (word "${#a[@]}"))
---

=== a[40] grows array
a=(1 2 3)
a[1]=5
a[40]=30  # out of order
a[10]=20
echo "${a[@]}" "${#a[@]}"  # length is 1
---
(command (word "a=(1 2 3)"))
(command (word "a[1]=5"))
(command (word "a[40]=30"))
(command (word "a[10]=20"))
(command (word "echo") (word "\"${a[@]}\"") (word "\"${#a[@]}\""))
---

=== array decays to string when comparing with [[ a = b ]]
a=('1 2' '3 4')
s='1 2 3 4'  # length 2, length 4
echo ${#a[@]} ${#s}
[[ "${a[@]}" = "$s" ]] && echo EQUAL
---
(command (word "a=('1 2' '3 4')"))
(command (word "s='1 2 3 4'"))
(command (word "echo") (word "${#a[@]}") (word "${#s}"))
(and (cond (cond-binary "=" (cond-term ""${a[@]}"") (cond-term ""$s""))) (command (word "echo") (word "EQUAL")))
---

=== ++ on a whole array increments the first element (disallowed with strict_array)
shopt -s strict_array

a=(1 10)
(( a++ ))  # doesn't make sense
echo "${a[@]}"
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "a=(1 10)"))
(arith (word " a++ "))
(command (word "echo") (word "\"${a[@]}\""))
---

=== Apply vectorized operations on ${a[*]}
a=('-x-' 'y-y' '-z-')

# This does the prefix stripping FIRST, and then it joins.
argv.py "${a[*]#-}"
---
(command (word "a=('-x-' 'y-y' '-z-')"))
(command (word "argv.py") (word "\"${a[*]#-}\""))
---

=== value.BashArray internal representation - Indexed
case $SH in mksh) exit ;; esac

z=()
declare -a | grep z=

z+=(b c)
declare -a | grep z=

# z[5]= finds the index, or puts it in SORTED order I think
z[5]=d
declare -a | grep z=

z[1]=ZZZ
declare -a | grep z=

# Adds after last index
z+=(f g)
declare -a | grep z=

# This is the equivalent of z[0]+=mystr
z+=-mystr
declare -a | grep z=

z[1]+=-append
declare -a | grep z=

argv.py keys "${!z[@]}"  # 0 1 5 6 7
argv.py values "${z[@]}"

# can't do this conversion
declare -A z
declare -A | grep z=

echo status=$?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "z=()"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z+=(b c)"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z[5]=d"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z[1]=ZZZ"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z+=(f g)"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z+=-mystr"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "z[1]+=-append"))
(pipe (command (word "declare") (word "-a")) (command (word "grep") (word "z=")))
(command (word "argv.py") (word "keys") (word "\"${!z[@]}\""))
(command (word "argv.py") (word "values") (word "\"${z[@]}\""))
(command (word "declare") (word "-A") (word "z"))
(pipe (command (word "declare") (word "-A")) (command (word "grep") (word "z=")))
(command (word "echo") (word "status=$?"))
---

=== value.BashArray internal representation - Assoc (ordering is a problem)
case $SH in mksh) exit ;; esac

declare -A A=([k]=v)
declare -A | grep A=

argv.py keys "${!A[@]}"
argv.py values "${A[@]}"

exit

# Huh this actually works, we don't support it
# Hm the order here is all messed up, in bash 5.2
A+=([k2]=v2 [0]=foo [9]=9 [9999]=9999)
declare -A | grep A=

A+=-append
declare -A | grep A=

argv.py keys "${!A[@]}"
argv.py values "${A[@]}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "declare") (word "-A") (word "A=([k]=v)"))
(pipe (command (word "declare") (word "-A")) (command (word "grep") (word "A=")))
(command (word "argv.py") (word "keys") (word "\"${!A[@]}\""))
(command (word "argv.py") (word "values") (word "\"${A[@]}\""))
(command (word "exit"))
(command (word "A+=([k2]=v2 [0]=foo [9]=9 [9999]=9999)"))
(pipe (command (word "declare") (word "-A")) (command (word "grep") (word "A=")))
(command (word "A+=-append"))
(pipe (command (word "declare") (word "-A")) (command (word "grep") (word "A=")))
(command (word "argv.py") (word "keys") (word "\"${!A[@]}\""))
(command (word "argv.py") (word "values") (word "\"${A[@]}\""))
---

=== Tilde expansions in RHS of [k]=v (BashArray)
HOME=/home/user
a=([2]=~ [4]=~:~:~)
echo "${a[2]}"
echo "${a[4]}"
---
(command (word "HOME=/home/user"))
(command (word "a=([2]=~ [4]=~:~:~)"))
(command (word "echo") (word "\"${a[2]}\""))
(command (word "echo") (word "\"${a[4]}\""))
---

=== Tilde expansions in RHS of [k]=v (BashAssoc)
# Note: bash-5.2 has a bug that the tilde doesn't expand on the right hand side
# of [key]=value.  This problem doesn't happen in bash-3.1..5.1 and bash-5.3.
HOME=/home/user
declare -A a
declare -A a=(['home']=~ ['hello']=~:~:~)
echo "${a['home']}"
echo "${a['hello']}"
---
(command (word "HOME=/home/user"))
(command (word "declare") (word "-A") (word "a"))
(command (word "declare") (word "-A") (word "a=(['home']=~ ['hello']=~:~:~)"))
(command (word "echo") (word "\"${a['home']}\""))
(command (word "echo") (word "\"${a['hello']}\""))
---

=== index increments without [k]= (BashArray)
a=([100]=1 2 3 4)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([100]=1 2 3 4 [5]=a b c d)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "a=([100]=1 2 3 4)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=([100]=1 2 3 4 [5]=a b c d)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== [k]=$v and [k]="$@" (BashArray)
i=5
v='1 2 3'
a=($v [i]=$v)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

x=(3 5 7)
a=($v [i]="${x[*]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]="${x[@]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]=${x[*]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]=${x[@]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "i=5"))
(command (word "v='1 2 3'"))
(command (word "a=($v [i]=$v)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "x=(3 5 7)"))
(command (word "a=($v [i]=\"${x[*]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=($v [i]=\"${x[@]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=($v [i]=${x[*]})"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=($v [i]=${x[@]})"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== [k]=$v and [k]="$@" (BashAssoc)
i=5
v='1 2 3'
declare -A a
a=([i]=$v)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

x=(3 5 7)
a=([i]="${x[*]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]="${x[@]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]=${x[*]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]=${x[@]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "i=5"))
(command (word "v='1 2 3'"))
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([i]=$v)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "x=(3 5 7)"))
(command (word "a=([i]=\"${x[*]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=([i]=\"${x[@]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=([i]=${x[*]})"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=([i]=${x[@]})"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== append to element (BashArray)
hello=100
a=([hello]=1 [hello]+=2)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a+=([hello]+=:34 [hello]+=:56)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "hello=100"))
(command (word "a=([hello]=1 [hello]+=2)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a+=([hello]+=:34 [hello]+=:56)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== append to element (BashAssoc)
declare -A a
hello=100
a=([hello]=1 [hello]+=2)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a+=([hello]+=:34 [hello]+=:56)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "hello=100"))
(command (word "a=([hello]=1 [hello]+=2)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a+=([hello]+=:34 [hello]+=:56)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== non-index forms of element (BashAssoc)
declare -A a
a=([j]=1 2 3 4)
echo "status=$?"
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([j]=1 2 3 4)"))
(command (word "echo") (word "\"status=$?\""))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== Evaluation order (1)
# RHS of [k]=v are expanded when the initializer list is instanciated.  For the
# indexed array, the array indices are evaluated when the array is modified.
i=1
a=([100+i++]=$((i++)) [200+i++]=$((i++)) [300+i++]=$((i++)))
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "i=1"))
(command (word "a=([100+i++]=$((i++)) [200+i++]=$((i++)) [300+i++]=$((i++)))"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== Evaluation order (2)
# When evaluating the index, the modification to the array by the previous item
# of the initializer list is visible to the current item.
a=([0]=1+2+3 [a[0]]=10 [a[6]]=hello)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "a=([0]=1+2+3 [a[0]]=10 [a[6]]=hello)"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== Evaluation order (3)
# RHS should be expanded before any modification to the array.
a=(old1 old2 old3)
a=("${a[2]}" "${a[0]}" "${a[1]}" "${a[2]}" "${a[0]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=(old1 old2 old3)
old1=101 old2=102 old3=103
new1=201 new2=202 new3=203
a+=([0]=new1 [1]=new2 [2]=new3 [5]="${a[2]}" [a[0]]="${a[0]}" [a[1]]="${a[1]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
---
(command (word "a=(old1 old2 old3)"))
(command (word "a=(\"${a[2]}\" \"${a[0]}\" \"${a[1]}\" \"${a[2]}\" \"${a[0]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
(command (word "a=(old1 old2 old3)"))
(command (word "old1=101") (word "old2=102") (word "old3=103"))
(command (word "new1=201") (word "new2=202") (word "new3=203"))
(command (word "a+=([0]=new1 [1]=new2 [2]=new3 [5]=\"${a[2]}\" [a[0]]=\"${a[0]}\" [a[1]]=\"${a[1]}\")"))
(semi (command (word "printf") (word "'keys: '")) (command (word "argv.py") (word "\"${!a[@]}\"")))
(semi (command (word "printf") (word "'vals: '")) (command (word "argv.py") (word "\"${a[@]}\"")))
---

=== [k1]=v1 (BashArray)
# Note: This and next tests have originally been in "spec/assign.test.sh" and
# compared the behavior of OSH's BashAssoc and Bash's indexed array.  After
# supporting "arr=([index]=value)" for indexed arrays, the test was adjusted
# and copied here. See also the corresponding tests in "spec/assign.test.sh"
a=([k1]=v1 [k2]=v2)
echo ${a["k1"]}
echo ${a["k2"]}
---
(command (word "a=([k1]=v1 [k2]=v2)"))
(command (word "echo") (word "${a[\"k1\"]}"))
(command (word "echo") (word "${a[\"k2\"]}"))
---

=== [k1]=v1 (BashAssoc)
declare -A a
a=([k1]=v1 [k2]=v2)
echo ${a["k1"]}
echo ${a["k2"]}
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([k1]=v1 [k2]=v2)"))
(command (word "echo") (word "${a[\"k1\"]}"))
(command (word "echo") (word "${a[\"k2\"]}"))
---

=== [k1]=v1 looking like brace expansions (BashAssoc)
declare -A a
a=([k2]=-{a,b}-)
echo ${a["k2"]}
---
(command (word "declare") (word "-A") (word "a"))
(command (word "a=([k2]=-{a,b}-)"))
(command (word "echo") (word "${a[\"k2\"]}"))
---

=== [k1]=v1 looking like brace expansions (BashArray)
a=([k2]=-{a,b}-)
echo ${a["k2"]}
---
(command (word "a=([k2]=-{a,b}-)"))
(command (word "echo") (word "${a[\"k2\"]}"))
---

=== BashArray cannot be changed to BashAssoc and vice versa
declare -a a=(1 2 3 4)
eval 'declare -A a=([a]=x [b]=y [c]=z)'
echo status=$?
argv.py "${a[@]}"

declare -A A=([a]=x [b]=y [c]=z)
eval 'declare -a A=(1 2 3 4)'
echo status=$?
argv.py $(printf '%s\n' "${A[@]}" | sort)
---
(command (word "declare") (word "-a") (word "a=(1 2 3 4)"))
(command (word "eval") (word "'declare -A a=([a]=x [b]=y [c]=z)'"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "declare") (word "-A") (word "A=([a]=x [b]=y [c]=z)"))
(command (word "eval") (word "'declare -a A=(1 2 3 4)'"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "$(printf '%s\\n' \"${A[@]}\" | sort)"))
---

=== (strict_array) s+=()
case $SH in bash) ;; *) shopt --set strict_array ;; esac

s1=hello
s2=world

# Overwriting Str with a new BashArray is allowed
eval 's1=(1 2 3 4)'
echo status=$?
declare -p s1
# Promoting Str to a BashArray is disallowed
eval 's2+=(1 2 3 4)'
echo status=$?
declare -p s2
---
(case (word "$SH") (pattern ((word "bash")) ()) (pattern ((word "*")) (command (word "shopt") (word "--set") (word "strict_array"))))
(command (word "s1=hello"))
(command (word "s2=world"))
(command (word "eval") (word "'s1=(1 2 3 4)'"))
(command (word "echo") (word "status=$?"))
(command (word "declare") (word "-p") (word "s1"))
(command (word "eval") (word "'s2+=(1 2 3 4)'"))
(command (word "echo") (word "status=$?"))
(command (word "declare") (word "-p") (word "s2"))
---

=== (strict_array) declare -A s+=()
case $SH in bash) ;; *) shopt --set strict_array ;; esac

s1=hello
s2=world

# Overwriting Str with a new BashAssoc is allowed
eval 'declare -A s1=([a]=x [b]=y)'
echo status=$?
declare -p s1
# Promoting Str to a BashAssoc is disallowed
eval 'declare -A s2+=([a]=x [b]=y)'
echo status=$?
declare -p s2
---
(case (word "$SH") (pattern ((word "bash")) ()) (pattern ((word "*")) (command (word "shopt") (word "--set") (word "strict_array"))))
(command (word "s1=hello"))
(command (word "s2=world"))
(command (word "eval") (word "'declare -A s1=([a]=x [b]=y)'"))
(command (word "echo") (word "status=$?"))
(command (word "declare") (word "-p") (word "s1"))
(command (word "eval") (word "'declare -A s2+=([a]=x [b]=y)'"))
(command (word "echo") (word "status=$?"))
(command (word "declare") (word "-p") (word "s2"))
---

=== (strict_array) assoc=(key value ...) is not allowed
case $SH in bash) ;; *) shopt --set strict_array ;; esac

declare -A a=([a]=b)
eval "a=(1 2 3 4)"
declare -p a
---
(case (word "$SH") (pattern ((word "bash")) ()) (pattern ((word "*")) (command (word "shopt") (word "--set") (word "strict_array"))))
(command (word "declare") (word "-A") (word "a=([a]=b)"))
(command (word "eval") (word "\"a=(1 2 3 4)\""))
(command (word "declare") (word "-p") (word "a"))
---

=== Performance demo
case $SH in bash|mksh) exit ;; esac

shopt -s ysh:upgrade

#pp test_ (a)

sp=( foo {25..27} bar )

sp[10]='sparse'

echo $[type(sp)]

echo len: "${#sp[@]}"

#echo $[len(sp)]

echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"

echo slice: "${sp[@]:2:3}"

sp[0]=set0

echo get0: "${sp[0]}"
echo get1: "${sp[1]}"
echo ---

to_append=(x y)
echo append
sp+=("${to_append[@]}")
echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"
echo ---

echo unset
unset -v 'sp[11]'
echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"
---
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (command (word "exit"))))
(command (word "shopt") (word "-s") (word "ysh:upgrade"))
(command (word "sp=(foo {25..27} bar)"))
(command (word "sp[10]='sparse'"))
(command (word "echo") (word "$[type(sp)]"))
(command (word "echo") (word "len:") (word "\"${#sp[@]}\""))
(command (word "echo") (word "subst:") (word "\"${sp[@]}\""))
(command (word "echo") (word "keys:") (word "\"${!sp[@]}\""))
(command (word "echo") (word "slice:") (word "\"${sp[@]:2:3}\""))
(command (word "sp[0]=set0"))
(command (word "echo") (word "get0:") (word "\"${sp[0]}\""))
(command (word "echo") (word "get1:") (word "\"${sp[1]}\""))
(command (word "echo") (word "---"))
(command (word "to_append=(x y)"))
(command (word "echo") (word "append"))
(command (word "sp+=(\"${to_append[@]}\")"))
(command (word "echo") (word "subst:") (word "\"${sp[@]}\""))
(command (word "echo") (word "keys:") (word "\"${!sp[@]}\""))
(command (word "echo") (word "---"))
(command (word "echo") (word "unset"))
(command (word "unset") (word "-v") (word "'sp[11]'"))
(command (word "echo") (word "subst:") (word "\"${sp[@]}\""))
(command (word "echo") (word "keys:") (word "\"${!sp[@]}\""))
---

=== test length
sp=(x y z)

sp[5]=z

echo len=${#sp[@]}

sp[10]=z

echo len=${#sp[@]}
---
(command (word "sp=(x y z)"))
(command (word "sp[5]=z"))
(command (word "echo") (word "len=${#sp[@]}"))
(command (word "sp[10]=z"))
(command (word "echo") (word "len=${#sp[@]}"))
---

=== test "declare -p sp"
a0=()
a1=(1)
a2=(1 2)
a=(x y z w)
a[500]=100
a[1000]=100

case $SH in
bash|mksh)
  typeset -p a0 a1 a2 a
  exit ;;
esac

declare -p a0 a1 a2 a
---
(command (word "a0=()"))
(command (word "a1=(1)"))
(command (word "a2=(1 2)"))
(command (word "a=(x y z w)"))
(command (word "a[500]=100"))
(command (word "a[1000]=100"))
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (semi (command (word "typeset") (word "-p") (word "a0") (word "a1") (word "a2") (word "a")) (command (word "exit")))))
(command (word "declare") (word "-p") (word "a0") (word "a1") (word "a2") (word "a"))
---

=== +=
sp1[10]=a
sp1[20]=b
sp1[99]=c
typeset -p sp1 | sed 's/"//g'
sp1+=(1 2 3)
typeset -p sp1 | sed 's/"//g'
---
(command (word "sp1[10]=a"))
(command (word "sp1[20]=b"))
(command (word "sp1[99]=c"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
(command (word "sp1+=(1 2 3)"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
---

=== a[i]=v
sp1[10]=a
sp1[20]=b
sp1[30]=c
typeset -p sp1 | sed 's/"//g'
sp1[10]=X
sp1[25]=Y
sp1[90]=Z
typeset -p sp1 | sed 's/"//g'
---
(command (word "sp1[10]=a"))
(command (word "sp1[20]=b"))
(command (word "sp1[30]=c"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
(command (word "sp1[10]=X"))
(command (word "sp1[25]=Y"))
(command (word "sp1[90]=Z"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
---

=== Negative index with a[i]=v
case $SH in mksh) exit ;; esac

sp1[9]=x
typeset -p sp1 | sed 's/"//g'

sp1[-1]=A
sp1[-4]=B
sp1[-8]=C
sp1[-10]=D
typeset -p sp1 | sed 's/"//g'
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1[9]=x"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
(command (word "sp1[-1]=A"))
(command (word "sp1[-4]=B"))
(command (word "sp1[-8]=C"))
(command (word "sp1[-10]=D"))
(pipe (command (word "typeset") (word "-p") (word "sp1")) (command (word "sed") (word "'s/\"//g'")))
---

=== a[i]=v with BigInt
case $SH in mksh) exit ;; esac

sp1[1]=x
sp1[5]=y
sp1[9]=z

echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFF]=a
echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFE]=b
echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFD]=c
echo "${#sp1[@]}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1[1]=x"))
(command (word "sp1[5]=y"))
(command (word "sp1[9]=z"))
(command (word "echo") (word "\"${#sp1[@]}\""))
(command (word "sp1[0x7FFFFFFFFFFFFFFF]=a"))
(command (word "echo") (word "\"${#sp1[@]}\""))
(command (word "sp1[0x7FFFFFFFFFFFFFFE]=b"))
(command (word "echo") (word "\"${#sp1[@]}\""))
(command (word "sp1[0x7FFFFFFFFFFFFFFD]=c"))
(command (word "echo") (word "\"${#sp1[@]}\""))
---

=== Negative out-of-bound index with a[i]=v (1/2)
case $SH in mksh) exit ;; esac

sp1[9]=x
sp1[-11]=E
declare -p sp1
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1[9]=x"))
(command (word "sp1[-11]=E"))
(command (word "declare") (word "-p") (word "sp1"))
---

=== Negative out-of-bound index with a[i]=v (2/2)
case $SH in mksh) exit ;; esac

sp1[9]=x

sp1[-21]=F
declare -p sp1
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1[9]=x"))
(command (word "sp1[-21]=F"))
(command (word "declare") (word "-p") (word "sp1"))
---

=== xtrace a+=()
#case $SH in mksh) exit ;; esac

sp1=(1)
set -x
sp1+=(2)
---
(command (word "sp1=(1)"))
(command (word "set") (word "-x"))
(command (word "sp1+=(2)"))
---

=== unset -v a[i]
a=(1 2 3 4 5 6 7 8 9)
typeset -p a
unset -v "a[1]"
typeset -p a
unset -v "a[9]"
typeset -p a
unset -v "a[0]"
typeset -p a
---
(command (word "a=(1 2 3 4 5 6 7 8 9)"))
(command (word "typeset") (word "-p") (word "a"))
(command (word "unset") (word "-v") (word "\"a[1]\""))
(command (word "typeset") (word "-p") (word "a"))
(command (word "unset") (word "-v") (word "\"a[9]\""))
(command (word "typeset") (word "-p") (word "a"))
(command (word "unset") (word "-v") (word "\"a[0]\""))
(command (word "typeset") (word "-p") (word "a"))
---

=== unset -v a[i] with out-of-bound negative index
case $SH in mksh) exit ;; esac

a=(1)

unset -v "a[-2]"
unset -v "a[-3]"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(1)"))
(command (word "unset") (word "-v") (word "\"a[-2]\""))
(command (word "unset") (word "-v") (word "\"a[-3]\""))
---

=== unset -v a[i] for max index
case $SH in mksh) exit ;; esac

a=({1..9})
unset -v 'a[-1]'
a[-1]=x
declare -p a
unset -v 'a[-1]'
a[-1]=x
declare -p a
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=({1..9})"))
(command (word "unset") (word "-v") (word "'a[-1]'"))
(command (word "a[-1]=x"))
(command (word "declare") (word "-p") (word "a"))
(command (word "unset") (word "-v") (word "'a[-1]'"))
(command (word "a[-1]=x"))
(command (word "declare") (word "-p") (word "a"))
---

=== [[ -v a[i] ]]
case $SH in mksh) exit ;; esac

sp1=()
[[ -v sp1[0] ]]; echo "$? (expect 1)"
[[ -v sp1[9] ]]; echo "$? (expect 1)"

sp2=({1..9})
[[ -v sp2[0] ]]; echo "$? (expect 0)"
[[ -v sp2[8] ]]; echo "$? (expect 0)"
[[ -v sp2[9] ]]; echo "$? (expect 1)"
[[ -v sp2[-1] ]]; echo "$? (expect 0)"
[[ -v sp2[-2] ]]; echo "$? (expect 0)"
[[ -v sp2[-9] ]]; echo "$? (expect 0)"

sp3=({1..9})
unset -v 'sp3[4]'
[[ -v sp3[3] ]]; echo "$? (expect 0)"
[[ -v sp3[4] ]]; echo "$? (expect 1)"
[[ -v sp3[5] ]]; echo "$? (expect 0)"
[[ -v sp3[-1] ]]; echo "$? (expect 0)"
[[ -v sp3[-4] ]]; echo "$? (expect 0)"
[[ -v sp3[-5] ]]; echo "$? (expect 1)"
[[ -v sp3[-6] ]]; echo "$? (expect 0)"
[[ -v sp3[-9] ]]; echo "$? (expect 0)"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1=()"))
(semi (cond (cond-unary "-v" (cond-term "sp1[0]"))) (command (word "echo") (word "\"$? (expect 1)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp1[9]"))) (command (word "echo") (word "\"$? (expect 1)\"")))
(command (word "sp2=({1..9})"))
(semi (cond (cond-unary "-v" (cond-term "sp2[0]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp2[8]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp2[9]"))) (command (word "echo") (word "\"$? (expect 1)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp2[-1]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp2[-2]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp2[-9]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(command (word "sp3=({1..9})"))
(command (word "unset") (word "-v") (word "'sp3[4]'"))
(semi (cond (cond-unary "-v" (cond-term "sp3[3]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[4]"))) (command (word "echo") (word "\"$? (expect 1)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[5]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[-1]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[-4]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[-5]"))) (command (word "echo") (word "\"$? (expect 1)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[-6]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
(semi (cond (cond-unary "-v" (cond-term "sp3[-9]"))) (command (word "echo") (word "\"$? (expect 0)\"")))
---

=== [[ -v a[i] ]] with invalid negative index
case $SH in mksh) exit ;; esac

sp1=()
([[ -v sp1[-1] ]]; echo "$? (expect 1)")
sp2=({1..9})
([[ -v sp2[-10] ]]; echo "$? (expect 1)")
sp3=({1..9})
unset -v 'sp3[4]'
([[ -v sp3[-10] ]]; echo "$? (expect 1)")
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp1=()"))
(subshell (semi (cond (cond-unary "-v" (cond-term "sp1[-1]"))) (command (word "echo") (word "\"$? (expect 1)\""))))
(command (word "sp2=({1..9})"))
(subshell (semi (cond (cond-unary "-v" (cond-term "sp2[-10]"))) (command (word "echo") (word "\"$? (expect 1)\""))))
(command (word "sp3=({1..9})"))
(command (word "unset") (word "-v") (word "'sp3[4]'"))
(subshell (semi (cond (cond-unary "-v" (cond-term "sp3[-10]"))) (command (word "echo") (word "\"$? (expect 1)\""))))
---

=== ((sp[i])) and ((sp[i]++))
a=(1 2 3 4 5 6 7 8 9)
unset -v 'a[2]' 'a[3]' 'a[7]'

echo $((a[0]))
echo $((a[1]))
echo $((a[2]))
echo $((a[3]))
echo $((a[7]))

echo $((a[1]++))
echo $((a[2]++))
echo $((a[3]++))
echo $((a[7]++))

echo $((++a[1]))
echo $((++a[2]))
echo $((++a[3]))
echo $((++a[7]))

echo $((a[1] = 100, a[1]))
echo $((a[2] = 100, a[2]))
echo $((a[3] = 100, a[3]))
echo $((a[7] = 100, a[7]))
---
(command (word "a=(1 2 3 4 5 6 7 8 9)"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[7]'"))
(command (word "echo") (word "$((a[0]))"))
(command (word "echo") (word "$((a[1]))"))
(command (word "echo") (word "$((a[2]))"))
(command (word "echo") (word "$((a[3]))"))
(command (word "echo") (word "$((a[7]))"))
(command (word "echo") (word "$((a[1]++))"))
(command (word "echo") (word "$((a[2]++))"))
(command (word "echo") (word "$((a[3]++))"))
(command (word "echo") (word "$((a[7]++))"))
(command (word "echo") (word "$((++a[1]))"))
(command (word "echo") (word "$((++a[2]))"))
(command (word "echo") (word "$((++a[3]))"))
(command (word "echo") (word "$((++a[7]))"))
(command (word "echo") (word "$((a[1] = 100, a[1]))"))
(command (word "echo") (word "$((a[2] = 100, a[2]))"))
(command (word "echo") (word "$((a[3] = 100, a[3]))"))
(command (word "echo") (word "$((a[7] = 100, a[7]))"))
---

=== ((sp[i])) and ((sp[i]++)) with invalid negative index
case $SH in mksh) exit ;; esac

a=({1..9})
unset -v 'a[2]' 'a[3]' 'a[7]'

echo $((a[-10]))
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=({1..9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[7]'"))
(command (word "echo") (word "$((a[-10]))"))
---

=== ${sp[i]}
case $SH in mksh) exit ;; esac

sp=({1..9})
unset -v 'sp[2]'
unset -v 'sp[3]'
unset -v 'sp[7]'

echo "sp[0]: '${sp[0]}', ${sp[0]:-(empty)}, ${sp[0]+set}."
echo "sp[1]: '${sp[1]}', ${sp[1]:-(empty)}, ${sp[1]+set}."
echo "sp[8]: '${sp[8]}', ${sp[8]:-(empty)}, ${sp[8]+set}."
echo "sp[2]: '${sp[2]}', ${sp[2]:-(empty)}, ${sp[2]+set}."
echo "sp[3]: '${sp[3]}', ${sp[3]:-(empty)}, ${sp[3]+set}."
echo "sp[7]: '${sp[7]}', ${sp[7]:-(empty)}, ${sp[7]+set}."

echo "sp[-1]: '${sp[-1]}'."
echo "sp[-2]: '${sp[-2]}'."
echo "sp[-3]: '${sp[-3]}'."
echo "sp[-4]: '${sp[-4]}'."
echo "sp[-9]: '${sp[-9]}'."
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp=({1..9})"))
(command (word "unset") (word "-v") (word "'sp[2]'"))
(command (word "unset") (word "-v") (word "'sp[3]'"))
(command (word "unset") (word "-v") (word "'sp[7]'"))
(command (word "echo") (word "\"sp[0]: '${sp[0]}', ${sp[0]:-(empty)}, ${sp[0]+set}.\""))
(command (word "echo") (word "\"sp[1]: '${sp[1]}', ${sp[1]:-(empty)}, ${sp[1]+set}.\""))
(command (word "echo") (word "\"sp[8]: '${sp[8]}', ${sp[8]:-(empty)}, ${sp[8]+set}.\""))
(command (word "echo") (word "\"sp[2]: '${sp[2]}', ${sp[2]:-(empty)}, ${sp[2]+set}.\""))
(command (word "echo") (word "\"sp[3]: '${sp[3]}', ${sp[3]:-(empty)}, ${sp[3]+set}.\""))
(command (word "echo") (word "\"sp[7]: '${sp[7]}', ${sp[7]:-(empty)}, ${sp[7]+set}.\""))
(command (word "echo") (word "\"sp[-1]: '${sp[-1]}'.\""))
(command (word "echo") (word "\"sp[-2]: '${sp[-2]}'.\""))
(command (word "echo") (word "\"sp[-3]: '${sp[-3]}'.\""))
(command (word "echo") (word "\"sp[-4]: '${sp[-4]}'.\""))
(command (word "echo") (word "\"sp[-9]: '${sp[-9]}'.\""))
---

=== ${sp[i]} with negative invalid index
case $SH in mksh) exit ;; esac

sp=({1..9})
unset -v 'sp[2]'
unset -v 'sp[3]'
unset -v 'sp[7]'

echo "sp[-10]: '${sp[-10]}'."
echo "sp[-11]: '${sp[-11]}'."
echo "sp[-19]: '${sp[-19]}'."
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "sp=({1..9})"))
(command (word "unset") (word "-v") (word "'sp[2]'"))
(command (word "unset") (word "-v") (word "'sp[3]'"))
(command (word "unset") (word "-v") (word "'sp[7]'"))
(command (word "echo") (word "\"sp[-10]: '${sp[-10]}'.\""))
(command (word "echo") (word "\"sp[-11]: '${sp[-11]}'.\""))
(command (word "echo") (word "\"sp[-19]: '${sp[-19]}'.\""))
---

=== ${a[@]:offset:length}
case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

echo '==== ${a[@]:offset} ===='
echo "[${a[@]:0}][${a[*]:0}]"
echo "[${a[@]:2}][${a[*]:2}]"
echo "[${a[@]:3}][${a[*]:3}]"
echo "[${a[@]:5}][${a[*]:5}]"
echo "[${a[@]:9}][${a[*]:9}]"
echo "[${a[@]:10}][${a[*]:10}]"
echo "[${a[@]:11}][${a[*]:11}]"

echo '==== ${a[@]:negative} ===='
echo "[${a[@]: -1}][${a[*]: -1}]"
echo "[${a[@]: -2}][${a[*]: -2}]"
echo "[${a[@]: -5}][${a[*]: -5}]"
echo "[${a[@]: -9}][${a[*]: -9}]"
echo "[${a[@]: -10}][${a[*]: -10}]"
echo "[${a[@]: -11}][${a[*]: -11}]"
echo "[${a[@]: -21}][${a[*]: -21}]"

echo '==== ${a[@]:offset:length} ===='
echo "[${a[@]:0:0}][${a[*]:0:0}]"
echo "[${a[@]:0:1}][${a[*]:0:1}]"
echo "[${a[@]:0:3}][${a[*]:0:3}]"
echo "[${a[@]:2:1}][${a[*]:2:1}]"
echo "[${a[@]:2:4}][${a[*]:2:4}]"
echo "[${a[@]:3:4}][${a[*]:3:4}]"
echo "[${a[@]:5:4}][${a[*]:5:4}]"
echo "[${a[@]:5:0}][${a[*]:5:0}]"
echo "[${a[@]:9:1}][${a[*]:9:1}]"
echo "[${a[@]:9:2}][${a[*]:9:2}]"
echo "[${a[@]:10:1}][${a[*]:10:1}]"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(v{0..9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'"))
(command (word "echo") (word "'==== ${a[@]:offset} ===='"))
(command (word "echo") (word "\"[${a[@]:0}][${a[*]:0}]\""))
(command (word "echo") (word "\"[${a[@]:2}][${a[*]:2}]\""))
(command (word "echo") (word "\"[${a[@]:3}][${a[*]:3}]\""))
(command (word "echo") (word "\"[${a[@]:5}][${a[*]:5}]\""))
(command (word "echo") (word "\"[${a[@]:9}][${a[*]:9}]\""))
(command (word "echo") (word "\"[${a[@]:10}][${a[*]:10}]\""))
(command (word "echo") (word "\"[${a[@]:11}][${a[*]:11}]\""))
(command (word "echo") (word "'==== ${a[@]:negative} ===='"))
(command (word "echo") (word "\"[${a[@]: -1}][${a[*]: -1}]\""))
(command (word "echo") (word "\"[${a[@]: -2}][${a[*]: -2}]\""))
(command (word "echo") (word "\"[${a[@]: -5}][${a[*]: -5}]\""))
(command (word "echo") (word "\"[${a[@]: -9}][${a[*]: -9}]\""))
(command (word "echo") (word "\"[${a[@]: -10}][${a[*]: -10}]\""))
(command (word "echo") (word "\"[${a[@]: -11}][${a[*]: -11}]\""))
(command (word "echo") (word "\"[${a[@]: -21}][${a[*]: -21}]\""))
(command (word "echo") (word "'==== ${a[@]:offset:length} ===='"))
(command (word "echo") (word "\"[${a[@]:0:0}][${a[*]:0:0}]\""))
(command (word "echo") (word "\"[${a[@]:0:1}][${a[*]:0:1}]\""))
(command (word "echo") (word "\"[${a[@]:0:3}][${a[*]:0:3}]\""))
(command (word "echo") (word "\"[${a[@]:2:1}][${a[*]:2:1}]\""))
(command (word "echo") (word "\"[${a[@]:2:4}][${a[*]:2:4}]\""))
(command (word "echo") (word "\"[${a[@]:3:4}][${a[*]:3:4}]\""))
(command (word "echo") (word "\"[${a[@]:5:4}][${a[*]:5:4}]\""))
(command (word "echo") (word "\"[${a[@]:5:0}][${a[*]:5:0}]\""))
(command (word "echo") (word "\"[${a[@]:9:1}][${a[*]:9:1}]\""))
(command (word "echo") (word "\"[${a[@]:9:2}][${a[*]:9:2}]\""))
(command (word "echo") (word "\"[${a[@]:10:1}][${a[*]:10:1}]\""))
---

=== ${@:offset:length}
case $SH in mksh) exit ;; esac

set -- v{1..9}

{
  echo '==== ${@:offset:length} ===='
  echo "[${*:0:3}][${*:0:3}]"
  echo "[${*:1:3}][${*:1:3}]"
  echo "[${*:3:3}][${*:3:3}]"
  echo "[${*:5:10}][${*:5:10}]"

  echo '==== ${@:negative} ===='
  echo "[${*: -1}][${*: -1}]"
  echo "[${*: -3}][${*: -3}]"
  echo "[${*: -9}][${*: -9}]"
  echo "[${*: -10}][${*: -10}]"
  echo "[${*: -11}][${*: -11}]"
  echo "[${*: -3:2}][${*: -3:2}]"
  echo "[${*: -9:4}][${*: -9:4}]"
  echo "[${*: -10:4}][${*: -10:4}]"
  echo "[${*: -11:4}][${*: -11:4}]"
} | sed "s:$SH:\$SH:g;s:${SH##*/}:\$SH:g"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "set") (word "--") (word "v{1..9}"))
(pipe (brace-group (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "'==== ${@:offset:length} ===='")) (command (word "echo") (word "\"[${*:0:3}][${*:0:3}]\""))) (command (word "echo") (word "\"[${*:1:3}][${*:1:3}]\""))) (command (word "echo") (word "\"[${*:3:3}][${*:3:3}]\""))) (command (word "echo") (word "\"[${*:5:10}][${*:5:10}]\""))) (command (word "echo") (word "'==== ${@:negative} ===='"))) (command (word "echo") (word "\"[${*: -1}][${*: -1}]\""))) (command (word "echo") (word "\"[${*: -3}][${*: -3}]\""))) (command (word "echo") (word "\"[${*: -9}][${*: -9}]\""))) (command (word "echo") (word "\"[${*: -10}][${*: -10}]\""))) (command (word "echo") (word "\"[${*: -11}][${*: -11}]\""))) (command (word "echo") (word "\"[${*: -3:2}][${*: -3:2}]\""))) (command (word "echo") (word "\"[${*: -9:4}][${*: -9:4}]\""))) (command (word "echo") (word "\"[${*: -10:4}][${*: -10:4}]\""))) (command (word "echo") (word "\"[${*: -11:4}][${*: -11:4}]\"")))) (command (word "sed") (word "\"s:$SH:\\$SH:g;s:${SH##*/}:\\$SH:g\"")))
---

=== ${a[@]:BigInt}
case $SH in mksh) exit ;; esac

case $SH in
  bash)
    # disabled with soil-ovm-tarball image 2025-04-30b - the CI runs on Debian 12
    # now
    exit

    # Work around bash integer overflow bug that only happens on say Debian 10,
    # but NOT Debian 12.  The bug exists in bash 5.2.  It's unclear why it
    # depends on the OS version.
    v='/etc/debian_version'
    # debian version 10 / debian buster
    if test -f $v && grep -E 'buster/sid|^10' $v >/dev/null; then
      cat << 'EOF'
[x][x]
[y x][y x]
[z y x][z y x]
[z y x][z y x]
EOF
      exit
    fi
    # Actual STDOUT of buggy bash builds:
    # [][]
    # [][]
    # [][]
    # [][]
    ;;
esac

a=(1 2 3)
a[0x7FFFFFFFFFFFFFFF]=x
a[0x7FFFFFFFFFFFFFFE]=y
a[0x7FFFFFFFFFFFFFFD]=z

echo "[${a[@]: -1}][${a[*]: -1}]"
echo "[${a[@]: -2}][${a[*]: -2}]"
echo "[${a[@]: -3}][${a[*]: -3}]"
echo "[${a[@]: -4}][${a[*]: -4}]"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(case (word "$SH") (pattern ((word "bash")) (semi (semi (command (word "exit")) (command (word "v='/etc/debian_version'"))) (if (and (command (word "test") (word "-f") (word "$v")) (command (word "grep") (word "-E") (word "'buster/sid|^10'") (word "$v") (redirect ">" "/dev/null"))) (semi (command (word "cat") (redirect "<<" "[x][x]
[y x][y x]
[z y x][z y x]
[z y x][z y x]
")) (command (word "exit")))))))
(command (word "a=(1 2 3)"))
(command (word "a[0x7FFFFFFFFFFFFFFF]=x"))
(command (word "a[0x7FFFFFFFFFFFFFFE]=y"))
(command (word "a[0x7FFFFFFFFFFFFFFD]=z"))
(command (word "echo") (word "\"[${a[@]: -1}][${a[*]: -1}]\""))
(command (word "echo") (word "\"[${a[@]: -2}][${a[*]: -2}]\""))
(command (word "echo") (word "\"[${a[@]: -3}][${a[*]: -3}]\""))
(command (word "echo") (word "\"[${a[@]: -4}][${a[*]: -4}]\""))
---

=== ${a[@]}
a=(v{0,1,2,3,4,5,6,7,8,9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]}"
argv.py "abc${a[@]}xyz"
---
(command (word "a=(v{0,1,2,3,4,5,6,7,8,9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "argv.py") (word "\"abc${a[@]}xyz\""))
---

=== ${a[@]#...}
case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]#v}"
argv.py "abc${a[@]#v}xyz"
argv.py "${a[@]%[0-5]}"
argv.py "abc${a[@]%[0-5]}xyz"
argv.py "${a[@]#v?}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(v{0..9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'"))
(command (word "argv.py") (word "\"${a[@]#v}\""))
(command (word "argv.py") (word "\"abc${a[@]#v}xyz\""))
(command (word "argv.py") (word "\"${a[@]%[0-5]}\""))
(command (word "argv.py") (word "\"abc${a[@]%[0-5]}xyz\""))
(command (word "argv.py") (word "\"${a[@]#v?}\""))
---

=== ${a[@]/pat/rep}
case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]/?}"
argv.py "${a[@]//?}"
argv.py "${a[@]/#?}"
argv.py "${a[@]/%?}"

argv.py "${a[@]/v/x}"
argv.py "${a[@]//v/x}"
argv.py "${a[@]/[0-5]/D}"
argv.py "${a[@]//[!0-5]/_}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(v{0..9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'"))
(command (word "argv.py") (word "\"${a[@]/?}\""))
(command (word "argv.py") (word "\"${a[@]//?}\""))
(command (word "argv.py") (word "\"${a[@]/#?}\""))
(command (word "argv.py") (word "\"${a[@]/%?}\""))
(command (word "argv.py") (word "\"${a[@]/v/x}\""))
(command (word "argv.py") (word "\"${a[@]//v/x}\""))
(command (word "argv.py") (word "\"${a[@]/[0-5]/D}\""))
(command (word "argv.py") (word "\"${a[@]//[!0-5]/_}\""))
---

=== ${a[@]@P}, ${a[@]@Q}, and ${a[@]@a}
case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]@P}"
argv.py "${a[*]@P}"
argv.py "${a[@]@Q}"
argv.py "${a[*]@Q}"
argv.py "${a[@]@a}"
argv.py "${a[*]@a}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(v{0..9})"))
(command (word "unset") (word "-v") (word "'a[2]'") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'"))
(command (word "argv.py") (word "\"${a[@]@P}\""))
(command (word "argv.py") (word "\"${a[*]@P}\""))
(command (word "argv.py") (word "\"${a[@]@Q}\""))
(command (word "argv.py") (word "\"${a[*]@Q}\""))
(command (word "argv.py") (word "\"${a[@]@a}\""))
(command (word "argv.py") (word "\"${a[*]@a}\""))
---

=== ${a[@]-unset}, ${a[@]:-empty}, etc.
a1=()
a2=("")
a3=("" "")

echo "a1 unset: [${a1[@]-unset}]"
echo "a1 empty: [${a1[@]:-empty}]"
echo "a2 unset: [${a2[@]-unset}]"
echo "a2 empty: [${a2[@]:-empty}]"
echo "a3 unset: [${a3[@]-unset}]"
echo "a3 empty: [${a3[@]:-empty}]"
---
(command (word "a1=()"))
(command (word "a2=(\"\")"))
(command (word "a3=(\"\" \"\")"))
(command (word "echo") (word "\"a1 unset: [${a1[@]-unset}]\""))
(command (word "echo") (word "\"a1 empty: [${a1[@]:-empty}]\""))
(command (word "echo") (word "\"a2 unset: [${a2[@]-unset}]\""))
(command (word "echo") (word "\"a2 empty: [${a2[@]:-empty}]\""))
(command (word "echo") (word "\"a3 unset: [${a3[@]-unset}]\""))
(command (word "echo") (word "\"a3 empty: [${a3[@]:-empty}]\""))
---

=== ${a-}
a1=()
a2=("" "")
a3=(foo bar)

echo "$a1, ${a1-(unset)}, ${a1:-(empty)};"
echo "$a2, ${a2-(unset)}, ${a2:-(empty)};"
echo "$a3, ${a3-(unset)}, ${a3:-(empty)};"
---
(command (word "a1=()"))
(command (word "a2=(\"\" \"\")"))
(command (word "a3=(foo bar)"))
(command (word "echo") (word "\"$a1, ${a1-(unset)}, ${a1:-(empty)};\""))
(command (word "echo") (word "\"$a2, ${a2-(unset)}, ${a2:-(empty)};\""))
(command (word "echo") (word "\"$a3, ${a3-(unset)}, ${a3:-(empty)};\""))
---

=== ${!a[0]}
case $SH in mksh) exit ;; esac

v1=hello v2=world
a=(v1 v2)

echo "${!a[0]}, ${!a[1]}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "v1=hello") (word "v2=world"))
(command (word "a=(v1 v2)"))
(command (word "echo") (word "\"${!a[0]}, ${!a[1]}\""))
---

=== ${!a[@]}
case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[3]' 'a[4]' 'a[7]' 'a[9]'

argv.py "${!a[@]}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(v{0..9})"))
(command (word "unset") (word "-v") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'") (word "'a[9]'"))
(command (word "argv.py") (word "\"${!a[@]}\""))
---

=== "${a[*]}"
a=(v{0,1,2,3,4,5,6,7,8,9})
unset -v 'a[3]' 'a[4]' 'a[7]' 'a[9]'

echo "${a[*]}"
IFS=
echo "${a[*]}"
IFS=/
echo "${a[*]}"
---
(command (word "a=(v{0,1,2,3,4,5,6,7,8,9})"))
(command (word "unset") (word "-v") (word "'a[3]'") (word "'a[4]'") (word "'a[7]'") (word "'a[9]'"))
(command (word "echo") (word "\"${a[*]}\""))
(command (word "IFS="))
(command (word "echo") (word "\"${a[*]}\""))
(command (word "IFS=/"))
(command (word "echo") (word "\"${a[*]}\""))
---

=== compgen -F _set_COMPREPLY
case $SH in mksh) exit ;; esac

_set_COMPREPLY() {
  COMPREPLY=({0..9})
  unset -v 'COMPREPLY[2]' 'COMPREPLY[4]' 'COMPREPLY[6]'
}

compgen -F _set_COMPREPLY
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(function "_set_COMPREPLY" (brace-group (semi (command (word "COMPREPLY=({0..9})")) (command (word "unset") (word "-v") (word "'COMPREPLY[2]'") (word "'COMPREPLY[4]'") (word "'COMPREPLY[6]'")))))
(command (word "compgen") (word "-F") (word "_set_COMPREPLY"))
---

=== compadjust
case $SH in bash|mksh) exit ;; esac

COMP_ARGV=(echo 'Hello,' 'Bash' 'world!')
compadjust cur prev words cword
argv.py "$cur" "$prev" "$cword"
argv.py "${words[@]}"
---
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (command (word "exit"))))
(command (word "COMP_ARGV=(echo 'Hello,' 'Bash' 'world!')"))
(command (word "compadjust") (word "cur") (word "prev") (word "words") (word "cword"))
(command (word "argv.py") (word "\"$cur\"") (word "\"$prev\"") (word "\"$cword\""))
(command (word "argv.py") (word "\"${words[@]}\""))
---

=== (YSH) @[sp] and @sp
case $SH in bash|mksh) exit ;; esac

a=({0..5})
unset -v 'a[1]' 'a[2]' 'a[4]'

shopt -s parse_at
argv.py @[a]
argv.py @a
---
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (command (word "exit"))))
(command (word "a=({0..5})"))
(command (word "unset") (word "-v") (word "'a[1]'") (word "'a[2]'") (word "'a[4]'"))
(command (word "shopt") (word "-s") (word "parse_at"))
(command (word "argv.py") (word "@[a]"))
(command (word "argv.py") (word "@a"))
---

=== (YSH) $[a1 === a2]
case $SH in bash|mksh) exit ;; esac

a1=(1 2 3)
unset -v 'a1[1]'
a2=(1 2 3)
unset -v 'a2[1]'
a3=(1 2 4)
unset -v 'a3[1]'
a4=(1 2 3)

shopt -s ysh:upgrade

echo $[a1 === a1]
echo $[a1 === a2]
echo $[a1 === a3]
echo $[a1 === a4]
echo $[a2 === a1]
echo $[a3 === a1]
echo $[a4 === a1]
---
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (command (word "exit"))))
(command (word "a1=(1 2 3)"))
(command (word "unset") (word "-v") (word "'a1[1]'"))
(command (word "a2=(1 2 3)"))
(command (word "unset") (word "-v") (word "'a2[1]'"))
(command (word "a3=(1 2 4)"))
(command (word "unset") (word "-v") (word "'a3[1]'"))
(command (word "a4=(1 2 3)"))
(command (word "shopt") (word "-s") (word "ysh:upgrade"))
(command (word "echo") (word "$[a1 === a1]"))
(command (word "echo") (word "$[a1 === a2]"))
(command (word "echo") (word "$[a1 === a3]"))
(command (word "echo") (word "$[a1 === a4]"))
(command (word "echo") (word "$[a2 === a1]"))
(command (word "echo") (word "$[a3 === a1]"))
(command (word "echo") (word "$[a4 === a1]"))
---

=== (YSH) $[bool(a)]
case $SH in bash|mksh) exit ;; esac

a1=()
a2=(0)
a3=(0 1 2)
a4=(0 0)
unset -v 'a4[0]'

shopt -s ysh:upgrade

echo $[bool(a1)]
echo $[bool(a2)]
echo $[bool(a3)]
echo $[bool(a4)]
---
(case (word "$SH") (pattern ((word "bash") (word "mksh")) (command (word "exit"))))
(command (word "a1=()"))
(command (word "a2=(0)"))
(command (word "a3=(0 1 2)"))
(command (word "a4=(0 0)"))
(command (word "unset") (word "-v") (word "'a4[0]'"))
(command (word "shopt") (word "-s") (word "ysh:upgrade"))
(command (word "echo") (word "$[bool(a1)]"))
(command (word "echo") (word "$[bool(a2)]"))
(command (word "echo") (word "$[bool(a3)]"))
(command (word "echo") (word "$[bool(a4)]"))
---

=== Regression: a[-1]=1
case $SH in mksh) exit 99 ;; esac

a[-1]=1
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit") (word "99"))))
(command (word "a[-1]=1"))
---

=== Initializing indexed array with ([index]=value)
case $SH in mksh) exit 99 ;; esac
declare -a a=([xx]=1 [yy]=2 [zz]=3)
echo status=$?
argv.py "${a[@]}"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit") (word "99"))))
(command (word "declare") (word "-a") (word "a=([xx]=1 [yy]=2 [zz]=3)"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== nounset / set -u with empty array (bug in bash 4.3, fixed in 4.4)
# http://lists.gnu.org/archive/html/help-bash/2017-09/msg00005.html

set -o nounset
empty=()
argv.py "${empty[@]}"
echo status=$?
---
(command (word "set") (word "-o") (word "nounset"))
(command (word "empty=()"))
(command (word "argv.py") (word "\"${empty[@]}\""))
(command (word "echo") (word "status=$?"))
---

=== local array
# mksh support local variables, but not local arrays, oddly.
f() {
  local a=(1 '2 3')
  argv.py "${a[0]}"
}
f
---
(function "f" (brace-group (semi (command (word "local") (word "a=(1 '2 3')")) (command (word "argv.py") (word "\"${a[0]}\"")))))
(command (word "f"))
---

=== Command with with word splitting in array
array=('1 2' $(echo '3 4'))
argv.py "${array[@]}"
---
(command (word "array=('1 2' $(echo '3 4'))"))
(command (word "argv.py") (word "\"${array[@]}\""))
---

=== array over multiple lines
a=(
1
'2 3'
)
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== array with empty string
empty=('')
argv.py "${empty[@]}"
---
(command (word "empty=('')"))
(command (word "argv.py") (word "\"${empty[@]}\""))
---

=== Retrieve index
a=(1 '2 3')
argv.py "${a[1]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[1]}\""))
---

=== Retrieve out of bounds index
a=(1 '2 3')
argv.py "${a[3]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[3]}\""))
---

=== Negative index
a=(1 '2 3')
argv.py "${a[-1]}" "${a[-2]}" "${a[-5]}"  # last one out of bounds
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[-1]}\"") (word "\"${a[-2]}\"") (word "\"${a[-5]}\""))
---

=== Negative index and sparse array
a=(0 1 2 3 4)
unset a[1]
unset a[4]
echo "${a[@]}"
echo -1 ${a[-1]}
echo -2 ${a[-2]}
echo -3 ${a[-3]}
echo -4 ${a[-4]}
echo -5 ${a[-5]}

a[-1]+=0  # append 0 on the end
echo ${a[@]}
(( a[-1] += 42 ))
echo ${a[@]}
---
(command (word "a=(0 1 2 3 4)"))
(command (word "unset") (word "a[1]"))
(command (word "unset") (word "a[4]"))
(command (word "echo") (word "\"${a[@]}\""))
(command (word "echo") (word "-1") (word "${a[-1]}"))
(command (word "echo") (word "-2") (word "${a[-2]}"))
(command (word "echo") (word "-3") (word "${a[-3]}"))
(command (word "echo") (word "-4") (word "${a[-4]}"))
(command (word "echo") (word "-5") (word "${a[-5]}"))
(command (word "a[-1]+=0"))
(command (word "echo") (word "${a[@]}"))
(arith (word " a[-1] += 42 "))
(command (word "echo") (word "${a[@]}"))
---

=== Negative index and sparse array
a=(0 1)
unset 'a[-1]'  # remove last element
a+=(2 3)
echo ${a[0]} $((a[0]))
echo ${a[1]} $((a[1]))
echo ${a[2]} $((a[2]))
echo ${a[3]} $((a[3]))
---
(command (word "a=(0 1)"))
(command (word "unset") (word "'a[-1]'"))
(command (word "a+=(2 3)"))
(command (word "echo") (word "${a[0]}") (word "$((a[0]))"))
(command (word "echo") (word "${a[1]}") (word "$((a[1]))"))
(command (word "echo") (word "${a[2]}") (word "$((a[2]))"))
(command (word "echo") (word "${a[3]}") (word "$((a[3]))"))
---

=== Length after unset
a=(0 1 2 3)
unset a[-1]
echo len=${#a[@]}
unset a[-1]
echo len=${#a[@]}
---
(command (word "a=(0 1 2 3)"))
(command (word "unset") (word "a[-1]"))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "unset") (word "a[-1]"))
(command (word "echo") (word "len=${#a[@]}"))
---

=== Retrieve index that is a variable
a=(1 '2 3')
i=1
argv.py "${a[$i]}"
---
(command (word "a=(1 '2 3')"))
(command (word "i=1"))
(command (word "argv.py") (word "\"${a[$i]}\""))
---

=== Retrieve index that is a variable without $
a=(1 '2 3')
i=5
argv.py "${a[i-4]}"
---
(command (word "a=(1 '2 3')"))
(command (word "i=5"))
(command (word "argv.py") (word "\"${a[i-4]}\""))
---

=== Retrieve index that is a command sub
a=(1 '2 3')
argv.py "${a[$(echo 1)]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[$(echo 1)]}\""))
---

=== Retrieve array indices with ${!a}
a=(1 '2 3')
argv.py "${!a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${!a[@]}\""))
---

=== Retrieve sparse array indices with ${!a}
a=()
(( a[99]=1 ))
argv.py "${!a[@]}"
---
(command (word "a=()"))
(arith (word " a[99]=1 "))
(command (word "argv.py") (word "\"${!a[@]}\""))
---

=== ${!a[1]} is named ref in bash
# mksh ignores it
foo=bar
a=('1 2' foo '2 3')
argv.py "${!a[1]}"
---
(command (word "foo=bar"))
(command (word "a=('1 2' foo '2 3')"))
(command (word "argv.py") (word "\"${!a[1]}\""))
---

=== ${!a} on array
# bash gives empty string because it's like a[0]
# mksh gives the name of the variable with !.  Very weird.

a=(1 '2 3')
argv.py "${!a}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${!a}\""))
---

=== All elements unquoted
a=(1 '2 3')
argv.py ${a[@]}
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "${a[@]}"))
---

=== All elements quoted
a=(1 '2 3')
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== $*
a=(1 '2 3')
argv.py ${a[*]}
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "${a[*]}"))
---

=== "$*"
a=(1 '2 3')
argv.py "${a[*]}"
---
(command (word "a=(1 '2 3')"))
(command (word "argv.py") (word "\"${a[*]}\""))
---

=== Interpolate array into array
a=(1 '2 3')
a=(0 "${a[@]}" '4 5')
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "a=(0 \"${a[@]}\" '4 5')"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Exporting array doesn't do anything, not even first element
# bash parses, but doesn't execute.
# mksh gives syntax error -- parses differently with 'export'
# osh no longer parses this statically.

export PYTHONPATH

PYTHONPATH=mystr  # NOTE: in bash, this doesn't work afterward!
printenv.py PYTHONPATH

PYTHONPATH=(myarray)
printenv.py PYTHONPATH

PYTHONPATH=(a b c)
printenv.py PYTHONPATH
---
(command (word "export") (word "PYTHONPATH"))
(command (word "PYTHONPATH=mystr"))
(command (word "printenv.py") (word "PYTHONPATH"))
(command (word "PYTHONPATH=(myarray)"))
(command (word "printenv.py") (word "PYTHONPATH"))
(command (word "PYTHONPATH=(a b c)"))
(command (word "printenv.py") (word "PYTHONPATH"))
---

=== strict_array prevents exporting array
shopt -s strict_array

export PYTHONPATH
PYTHONPATH=(a b c)
printenv.py PYTHONPATH
---
(command (word "shopt") (word "-s") (word "strict_array"))
(command (word "export") (word "PYTHONPATH"))
(command (word "PYTHONPATH=(a b c)"))
(command (word "printenv.py") (word "PYTHONPATH"))
---

=== Arrays can't be used as env bindings
# Hm bash it treats it as a string!
A=a B=(b b) printenv.py A B
---
(command (word "A=a") (word "B=(b b)") (word "printenv.py") (word "A") (word "B"))
---

=== Associative arrays can't be used as env bindings either
A=a B=([k]=v) printenv.py A B
---
(command (word "A=a") (word "B=([k]=v)") (word "printenv.py") (word "A") (word "B"))
---

=== Set element
a=(1 '2 3')
a[0]=9
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "a[0]=9"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Set element with var ref
a=(1 '2 3')
i=0
a[$i]=9
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "i=0"))
(command (word "a[$i]=9"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Set element with array ref
# This makes parsing a little more complex.  Anything can be inside [],
# including other [].
a=(1 '2 3')
i=(0 1)
a[${i[1]}]=9
argv.py "${a[@]}"
---
(command (word "a=(1 '2 3')"))
(command (word "i=(0 1)"))
(command (word "a[${i[1]}]=9"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Set array item to array
a=(1 2)
a[0]=(3 4)
echo "status=$?"
---
(command (word "a=(1 2)"))
(command (word "a[0]=(3 4)"))
(command (word "echo") (word "\"status=$?\""))
---

=== Slice of array with [@]
# mksh doesn't support this syntax!  It's a bash extension.
a=(1 2 3)
argv.py "${a[@]:1:2}"
---
(command (word "a=(1 2 3)"))
(command (word "argv.py") (word "\"${a[@]:1:2}\""))
---

=== Negative slice begin
# mksh doesn't support this syntax!  It's a bash extension.
# NOTE: for some reason -2) has to be in parens?  Ah that's because it
# conflicts with :-!  That's silly.  You can also add a space.
a=(1 2 3 4 5)
argv.py "${a[@]:(-4)}"
---
(command (word "a=(1 2 3 4 5)"))
(command (word "argv.py") (word "\"${a[@]:(-4)}\""))
---

=== Negative slice length
a=(1 2 3 4 5)
argv.py "${a[@]: 1: -3}"
---
(command (word "a=(1 2 3 4 5)"))
(command (word "argv.py") (word "\"${a[@]: 1: -3}\""))
---

=== Slice with arithmetic
a=(1 2 3)
i=5
argv.py "${a[@]:i-4:2}"
---
(command (word "a=(1 2 3)"))
(command (word "i=5"))
(command (word "argv.py") (word "\"${a[@]:i-4:2}\""))
---

=== Number of elements
a=(1 '2 3')
echo "${#a[@]}" ${#a[@]}  # bug fix: also test without quotes
---
(command (word "a=(1 '2 3')"))
(command (word "echo") (word "\"${#a[@]}\"") (word "${#a[@]}"))
---

=== Length of an element
a=(1 '2 3')
echo "${#a[1]}"
---
(command (word "a=(1 '2 3')"))
(command (word "echo") (word "\"${#a[1]}\""))
---

=== Iteration
a=(1 '2 3')
for v in "${a[@]}"; do
  echo $v
done
---
(command (word "a=(1 '2 3')"))
(for (word "v") (in (word "\"${a[@]}\"")) (command (word "echo") (word "$v")))
---

=== glob within array yields separate elements
touch y.Y yy.Y
a=(*.Y)
argv.py "${a[@]}"
---
(command (word "touch") (word "y.Y") (word "yy.Y"))
(command (word "a=(*.Y)"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== declare array and then append
declare -a array
array+=(a)
array+=(b c)
argv.py "${array[@]}"
---
(command (word "declare") (word "-a") (word "array"))
(command (word "array+=(a)"))
(command (word "array+=(b c)"))
(command (word "argv.py") (word "\"${array[@]}\""))
---

=== Single array with :-
# 2024-06 - bash 5.2 and mksh now match, bash 4.4 differed.
# Could change OSH
# zsh agrees with OSH, but it fails most test cases
# 2025-01 We changed OSH.

single=('')
argv.py ${single[@]:-none} x "${single[@]:-none}"
---
(command (word "single=('')"))
(command (word "argv.py") (word "${single[@]:-none}") (word "x") (word "\"${single[@]:-none}\""))
---

=== Stripping a whole array unquoted
# Problem: it joins it first.
files=('foo.c' 'sp ace.h' 'bar.c')
argv.py ${files[@]%.c}
---
(command (word "files=('foo.c' 'sp ace.h' 'bar.c')"))
(command (word "argv.py") (word "${files[@]%.c}"))
---

=== Stripping a whole array quoted
files=('foo.c' 'sp ace.h' 'bar.c')
argv.py "${files[@]%.c}"
---
(command (word "files=('foo.c' 'sp ace.h' 'bar.c')"))
(command (word "argv.py") (word "\"${files[@]%.c}\""))
---

=== Multiple subscripts not allowed
# NOTE: bash 4.3 had a bug where it ignored the bad subscript, but now it is
# fixed.
a=('123' '456')
argv.py "${a[0]}" "${a[0][0]}"
---
(command (word "a=('123' '456')"))
(command (word "argv.py") (word "\"${a[0]}\"") (word "\"${a[0][0]}\""))
---

=== Length op, index op, then transform op is not allowed
a=('123' '456')
echo "${#a[0]}" "${#a[0]/1/xxx}"
---
(command (word "a=('123' '456')"))
(command (word "echo") (word "\"${#a[0]}\"") (word "\"${#a[0]/1/xxx}\""))
---

=== ${mystr[@]} and ${mystr[*]} are no-ops
s='abc'
echo ${s[@]}
echo ${s[*]}
---
(command (word "s='abc'"))
(command (word "echo") (word "${s[@]}"))
(command (word "echo") (word "${s[*]}"))
---

=== ${mystr[@]} and ${mystr[*]} disallowed with strict_array
$SH -c 'shopt -s strict_array; s="abc"; echo ${s[@]}'
echo status=$?

$SH -c 'shopt -s strict_array; s="abc"; echo ${s[*]}'
echo status=$?
---
(command (word "$SH") (word "-c") (word "'shopt -s strict_array; s=\"abc\"; echo ${s[@]}'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'shopt -s strict_array; s=\"abc\"; echo ${s[*]}'"))
(command (word "echo") (word "status=$?"))
---

=== Create a "user" array out of the argv array
set -- 'a b' 'c'
array1=('x y' 'z')
array2=("$@")
argv.py "${array1[@]}" "${array2[@]}"
---
(command (word "set") (word "--") (word "'a b'") (word "'c'"))
(command (word "array1=('x y' 'z')"))
(command (word "array2=(\"$@\")"))
(command (word "argv.py") (word "\"${array1[@]}\"") (word "\"${array2[@]}\""))
---

=== Tilde expansion within array
HOME=/home/bob
a=(~/src ~/git)
echo "${a[@]}"
---
(command (word "HOME=/home/bob"))
(command (word "a=(~/src ~/git)"))
(command (word "echo") (word "\"${a[@]}\""))
---

=== Brace Expansion within Array
a=(-{a,b} {c,d}-)
echo "${a[@]}"
---
(command (word "a=(-{a,b} {c,d}-)"))
(command (word "echo") (word "\"${a[@]}\""))
---

=== array default
default=('1 2' '3')
argv.py "${undef[@]:-${default[@]}}"
---
(command (word "default=('1 2' '3')"))
(command (word "argv.py") (word "\"${undef[@]:-${default[@]}}\""))
---

=== Singleton Array Copy and Assign.  OSH can't index strings with ints
a=( '12 3' )
b=( "${a[@]}" )
c="${a[@]}"  # This decays it to a string
d=${a[*]}  # This decays it to a string
echo ${#a[0]} ${#b[0]}
echo ${#a[@]} ${#b[@]}

# osh is intentionally stricter, and these fail.
echo ${#c[0]} ${#d[0]}
echo ${#c[@]} ${#d[@]}
---
(command (word "a=('12 3')"))
(command (word "b=(\"${a[@]}\")"))
(command (word "c=\"${a[@]}\""))
(command (word "d=${a[*]}"))
(command (word "echo") (word "${#a[0]}") (word "${#b[0]}"))
(command (word "echo") (word "${#a[@]}") (word "${#b[@]}"))
(command (word "echo") (word "${#c[0]}") (word "${#d[0]}"))
(command (word "echo") (word "${#c[@]}") (word "${#d[@]}"))
---

=== declare -a / local -a is empty array
declare -a myarray
argv.py "${myarray[@]}"
myarray+=('x')
argv.py "${myarray[@]}"

f() {
  local -a myarray
  argv.py "${myarray[@]}"
  myarray+=('x')
  argv.py "${myarray[@]}"
}
f
---
(command (word "declare") (word "-a") (word "myarray"))
(command (word "argv.py") (word "\"${myarray[@]}\""))
(command (word "myarray+=('x')"))
(command (word "argv.py") (word "\"${myarray[@]}\""))
(function "f" (brace-group (semi (semi (semi (command (word "local") (word "-a") (word "myarray")) (command (word "argv.py") (word "\"${myarray[@]}\""))) (command (word "myarray+=('x')"))) (command (word "argv.py") (word "\"${myarray[@]}\"")))))
(command (word "f"))
---

=== Create sparse array
a=()
(( a[99]=1 )) # osh doesn't parse index assignment outside arithmetic yet
echo len=${#a[@]}
argv.py "${a[@]}"
echo "unset=${a[33]}"
echo len-of-unset=${#a[33]}
---
(command (word "a=()"))
(arith (word " a[99]=1 "))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "echo") (word "\"unset=${a[33]}\""))
(command (word "echo") (word "len-of-unset=${#a[33]}"))
---

=== Create sparse array implicitly
(( a[99]=1 ))
echo len=${#a[@]}
argv.py "${a[@]}"
echo "unset=${a[33]}"
echo len-of-unset=${#a[33]}
---
(arith (word " a[99]=1 "))
(command (word "echo") (word "len=${#a[@]}"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "echo") (word "\"unset=${a[33]}\""))
(command (word "echo") (word "len-of-unset=${#a[33]}"))
---

=== Append sparse arrays
a=()
(( a[99]=1 ))
b=()
(( b[33]=2 ))
(( b[66]=3 ))
a+=( "${b[@]}" )
argv.py "${a[@]}"
argv.py "${a[99]}" "${a[100]}" "${a[101]}"
---
(command (word "a=()"))
(arith (word " a[99]=1 "))
(command (word "b=()"))
(arith (word " b[33]=2 "))
(arith (word " b[66]=3 "))
(command (word "a+=(\"${b[@]}\")"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "argv.py") (word "\"${a[99]}\"") (word "\"${a[100]}\"") (word "\"${a[101]}\""))
---

=== Slice of sparse array with [@]
# mksh doesn't support this syntax!  It's a bash extension.
(( a[33]=1 ))
(( a[66]=2 ))
(( a[99]=2 ))
argv.py "${a[@]:15:2}"
---
(arith (word " a[33]=1 "))
(arith (word " a[66]=2 "))
(arith (word " a[99]=2 "))
(command (word "argv.py") (word "\"${a[@]:15:2}\""))
---

=== Using an array itself as the index on LHS
shopt -u strict_arith
a[a]=42
a[a]=99
argv.py "${a[@]}" "${a[0]}" "${a[42]}" "${a[99]}"
---
(command (word "shopt") (word "-u") (word "strict_arith"))
(command (word "a[a]=42"))
(command (word "a[a]=99"))
(command (word "argv.py") (word "\"${a[@]}\"") (word "\"${a[0]}\"") (word "\"${a[42]}\"") (word "\"${a[99]}\""))
---

=== Using an array itself as the index on RHS
shopt -u strict_arith
a=(1 2 3)
(( x = a[a] ))
echo $x
---
(command (word "shopt") (word "-u") (word "strict_arith"))
(command (word "a=(1 2 3)"))
(arith (word " x = a[a] "))
(command (word "echo") (word "$x"))
---

=== a[$x$y] on LHS and RHS
x=1
y=2
a[$x$y]=foo

# not allowed by OSH parsing
#echo ${a[$x$y]}

echo ${a[12]}
echo ${#a[@]}
---
(command (word "x=1"))
(command (word "y=2"))
(command (word "a[$x$y]=foo"))
(command (word "echo") (word "${a[12]}"))
(command (word "echo") (word "${#a[@]}"))
---

=== Dynamic parsing of LHS a[$code]=value
declare -a array
array[x=1]='one'

code='y=2'
#code='1+2'  # doesn't work either
array[$code]='two'

argv.py "${array[@]}"
echo x=$x
echo y=$y
---
(command (word "declare") (word "-a") (word "array"))
(command (word "array[x=1]='one'"))
(command (word "code='y=2'"))
(command (word "array[$code]='two'"))
(command (word "argv.py") (word "\"${array[@]}\""))
(command (word "echo") (word "x=$x"))
(command (word "echo") (word "y=$y"))
---

=== Dynamic parsing of RHS ${a[$code]}
declare -a array
array=(zero one two three)

echo ${array[1+2]}

code='1+2'
echo ${array[$code]}
---
(command (word "declare") (word "-a") (word "array"))
(command (word "array=(zero one two three)"))
(command (word "echo") (word "${array[1+2]}"))
(command (word "code='1+2'"))
(command (word "echo") (word "${array[$code]}"))
---

=== Is element set?  test -v a[i]
# note: modern versions of zsh implement this

array=(1 2 3 '')

test -v 'array[1]'
echo set=$?

test -v 'array[3]'
echo empty=$?

test -v 'array[4]'
echo unset=$?
---
(command (word "array=(1 2 3 '')"))
(command (word "test") (word "-v") (word "'array[1]'"))
(command (word "echo") (word "set=$?"))
(command (word "test") (word "-v") (word "'array[3]'"))
(command (word "echo") (word "empty=$?"))
(command (word "test") (word "-v") (word "'array[4]'"))
(command (word "echo") (word "unset=$?"))
---

=== [[ -v a[i] ]]
# note: modern versions of zsh implement this

array=(1 2 3)
[[ -v array[1] ]]
echo status=$?

[[ -v array[4] ]]
echo status=$?
---
(command (word "array=(1 2 3)"))
(cond (cond-unary "-v" (cond-term "array[1]")))
(command (word "echo") (word "status=$?"))
(cond (cond-unary "-v" (cond-term "array[4]")))
(command (word "echo") (word "status=$?"))
---

=== test -v a[i] with arith expressions
array=(1 2 3 '')

test -v 'array[1+1]'
echo status=$?

test -v 'array[4+1]'
echo status=$?

echo
echo dbracket

[[ -v array[1+1] ]]
echo status=$?

[[ -v array[4+1] ]]
echo status=$?
---
(command (word "array=(1 2 3 '')"))
(command (word "test") (word "-v") (word "'array[1+1]'"))
(command (word "echo") (word "status=$?"))
(command (word "test") (word "-v") (word "'array[4+1]'"))
(command (word "echo") (word "status=$?"))
(command (word "echo"))
(command (word "echo") (word "dbracket"))
(cond (cond-unary "-v" (cond-term "array[1+1]")))
(command (word "echo") (word "status=$?"))
(cond (cond-unary "-v" (cond-term "array[4+1]")))
(command (word "echo") (word "status=$?"))
---

=== More arith expressions in [[ -v array[expr]] ]]
typeset -a array
array=('' nonempty)

# This feels inconsistent with the rest of bash?
zero=0

[[ -v array[zero+0] ]]
echo zero=$?

[[ -v array[zero+1] ]]
echo one=$?

[[ -v array[zero+2] ]]
echo two=$?

echo ---

i='0+0'
[[ -v array[i] ]]
echo zero=$?

i='0+1'
[[ -v array[i] ]]
echo one=$?

i='0+2'
[[ -v array[i] ]]
echo two=$?

echo ---

i='0+0'
[[ -v array[$i] ]]
echo zero=$?

i='0+1'
[[ -v array[$i] ]]
echo one=$?

i='0+2'
[[ -v array[$i] ]]
echo two=$?
---
(command (word "typeset") (word "-a") (word "array"))
(command (word "array=('' nonempty)"))
(command (word "zero=0"))
(cond (cond-unary "-v" (cond-term "array[zero+0]")))
(command (word "echo") (word "zero=$?"))
(cond (cond-unary "-v" (cond-term "array[zero+1]")))
(command (word "echo") (word "one=$?"))
(cond (cond-unary "-v" (cond-term "array[zero+2]")))
(command (word "echo") (word "two=$?"))
(command (word "echo") (word "---"))
(command (word "i='0+0'"))
(cond (cond-unary "-v" (cond-term "array[i]")))
(command (word "echo") (word "zero=$?"))
(command (word "i='0+1'"))
(cond (cond-unary "-v" (cond-term "array[i]")))
(command (word "echo") (word "one=$?"))
(command (word "i='0+2'"))
(cond (cond-unary "-v" (cond-term "array[i]")))
(command (word "echo") (word "two=$?"))
(command (word "echo") (word "---"))
(command (word "i='0+0'"))
(cond (cond-unary "-v" (cond-term "array[$i]")))
(command (word "echo") (word "zero=$?"))
(command (word "i='0+1'"))
(cond (cond-unary "-v" (cond-term "array[$i]")))
(command (word "echo") (word "one=$?"))
(command (word "i='0+2'"))
(cond (cond-unary "-v" (cond-term "array[$i]")))
(command (word "echo") (word "two=$?"))
---

=== Regression: Assigning with out-of-range negative index
a=()
a[-1]=1
---
(command (word "a=()"))
(command (word "a[-1]=1"))
---

=== Regression: Negative index in [[ -v a[index] ]]
a[0]=x
a[5]=y
a[10]=z
[[ -v a[-1] ]] && echo 'a has -1'
[[ -v a[-2] ]] && echo 'a has -2'
[[ -v a[-5] ]] && echo 'a has -5'
[[ -v a[-6] ]] && echo 'a has -6'
[[ -v a[-10] ]] && echo 'a has -10'
[[ -v a[-11] ]] && echo 'a has -11'
---
(command (word "a[0]=x"))
(command (word "a[5]=y"))
(command (word "a[10]=z"))
(and (cond (cond-unary "-v" (cond-term "a[-1]"))) (command (word "echo") (word "'a has -1'")))
(and (cond (cond-unary "-v" (cond-term "a[-2]"))) (command (word "echo") (word "'a has -2'")))
(and (cond (cond-unary "-v" (cond-term "a[-5]"))) (command (word "echo") (word "'a has -5'")))
(and (cond (cond-unary "-v" (cond-term "a[-6]"))) (command (word "echo") (word "'a has -6'")))
(and (cond (cond-unary "-v" (cond-term "a[-10]"))) (command (word "echo") (word "'a has -10'")))
(and (cond (cond-unary "-v" (cond-term "a[-11]"))) (command (word "echo") (word "'a has -11'")))
---

=== Regression: Negative out-of-range index in [[ -v a[index] ]]
e=()
[[ -v e[-1] ]] && echo 'e has -1'
---
(command (word "e=()"))
(and (cond (cond-unary "-v" (cond-term "e[-1]"))) (command (word "echo") (word "'e has -1'")))
---

=== a+=() modifies existing instance of BashArray
case $SH in mksh|bash) exit ;; esac

a=(1 2 3)
var b = a
a+=(4 5)
echo "a=(${a[*]})"
echo "b=(${b[*]})"
---
(case (word "$SH") (pattern ((word "mksh") (word "bash")) (command (word "exit"))))
(command (word "a=(1 2 3)"))
(command (word "var") (word "b") (word "=") (word "a"))
(command (word "a+=(4 5)"))
(command (word "echo") (word "\"a=(${a[*]})\""))
(command (word "echo") (word "\"b=(${b[*]})\""))
---

=== Regression: unset a[-2]: out-of-bound negative index should cause error
case $SH in mksh) exit ;; esac

a=(1)
unset -v 'a[-2]'
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(1)"))
(command (word "unset") (word "-v") (word "'a[-2]'"))
---

=== Regression: Out-of-bound negative offset for ${a[@]:offset}
case $SH in mksh) exit ;; esac

a=(1 2 3 4)
echo "a=(${a[*]})"
echo "begin=-1 -> (${a[*]: -1})"
echo "begin=-2 -> (${a[*]: -2})"
echo "begin=-3 -> (${a[*]: -3})"
echo "begin=-4 -> (${a[*]: -4})"
echo "begin=-5 -> (${a[*]: -5})"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(1 2 3 4)"))
(command (word "echo") (word "\"a=(${a[*]})\""))
(command (word "echo") (word "\"begin=-1 -> (${a[*]: -1})\""))
(command (word "echo") (word "\"begin=-2 -> (${a[*]: -2})\""))
(command (word "echo") (word "\"begin=-3 -> (${a[*]: -3})\""))
(command (word "echo") (word "\"begin=-4 -> (${a[*]: -4})\""))
(command (word "echo") (word "\"begin=-5 -> (${a[*]: -5})\""))
---

=== Regression: Array length after unset
case $SH in mksh) exit ;; esac

a=(x)
a[9]=y
echo "len ${#a[@]};"

unset -v 'a[-1]'
echo "len ${#a[@]};"
echo "last ${a[@]: -1};"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(x)"))
(command (word "a[9]=y"))
(command (word "echo") (word "\"len ${#a[@]};\""))
(command (word "unset") (word "-v") (word "'a[-1]'"))
(command (word "echo") (word "\"len ${#a[@]};\""))
(command (word "echo") (word "\"last ${a[@]: -1};\""))
---

=== Regression: ${a[@]@Q} crash with `a[0]=x a[2]=y`
case $SH in mksh) exit ;; esac

a[0]=x
a[2]=y
echo "quoted = (${a[@]@Q})"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a[0]=x"))
(command (word "a[2]=y"))
(command (word "echo") (word "\"quoted = (${a[@]@Q})\""))
---

=== Regression: silent out-of-bound negative index in ${a[-2]} and $((a[-2]))
case $SH in mksh) exit ;; esac

a=(x)
echo "[${a[-2]}]"
echo $?
echo "[$((a[-2]))]"
echo $?
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "a=(x)"))
(command (word "echo") (word "\"[${a[-2]}]\""))
(command (word "echo") (word "$?"))
(command (word "echo") (word "\"[$((a[-2]))]\""))
(command (word "echo") (word "$?"))
---

=== typeset a[3]=4
typeset a[3]=4 a[5]=6
echo status=$?
argv.py "${!a[@]}" "${a[@]}"
---
(command (word "typeset") (word "a[3]=4") (word "a[5]=6"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${!a[@]}\"") (word "\"${a[@]}\""))
---

=== typeset -a a[1]=a a[3]=c
# declare works the same way in bash, but not mksh.
# spaces are NOT allowed here.
typeset -a a[1*1]=x a[1+2]=z
argv.py "${a[@]}"
---
(command (word "typeset") (word "-a") (word "a[1*1]=x") (word "a[1+2]=z"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== local a[3]=4
f() {
  local a[3]=4 a[5]=6
  echo status=$?
  argv.py "${!a[@]}" "${a[@]}"
}
f
---
(function "f" (brace-group (semi (semi (command (word "local") (word "a[3]=4") (word "a[5]=6")) (command (word "echo") (word "status=$?"))) (command (word "argv.py") (word "\"${!a[@]}\"") (word "\"${a[@]}\"")))))
(command (word "f"))
---

=== readonly a[7]=8
readonly b[7]=8
echo status=$?
argv.py "${!b[@]}" "${b[@]}"
---
(command (word "readonly") (word "b[7]=8"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${!b[@]}\"") (word "\"${b[@]}\""))
---

=== export a[7]=8
export a[7]=8
echo status=$?
argv.py "${!a[@]}" "${a[@]}"
printenv.py a
---
(command (word "export") (word "a[7]=8"))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"${!a[@]}\"") (word "\"${a[@]}\""))
(command (word "printenv.py") (word "a"))
---

=== 'builtin' prefix is allowed on assignments
builtin export e='E'
echo e=$e
---
(command (word "builtin") (word "export") (word "e='E'"))
(command (word "echo") (word "e=$e"))
---

=== 'command' prefix is allowed on assignments
readonly r1='R1'  # zsh has this
command readonly r2='R2'  # but not this
echo r1=$r1
echo r2=$r2
---
(command (word "readonly") (word "r1='R1'"))
(command (word "command") (word "readonly") (word "r2='R2'"))
(command (word "echo") (word "r1=$r1"))
(command (word "echo") (word "r2=$r2"))
---

=== K and V are variables in (( array[K] = V ))
K=5
V=42
typeset -a array
(( array[K] = V ))

echo array[5]=${array[5]}
echo keys = ${!array[@]}
echo values = ${array[@]}
---
(command (word "K=5"))
(command (word "V=42"))
(command (word "typeset") (word "-a") (word "array"))
(arith (word " array[K] = V "))
(command (word "echo") (word "array[5]=${array[5]}"))
(command (word "echo") (word "keys") (word "=") (word "${!array[@]}"))
(command (word "echo") (word "values") (word "=") (word "${array[@]}"))
---

=== test -v with strings
test -v str
echo str=$?

str=x

test -v str
echo str=$?
---
(command (word "test") (word "-v") (word "str"))
(command (word "echo") (word "str=$?"))
(command (word "str=x"))
(command (word "test") (word "-v") (word "str"))
(command (word "echo") (word "str=$?"))
---

=== test -v with arrays
typeset -a a

test -v a
echo a=$?
test -v 'a[0]'
echo "a[0]=$?"
echo

a[0]=1

test -v a
echo a=$?
test -v 'a[0]'
echo "a[0]=$?"
echo

test -v 'a[1]'
echo "a[1]=$?"

# stupid rule about undefined 'x'
test -v 'a[x]'
echo "a[x]=$?"
echo
---
(command (word "typeset") (word "-a") (word "a"))
(command (word "test") (word "-v") (word "a"))
(command (word "echo") (word "a=$?"))
(command (word "test") (word "-v") (word "'a[0]'"))
(command (word "echo") (word "\"a[0]=$?\""))
(command (word "echo"))
(command (word "a[0]=1"))
(command (word "test") (word "-v") (word "a"))
(command (word "echo") (word "a=$?"))
(command (word "test") (word "-v") (word "'a[0]'"))
(command (word "echo") (word "\"a[0]=$?\""))
(command (word "echo"))
(command (word "test") (word "-v") (word "'a[1]'"))
(command (word "echo") (word "\"a[1]=$?\""))
(command (word "test") (word "-v") (word "'a[x]'"))
(command (word "echo") (word "\"a[x]=$?\""))
(command (word "echo"))
---

=== test -v with assoc arrays
typeset -A A

test -v A
echo A=$?
test -v 'A[0]'
echo "A[0]=$?"
echo

A['0']=x

test -v A
echo A=$?
test -v 'A[0]'
echo "A[0]=$?"
echo

test -v 'A[1]'
echo "A[1]=$?"

# stupid rule about undefined 'x'
test -v 'A[x]'
echo "A[x]=$?"
echo
---
(command (word "typeset") (word "-A") (word "A"))
(command (word "test") (word "-v") (word "A"))
(command (word "echo") (word "A=$?"))
(command (word "test") (word "-v") (word "'A[0]'"))
(command (word "echo") (word "\"A[0]=$?\""))
(command (word "echo"))
(command (word "A['0']=x"))
(command (word "test") (word "-v") (word "A"))
(command (word "echo") (word "A=$?"))
(command (word "test") (word "-v") (word "'A[0]'"))
(command (word "echo") (word "\"A[0]=$?\""))
(command (word "echo"))
(command (word "test") (word "-v") (word "'A[1]'"))
(command (word "echo") (word "\"A[1]=$?\""))
(command (word "test") (word "-v") (word "'A[x]'"))
(command (word "echo") (word "\"A[x]=$?\""))
(command (word "echo"))
---

=== local -a
# nixpkgs setup.sh uses this (issue #26)
f() {
  local -a array=(x y z)
  argv.py "${array[@]}"
}
f
---
(function "f" (brace-group (semi (command (word "local") (word "-a") (word "array=(x y z)")) (command (word "argv.py") (word "\"${array[@]}\"")))))
(command (word "f"))
---

=== declare -a
# nixpkgs setup.sh uses this (issue #26)
declare -a array=(x y z)
argv.py "${array[@]}"
---
(command (word "declare") (word "-a") (word "array=(x y z)"))
(command (word "argv.py") (word "\"${array[@]}\""))
---

=== declare -f exit code indicates function existence
func2=x  # var names are NOT found
declare -f myfunc func2
echo $?

myfunc() { echo myfunc; }
declare -f myfunc func2 > /dev/null
echo $?

func2() { echo func2; }
declare -f myfunc func2 > /dev/null
echo $?
---
(command (word "func2=x"))
(command (word "declare") (word "-f") (word "myfunc") (word "func2"))
(command (word "echo") (word "$?"))
(function "myfunc" (brace-group (command (word "echo") (word "myfunc"))))
(command (word "declare") (word "-f") (word "myfunc") (word "func2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(function "func2" (brace-group (command (word "echo") (word "func2"))))
(command (word "declare") (word "-f") (word "myfunc") (word "func2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== declare -F prints function names
add () { expr 4 + 4; }
div () { expr 6 / 2; }
ek () { echo hello; }
__ec () { echo hi; }
_ab () { expr 10 % 3; }

declare -F
---
(function "add" (brace-group (command (word "expr") (word "4") (word "+") (word "4"))))
(function "div" (brace-group (command (word "expr") (word "6") (word "/") (word "2"))))
(function "ek" (brace-group (command (word "echo") (word "hello"))))
(function "__ec" (brace-group (command (word "echo") (word "hi"))))
(function "_ab" (brace-group (command (word "expr") (word "10") (word "%") (word "3"))))
(command (word "declare") (word "-F"))
---

=== declare -F with shopt -s extdebug prints more info
case $SH in mksh) exit ;; esac

source $REPO_ROOT/spec/testdata/bash-source-2.sh

shopt -s extdebug

add () { expr 4 + 4; }

declare -F 
echo

declare -F add
# in bash-source-2
declare -F g | sed "s;$REPO_ROOT;ROOT;g"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word "source") (word "$REPO_ROOT/spec/testdata/bash-source-2.sh"))
(command (word "shopt") (word "-s") (word "extdebug"))
(function "add" (brace-group (command (word "expr") (word "4") (word "+") (word "4"))))
(command (word "declare") (word "-F"))
(command (word "echo"))
(command (word "declare") (word "-F") (word "add"))
(pipe (command (word "declare") (word "-F") (word "g")) (command (word "sed") (word "\"s;$REPO_ROOT;ROOT;g\"")))
---

=== declare -F with shopt -s extdebug and main file
case $SH in mksh) exit ;; esac

$SH $REPO_ROOT/spec/testdata/extdebug.sh | sed "s;$REPO_ROOT;ROOT;g"
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(pipe (command (word "$SH") (word "$REPO_ROOT/spec/testdata/extdebug.sh")) (command (word "sed") (word "\"s;$REPO_ROOT;ROOT;g\"")))
---

=== declare -p var (exit status)
var1() { echo func; }  # function names are NOT found.
declare -p var1 var2 >/dev/null
echo $?

var1=x
declare -p var1 var2 >/dev/null
echo $?

var2=y
declare -p var1 var2 >/dev/null
echo $?
---
(function "var1" (brace-group (command (word "echo") (word "func"))))
(command (word "declare") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(command (word "var1=x"))
(command (word "declare") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(command (word "var2=y"))
(command (word "declare") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== declare
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare
    echo '[readonly]'
    readonly
    echo '[export]'
    export
    echo '[local]'
    local
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=111"))
(command (word "readonly") (word "test_var2=222"))
(command (word "export") (word "test_var3=333"))
(command (word "declare") (word "-n") (word "test_var4=test_var1"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var5=555")) (pipe (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "'[declare]'")) (command (word "declare"))) (command (word "echo") (word "'[readonly]'"))) (command (word "readonly"))) (command (word "echo") (word "'[export]'"))) (command (word "export"))) (command (word "echo") (word "'[local]'"))) (command (word "local")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -p
# BUG: bash doesn't output flags with "local -p", which seems to contradict
#   with manual.
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare -p
    echo '[readonly]'
    readonly -p
    echo '[export]'
    export -p
    echo '[local]'
    local -p
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=111"))
(command (word "readonly") (word "test_var2=222"))
(command (word "export") (word "test_var3=333"))
(command (word "declare") (word "-n") (word "test_var4=test_var1"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var5=555")) (pipe (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "'[declare]'")) (command (word "declare") (word "-p"))) (command (word "echo") (word "'[readonly]'"))) (command (word "readonly") (word "-p"))) (command (word "echo") (word "'[export]'"))) (command (word "export") (word "-p"))) (command (word "echo") (word "'[local]'"))) (command (word "local") (word "-p")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -p doesn't print binary data, but can be loaded into bash
# bash prints binary data!
case $SH in bash*|mksh) exit ;; esac

unquoted='foo'
sq='foo bar'
bash1=$'\x1f'  # ASCII control char
bash2=$'\xfe\xff'  # Invalid UTF-8

s1=$unquoted
s2=$sq
s3=$bash1
s4=$bash2

declare -a a=("$unquoted" "$sq" "$bash1" "$bash2")
declare -A A=(["$unquoted"]="$sq" ["$bash1"]="$bash2")

#echo lengths ${#s1} ${#s2} ${#s3} ${#s4} ${#a[@]} ${#A[@]}

declare -p s1 s2 s3 s4 a A | tee tmp.bash

echo ---

bash -c 'source tmp.bash; echo "$s1 $s2"; echo -n "$s3" "$s4" | od -A n -t x1'
echo bash=$?
---
(case (word "$SH") (pattern ((word "bash*") (word "mksh")) (command (word "exit"))))
(command (word "unquoted='foo'"))
(command (word "sq='foo bar'"))
(command (word "bash1=''"))
(command (word "bash2=''"))
(command (word "s1=$unquoted"))
(command (word "s2=$sq"))
(command (word "s3=$bash1"))
(command (word "s4=$bash2"))
(command (word "declare") (word "-a") (word "a=(\"$unquoted\" \"$sq\" \"$bash1\" \"$bash2\")"))
(command (word "declare") (word "-A") (word "A=([\"$unquoted\"]=\"$sq\" [\"$bash1\"]=\"$bash2\")"))
(pipe (command (word "declare") (word "-p") (word "s1") (word "s2") (word "s3") (word "s4") (word "a") (word "A")) (command (word "tee") (word "tmp.bash")))
(command (word "echo") (word "---"))
(command (word "bash") (word "-c") (word "'source tmp.bash; echo \"$s1 $s2\"; echo -n \"$s3\" \"$s4\" | od -A n -t x1'"))
(command (word "echo") (word "bash=$?"))
---

=== declare -p var
# BUG? bash doesn't output anything for 'local/readonly -p var', which seems to
#   contradict with manual.  Besides, 'export -p var' is not described in
#   manual
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare -p test_var{0..5}
    echo '[readonly]'
    readonly -p test_var{0..5}
    echo '[export]'
    export -p test_var{0..5}
    echo '[local]'
    local -p test_var{0..5}
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=111"))
(command (word "readonly") (word "test_var2=222"))
(command (word "export") (word "test_var3=333"))
(command (word "declare") (word "-n") (word "test_var4=test_var1"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var5=555")) (pipe (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "echo") (word "'[declare]'")) (command (word "declare") (word "-p") (word "test_var{0..5}"))) (command (word "echo") (word "'[readonly]'"))) (command (word "readonly") (word "-p") (word "test_var{0..5}"))) (command (word "echo") (word "'[export]'"))) (command (word "export") (word "-p") (word "test_var{0..5}"))) (command (word "echo") (word "'[local]'"))) (command (word "local") (word "-p") (word "test_var{0..5}")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -p arr
test_arr1=()
declare -a test_arr2=()
declare -A test_arr3=()
test_arr4=(1 2 3)
declare -a test_arr5=(1 2 3)
declare -A test_arr6=(['a']=1 ['b']=2 ['c']=3)
test_arr7=()
test_arr7[3]=foo
declare -p test_arr{1..7}
---
(command (word "test_arr1=()"))
(command (word "declare") (word "-a") (word "test_arr2=()"))
(command (word "declare") (word "-A") (word "test_arr3=()"))
(command (word "test_arr4=(1 2 3)"))
(command (word "declare") (word "-a") (word "test_arr5=(1 2 3)"))
(command (word "declare") (word "-A") (word "test_arr6=(['a']=1 ['b']=2 ['c']=3)"))
(command (word "test_arr7=()"))
(command (word "test_arr7[3]=foo"))
(command (word "declare") (word "-p") (word "test_arr{1..7}"))
---

=== declare -p foo=bar doesn't make sense
case $SH in mksh) exit 0 ;; esac

declare -p foo=bar
echo status=$?

a=b
declare -p a foo=bar > tmp.txt
echo status=$?
sed 's/"//g' tmp.txt  # don't care about quotes
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit") (word "0"))))
(command (word "declare") (word "-p") (word "foo=bar"))
(command (word "echo") (word "status=$?"))
(command (word "a=b"))
(command (word "declare") (word "-p") (word "a") (word "foo=bar") (redirect ">" "tmp.txt"))
(command (word "echo") (word "status=$?"))
(command (word "sed") (word "'s/\"//g'") (word "tmp.txt"))
---

=== declare -pnrx
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare -pn]'
    declare -pn
    echo '[declare -pr]'
    declare -pr
    echo '[declare -px]'
    declare -px
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=111"))
(command (word "readonly") (word "test_var2=222"))
(command (word "export") (word "test_var3=333"))
(command (word "declare") (word "-n") (word "test_var4=test_var1"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var5=555")) (pipe (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "'[declare -pn]'")) (command (word "declare") (word "-pn"))) (command (word "echo") (word "'[declare -pr]'"))) (command (word "declare") (word "-pr"))) (command (word "echo") (word "'[declare -px]'"))) (command (word "declare") (word "-px")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -paA
declare -a test_var6=()
declare -A test_var7=()
f1() {
  {
    echo '[declare -pa]'
    declare -pa
    echo '[declare -pA]'
    declare -pA
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "declare") (word "-a") (word "test_var6=()"))
(command (word "declare") (word "-A") (word "test_var7=()"))
(function "f1" (brace-group (pipe (brace-group (semi (semi (semi (command (word "echo") (word "'[declare -pa]'")) (command (word "declare") (word "-pa"))) (command (word "echo") (word "'[declare -pA]'"))) (command (word "declare") (word "-pA")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'")))))
(command (word "f1"))
---

=== declare -pnrx var
# Note: Bash ignores other flags (-nrx) when variable names are supplied while
#   OSH uses other flags to select variables.  Bash's behavior is documented.
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare -pn]'
    declare -pn test_var{0..5}
    echo '[declare -pr]'
    declare -pr test_var{0..5}
    echo '[declare -px]'
    declare -px test_var{0..5}
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=111"))
(command (word "readonly") (word "test_var2=222"))
(command (word "export") (word "test_var3=333"))
(command (word "declare") (word "-n") (word "test_var4=test_var1"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var5=555")) (pipe (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "'[declare -pn]'")) (command (word "declare") (word "-pn") (word "test_var{0..5}"))) (command (word "echo") (word "'[declare -pr]'"))) (command (word "declare") (word "-pr") (word "test_var{0..5}"))) (command (word "echo") (word "'[declare -px]'"))) (command (word "declare") (word "-px") (word "test_var{0..5}")))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -pg
test_var1=global
f1() {
  local test_var1=local
  {
    declare -pg
  } | grep -E '^\[|^\b[^"]*test_var.\b'
}
f1
---
(command (word "test_var1=global"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var1=local")) (pipe (brace-group (command (word "declare") (word "-pg"))) (command (word "grep") (word "-E") (word "'^\\[|^\\b[^\"]*test_var.\\b'"))))))
(command (word "f1"))
---

=== declare -pg var
test_var1=global
f1() {
  local test_var1=local
  {
    declare -pg test_var1
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1
---
(command (word "test_var1=global"))
(function "f1" (brace-group (semi (command (word "local") (word "test_var1=local")) (pipe (brace-group (command (word "declare") (word "-pg") (word "test_var1"))) (command (word "grep") (word "-E") (word "'^\\[|^\\b.*test_var.\\b'"))))))
(command (word "f1"))
---

=== ble.sh: eval -- "$(declare -p var arr)"
# This illustrates an example usage of "eval & declare" for exporting
# multiple variables from $().
eval -- "$(
  printf '%s\n' a{1..10} | {
    sum=0 i=0 arr=()
    while read line; do
      ((sum+=${#line},i++))
      arr[$((i/3))]=$line
    done
    declare -p sum arr
  })"
echo sum=$sum
for ((i=0;i<${#arr[@]};i++)); do
  echo "arr[$i]=${arr[i]}"
done
---
(command (word "eval") (word "--") (word "\"$(printf '%s\\n' a{1..10} | { sum=0 i=0 arr=()\nwhile read line; do\n    ((sum+=${#line},i++))\narr[$((i/3))]=$line;\ndone\ndeclare -p sum arr; })\""))
(command (word "echo") (word "sum=$sum"))
(arith-for (init (word "i=0")) (test (word "i<${#arr[@]}")) (step (word "i++")) (command (word "echo") (word "\"arr[$i]=${arr[i]}\"")))
---

=== declare -p and value.Undef
# This is a regression for a crash
# But actually there is also an incompatibility -- we don't print anything

declare x
declare -p x

function f { local x; declare -p x; }
x=1
f
---
(command (word "declare") (word "x"))
(command (word "declare") (word "-p") (word "x"))
(function "f" (brace-group (semi (command (word "local") (word "x")) (command (word "declare") (word "-p") (word "x")))))
(command (word "x=1"))
(command (word "f"))
---

=== eval -- "$(declare -p arr)" (restore arrays w/ unset elements)
arr=(1 2 3)
eval -- "$(arr=(); arr[3]= arr[4]=foo; declare -p arr)"
for i in {0..4}; do
  echo "arr[$i]: ${arr[$i]+set ... [}${arr[$i]-unset}${arr[$i]+]}"
done
---
(command (word "arr=(1 2 3)"))
(command (word "eval") (word "--") (word "\"$(arr=(); arr[3]= arr[4]=foo; declare -p arr)\""))
(for (word "i") (in (word "{0..4}")) (command (word "echo") (word "\"arr[$i]: ${arr[$i]+set ... [}${arr[$i]-unset}${arr[$i]+]}\"")))
---

=== declare -p UNDEF (and typeset) -- prints something to stderr
x=42
readonly x
export x

declare -p x undef1 undef2 2> de

typeset -p x undef1 undef2 2> ty

# readonly -p and export -p don't accept args!  They only print all
#
# These do not accept args
# readonly -p x undef1 undef2 2> re
# export -p x undef1 undef2 2> ex

f() {
  # it behaves weird with x
  #local -p undef1 undef2 2>lo
  local -p a b b>lo
  #local -p x undef1 undef2 2> lo
}
# local behaves differently in bash 4.4 and bash 5, not specifying now
# f
# files='de ty lo'

files='de ty'

wc -l $files
#cat $files
---
(command (word "x=42"))
(command (word "readonly") (word "x"))
(command (word "export") (word "x"))
(command (word "declare") (word "-p") (word "x") (word "undef1") (word "undef2") (redirect ">" "de"))
(command (word "typeset") (word "-p") (word "x") (word "undef1") (word "undef2") (redirect ">" "ty"))
(function "f" (brace-group (command (word "local") (word "-p") (word "a") (word "b") (word "b") (redirect ">" "lo"))))
(command (word "files='de ty'"))
(command (word "wc") (word "-l") (word "$files"))
---

=== typeset -f
# mksh implement typeset but not declare
typeset  -f myfunc func2
echo $?

myfunc() { echo myfunc; }
# This prints the source code.
typeset  -f myfunc func2 > /dev/null
echo $?

func2() { echo func2; }
typeset  -f myfunc func2 > /dev/null
echo $?
---
(command (word "typeset") (word "-f") (word "myfunc") (word "func2"))
(command (word "echo") (word "$?"))
(function "myfunc" (brace-group (command (word "echo") (word "myfunc"))))
(command (word "typeset") (word "-f") (word "myfunc") (word "func2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(function "func2" (brace-group (command (word "echo") (word "func2"))))
(command (word "typeset") (word "-f") (word "myfunc") (word "func2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== typeset -p
var1() { echo func; }  # function names are NOT found.
typeset -p var1 var2 >/dev/null
echo $?

var1=x
typeset -p var1 var2 >/dev/null
echo $?

var2=y
typeset -p var1 var2 >/dev/null
echo $?
---
(function "var1" (brace-group (command (word "echo") (word "func"))))
(command (word "typeset") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(command (word "var1=x"))
(command (word "typeset") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
(command (word "var2=y"))
(command (word "typeset") (word "-p") (word "var1") (word "var2") (redirect ">" "/dev/null"))
(command (word "echo") (word "$?"))
---

=== typeset -r makes a string readonly
typeset -r s1='12'
typeset -r s2='34'

s1='c'
echo status=$?
s2='d'
echo status=$?

s1+='e'
echo status=$?
s2+='f'
echo status=$?

unset s1
echo status=$?
unset s2
echo status=$?
---
(command (word "typeset") (word "-r") (word "s1='12'"))
(command (word "typeset") (word "-r") (word "s2='34'"))
(command (word "s1='c'"))
(command (word "echo") (word "status=$?"))
(command (word "s2='d'"))
(command (word "echo") (word "status=$?"))
(command (word "s1+='e'"))
(command (word "echo") (word "status=$?"))
(command (word "s2+='f'"))
(command (word "echo") (word "status=$?"))
(command (word "unset") (word "s1"))
(command (word "echo") (word "status=$?"))
(command (word "unset") (word "s2"))
(command (word "echo") (word "status=$?"))
---

=== typeset -ar makes it readonly
typeset -a -r array1=(1 2)
typeset -ar array2=(3 4)

array1=('c')
echo status=$?
array2=('d')
echo status=$?

array1+=('e')
echo status=$?
array2+=('f')
echo status=$?

unset array1
echo status=$?
unset array2
echo status=$?
---
(command (word "typeset") (word "-a") (word "-r") (word "array1=(1 2)"))
(command (word "typeset") (word "-ar") (word "array2=(3 4)"))
(command (word "array1=('c')"))
(command (word "echo") (word "status=$?"))
(command (word "array2=('d')"))
(command (word "echo") (word "status=$?"))
(command (word "array1+=('e')"))
(command (word "echo") (word "status=$?"))
(command (word "array2+=('f')"))
(command (word "echo") (word "status=$?"))
(command (word "unset") (word "array1"))
(command (word "echo") (word "status=$?"))
(command (word "unset") (word "array2"))
(command (word "echo") (word "status=$?"))
---

=== typeset -x makes it exported
typeset -rx PYTHONPATH=lib/
printenv.py PYTHONPATH
---
(command (word "typeset") (word "-rx") (word "PYTHONPATH=lib/"))
(command (word "printenv.py") (word "PYTHONPATH"))
---

=== Multiple assignments / array assignments on a line
a=1 b[0+0]=2 c=3
echo $a ${b[@]} $c
---
(command (word "a=1") (word "b[0+0]=2") (word "c=3"))
(command (word "echo") (word "$a") (word "${b[@]}") (word "$c"))
---

=== Env bindings shouldn't contain array assignments
a=1 b[0]=2 c=3 printenv.py a b c
---
(command (word "a=1") (word "b[0]=2") (word "c=3") (word "printenv.py") (word "a") (word "b") (word "c"))
---

=== syntax error in array assignment
a=x b[0+]=y c=z
echo $a $b $c
---
(command (word "a=x") (word "b[0+]=y") (word "c=z"))
(command (word "echo") (word "$a") (word "$b") (word "$c"))
---

=== declare -g (bash-specific; bash-completion uses it)
f() {
  declare -g G=42
  declare L=99

  declare -Ag dict
  dict["foo"]=bar

  declare -A localdict
  localdict["spam"]=Eggs

  # For bash-completion
  eval 'declare -Ag ev'
  ev["ev1"]=ev2
}
f
argv.py "$G" "$L"
argv.py "${dict["foo"]}" "${localdict["spam"]}"
argv.py "${ev["ev1"]}"
---
(function "f" (brace-group (semi (semi (semi (semi (semi (semi (semi (command (word "declare") (word "-g") (word "G=42")) (command (word "declare") (word "L=99"))) (command (word "declare") (word "-Ag") (word "dict"))) (command (word "dict[\"foo\"]=bar"))) (command (word "declare") (word "-A") (word "localdict"))) (command (word "localdict[\"spam\"]=Eggs"))) (command (word "eval") (word "'declare -Ag ev'"))) (command (word "ev[\"ev1\"]=ev2")))))
(command (word "f"))
(command (word "argv.py") (word "\"$G\"") (word "\"$L\""))
(command (word "argv.py") (word "\"${dict[\"foo\"]}\"") (word "\"${localdict[\"spam\"]}\""))
(command (word "argv.py") (word "\"${ev[\"ev1\"]}\""))
---

=== myvar=typeset (another form of dynamic assignment)
myvar=typeset
x='a b'
$myvar x=$x
echo $x
---
(command (word "myvar=typeset"))
(command (word "x='a b'"))
(command (word "$myvar") (word "x=$x"))
(command (word "echo") (word "$x"))
---

=== dynamic array parsing is not allowed
code='x=(1 2 3)'
typeset -a "$code"  # note: -a flag is required
echo status=$?
argv.py "$x"
---
(command (word "code='x=(1 2 3)'"))
(command (word "typeset") (word "-a") (word "\"$code\""))
(command (word "echo") (word "status=$?"))
(command (word "argv.py") (word "\"$x\""))
---

=== dynamic flag in array in assign builtin
typeset b
b=(unused1 unused2)  # this works in mksh

a=(x 'foo=F' 'bar=B')
typeset -"${a[@]}"
echo foo=$foo
echo bar=$bar
printenv.py foo
printenv.py bar

# syntax error in mksh!  But works in bash and zsh.
#typeset -"${a[@]}" b=(spam eggs)
#echo "length of b = ${#b[@]}"
#echo "b[0]=${b[0]}"
#echo "b[1]=${b[1]}"
---
(command (word "typeset") (word "b"))
(command (word "b=(unused1 unused2)"))
(command (word "a=(x 'foo=F' 'bar=B')"))
(command (word "typeset") (word "-\"${a[@]}\""))
(command (word "echo") (word "foo=$foo"))
(command (word "echo") (word "bar=$bar"))
(command (word "printenv.py") (word "foo"))
(command (word "printenv.py") (word "bar"))
---

=== typeset +x
export e=E
printenv.py e
typeset +x e=E2
printenv.py e  # no longer exported
---
(command (word "export") (word "e=E"))
(command (word "printenv.py") (word "e"))
(command (word "typeset") (word "+x") (word "e=E2"))
(command (word "printenv.py") (word "e"))
---

=== typeset +r removes read-only attribute (TODO: documented in bash to do nothing)
readonly r=r1
echo r=$r

# clear the readonly flag.  Why is this accepted in bash, but doesn't do
# anything?
typeset +r r=r2 
echo r=$r

r=r3
echo r=$r
---
(command (word "readonly") (word "r=r1"))
(command (word "echo") (word "r=$r"))
(command (word "typeset") (word "+r") (word "r=r2"))
(command (word "echo") (word "r=$r"))
(command (word "r=r3"))
(command (word "echo") (word "r=$r"))
---

=== function name with /
ble/foo() { echo hi; }
declare -F ble/foo
echo status=$?
---
(function "ble/foo" (brace-group (command (word "echo") (word "hi"))))
(command (word "declare") (word "-F") (word "ble/foo"))
(command (word "echo") (word "status=$?"))
---

=== invalid var name
typeset foo/bar
---
(command (word "typeset") (word "foo/bar"))
---

=== unset and shell funcs
foo() {
  echo bar
}

foo

declare -F
unset foo
declare -F

foo
---
(function "foo" (brace-group (command (word "echo") (word "bar"))))
(command (word "foo"))
(command (word "declare") (word "-F"))
(command (word "unset") (word "foo"))
(command (word "declare") (word "-F"))
(command (word "foo"))
---

=== Env value doesn't persist
FOO=foo printenv.py FOO
echo -$FOO-
---
(command (word "FOO=foo") (word "printenv.py") (word "FOO"))
(command (word "echo") (word "-$FOO-"))
---

=== Env value with equals
FOO=foo=foo printenv.py FOO
---
(command (word "FOO=foo=foo") (word "printenv.py") (word "FOO"))
---

=== Env binding can use preceding bindings, but not subsequent ones
# This means that for ASSIGNMENT_WORD, on the RHS you invoke the parser again!
# Could be any kind of quoted string.
FOO="foo" BAR="[$FOO][$BAZ]" BAZ=baz printenv.py FOO BAR BAZ
---
(command (word "FOO=\"foo\"") (word "BAR=\"[$FOO][$BAZ]\"") (word "BAZ=baz") (word "printenv.py") (word "FOO") (word "BAR") (word "BAZ"))
---

=== Env value with two quotes
FOO='foo'"adjacent" printenv.py FOO
---
(command (word "FOO='foo'\"adjacent\"") (word "printenv.py") (word "FOO"))
---

=== Env value with escaped <
FOO=foo\<foo printenv.py FOO
---
(command (word "FOO=foo\\<foo") (word "printenv.py") (word "FOO"))
---

=== FOO=foo echo [foo]
FOO=foo echo "[$foo]"
---
(command (word "FOO=foo") (word "echo") (word "\"[$foo]\""))
---

=== FOO=foo fun
fun() {
  echo "[$FOO]"
}
FOO=foo fun
---
(function "fun" (brace-group (command (word "echo") (word "\"[$FOO]\""))))
(command (word "FOO=foo") (word "fun"))
---

=== Multiple temporary envs on the stack
g() {
  echo "$F" "$G1" "$G2"
  echo '--- g() ---'
  P=p printenv.py F G1 G2 A P
}
f() {
  # NOTE: G1 doesn't pick up binding f, but G2 picks up a.
  # I don't quite understand why this is, but bash and OSH agree!
  G1=[$f] G2=[$a] g
  echo '--- f() ---'
  printenv.py F G1 G2 A P
}
a=A
F=f f
---
(function "g" (brace-group (semi (semi (command (word "echo") (word "\"$F\"") (word "\"$G1\"") (word "\"$G2\"")) (command (word "echo") (word "'--- g() ---'"))) (command (word "P=p") (word "printenv.py") (word "F") (word "G1") (word "G2") (word "A") (word "P")))))
(function "f" (brace-group (semi (semi (command (word "G1=[$f]") (word "G2=[$a]") (word "g")) (command (word "echo") (word "'--- f() ---'"))) (command (word "printenv.py") (word "F") (word "G1") (word "G2") (word "A") (word "P")))))
(command (word "a=A"))
(command (word "F=f") (word "f"))
---

=== Escaped = in command name
# foo=bar is in the 'spec/bin' dir.
foo\=bar
---
(command (word "foo\\=bar"))
---

=== Trying to run keyword 'for'
FOO=bar for
---
(command (word "FOO=bar") (word "for"))
---

=== Empty env binding
EMPTY= printenv.py EMPTY
---
(command (word "EMPTY=") (word "printenv.py") (word "EMPTY"))
---

=== Assignment doesn't do word splitting
words='one two'
a=$words
argv.py "$a"
---
(command (word "words='one two'"))
(command (word "a=$words"))
(command (word "argv.py") (word "\"$a\""))
---

=== Assignment doesn't do glob expansion
touch _tmp/z.Z _tmp/zz.Z
a=_tmp/*.Z
argv.py "$a"
---
(command (word "touch") (word "_tmp/z.Z") (word "_tmp/zz.Z"))
(command (word "a=_tmp/*.Z"))
(command (word "argv.py") (word "\"$a\""))
---

=== Env binding in readonly/declare is NOT exported!  (pitfall)
# All shells agree on this, but it's very confusing behavior.
FOO=foo readonly v=$(printenv.py FOO)
echo "v=$v"

# bash has probems here:
FOO=foo readonly v2=$FOO
echo "v2=$v2"
---
(command (word "FOO=foo") (word "readonly") (word "v=$(printenv.py FOO)"))
(command (word "echo") (word "\"v=$v\""))
(command (word "FOO=foo") (word "readonly") (word "v2=$FOO"))
(command (word "echo") (word "\"v2=$v2\""))
---

=== assignments / array assignments not interpreted after 'echo'
a=1 echo b[0]=2 c=3
---
(command (word "a=1") (word "echo") (word "b[0]=2") (word "c=3"))
---

=== dynamic local variables (and splitting)
f() {
  local "$1"  # Only x is assigned here
  echo x=\'$x\'
  echo a=\'$a\'

  local $1  # x and a are assigned here
  echo x=\'$x\'
  echo a=\'$a\'
}
f 'x=y a=b'
---
(function "f" (brace-group (semi (semi (semi (semi (semi (command (word "local") (word "\"$1\"")) (command (word "echo") (word "x=\\'$x\\'"))) (command (word "echo") (word "a=\\'$a\\'"))) (command (word "local") (word "$1"))) (command (word "echo") (word "x=\\'$x\\'"))) (command (word "echo") (word "a=\\'$a\\'")))))
(command (word "f") (word "'x=y a=b'"))
---

=== readonly x= gives empty string (regression)
readonly x=
argv.py "$x"
---
(command (word "readonly") (word "x="))
(command (word "argv.py") (word "\"$x\""))
---

=== 'local x' does not set variable
set -o nounset
f() {
  local x
  echo $x
}
f
---
(command (word "set") (word "-o") (word "nounset"))
(function "f" (brace-group (semi (command (word "local") (word "x")) (command (word "echo") (word "$x")))))
(command (word "f"))
---

=== 'local -a x' does not set variable
set -o nounset
f() {
  local -a x
  echo $x
}
f
---
(command (word "set") (word "-o") (word "nounset"))
(function "f" (brace-group (semi (command (word "local") (word "-a") (word "x")) (command (word "echo") (word "$x")))))
(command (word "f"))
---

=== 'local x' and then array assignment
f() {
  local x
  x[3]=foo
  echo ${x[3]}
}
f
---
(function "f" (brace-group (semi (semi (command (word "local") (word "x")) (command (word "x[3]=foo"))) (command (word "echo") (word "${x[3]}")))))
(command (word "f"))
---

=== 'declare -A' and then dict assignment
declare -A foo
key=bar
foo["$key"]=value
echo ${foo["bar"]}
---
(command (word "declare") (word "-A") (word "foo"))
(command (word "key=bar"))
(command (word "foo[\"$key\"]=value"))
(command (word "echo") (word "${foo[\"bar\"]}"))
---

=== declare in an if statement
# bug caught by my feature detection snippet in bash-completion
if ! foo=bar; then
  echo BAD
fi
echo $foo
if ! eval 'spam=eggs'; then
  echo BAD
fi
echo $spam
---
(if (negation (command (word "foo=bar"))) (command (word "echo") (word "BAD")))
(command (word "echo") (word "$foo"))
(if (negation (command (word "eval") (word "'spam=eggs'"))) (command (word "echo") (word "BAD")))
(command (word "echo") (word "$spam"))
---

=== Modify a temporary binding
# (regression for bug found by Michael Greenberg)
f() {
  echo "x before = $x"
  x=$((x+1))
  echo "x after  = $x"
}
x=5 f
---
(function "f" (brace-group (semi (semi (command (word "echo") (word "\"x before = $x\"")) (command (word "x=$((x+1))"))) (command (word "echo") (word "\"x after  = $x\"")))))
(command (word "x=5") (word "f"))
---

=== Reveal existence of "temp frame" (All shells disagree here!!!)
f() {
  echo "x=$x"

  x=mutated-temp  # mutate temp frame
  echo "x=$x"

  # Declare a new local
  local x='local'
  echo "x=$x"

  # Unset it
  unset x
  echo "x=$x"
}

x=global
x=temp-binding f
echo "x=$x"
---
(function "f" (brace-group (semi (semi (semi (semi (semi (semi (command (word "echo") (word "\"x=$x\"")) (command (word "x=mutated-temp"))) (command (word "echo") (word "\"x=$x\""))) (command (word "local") (word "x='local'"))) (command (word "echo") (word "\"x=$x\""))) (command (word "unset") (word "x"))) (command (word "echo") (word "\"x=$x\"")))))
(command (word "x=global"))
(command (word "x=temp-binding") (word "f"))
(command (word "echo") (word "\"x=$x\""))
---

=== Test above without 'local' (which is not POSIX)
f() {
  echo "x=$x"

  x=mutated-temp  # mutate temp frame
  echo "x=$x"

  # Unset it
  unset x
  echo "x=$x"
}

x=global
x=temp-binding f
echo "x=$x"
---
(function "f" (brace-group (semi (semi (semi (semi (command (word "echo") (word "\"x=$x\"")) (command (word "x=mutated-temp"))) (command (word "echo") (word "\"x=$x\""))) (command (word "unset") (word "x"))) (command (word "echo") (word "\"x=$x\"")))))
(command (word "x=global"))
(command (word "x=temp-binding") (word "f"))
(command (word "echo") (word "\"x=$x\""))
---

=== Using ${x-default} after unsetting local shadowing a global
f() {
  echo "x=$x"
  local x='local'
  echo "x=$x"
  unset x
  echo "- operator = ${x-default}"
  echo ":- operator = ${x:-default}"
}
x=global
f
---
(function "f" (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "\"x=$x\"")) (command (word "local") (word "x='local'"))) (command (word "echo") (word "\"x=$x\""))) (command (word "unset") (word "x"))) (command (word "echo") (word "\"- operator = ${x-default}\""))) (command (word "echo") (word "\":- operator = ${x:-default}\"")))))
(command (word "x=global"))
(command (word "f"))
---

=== Using ${x-default} after unsetting a temp binding shadowing a global
f() {
  echo "x=$x"
  local x='local'
  echo "x=$x"
  unset x
  echo "- operator = ${x-default}"
  echo ":- operator = ${x:-default}"
}
x=global
x=temp-binding f
---
(function "f" (brace-group (semi (semi (semi (semi (semi (command (word "echo") (word "\"x=$x\"")) (command (word "local") (word "x='local'"))) (command (word "echo") (word "\"x=$x\""))) (command (word "unset") (word "x"))) (command (word "echo") (word "\"- operator = ${x-default}\""))) (command (word "echo") (word "\":- operator = ${x:-default}\"")))))
(command (word "x=global"))
(command (word "x=temp-binding") (word "f"))
---

=== static assignment doesn't split
words='a b c'
export ex=$words
glo=$words
readonly ro=$words
argv.py "$ex" "$glo" "$ro"
---
(command (word "words='a b c'"))
(command (word "export") (word "ex=$words"))
(command (word "glo=$words"))
(command (word "readonly") (word "ro=$words"))
(command (word "argv.py") (word "\"$ex\"") (word "\"$glo\"") (word "\"$ro\""))
---

=== aliased assignment doesn't split
shopt -s expand_aliases || true
words='a b c'
alias e=export
alias r=readonly
e ex=$words
r ro=$words
argv.py "$ex" "$ro"
---
(or (command (word "shopt") (word "-s") (word "expand_aliases")) (command (word "true")))
(command (word "words='a b c'"))
(command (word "alias") (word "e=export"))
(command (word "alias") (word "r=readonly"))
(command (word "e") (word "ex=$words"))
(command (word "r") (word "ro=$words"))
(command (word "argv.py") (word "\"$ex\"") (word "\"$ro\""))
---

=== assignment using dynamic keyword (splits in most shells, not in zsh/osh)
words='a b c'
e=export
r=readonly
$e ex=$words
$r ro=$words
argv.py "$ex" "$ro"

# zsh and OSH are smart
---
(command (word "words='a b c'"))
(command (word "e=export"))
(command (word "r=readonly"))
(command (word "$e") (word "ex=$words"))
(command (word "$r") (word "ro=$words"))
(command (word "argv.py") (word "\"$ex\"") (word "\"$ro\""))
---

=== assignment using dynamic var names doesn't split
words='a b c'
arg_ex=ex=$words
arg_ro=ro=$words

# no quotes, this is split of course
export $arg_ex
readonly $arg_ro

argv.py "$ex" "$ro"

arg_ex2=ex2=$words
arg_ro2=ro2=$words

# quotes, no splitting
export "$arg_ex2"
readonly "$arg_ro2"

argv.py "$ex2" "$ro2"
---
(command (word "words='a b c'"))
(command (word "arg_ex=ex=$words"))
(command (word "arg_ro=ro=$words"))
(command (word "export") (word "$arg_ex"))
(command (word "readonly") (word "$arg_ro"))
(command (word "argv.py") (word "\"$ex\"") (word "\"$ro\""))
(command (word "arg_ex2=ex2=$words"))
(command (word "arg_ro2=ro2=$words"))
(command (word "export") (word "\"$arg_ex2\""))
(command (word "readonly") (word "\"$arg_ro2\""))
(command (word "argv.py") (word "\"$ex2\"") (word "\"$ro2\""))
---

=== assign and glob
cd $TMP
touch foo=a foo=b
foo=*
argv.py "$foo"
unset foo

export foo=*
argv.py "$foo"
unset foo
---
(command (word "cd") (word "$TMP"))
(command (word "touch") (word "foo=a") (word "foo=b"))
(command (word "foo=*"))
(command (word "argv.py") (word "\"$foo\""))
(command (word "unset") (word "foo"))
(command (word "export") (word "foo=*"))
(command (word "argv.py") (word "\"$foo\""))
(command (word "unset") (word "foo"))
---

=== declare and glob
cd $TMP
touch foo=a foo=b
typeset foo=*
argv.py "$foo"
unset foo
---
(command (word "cd") (word "$TMP"))
(command (word "touch") (word "foo=a") (word "foo=b"))
(command (word "typeset") (word "foo=*"))
(command (word "argv.py") (word "\"$foo\""))
(command (word "unset") (word "foo"))
---

=== readonly $x where x='b c'
one=a
two='b c'
readonly $two $one
a=new
echo status=$?
b=new
echo status=$?
c=new
echo status=$?

# in OSH and zsh, this is an invalid variable name
---
(command (word "one=a"))
(command (word "two='b c'"))
(command (word "readonly") (word "$two") (word "$one"))
(command (word "a=new"))
(command (word "echo") (word "status=$?"))
(command (word "b=new"))
(command (word "echo") (word "status=$?"))
(command (word "c=new"))
(command (word "echo") (word "status=$?"))
---

=== readonly a=(1 2) no_value c=(3 4) makes 'no_value' readonly
readonly a=(1 2) no_value c=(3 4)
no_value=x
---
(command (word "readonly") (word "a=(1 2)") (word "no_value") (word "c=(3 4)"))
(command (word "no_value=x"))
---

=== export a=1 no_value c=2
no_value=foo
export a=1 no_value c=2
printenv.py no_value
---
(command (word "no_value=foo"))
(command (word "export") (word "a=1") (word "no_value") (word "c=2"))
(command (word "printenv.py") (word "no_value"))
---

=== local a=loc $var c=loc
var='b'
b=global
echo $b
f() {
  local a=loc $var c=loc
  argv.py "$a" "$b" "$c"
}
f
---
(command (word "var='b'"))
(command (word "b=global"))
(command (word "echo") (word "$b"))
(function "f" (brace-group (semi (command (word "local") (word "a=loc") (word "$var") (word "c=loc")) (command (word "argv.py") (word "\"$a\"") (word "\"$b\"") (word "\"$c\"")))))
(command (word "f"))
---

=== redirect after assignment builtin (eval redirects after evaluating arguments)
# See also: spec/redir-order.test.sh (#2307)
# The $(stdout_stderr.py) is evaluated *before* the 2>/dev/null redirection

readonly x=$(stdout_stderr.py) 2>/dev/null
echo done
---
(command (word "readonly") (word "x=$(stdout_stderr.py)") (redirect ">" "/dev/null"))
(command (word "echo") (word "done"))
---

=== redirect after command sub (like case above but without assignment builtin)
echo stdout=$(stdout_stderr.py) 2>/dev/null
---
(command (word "echo") (word "stdout=$(stdout_stderr.py)") (redirect ">" "/dev/null"))
---

=== redirect after bare assignment
x=$(stdout_stderr.py) 2>/dev/null
echo done
---
(command (word "x=$(stdout_stderr.py)") (redirect ">" "/dev/null"))
(command (word "echo") (word "done"))
---

=== redirect after declare -p
case $SH in *dash) exit 99 ;; esac  # stderr unpredictable

foo=bar
typeset -p foo 1>&2

# zsh and mksh agree on exact output, which we don't really care about
---
(case (word "$SH") (pattern ((word "*dash")) (command (word "exit") (word "99"))))
(command (word "foo=bar"))
(command (word "typeset") (word "-p") (word "foo") (redirect ">&" 2))
---

=== declare -a arr does not remove existing arrays (OSH regression)
case $SH in dash) exit 99 ;; esac # dash does not support arrays

declare -a arr
arr=(foo bar baz)
declare -a arr
echo arr:${#arr[@]}
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit") (word "99"))))
(command (word "declare") (word "-a") (word "arr"))
(command (word "arr=(foo bar baz)"))
(command (word "declare") (word "-a") (word "arr"))
(command (word "echo") (word "arr:${#arr[@]}"))
---

=== declare -A dict does not remove existing arrays (OSH regression)
case $SH in dash|mksh) exit 99 ;; esac # dash/mksh does not support associative arrays

declare -A dict
dict['foo']=hello
dict['bar']=oil
dict['baz']=world
declare -A dict
echo dict:${#dict[@]}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit") (word "99"))))
(command (word "declare") (word "-A") (word "dict"))
(command (word "dict['foo']=hello"))
(command (word "dict['bar']=oil"))
(command (word "dict['baz']=world"))
(command (word "declare") (word "-A") (word "dict"))
(command (word "echo") (word "dict:${#dict[@]}"))
---

=== "readonly -a arr" and "readonly -A dict" should not not remove existing arrays
# mksh's readonly does not support the -a option.
# dash/mksh does not support associative arrays.
case $SH in dash|mksh) exit 99 ;; esac

declare -a arr
arr=(foo bar baz)
declare -A dict
dict['foo']=hello
dict['bar']=oil
dict['baz']=world

readonly -a arr
echo arr:${#arr[@]}
readonly -A dict
echo dict:${#dict[@]}
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit") (word "99"))))
(command (word "declare") (word "-a") (word "arr"))
(command (word "arr=(foo bar baz)"))
(command (word "declare") (word "-A") (word "dict"))
(command (word "dict['foo']=hello"))
(command (word "dict['bar']=oil"))
(command (word "dict['baz']=world"))
(command (word "readonly") (word "-a") (word "arr"))
(command (word "echo") (word "arr:${#arr[@]}"))
(command (word "readonly") (word "-A") (word "dict"))
(command (word "echo") (word "dict:${#dict[@]}"))
---

=== "declare -a arr" and "readonly -a a" creates an empty array (OSH)
case $SH in dash|mksh) exit 99 ;; esac # dash/mksh does not support associative arrays

declare -a arr1
readonly -a arr2
declare -A dict1
readonly -A dict2

declare -p arr1 arr2 dict1 dict2
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit") (word "99"))))
(command (word "declare") (word "-a") (word "arr1"))
(command (word "readonly") (word "-a") (word "arr2"))
(command (word "declare") (word "-A") (word "dict1"))
(command (word "readonly") (word "-A") (word "dict2"))
(command (word "declare") (word "-p") (word "arr1") (word "arr2") (word "dict1") (word "dict2"))
---

=== "var d = {}; declare -p d" does not print anything (OSH)
case $SH in bash-4.4|dash|mksh|zsh) exit 99 ;; esac

# We pretend that the variable does not exist when the variable is not
# representable with the "declare -p" format.

var d = {}
declare -p d
---
(case (word "$SH") (pattern ((word "bash-4.4") (word "dash") (word "mksh") (word "zsh")) (command (word "exit") (word "99"))))
(command (word "var") (word "d") (word "=") (word "{}"))
(command (word "declare") (word "-p") (word "d"))
---

=== readonly array should not be modified by a+=(1)
case $SH in dash) exit 99 ;; esac # dash/mksh does not support associative arrays

a=(1 2 3)
readonly -a a
eval 'a+=(4)'
argv.py "${a[@]}"
eval 'declare -n r=a; r+=(4)'
argv.py "${a[@]}"
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit") (word "99"))))
(command (word "a=(1 2 3)"))
(command (word "readonly") (word "-a") (word "a"))
(command (word "eval") (word "'a+=(4)'"))
(command (word "argv.py") (word "\"${a[@]}\""))
(command (word "eval") (word "'declare -n r=a; r+=(4)'"))
(command (word "argv.py") (word "\"${a[@]}\""))
---

=== Here string
cat <<< 'hi'
---
(command (word "cat") (redirect "<<<" "'hi'"))
---

=== Here string with $
cat <<< $'one\ntwo\n'
---
(command (word "cat") (redirect "<<<" "'one
two
'"))
---

=== Here redirect with explicit descriptor
# A space between 0 and <<EOF causes it to pass '0' as an arg to cat.
cat 0<<EOF
one
EOF
---
(command (word "cat") (redirect "<<" "one
"))
---

=== Here doc from another input file descriptor
# NOTE: OSH fails on descriptor 9, but not descriptor 8?  Is this because of
# the Python VM?  How  to inspect state?
read_from_fd.py 8  8<<EOF
here doc on descriptor
EOF
---
(command (word "read_from_fd.py") (word "8") (redirect "<<" "here doc on descriptor
"))
---

=== Multiple here docs with different descriptors
read_from_fd.py 0 3 <<EOF 3<<EOF3
fd0
EOF
fd3
EOF3
---
(command (word "read_from_fd.py") (word "0") (word "3") (redirect "<<" "fd0
") (redirect "<<" "fd3
"))
---

=== Here doc with bad var delimiter
# Most shells accept this, but OSH is stricter.
cat <<${a}
here
${a}
---
(command (word "cat") (redirect "<<" "here
"))
---

=== Here doc with bad comsub delimiter
# bash is OK with this; dash isn't.  Should be a parse error.
cat <<$(a)
here
$(a)
---
(command (word "cat") (redirect "<<" "here
"))
---

=== Here doc and < redirect -- last one wins
echo hello >$TMP/hello.txt

cat <<EOF <$TMP/hello.txt
here
EOF
---
(command (word "echo") (word "hello") (redirect ">" "$TMP/hello.txt"))
(command (word "cat") (redirect "<<" "here
") (redirect "<" "$TMP/hello.txt"))
---

=== < redirect and here doc -- last one wins
echo hello >$TMP/hello.txt

cat <$TMP/hello.txt <<EOF
here
EOF
---
(command (word "echo") (word "hello") (redirect ">" "$TMP/hello.txt"))
(command (word "cat") (redirect "<" "$TMP/hello.txt") (redirect "<<" "here
"))
---

=== Here doc with var sub, command sub, arith sub
var=v
cat <<EOF
var: ${var}
command: $(echo hi)
arith: $((1+2))
EOF
---
(command (word "var=v"))
(command (word "cat") (redirect "<<" "var: ${var}
command: $(echo hi)
arith: $((1+2))
"))
---

=== Here doc in middle.  And redirects in the middle.
# This isn't specified by the POSIX grammar, but it's accepted by both dash and
# bash!
echo foo > foo.txt
echo bar > bar.txt
cat <<EOF 1>&2 foo.txt - bar.txt
here
EOF
---
(command (word "echo") (word "foo") (redirect ">" "foo.txt"))
(command (word "echo") (word "bar") (redirect ">" "bar.txt"))
(command (word "cat") (word "foo.txt") (word "-") (word "bar.txt") (redirect "<<" "here
") (redirect ">&" 2))
---

=== Here doc line continuation
cat <<EOF \
; echo two
one
EOF
---
(semi (command (word "cat") (redirect "<<" "one
")) (command (word "echo") (word "two")))
---

=== Here doc with quote expansion in terminator
cat <<'EOF'"2"
one
two
EOF2
---
(command (word "cat") (redirect "<<" "one
two
"))
---

=== Here doc with multiline double quoted string
cat <<EOF; echo "two
three"
one
EOF
---
(semi (command (word "cat") (redirect "<<" "one
")) (command (word "echo") (word "\"two\nthree\"")))
---

=== Two here docs -- first is ignored; second ones wins!
<<EOF1 cat <<EOF2
hello
EOF1
there
EOF2
---
(command (word "cat") (redirect "<<" "hello
") (redirect "<<" "there
"))
---

=== Here doc with pipe on first line
cat <<EOF | tac
1
2
3
EOF
---
(pipe (command (word "cat") (redirect "<<" "1
2
3
")) (command (word "tac")))
---

=== Here doc with pipe continued on last line
cat <<EOF |
1
2
3
EOF
tac
---
(pipe (command (word "cat") (redirect "<<" "1
2
3
")) (command (word "tac")))
---

=== Here doc with builtin 'read'
# read can't be run in a subshell.
read v1 v2 <<EOF
val1 val2
EOF
echo =$v1= =$v2=
---
(command (word "read") (word "v1") (word "v2") (redirect "<<" "val1 val2
"))
(command (word "echo") (word "=$v1=") (word "=$v2="))
---

=== Compound command here doc
while read line; do
  echo X $line
done <<EOF
1
2
3
EOF
---
(while (command (word "read") (word "line")) (command (word "echo") (word "X") (word "$line"))) (redirect "<<" "1
2
3
")
---

=== Here doc in while condition and here doc in body
while cat <<E1 && cat <<E2; do cat <<E3; break; done
1
E1
2
E2
3
E3
---
(while (and (command (word "cat") (redirect "<<" "1
")) (command (word "cat") (redirect "<<" "2
"))) (semi (command (word "cat") (redirect "<<" "3
")) (command (word "break"))))
---

=== Here doc in while condition and here doc in body on multiple lines
while cat <<E1 && cat <<E2
1
E1
2
E2
do
  cat <<E3
3
E3
  break
done
---
(while (and (command (word "cat") (redirect "<<" "1
")) (command (word "cat") (redirect "<<" "2
"))) (semi (command (word "cat") (redirect "<<" "3
")) (command (word "break"))))
---

=== Here doc in while loop split up more
while cat <<E1
1
E1

cat <<E2
2
E2

do
  cat <<E3
3
E3
  break
done
---
(while (semi (command (word "cat") (redirect "<<" "1
")) (command (word "cat") (redirect "<<" "2
"))) (semi (command (word "cat") (redirect "<<" "3
")) (command (word "break"))))
---

=== Mixing << and <<-
cat <<-EOF; echo --; cat <<EOF2
	one
EOF
two
EOF2
---
(semi (semi (command (word "cat") (redirect "<<-" "one
")) (command (word "echo") (word "--"))) (command (word "cat") (redirect "<<" "two
")))
---

=== Two compound commands with two here docs
while read line; do echo X $line; done <<EOF; echo ==;  while read line; do echo Y $line; done <<EOF2
1
2
EOF
3
4
EOF2
---
(semi (semi (while (command (word "read") (word "line")) (command (word "echo") (word "X") (word "$line"))) (redirect "<<" "1
2
") (command (word "echo") (word "=="))) (while (command (word "read") (word "line")) (command (word "echo") (word "Y") (word "$line"))) (redirect "<<" "3
4
"))
---

=== Function def and execution with here doc
fun() { cat; } <<EOF; echo before; fun; echo after 
1
2
EOF
---
(semi (semi (semi (function "fun" (brace-group (command (word "cat"))) (redirect "<<" "1
2
")) (command (word "echo") (word "before"))) (command (word "fun"))) (command (word "echo") (word "after")))
---

=== Here doc as command prefix
<<EOF tac
1
2
3
EOF
---
(command (word "tac") (redirect "<<" "1
2
3
"))
---

=== Redirect after here doc
cat <<EOF 1>&2
out
EOF
---
(command (word "cat") (redirect "<<" "out
") (redirect ">&" 2))
---

=== here doc stripping tabs
cat <<-EOF
	1
	2
		3  # 2 tabs are both stripped
  4  # spaces are preserved
	EOF
---
(command (word "cat") (redirect "<<-" "1
2
3  # 2 tabs are both stripped
  4  # spaces are preserved
"))
---

=== Here doc within subshell with boolean
[[ $(cat <<EOF
foo
EOF
) == foo ]]; echo $?
---
(semi (cond (cond-binary "==" (cond-term "$(cat <<EOF
foo
EOF
)") (cond-term "foo"))) (command (word "echo") (word "$?")))
---

=== Here Doc in if condition
if cat <<EOF; then
here doc in IF CONDITION
EOF
  echo THEN executed
fi
---
(if (command (word "cat") (redirect "<<" "here doc in IF CONDITION
")) (command (word "echo") (word "THEN") (word "executed")))
---

=== Nested here docs which are indented
cat <<- EOF
	outside
	$(cat <<- INSIDE
		inside
INSIDE
)
EOF
---
(command (word "cat") (redirect "<<-" "outside
$(cat <<- INSIDE
inside
INSIDE
)
"))
---

=== Multiple here docs in pipeline
case $SH in *osh) exit ;; esac

# The second instance reads its stdin from the pipe, and fd 5 from a here doc.
read_from_fd.py 3 3<<EOF3 | read_from_fd.py 0 5 5<<EOF5
fd3
EOF3
fd5
EOF5

echo ok
---
(case (word "$SH") (pattern ((word "*osh")) (command (word "exit"))))
(pipe (command (word "read_from_fd.py") (word "3") (redirect "<<" "fd3
")) (command (word "read_from_fd.py") (word "0") (word "5") (redirect "<<" "fd5
")))
(command (word "echo") (word "ok"))
---

=== Multiple here docs in pipeline on multiple lines
case $SH in *osh) exit ;; esac

# SKIPPED: hangs with osh on Debian
# The second instance reads its stdin from the pipe, and fd 5 from a here doc.
read_from_fd.py 3 3<<EOF3 |
fd3
EOF3
read_from_fd.py 0 5 5<<EOF5
fd5
EOF5

echo ok
---
(case (word "$SH") (pattern ((word "*osh")) (command (word "exit"))))
(pipe (command (word "read_from_fd.py") (word "3") (redirect "<<" "fd3
")) (command (word "read_from_fd.py") (word "0") (word "5") (redirect "<<" "fd5
")))
(command (word "echo") (word "ok"))
---

=== Here doc and backslash double quote
cat <<EOF
a \"quote\"
EOF
---
(command (word "cat") (redirect "<<" "a \"quote\"
"))
---

=== Here doc escapes
# these are the chars from _DQ_ESCAPED_CHAR
cat <<EOF
\\ \" \$ \`
EOF
---
(command (word "cat") (redirect "<<" "\\ \" \$ \`
"))
---

=== Brace group in pipeline
{ echo one; echo two; } | tac
---
(pipe (brace-group (semi (command (word "echo") (word "one")) (command (word "echo") (word "two")))) (command (word "tac")))
---

=== For loop starts pipeline
for w in one two; do
  echo $w
done | tac
---
(pipe (for (word "w") (in (word "one") (word "two")) (command (word "echo") (word "$w"))) (command (word "tac")))
---

=== While Loop ends pipeline
seq 3 | while read i
do
  echo ".$i"
done
---
(pipe (command (word "seq") (word "3")) (while (command (word "read") (word "i")) (command (word "echo") (word "\".$i\""))))
---

=== Redirect in Pipeline
echo hi 1>&2 | wc -l
---
(pipe (command (word "echo") (word "hi") (redirect ">&" 2)) (command (word "wc") (word "-l")))
---

=== Pipeline comments
echo abcd |    # input
               # blank line
tr a-z A-Z     # transform
---
(pipe (command (word "echo") (word "abcd")) (command (word "tr") (word "a-z") (word "A-Z")))
---

=== Exit code is last status
echo a | egrep '[0-9]+'
---
(pipe (command (word "echo") (word "a")) (command (word "egrep") (word "'[0-9]+'")))
---

=== Initial value of PIPESTATUS is empty string
case $SH in dash|zsh) exit ;; esac

echo pipestatus ${PIPESTATUS[@]}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "echo") (word "pipestatus") (word "${PIPESTATUS[@]}"))
---

=== PIPESTATUS
return3() {
  return 3
}
{ sleep 0.03; exit 1; } | { sleep 0.02; exit 2; } | { sleep 0.01; return3; }
echo ${PIPESTATUS[@]}
---
(function "return3" (brace-group (command (word "return") (word "3"))))
(pipe (brace-group (semi (command (word "sleep") (word "0.03")) (command (word "exit") (word "1")))) (pipe (brace-group (semi (command (word "sleep") (word "0.02")) (command (word "exit") (word "2")))) (brace-group (semi (command (word "sleep") (word "0.01")) (command (word "return3"))))))
(command (word "echo") (word "${PIPESTATUS[@]}"))
---

=== PIPESTATUS is set on simple commands
case $SH in dash|zsh) exit ;; esac

false
echo pipestatus ${PIPESTATUS[@]}

exit 55 | (exit 44)
echo pipestatus ${PIPESTATUS[@]}

true
echo pipestatus ${PIPESTATUS[@]}
---
(case (word "$SH") (pattern ((word "dash") (word "zsh")) (command (word "exit"))))
(command (word "false"))
(command (word "echo") (word "pipestatus") (word "${PIPESTATUS[@]}"))
(pipe (command (word "exit") (word "55")) (subshell (command (word "exit") (word "44"))))
(command (word "echo") (word "pipestatus") (word "${PIPESTATUS[@]}"))
(command (word "true"))
(command (word "echo") (word "pipestatus") (word "${PIPESTATUS[@]}"))
---

=== PIPESTATUS with shopt -s lastpipe
shopt -s lastpipe
return3() {
  return 3
}
{ sleep 0.03; exit 1; } | { sleep 0.02; exit 2; } | { sleep 0.01; return3; }
echo ${PIPESTATUS[@]}
---
(command (word "shopt") (word "-s") (word "lastpipe"))
(function "return3" (brace-group (command (word "return") (word "3"))))
(pipe (brace-group (semi (command (word "sleep") (word "0.03")) (command (word "exit") (word "1")))) (pipe (brace-group (semi (command (word "sleep") (word "0.02")) (command (word "exit") (word "2")))) (brace-group (semi (command (word "sleep") (word "0.01")) (command (word "return3"))))))
(command (word "echo") (word "${PIPESTATUS[@]}"))
---

=== |&
stdout_stderr.py |& cat
---
(pipe (command (word "stdout_stderr.py") (redirect ">&" 1)) (command (word "cat")))
---

=== ! turns non-zero into zero
! $SH -c 'exit 42'; echo $?
---
(semi (negation (command (word "$SH") (word "-c") (word "'exit 42'"))) (command (word "echo") (word "$?")))
---

=== ! turns zero into 1
! $SH -c 'exit 0'; echo $?
---
(semi (negation (command (word "$SH") (word "-c") (word "'exit 0'"))) (command (word "echo") (word "$?")))
---

=== ! in if
if ! echo hi; then
  echo TRUE
else
  echo FALSE
fi
---
(if (negation (command (word "echo") (word "hi"))) (command (word "echo") (word "TRUE")) (command (word "echo") (word "FALSE")))
---

=== ! with ||
! echo hi || echo FAILED
---
(or (negation (command (word "echo") (word "hi"))) (command (word "echo") (word "FAILED")))
---

=== ! with { }
! { echo 1; echo 2; } || echo FAILED
---
(or (negation (brace-group (semi (command (word "echo") (word "1")) (command (word "echo") (word "2"))))) (command (word "echo") (word "FAILED")))
---

=== ! with ( )
! ( echo 1; echo 2 ) || echo FAILED
---
(or (negation (subshell (semi (command (word "echo") (word "1")) (command (word "echo") (word "2"))))) (command (word "echo") (word "FAILED")))
---

=== ! is not a command
v='!'
$v echo hi
---
(command (word "v='!'"))
(command (word "$v") (word "echo") (word "hi"))
---

=== Evaluation of argv[0] in pipeline occurs in child
${cmd=echo} hi | wc -l
echo "cmd=$cmd"
---
(pipe (command (word "${cmd=echo}") (word "hi")) (command (word "wc") (word "-l")))
(command (word "echo") (word "\"cmd=$cmd\""))
---

=== bash/dash/mksh run the last command is run in its own process
echo hi | read line
echo "line=$line"
---
(pipe (command (word "echo") (word "hi")) (command (word "read") (word "line")))
(command (word "echo") (word "\"line=$line\""))
---

=== shopt -s lastpipe (always on in OSH)
shopt -s lastpipe
echo hi | read line
echo "line=$line"
---
(command (word "shopt") (word "-s") (word "lastpipe"))
(pipe (command (word "echo") (word "hi")) (command (word "read") (word "line")))
(command (word "echo") (word "\"line=$line\""))
---

=== shopt -s lastpipe (always on in OSH)
shopt -s lastpipe
i=0
seq 3 | while read line; do
  (( i++ ))
done
echo i=$i
---
(command (word "shopt") (word "-s") (word "lastpipe"))
(command (word "i=0"))
(pipe (command (word "seq") (word "3")) (while (command (word "read") (word "line")) (arith (word " i++ "))))
(command (word "echo") (word "i=$i"))
---

=== SIGPIPE causes pipeline to die (regression for issue #295)
cat /dev/urandom | sleep 0.1
echo ${PIPESTATUS[@]}

# hm bash gives '1 0' which seems wrong
---
(pipe (command (word "cat") (word "/dev/urandom")) (command (word "sleep") (word "0.1")))
(command (word "echo") (word "${PIPESTATUS[@]}"))
---

=== Nested pipelines
{ sleep 0.1 | seq 3; } | cat
{ sleep 0.1 | seq 10; } | { cat | cat; } | wc -l
---
(pipe (brace-group (pipe (command (word "sleep") (word "0.1")) (command (word "seq") (word "3")))) (command (word "cat")))
(pipe (brace-group (pipe (command (word "sleep") (word "0.1")) (command (word "seq") (word "10")))) (pipe (brace-group (pipe (command (word "cat")) (command (word "cat")))) (command (word "wc") (word "-l"))))
---

=== Pipeline in eval
ls /dev/null | eval 'cat | cat' | wc -l
---
(pipe (command (word "ls") (word "/dev/null")) (pipe (command (word "eval") (word "'cat | cat'")) (command (word "wc") (word "-l"))))
---

=== shopt -s lastpipe and shopt -s no_last_fork interaction
case $SH in dash) exit ;; esac

$SH -c '
shopt -s lastpipe
set -o errexit
set -o pipefail

ls | false | wc -l'
echo status=$?

# Why does this give status 0?  It should fail

$SH -c '
shopt -s lastpipe
shopt -s no_fork_last  # OSH only
set -o errexit
set -o pipefail

ls | false | wc -l'
echo status=$?
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "$SH") (word "-c") (word "'\nshopt -s lastpipe\nset -o errexit\nset -o pipefail\n\nls | false | wc -l'"))
(command (word "echo") (word "status=$?"))
(command (word "$SH") (word "-c") (word "'\nshopt -s lastpipe\nshopt -s no_fork_last  # OSH only\nset -o errexit\nset -o pipefail\n\nls | false | wc -l'"))
(command (word "echo") (word "status=$?"))
---

=== >$file touches a file
rm -f myfile
test -f myfile
echo status=$?

>myfile
test -f myfile
echo status=$?
---
(command (word "rm") (word "-f") (word "myfile"))
(command (word "test") (word "-f") (word "myfile"))
(command (word "echo") (word "status=$?"))
(command (redirect ">" "myfile"))
(command (word "test") (word "-f") (word "myfile"))
(command (word "echo") (word "status=$?"))
---

=== $(< $file) yields the contents of the file
seq 2 3 > myfile
foo=$(< myfile)
argv.py "$foo"
---
(command (word "seq") (word "2") (word "3") (redirect ">" "myfile"))
(command (word "foo=$(< myfile)"))
(command (word "argv.py") (word "\"$foo\""))
---

=== `< $file` behaves like $(< file)
seq 7 8 > myfile

x=`< myfile`

echo "[$x]"
---
(command (word "seq") (word "7") (word "8") (redirect ">" "myfile"))
(command (word "x=`< myfile`"))
(command (word "echo") (word "\"[$x]\""))
---

=== $(< file; end) is not a special case
seq 5 6 > myfile

# zsh prints the file each time!
# other shells do nothing?

foo=$(echo begin; < myfile)
echo $foo
echo ---

foo=$(< myfile; echo end)
echo $foo
echo ---

foo=$(< myfile; <myfile)
echo $foo
echo ---
---
(command (word "seq") (word "5") (word "6") (redirect ">" "myfile"))
(command (word "foo=$(echo begin; < myfile)"))
(command (word "echo") (word "$foo"))
(command (word "echo") (word "---"))
(command (word "foo=$(< myfile; echo end)"))
(command (word "echo") (word "$foo"))
(command (word "echo") (word "---"))
(command (word "foo=$(< myfile; < myfile)"))
(command (word "echo") (word "$foo"))
(command (word "echo") (word "---"))
---

=== < file in pipeline and subshell doesn't work
echo FOO > file2

# This only happens in command subs, which is weird
< file2 | tr A-Z a-z
( < file2 )
echo end
---
(command (word "echo") (word "FOO") (redirect ">" "file2"))
(pipe (command (redirect "<" "file2")) (command (word "tr") (word "A-Z") (word "a-z")))
(subshell (command (redirect "<" "file2")))
(command (word "echo") (word "end"))
---

=== Leading redirect in a simple command
echo hello >$TMP/hello.txt  # temporary fix
<$TMP/hello.txt cat
---
(command (word "echo") (word "hello") (redirect ">" "$TMP/hello.txt"))
(command (word "cat") (redirect "<" "$TMP/hello.txt"))
---

=== Redirect in the middle of a simple command
f=$TMP/out
echo -n 1 2 '3 ' > $f
echo -n 4 5 >> $f '6 '
echo -n 7 >> $f 8 '9 '
echo -n >> $f 1 2 '3 '
echo >> $f -n 4 5 '6'

cat $f
echo
---
(command (word "f=$TMP/out"))
(command (word "echo") (word "-n") (word "1") (word "2") (word "'3 '") (redirect ">" "$f"))
(command (word "echo") (word "-n") (word "4") (word "5") (word "'6 '") (redirect ">>" "$f"))
(command (word "echo") (word "-n") (word "7") (word "8") (word "'9 '") (redirect ">>" "$f"))
(command (word "echo") (word "-n") (word "1") (word "2") (word "'3 '") (redirect ">>" "$f"))
(command (word "echo") (word "-n") (word "4") (word "5") (word "'6'") (redirect ">>" "$f"))
(command (word "cat") (word "$f"))
(command (word "echo"))
---

=== Redirect in command sub
FOO=$(echo foo 1>&2)
echo $FOO
---
(command (word "FOO=$(echo foo 1>&2)"))
(command (word "echo") (word "$FOO"))
---

=== Redirect in the middle of two assignments
FOO=foo >$TMP/out.txt BAR=bar printenv.py FOO BAR
tac $TMP/out.txt
---
(command (word "FOO=foo") (word "BAR=bar") (word "printenv.py") (word "FOO") (word "BAR") (redirect ">" "$TMP/out.txt"))
(command (word "tac") (word "$TMP/out.txt"))
---

=== Redirect in assignment
# dash captures stderr to a file here, which seems correct.  Bash doesn't and
# just lets it go to actual stderr.
# For now we agree with dash/mksh, since it involves fewer special cases in the
# code.

FOO=$(echo foo 1>&2) 2>$TMP/no-command.txt
echo FILE=
cat $TMP/no-command.txt
echo "FOO=$FOO"
---
(command (word "FOO=$(echo foo 1>&2)") (redirect ">" "$TMP/no-command.txt"))
(command (word "echo") (word "FILE="))
(command (word "cat") (word "$TMP/no-command.txt"))
(command (word "echo") (word "\"FOO=$FOO\""))
---

=== Redirect in function body
fun() { echo hi; } 1>&2
fun
---
(function "fun" (brace-group (command (word "echo") (word "hi"))) (redirect ">&" 2))
(command (word "fun"))
---

=== Redirect in function body is evaluated multiple times
i=0
fun() { echo "file $i"; } 1> "$TMP/file$((i++))"
fun
fun
echo i=$i
echo __
cat $TMP/file0
echo __
cat $TMP/file1
---
(command (word "i=0"))
(function "fun" (brace-group (command (word "echo") (word "\"file $i\""))) (redirect ">" ""$TMP/file$((i++))""))
(command (word "fun"))
(command (word "fun"))
(command (word "echo") (word "i=$i"))
(command (word "echo") (word "__"))
(command (word "cat") (word "$TMP/file0"))
(command (word "echo") (word "__"))
(command (word "cat") (word "$TMP/file1"))
---

=== Redirect in function body AND function call
fun() { echo hi; } 1>&2
fun 2>&1
---
(function "fun" (brace-group (command (word "echo") (word "hi"))) (redirect ">&" 2))
(command (word "fun") (redirect ">&" 1))
---

=== redirect bash extensions:   [[  ((  for ((
case $SH in dash|mksh) exit ;; esac

rm -f dbracket dparen for-expr

[[ x = x ]] > dbracket

(( 42 )) > dparen

for ((x = 0; x < 1; ++x)); do
  echo for-expr
done > for-expr

wc -l dbracket dparen for-expr
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit"))))
(command (word "rm") (word "-f") (word "dbracket") (word "dparen") (word "for-expr"))
(cond (cond-binary "=" (cond-term "x") (cond-term "x"))) (redirect ">" "dbracket")
(arith (word " 42 ")) (redirect ">" "dparen")
(arith-for (init (word "x = 0")) (test (word "x < 1")) (step (word "++x")) (command (word "echo") (word "for-expr"))) (redirect ">" "for-expr")
(command (word "wc") (word "-l") (word "dbracket") (word "dparen") (word "for-expr"))
---

=== redirect if
if true; then
  echo if-body
fi >out

cat out
---
(if (command (word "true")) (command (word "echo") (word "if-body"))) (redirect ">" "out")
(command (word "cat") (word "out"))
---

=== redirect case
case foo in
  foo)
    echo case-body
    ;;
esac > out

cat out
---
(case (word "foo") (pattern ((word "foo")) (command (word "echo") (word "case-body")))) (redirect ">" "out")
(command (word "cat") (word "out"))
---

=== redirect while
while true; do
  echo while-body
  break
done > out

cat out
---
(while (command (word "true")) (semi (command (word "echo") (word "while-body")) (command (word "break")))) (redirect ">" "out")
(command (word "cat") (word "out"))
---

=== redirect for loop
for i in $(seq 3)
do
  echo $i
done > $TMP/redirect-for-loop.txt
cat $TMP/redirect-for-loop.txt
---
(for (word "i") (in (word "$(seq 3)")) (command (word "echo") (word "$i"))) (redirect ">" "$TMP/redirect-for-loop.txt")
(command (word "cat") (word "$TMP/redirect-for-loop.txt"))
---

=== redirect subshell
( echo foo ) 1>&2
---
(subshell (command (word "echo") (word "foo"))) (redirect ">&" 2)
---

=== Brace group redirect
# Suffix works, but prefix does NOT work.
# That comes from '| compound_command redirect_list' in the grammar!
{ echo block-redirect; } > $TMP/br.txt
cat $TMP/br.txt | wc -c
---
(brace-group (command (word "echo") (word "block-redirect"))) (redirect ">" "$TMP/br.txt")
(pipe (command (word "cat") (word "$TMP/br.txt")) (command (word "wc") (word "-c")))
---

=== Redirect function stdout
f() { echo one; echo two; }
f > $TMP/redirect-func.txt
cat $TMP/redirect-func.txt
---
(function "f" (brace-group (semi (command (word "echo") (word "one")) (command (word "echo") (word "two")))))
(command (word "f") (redirect ">" "$TMP/redirect-func.txt"))
(command (word "cat") (word "$TMP/redirect-func.txt"))
---

=== Nested function stdout redirect
# Shows that a stack is necessary.
inner() {
  echo i1
  echo i2
}
outer() {
  echo o1
  inner > $TMP/inner.txt
  echo o2
}
outer > $TMP/outer.txt
cat $TMP/inner.txt
echo --
cat $TMP/outer.txt
---
(function "inner" (brace-group (semi (command (word "echo") (word "i1")) (command (word "echo") (word "i2")))))
(function "outer" (brace-group (semi (semi (command (word "echo") (word "o1")) (command (word "inner") (redirect ">" "$TMP/inner.txt"))) (command (word "echo") (word "o2")))))
(command (word "outer") (redirect ">" "$TMP/outer.txt"))
(command (word "cat") (word "$TMP/inner.txt"))
(command (word "echo") (word "--"))
(command (word "cat") (word "$TMP/outer.txt"))
---

=== File redirects with glob args (bash and zsh only)
touch one-bar

echo hi > one-*

cat one-bar

echo escaped > one-\*

cat one-\*
---
(command (word "touch") (word "one-bar"))
(command (word "echo") (word "hi") (redirect ">" "one-*"))
(command (word "cat") (word "one-bar"))
(command (word "echo") (word "escaped") (redirect ">" "one-\*"))
(command (word "cat") (word "one-\\*"))
---

=== File redirect without matching any file
echo hi > zz-*-xx
echo status=$?

echo zz*
---
(command (word "echo") (word "hi") (redirect ">" "zz-*-xx"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "zz*"))
---

=== ysh behavior when glob doesn't match
shopt -s ysh:upgrade

echo hi > qq-*-zz
echo status=$?

echo qq*
---
(command (word "shopt") (word "-s") (word "ysh:upgrade"))
(command (word "echo") (word "hi") (redirect ">" "qq-*-zz"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "qq*"))
---

=== File redirect without matching any file, with failglob
shopt -s failglob

echo hi > zz-*-xx
echo status=$?

echo zz*
echo status=$?
---
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "echo") (word "hi") (redirect ">" "zz-*-xx"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "zz*"))
(command (word "echo") (word "status=$?"))
---

=== Redirect to $empty (in function body)
empty=''
fun() { echo hi; } > $empty
fun
echo status=$?
---
(command (word "empty=''"))
(function "fun" (brace-group (command (word "echo") (word "hi"))) (redirect ">" "$empty"))
(command (word "fun"))
(command (word "echo") (word "status=$?"))
---

=== Redirect to ''
echo hi > ''
echo status=$?
---
(command (word "echo") (word "hi") (redirect ">" "''"))
(command (word "echo") (word "status=$?"))
---

=== File redirect to $var with glob char
touch two-bar

star='*'

# This gets glob-expanded, as it does outside redirects
echo hi > two-$star
echo status=$?

head two-bar two-\*
---
(command (word "touch") (word "two-bar"))
(command (word "star='*'"))
(command (word "echo") (word "hi") (redirect ">" "two-$star"))
(command (word "echo") (word "status=$?"))
(command (word "head") (word "two-bar") (word "two-\\*"))
---

=== File redirect that globs to more than one file (bash and zsh only)
touch foo-bar
touch foo-spam

echo hi > foo-*
echo status=$?

head foo-bar foo-spam
---
(command (word "touch") (word "foo-bar"))
(command (word "touch") (word "foo-spam"))
(command (word "echo") (word "hi") (redirect ">" "foo-*"))
(command (word "echo") (word "status=$?"))
(command (word "head") (word "foo-bar") (word "foo-spam"))
---

=== File redirect with extended glob
# @extglob
shopt -s extglob

touch foo-bar

echo hi > @(*-bar|other)
echo status=$?

cat foo-bar
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "touch") (word "foo-bar"))
(command (word "echo") (word "hi") (redirect ">" "@(*-bar|other)"))
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "foo-bar"))
---

=== Extended glob that doesn't match anything
# @extglob
shopt -s extglob
rm bad_*

# They actually write this literal file!  This is what EvalWordToString() does,
# as opposed to _EvalWordToParts.
echo foo > bad_@(*.cc|*.h)
echo status=$?

echo bad_*

shopt -s failglob

# Note: ysh:ugprade doesn't allow extended globs
# shopt -s ysh:upgrade

echo foo > bad_@(*.cc|*.h)
echo status=$?
---
(command (word "shopt") (word "-s") (word "extglob"))
(command (word "rm") (word "bad_*"))
(command (word "echo") (word "foo") (redirect ">" "bad_@(*.cc|*.h)"))
(command (word "echo") (word "status=$?"))
(command (word "echo") (word "bad_*"))
(command (word "shopt") (word "-s") (word "failglob"))
(command (word "echo") (word "foo") (redirect ">" "bad_@(*.cc|*.h)"))
(command (word "echo") (word "status=$?"))
---

=== Non-file redirects don't respect glob args (we differe from bash)
touch 10

exec 10>&1  # open stdout as descriptor 10

# Does this go to stdout?  ONLY bash respects it, not zsh
echo should-not-be-on-stdout >& 1*

echo stdout
echo stderr >&2
---
(command (word "touch") (word "10"))
(command (word "exec") (redirect ">&" 1))
(command (word "echo") (word "should-not-be-on-stdout") (redirect ">&" "1*"))
(command (word "echo") (word "stdout"))
(command (word "echo") (word "stderr") (redirect ">&" 2))
---

=== Redirect with brace expansion isn't allowed
echo hi > a-{one,two}
echo status=$?

head a-*
echo status=$?
---
(command (word "echo") (word "hi") (redirect ">" "a-{one,two}"))
(command (word "echo") (word "status=$?"))
(command (word "head") (word "a-*"))
(command (word "echo") (word "status=$?"))
---

=== File redirects have word splitting too!
file='foo bar'

echo hi > $file
echo status=$?

cat "$file"
echo status=$?
---
(command (word "file='foo bar'"))
(command (word "echo") (word "hi") (redirect ">" "$file"))
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "\"$file\""))
(command (word "echo") (word "status=$?"))
---

=== >& and <& are the same
echo one 1>&2

echo two 1<&2
---
(command (word "echo") (word "one") (redirect ">&" 2))
(command (word "echo") (word "two") (redirect "<&" 2))
---

=== <&
# Is there a simpler test case for this?
echo foo51 > $TMP/lessamp.txt

exec 6< $TMP/lessamp.txt
read line <&6

echo "[$line]"
---
(command (word "echo") (word "foo51") (redirect ">" "$TMP/lessamp.txt"))
(command (word "exec") (redirect "<" "$TMP/lessamp.txt"))
(command (word "read") (word "line") (redirect "<&" 6))
(command (word "echo") (word "\"[$line]\""))
---

=== 2>&1 with no command
( exit 42 )  # status is reset after this
echo status=$?
2>&1
echo status=$?
---
(subshell (command (word "exit") (word "42")))
(command (word "echo") (word "status=$?"))
(command (redirect ">&" 1))
(command (word "echo") (word "status=$?"))
---

=== 2&>1 (is it a redirect or is it like a&>1)
2&>1
echo status=$?
---
(command (word "2") (redirect "&>" "1"))
(command (word "echo") (word "status=$?"))
---

=== Nonexistent file
cat <$TMP/nonexistent.txt
echo status=$?
---
(command (word "cat") (redirect "<" "$TMP/nonexistent.txt"))
(command (word "echo") (word "status=$?"))
---

=== Descriptor redirect with spaces
# Hm this seems like a failure of lookahead!  The second thing should look to a
# file-like thing.
# I think this is a posix issue.
# tag: posix-issue
echo one 1>&2
echo two 1 >&2
echo three 1>& 2
---
(command (word "echo") (word "one") (redirect ">&" 2))
(command (word "echo") (word "two") (word "1") (redirect ">&" 2))
(command (word "echo") (word "three") (redirect ">&" 2))
---

=== Filename redirect with spaces
# This time 1 *is* a descriptor, not a word.  If you add a space between 1 and
# >, it doesn't work.
echo two 1> $TMP/file-redir1.txt
cat $TMP/file-redir1.txt
---
(command (word "echo") (word "two") (redirect ">" "$TMP/file-redir1.txt"))
(command (word "cat") (word "$TMP/file-redir1.txt"))
---

=== Quoted filename redirect with spaces
# POSIX makes node of this
echo two \1 > $TMP/file-redir2.txt
cat $TMP/file-redir2.txt
---
(command (word "echo") (word "two") (word "\\1") (redirect ">" "$TMP/file-redir2.txt"))
(command (word "cat") (word "$TMP/file-redir2.txt"))
---

=== Descriptor redirect with filename
# bash/mksh treat this like a filename, not a descriptor.
# dash aborts.
echo one 1>&$TMP/nonexistent-filename__
echo "status=$?"
---
(command (word "echo") (word "one") (redirect ">&" "$TMP/nonexistent-filename__"))
(command (word "echo") (word "\"status=$?\""))
---

=== Redirect echo to stderr, and then redirect all of stdout somewhere.
{ echo foo52 1>&2; echo 012345789; } > $TMP/block-stdout.txt
cat $TMP/block-stdout.txt |  wc -c 
---
(brace-group (semi (command (word "echo") (word "foo52") (redirect ">&" 2)) (command (word "echo") (word "012345789")))) (redirect ">" "$TMP/block-stdout.txt")
(pipe (command (word "cat") (word "$TMP/block-stdout.txt")) (command (word "wc") (word "-c")))
---

=== Named file descriptor
exec {myfd}> $TMP/named-fd.txt
echo named-fd-contents >& $myfd
cat $TMP/named-fd.txt
---
(command (word "exec") (redirect ">" "$TMP/named-fd.txt"))
(command (word "echo") (word "named-fd-contents") (redirect ">&" "$myfd"))
(command (word "cat") (word "$TMP/named-fd.txt"))
---

=== Double digit fd (20> file)
exec 20> "$TMP/double-digit-fd.txt"
echo hello20 >&20
cat "$TMP/double-digit-fd.txt"
---
(command (word "exec") (redirect ">" ""$TMP/double-digit-fd.txt""))
(command (word "echo") (word "hello20") (redirect ">&" 20))
(command (word "cat") (word "\"$TMP/double-digit-fd.txt\""))
---

=== : 9> fdleak (OSH regression)
true 9> "$TMP/fd.txt"
( echo world >&9 )
cat "$TMP/fd.txt"
---
(command (word "true") (redirect ">" ""$TMP/fd.txt""))
(subshell (command (word "echo") (word "world") (redirect ">&" 9)))
(command (word "cat") (word "\"$TMP/fd.txt\""))
---

=== : 3>&3 (OSH regression)
# mksh started being flaky on the continuous build and during release.  We
# don't care!  Related to issue #330.
case $SH in mksh) exit ;; esac

: 3>&3
echo hello
---
(case (word "$SH") (pattern ((word "mksh")) (command (word "exit"))))
(command (word ":") (redirect ">&" 3))
(command (word "echo") (word "hello"))
---

=== : 3>&3-
: 3>&3-
echo hello
---
(command (word ":") (redirect ">&" 3))
(command (word "echo") (word "hello"))
---

=== 3>&- << EOF (OSH regression: fail to restore fds)
exec 3> "$TMP/fd.txt"
echo hello 3>&- << EOF
EOF
echo world >&3
exec 3>&-  # close
cat "$TMP/fd.txt"
---
(command (word "exec") (redirect ">" ""$TMP/fd.txt""))
(command (word "echo") (word "hello") (redirect ">&-" 0) (redirect "<<" ""))
(command (word "echo") (word "world") (redirect ">&" 3))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "\"$TMP/fd.txt\""))
---

=== Open file on descriptor 3 and write to it many times
# different than case below because 3 is the likely first FD of open()

exec 3> "$TMP/fd3.txt"
echo hello >&3
echo world >&3
exec 3>&-  # close
cat "$TMP/fd3.txt"
---
(command (word "exec") (redirect ">" ""$TMP/fd3.txt""))
(command (word "echo") (word "hello") (redirect ">&" 3))
(command (word "echo") (word "world") (redirect ">&" 3))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "\"$TMP/fd3.txt\""))
---

=== Open file on descriptor 4 and write to it many times
# different than the case above because because 4 isn't the likely first FD

exec 4> "$TMP/fd4.txt"
echo hello >&4
echo world >&4
exec 4>&-  # close
cat "$TMP/fd4.txt"
---
(command (word "exec") (redirect ">" ""$TMP/fd4.txt""))
(command (word "echo") (word "hello") (redirect ">&" 4))
(command (word "echo") (word "world") (redirect ">&" 4))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "\"$TMP/fd4.txt\""))
---

=== Redirect to empty string
f=''
echo s > "$f"
echo "result=$?"
set -o errexit
echo s > "$f"
echo DONE
---
(command (word "f=''"))
(command (word "echo") (word "s") (redirect ">" ""$f""))
(command (word "echo") (word "\"result=$?\""))
(command (word "set") (word "-o") (word "errexit"))
(command (word "echo") (word "s") (redirect ">" ""$f""))
(command (word "echo") (word "DONE"))
---

=== Redirect to file descriptor that's not open
# Notes:
# - 7/2021: descriptor 7 seems to work on all CI systems.  The process state
#   isn't clean, but we could probably close it in OSH?
# - dash doesn't allow file descriptors greater than 9.  (This is a good
#   thing, because the bash chapter in AOSA book mentions that juggling user
#   vs.  system file descriptors is a huge pain.)
# - But somehow running in parallel under spec-runner.sh changes whether
#   descriptor 3 is open.  e.g. 'echo hi 1>&3'.  Possibly because of
#   /usr/bin/time.  The _tmp/spec/*.task.txt file gets corrupted!
# - Oh this is because I use time --output-file.  That opens descriptor 3.  And
#   then time forks the shell script.  The file descriptor table is inherited.
#   - You actually have to set the file descriptor to something.  What do
#   configure and debootstrap too?

opened=$(ls /proc/$$/fd)
if echo "$opened" | egrep '^7$'; then
  echo "FD 7 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi

echo hi 1>&7
---
(command (word "opened=$(ls /proc/$$/fd)"))
(if (pipe (command (word "echo") (word "\"$opened\"")) (command (word "egrep") (word "'^7$'"))) (semi (semi (command (word "echo") (word "\"FD 7 shouldn't be open\"")) (command (word "echo") (word "\"OPENED:\""))) (command (word "echo") (word "\"$opened\""))))
(command (word "echo") (word "hi") (redirect ">&" 7))
---

=== Open descriptor with exec
# What is the point of this?  ./configure scripts and debootstrap use it.
exec 3>&1
echo hi 1>&3
---
(command (word "exec") (redirect ">&" 1))
(command (word "echo") (word "hi") (redirect ">&" 3))
---

=== Open multiple descriptors with exec
# What is the point of this?  ./configure scripts and debootstrap use it.
exec 3>&1
exec 4>&1
echo three 1>&3
echo four 1>&4
---
(command (word "exec") (redirect ">&" 1))
(command (word "exec") (redirect ">&" 1))
(command (word "echo") (word "three") (redirect ">&" 3))
(command (word "echo") (word "four") (redirect ">&" 4))
---

=== >| to clobber
echo XX >| $TMP/c.txt

set -o noclobber

echo YY >  $TMP/c.txt  # not clobber
echo status=$?

cat $TMP/c.txt
echo ZZ >| $TMP/c.txt

cat $TMP/c.txt
---
(command (word "echo") (word "XX") (redirect ">|" "$TMP/c.txt"))
(command (word "set") (word "-o") (word "noclobber"))
(command (word "echo") (word "YY") (redirect ">" "$TMP/c.txt"))
(command (word "echo") (word "status=$?"))
(command (word "cat") (word "$TMP/c.txt"))
(command (word "echo") (word "ZZ") (redirect ">|" "$TMP/c.txt"))
(command (word "cat") (word "$TMP/c.txt"))
---

=== &> redirects stdout and stderr
tmp="$(basename $SH)-$$.txt"  # unique name for shell and test case
#echo $tmp

stdout_stderr.py &> $tmp

# order is indeterminate
grep STDOUT $tmp
grep STDERR $tmp
---
(command (word "tmp=\"$(basename $SH)-$$.txt\""))
(command (word "stdout_stderr.py") (redirect "&>" "$tmp"))
(command (word "grep") (word "STDOUT") (word "$tmp"))
(command (word "grep") (word "STDERR") (word "$tmp"))
---

=== >&word redirects stdout and stderr when word is not a number or -
# dash, mksh don't implement this bash behaviour.
case $SH in dash|mksh) exit 1 ;; esac

tmp="$(basename $SH)-$$.txt"  # unique name for shell and test case

stdout_stderr.py >&$tmp

# order is indeterminate
grep STDOUT $tmp
grep STDERR $tmp
---
(case (word "$SH") (pattern ((word "dash") (word "mksh")) (command (word "exit") (word "1"))))
(command (word "tmp=\"$(basename $SH)-$$.txt\""))
(command (word "stdout_stderr.py") (redirect ">&" "$tmp"))
(command (word "grep") (word "STDOUT") (word "$tmp"))
(command (word "grep") (word "STDERR") (word "$tmp"))
---

=== 1>&- to close file descriptor
exec 5> "$TMP/f.txt"
echo hello >&5
exec 5>&-
echo world >&5
cat "$TMP/f.txt"
---
(command (word "exec") (redirect ">" ""$TMP/f.txt""))
(command (word "echo") (word "hello") (redirect ">&" 5))
(command (word "exec") (redirect ">&-" 0))
(command (word "echo") (word "world") (redirect ">&" 5))
(command (word "cat") (word "\"$TMP/f.txt\""))
---

=== 1>&2- to move file descriptor
exec 5> "$TMP/f.txt"
echo hello5 >&5
exec 6>&5-
echo world5 >&5
echo world6 >&6
exec 6>&-
cat "$TMP/f.txt"
---
(command (word "exec") (redirect ">" ""$TMP/f.txt""))
(command (word "echo") (word "hello5") (redirect ">&" 5))
(command (word "exec") (redirect ">&" 5))
(command (word "echo") (word "world5") (redirect ">&" 5))
(command (word "echo") (word "world6") (redirect ">&" 6))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "\"$TMP/f.txt\""))
---

=== 1>&2- (Bash bug: fail to restore closed fd)
# 7/2021: descriptor 8 is open on Github Actions, so use descriptor 6 instead

# Fix for CI systems where process state isn't clean: Close descriptors 6 and 7.
exec 6>&- 7>&-

opened=$(ls /proc/$$/fd)
if echo "$opened" | egrep '^7$'; then
  echo "FD 7 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi
if echo "$opened" | egrep '^6$'; then
  echo "FD 6 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi

exec 7> "$TMP/f.txt"
: 6>&7 7>&-
echo hello >&7
: 6>&7-
echo world >&7
exec 7>&-
cat "$TMP/f.txt"
---
(command (word "exec") (redirect ">&-" 0) (redirect ">&-" 0))
(command (word "opened=$(ls /proc/$$/fd)"))
(if (pipe (command (word "echo") (word "\"$opened\"")) (command (word "egrep") (word "'^7$'"))) (semi (semi (command (word "echo") (word "\"FD 7 shouldn't be open\"")) (command (word "echo") (word "\"OPENED:\""))) (command (word "echo") (word "\"$opened\""))))
(if (pipe (command (word "echo") (word "\"$opened\"")) (command (word "egrep") (word "'^6$'"))) (semi (semi (command (word "echo") (word "\"FD 6 shouldn't be open\"")) (command (word "echo") (word "\"OPENED:\""))) (command (word "echo") (word "\"$opened\""))))
(command (word "exec") (redirect ">" ""$TMP/f.txt""))
(command (word ":") (redirect ">&" 7) (redirect ">&-" 0))
(command (word "echo") (word "hello") (redirect ">&" 7))
(command (word ":") (redirect ">&" 7))
(command (word "echo") (word "world") (redirect ">&" 7))
(command (word "exec") (redirect ">&-" 0))
(command (word "cat") (word "\"$TMP/f.txt\""))
---

=== <> for read/write
echo first >$TMP/rw.txt
exec 8<>$TMP/rw.txt
read line <&8
echo line=$line
echo second 1>&8
echo CONTENTS
cat $TMP/rw.txt
---
(command (word "echo") (word "first") (redirect ">" "$TMP/rw.txt"))
(command (word "exec") (redirect "<>" "$TMP/rw.txt"))
(command (word "read") (word "line") (redirect "<&" 8))
(command (word "echo") (word "line=$line"))
(command (word "echo") (word "second") (redirect ">&" 8))
(command (word "echo") (word "CONTENTS"))
(command (word "cat") (word "$TMP/rw.txt"))
---

=== <> for read/write named pipes
rm -f "$TMP/f.pipe"
mkfifo "$TMP/f.pipe"
exec 8<> "$TMP/f.pipe"
echo first >&8
echo second >&8
read line1 <&8
read line2 <&8
exec 8<&-
echo line1=$line1 line2=$line2
---
(command (word "rm") (word "-f") (word "\"$TMP/f.pipe\""))
(command (word "mkfifo") (word "\"$TMP/f.pipe\""))
(command (word "exec") (redirect "<>" ""$TMP/f.pipe""))
(command (word "echo") (word "first") (redirect ">&" 8))
(command (word "echo") (word "second") (redirect ">&" 8))
(command (word "read") (word "line1") (redirect "<&" 8))
(command (word "read") (word "line2") (redirect "<&" 8))
(command (word "exec") (redirect ">&-" 0))
(command (word "echo") (word "line1=$line1") (word "line2=$line2"))
---

=== &>> appends stdout and stderr
# Fix for flaky tests: dash behaves non-deterministically under load!  It
# doesn't implement the behavior anyway so I don't care why.
case $SH in
  *dash)
    exit 1
    ;;
esac

echo "ok" > $TMP/f.txt
stdout_stderr.py &>> $TMP/f.txt
grep ok $TMP/f.txt >/dev/null && echo 'ok'
grep STDOUT $TMP/f.txt >/dev/null && echo 'ok'
grep STDERR $TMP/f.txt >/dev/null && echo 'ok'
---
(case (word "$SH") (pattern ((word "*dash")) (command (word "exit") (word "1"))))
(command (word "echo") (word "\"ok\"") (redirect ">" "$TMP/f.txt"))
(command (word "stdout_stderr.py") (redirect "&>>" "$TMP/f.txt"))
(and (command (word "grep") (word "ok") (word "$TMP/f.txt") (redirect ">" "/dev/null")) (command (word "echo") (word "'ok'")))
(and (command (word "grep") (word "STDOUT") (word "$TMP/f.txt") (redirect ">" "/dev/null")) (command (word "echo") (word "'ok'")))
(and (command (word "grep") (word "STDERR") (word "$TMP/f.txt") (redirect ">" "/dev/null")) (command (word "echo") (word "'ok'")))
---

=== exec redirect then various builtins
exec 5>$TMP/log.txt
echo hi >&5
set -o >&5
echo done
---
(command (word "exec") (redirect ">" "$TMP/log.txt"))
(command (word "echo") (word "hi") (redirect ">&" 5))
(command (word "set") (word "-o") (redirect ">&" 5))
(command (word "echo") (word "done"))
---

=== can't mention big file descriptor
echo hi 9>&1
# trivia: 23 is the max descriptor for mksh
#echo hi 24>&1
echo hi 99>&1
echo hi 100>&1
---
(command (word "echo") (word "hi") (redirect ">&" 1))
(command (word "echo") (word "hi") (redirect ">&" 1))
(command (word "echo") (word "hi") (redirect ">&" 1))
---

=== : >/dev/null 2> / (OSH regression: fail to pop fd frame)
# oil 0.8.pre4 fails to restore fds after redirection failure. In the
# following case, the fd frame remains after the redirection failure
# "2> /" so that the effect of redirection ">/dev/null" remains after
# the completion of the command.
: >/dev/null 2> /
echo hello
---
(command (word ":") (redirect ">" "/dev/null") (redirect ">" "/"))
(command (word "echo") (word "hello"))
---

=== echo foo >&100 (OSH regression: does not fail with invalid fd 100)
# oil 0.8.pre4 does not fail with non-existent fd 100.
fd=100
echo foo53 >&$fd
---
(command (word "fd=100"))
(command (word "echo") (word "foo53") (redirect ">&" "$fd"))
---

=== echo foo >&N where N is first unused fd
# 1. prepare default fd for internal uses
minfd=10
case ${SH##*/} in
(mksh) minfd=24 ;;
(osh) minfd=100 ;;
esac

# 2. prepare first unused fd
fd=$minfd
is_fd_open() { : >&$1; }
while is_fd_open "$fd"; do
  : $((fd+=1))

  # OLD: prevent infinite loop for broken oils-for-unix
  #if test $fd -gt 1000; then
  #  break
  #fi
done

# 3. test
echo foo54 >&$fd
---
(command (word "minfd=10"))
(case (word "${SH##*/}") (pattern ((word "mksh")) (command (word "minfd=24"))) (pattern ((word "osh")) (command (word "minfd=100"))))
(command (word "fd=$minfd"))
(function "is_fd_open" (brace-group (command (word ":") (redirect ">&" "$1"))))
(while (command (word "is_fd_open") (word "\"$fd\"")) (command (word ":") (word "$((fd+=1))")))
(command (word "echo") (word "foo54") (redirect ">&" "$fd"))
---

=== exec {fd}>&- (OSH regression: fails to close fd)
# mksh, dash do not implement {fd} redirections.
case $SH in mksh|dash) exit 1 ;; esac
# oil 0.8.pre4 fails to close fd by {fd}&-.
exec {fd}>file1
echo foo55 >&$fd
exec {fd}>&-
echo bar >&$fd
cat file1
---
(case (word "$SH") (pattern ((word "mksh") (word "dash")) (command (word "exit") (word "1"))))
(command (word "exec") (redirect ">" "file1"))
(command (word "echo") (word "foo55") (redirect ">&" "$fd"))
(command (word "exec") (redirect ">&-" 0))
(command (word "echo") (word "bar") (redirect ">&" "$fd"))
(command (word "cat") (word "file1"))
---

=== noclobber can still write to non-regular files like /dev/null
set -C  # noclobber
set -e  # errexit (raise any redirection errors)

# Each redirect to /dev/null should succeed
echo a  >  /dev/null  # trunc, write stdout
echo a &>  /dev/null  # trunc, write stdout and stderr
echo a  >> /dev/null  # append, write stdout
echo a &>> /dev/null  # append, write stdout and stderr
echo a  >| /dev/null  # ignore noclobber, trunc, write stdout
---
(command (word "set") (word "-C"))
(command (word "set") (word "-e"))
(command (word "echo") (word "a") (redirect ">" "/dev/null"))
(command (word "echo") (word "a") (redirect "&>" "/dev/null"))
(command (word "echo") (word "a") (redirect ">>" "/dev/null"))
(command (word "echo") (word "a") (redirect "&>>" "/dev/null"))
(command (word "echo") (word "a") (redirect ">|" "/dev/null"))
---

=== Parsing of x=1> and related cases
echo x=1>/dev/stdout
echo x=1 >/dev/stdout
echo x= 1>/dev/stdout

echo +1>/dev/stdout
echo +1 >/dev/stdout
echo + 1>/dev/stdout

echo a1>/dev/stdout
---
(command (word "echo") (word "x=1") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "x=1") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "x=") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "+1") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "+1") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "+") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "a1") (redirect ">" "/dev/stdout"))
---

=== Parsing of x={myvar} and related cases
case $SH in dash) exit ;; esac

echo {myvar}>/dev/stdout
# Bash chooses fds starting with 10 here, osh with 100, and there can already
# be some open fds, so compare further fds against this one
starting_fd=$myvar

echo x={myvar}>/dev/stdout
echo $((myvar-starting_fd))
echo x={myvar} >/dev/stdout
echo $((myvar-starting_fd))
echo x= {myvar}>/dev/stdout
echo $((myvar-starting_fd))

echo +{myvar}>/dev/stdout
echo $((myvar-starting_fd))
echo +{myvar} >/dev/stdout
echo $((myvar-starting_fd))
echo + {myvar}>/dev/stdout
echo $((myvar-starting_fd))
---
(case (word "$SH") (pattern ((word "dash")) (command (word "exit"))))
(command (word "echo") (redirect ">" "/dev/stdout"))
(command (word "starting_fd=$myvar"))
(command (word "echo") (word "x={myvar}") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
(command (word "echo") (word "x={myvar}") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
(command (word "echo") (word "x=") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
(command (word "echo") (word "+{myvar}") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
(command (word "echo") (word "+{myvar}") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
(command (word "echo") (word "+") (redirect ">" "/dev/stdout"))
(command (word "echo") (word "$((myvar-starting_fd))"))
---

=== xtrace not affected by redirects
set -x
printf 'aaaa' > /dev/null 2> test_osh
set +x
cat test_osh
---
(command (word "set") (word "-x"))
(command (word "printf") (word "'aaaa'") (redirect ">" "/dev/null") (redirect ">" "test_osh"))
(command (word "set") (word "+x"))
(command (word "cat") (word "test_osh"))
---
