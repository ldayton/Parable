================================================================================
arith-context.test.sh: Multiple right brackets inside expression
================================================================================


a=(1 2 3)
echo ${a[a[0]]} ${a[a[a[0]]]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Slicing of string with constants
================================================================================

s='abcd'
echo ${s:0} ${s:0:4} ${s:1:1}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Slicing of string with variables
================================================================================

s='abcd'
zero=0
one=1
echo ${s:$zero} ${s:$zero:4} ${s:$one:$one}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Array index on LHS of assignment
================================================================================

a=(1 2 3)
zero=0
a[zero+5-4]=X
echo ${a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Array index on LHS with indices
================================================================================

a=(1 2 3)
a[a[1]]=X
echo ${a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Slicing of string with expressions
================================================================================

# mksh accepts ${s:0} and ${s:$zero} but not ${s:zero}
# zsh says unrecognized modifier 'z'
s='abcd'
zero=0
echo ${s:zero} ${s:zero+0} ${s:zero+1:zero+1}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Ambiguous colon in slice
================================================================================

s='abcd'
echo $(( 0 < 1 ? 2 : 0 ))  # evaluates to 2
echo ${s: 0 < 1 ? 2 : 0 : 1}  # 2:1 -- TRICKY THREE COLONS

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Triple parens should be disambiguated
================================================================================

# The first paren is part of the math, parens 2 and 3 are a single token ending
# arith sub.
((a=1 + (2*3)))
echo $a $((1 + (2*3)))

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Quadruple parens should be disambiguated
================================================================================

((a=1 + (2 * (3+4))))
echo $a $((1 + (2 * (3+4))))

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: $[ is a synonym for $((
================================================================================

echo $[1+2] $[3 * 4]

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: $[$var is a synonym for $(($var (#2426)
================================================================================

var=1
echo $[$var+2]

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: $[$undefined] is a synonym for $(($undefined (#2566)
================================================================================

a[0]=$[1+3]
b[0]=$[b[0]]
c[0]=$[b[0]]
echo ${c[0]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Empty expression (( ))  $(( ))
================================================================================


(( ))
echo status=$?

echo $(( ))

#echo $[]

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Empty expression for (( ))
================================================================================


for (( ; ; )); do
  echo one
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Empty expression in ${a[@]: : }
================================================================================


a=(a b c d e f)

# space required here -- see spec/var-op-slice
echo slice ${a[@]: }
echo status=$?
echo

echo slice ${a[@]: : }
echo status=$?
echo

# zsh doesn't accept this
echo slice ${a[@]:: }
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith-context.test.sh: Empty expression a[]
================================================================================


a=(1 2 3)

a[]=42
echo status=$?
echo ${a[@]}

echo ${a[]}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith-dynamic.test.sh: Double quotes
================================================================================

echo $(( "1 + 2" * 3 ))
echo $(( "1+2" * 3 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith-dynamic.test.sh: Single quotes
================================================================================

echo $(( '1' + '2' * 3 ))
echo status=$?

echo $(( '1 + 2' * 3 ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith-dynamic.test.sh: Substitutions
================================================================================

x='1 + 2'
echo $(( $x * 3 ))
echo $(( "$x" * 3 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith-dynamic.test.sh: Variable references
================================================================================

x='1'
echo $(( x + 2 * 3 ))
echo status=$?

# Expression like values are evaluated first (this is unlike double quotes)
x='1 + 2'
echo $(( x * 3 ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Side Effect in Array Indexing
================================================================================

a=(4 5 6)
echo "${a[b=2]} b=$b"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Add one to var
================================================================================

i=1
echo $(($i+1))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: $ is optional
================================================================================

i=1
echo $((i+1))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: SimpleVarSub within arith
================================================================================

j=0
echo $(($j + 42))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: BracedVarSub within ArithSub
================================================================================

echo $((${j:-5} + 1))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Arith word part
================================================================================

foo=1; echo $((foo+1))bar$(($foo+1))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Arith sub with word parts
================================================================================

# Making 13 from two different kinds of sub.  Geez.
echo $((1 + $(echo 1)${undefined:-3}))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Constant with quotes like '1'
================================================================================

# NOTE: Compare with [[.  That is a COMMAND level expression, while this is a
# WORD level expression.
echo $(('1' + 2))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Arith sub within arith sub
================================================================================

# This is unnecessary but works in all shells.
echo $((1 + $((2 + 3)) + 4))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Backticks within arith sub
================================================================================

# This is unnecessary but works in all shells.
echo $((`echo 1` + 2))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid string to int
================================================================================

# bash, mksh, and zsh all treat strings that don't look like numbers as zero.
shopt -u strict_arith || true
s=foo
echo $((s+5))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid string to int with strict_arith
================================================================================

shopt -s strict_arith || true
s=foo
echo $s
echo $((s+5))
echo 'should not get here'

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Integer constant parsing
================================================================================

echo $(( 0x12A ))
echo $(( 0x0A ))
echo $(( 0777 ))
echo $(( 0010 ))
echo $(( 24#ag7 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Integer constant validation
================================================================================

check() {
  $SH -c "shopt --set strict_arith; echo $1"
  echo status=$?
}

check '$(( 0x1X ))'
check '$(( 09 ))'
check '$(( 2#A ))'
check '$(( 02#0110 ))'

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Newline in the middle of expression
================================================================================

echo $((1
+ 2))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Ternary operator
================================================================================

a=1
b=2
echo $((a>b?5:10))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Preincrement
================================================================================

a=4
echo $((++a))
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Postincrement
================================================================================

a=4
echo $((a++))
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Increment undefined variables
================================================================================

shopt -u strict_arith || true
(( undef1++ ))
(( ++undef2 ))
echo "[$undef1][$undef2]"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Increment and decrement array elements
================================================================================

shopt -u strict_arith || true
a=(5 6 7 8)
(( a[0]++, ++a[1], a[2]--, --a[3] ))
(( undef[0]++, ++undef[1], undef[2]--, --undef[3] ))
echo "${a[@]}" - "${undef[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Increment undefined variables with nounset
================================================================================

set -o nounset
(( undef1++ ))
(( ++undef2 ))
echo "[$undef1][$undef2]"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Comma operator (borrowed from C)
================================================================================

a=1
b=2
echo $((a,(b+1)))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Augmented assignment
================================================================================

a=4
echo $((a+=1))
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Comparison Ops
================================================================================

echo $(( 1 == 1 ))
echo $(( 1 != 1 ))
echo $(( 1 < 1 ))
echo $(( 1 <= 1 ))
echo $(( 1 > 1 ))
echo $(( 1 >= 1 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Logical Ops
================================================================================

echo $((1 || 2))
echo $((1 && 2))
echo $((!(1 || 2)))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Logical Ops Short Circuit
================================================================================

x=11
(( 1 || (x = 22) ))
echo $x
(( 0 || (x = 33) ))
echo $x
(( 0 && (x = 44) ))
echo $x
(( 1 && (x = 55) ))
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Bitwise ops
================================================================================

echo $((1|2))
echo $((1&2))
echo $((1^2))
echo $((~(1|2)))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Unary minus and plus
================================================================================

a=1
b=3
echo $((- a + + b))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: No floating point
================================================================================

echo $((1 + 2.3))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Array indexing in arith
================================================================================

# zsh does 1-based indexing!
array=(1 2 3 4)
echo $((array[1] + array[2]*3))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Constants in base 36
================================================================================

echo $((36#a))-$((36#z))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Constants in bases 2 to 64
================================================================================

# This is a truly bizarre syntax.  Oh it comes from zsh... which allows 36.
echo $((64#a))-$((64#z)), $((64#A))-$((64#Z)), $((64#@)), $(( 64#_ ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Multiple digit constants with base N
================================================================================

echo $((10#0123)), $((16#1b))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic base constants
================================================================================

base=16
echo $(( ${base}#a ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Octal constant
================================================================================

echo $(( 011 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic octal constant
================================================================================

zero=0
echo $(( ${zero}11 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic hex constants
================================================================================

zero=0
echo $(( ${zero}xAB ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Hex constant with capital X
================================================================================

echo $(( 0XAA ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic var names - result of runtime parse/eval
================================================================================

foo=5
x=oo
echo $(( foo + f$x + 1 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Recursive name evaluation is a result of runtime parse/eval
================================================================================

foo=5
bar=foo
spam=bar
eggs=spam
echo $((foo+1)) $((bar+1)) $((spam+1)) $((eggs+1))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: nounset with arithmetic
================================================================================

set -o nounset
x=$(( y + 5 ))
echo "should not get here: x=${x:-<unset>}"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: 64-bit integer doesn't overflow
================================================================================


a=$(( 1 << 31 ))
echo $a

b=$(( a + a ))
echo $b

c=$(( b + a ))
echo $c

x=$(( 1 << 62 ))
y=$(( x - 1 ))
echo "max positive = $(( x + y ))"

#echo "overflow $(( x + x ))"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: More 64-bit ops
================================================================================

case $SH in dash) exit ;; esac

#shopt -s strict_arith

# This overflows - the extra 9 puts it above 2**31
#echo $(( 12345678909 ))

[[ 12345678909 = $(( 1 << 30 )) ]]
echo eq=$?
[[ 12345678909 = 12345678909 ]]
echo eq=$?

# Try both [ and [[
[ 12345678909 -gt $(( 1 << 30 )) ]
echo greater=$?
[[ 12345678909 -gt $(( 1 << 30 )) ]]
echo greater=$?

[[ 12345678909 -ge $(( 1 << 30 )) ]]
echo ge=$?
[[ 12345678909 -ge 12345678909 ]]
echo ge=$?

[[ 12345678909 -le $(( 1 << 30 )) ]]
echo le=$?
[[ 12345678909 -le 12345678909 ]]
echo le=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid LValue
================================================================================

a=9
(( (a + 2) = 3 ))
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid LValue that looks like array
================================================================================

(( 1[2] = 3 ))
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid LValue: two sets of brackets
================================================================================

(( a[1][2] = 3 ))
echo "status=$?"
#   shells treat this as a NON-fatal error

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Operator Precedence
================================================================================

echo $(( 1 + 2*3 - 8/2 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Exponentiation with **
================================================================================

echo $(( 3 ** 0 ))
echo $(( 3 ** 1 ))
echo $(( 3 ** 2 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Exponentiation operator has buggy precedence
================================================================================

# NOTE: All shells agree on this, but R and Python give -9, which is more
# mathematically correct.
echo $(( -3 ** 2 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Negative exponent
================================================================================

# bash explicitly disallows negative exponents!
echo $(( 2**-1 * 5 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Comment not allowed in the middle of multiline arithmetic
================================================================================

echo $((
1 +
2 + \
3
))
echo $((
1 + 2  # not a comment
))
(( a = 3 + 4  # comment
))
echo [$a]

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Add integer to indexed array (a[0] decay)
================================================================================

declare -a array=(1 2 3)
echo $((array + 5))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Add integer to associative array (a[0] decay)
================================================================================

typeset -A assoc
assoc[0]=42
echo $((assoc + 5))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Double subscript
================================================================================

a=(1 2 3)
echo $(( a[1] ))
echo $(( a[1][1] ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: result of ArithSub -- array[0] decay
================================================================================

a=(4 5 6)
echo declared
b=$(( a ))
echo $b

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: result of ArithSub -- assoc[0] decay
================================================================================

declare -A A=(['foo']=bar ['spam']=eggs)
echo declared
b=$(( A ))
echo $b

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: comma operator
================================================================================

a=(4 5 6)

# zsh and osh can't evaluate the array like that
# which is consistent with their behavior on $(( a ))

echo $(( a, last = a[2], 42 ))
echo last=$last

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: assignment with dynamic var name
================================================================================

foo=bar
echo $(( x$foo = 42 ))
echo xbar=$xbar

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: array assignment with dynamic array name
================================================================================

foo=bar
echo $(( x$foo[5] = 42 ))
echo 'xbar[5]='${xbar[5]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: unary assignment with dynamic var name
================================================================================

foo=bar
xbar=42
echo $(( x$foo++ ))
echo xbar=$xbar

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: unary array assignment with dynamic var name
================================================================================

foo=bar
xbar[5]=42
echo $(( x$foo[5]++ ))
echo 'xbar[5]='${xbar[5]}

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic parsing of arithmetic
================================================================================

e=1+2
echo $(( e + 3 ))
[[ e -eq 3 ]] && echo true
[ e -eq 3 ]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Dynamic parsing on empty string
================================================================================

a=''
echo $(( a ))

a2=' '
echo $(( a2 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: nested ternary (bug fix)
================================================================================

echo $((1?2?3:4:5))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: 1 ? a=1 : b=2 ( bug fix)
================================================================================

echo $((1 ? a=1 : 42 ))
echo a=$a

# this does NOT work
#echo $((1 ? a=1 : b=2 ))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Invalid constant
================================================================================


echo $((a + x42))
echo status=$?

# weird asymmetry -- the above is a syntax error, but this isn't
$SH -c 'echo $((a + 42x))'
echo status=$?

# regression
echo $((a + 42x))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Negative numbers with integer division /
================================================================================


echo $(( 10 / 3))
echo $((-10 / 3))
echo $(( 10 / -3))
echo $((-10 / -3))

echo ---

a=20
: $(( a /= 3 ))
echo $a

a=-20
: $(( a /= 3 ))
echo $a

a=20
: $(( a /= -3 ))
echo $a

a=-20
: $(( a /= -3 ))
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Negative numbers with %
================================================================================


echo $(( 10 % 3))
echo $((-10 % 3))
echo $(( 10 % -3))
echo $((-10 % -3))

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: Negative numbers with bit shift
================================================================================


echo $(( 5 << 1 ))
echo $(( 5 << 0 ))
$SH -c 'echo $(( 5 << -1 ))'  # implementation defined - OSH fails
echo ---

echo $(( 16 >> 1 ))
echo $(( 16 >> 0 ))
$SH -c 'echo $(( 16 >> -1 ))'  # not sure why this is zero
$SH -c 'echo $(( 16 >> -2 ))'  # also 0
echo ---

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: undef[0]
================================================================================

case $SH in dash) exit ;; esac

echo ARITH $(( undef[0] ))
echo status=$?
echo

(( undef[0] ))
echo status=$?
echo

echo UNDEF ${undef[0]}
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: undef[0] with nounset
================================================================================

case $SH in dash) exit ;; esac

set -o nounset
echo UNSET $(( undef[0] ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: s[0] with string abc
================================================================================

case $SH in dash) exit ;; esac

s='abc'
echo abc $(( s[0] )) $(( s[1] ))
echo status=$?
echo

(( s[0] ))
echo status=$?
echo

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: s[0] with string 42
================================================================================

case $SH in dash) exit ;; esac

s='42'
echo 42 $(( s[0] )) $(( s[1] ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
arith.test.sh: s[0] with string '12 34'
================================================================================


s='12 34'
echo '12 34' $(( s[0] )) $(( s[1] ))
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Indexed LHS without spaces, and +=
================================================================================

a[1]=x
echo status=$?
argv.py "${a[@]}"

a[0+2]=y
#a[2|3]=y  # zsh doesn't allow this
argv.py "${a[@]}"

# += does appending
a[0+2]+=z
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Indexed LHS with spaces
================================================================================

case $SH in zsh|ash) exit ;; esac

a[1 * 1]=x
a[ 1 + 2 ]=z
echo status=$?

argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Nested a[i[0]]=0
================================================================================

case $SH in zsh|ash) exit ;; esac

i=(0 1 2)

a[i[0]]=0
a[ i[1] ]=1
a[ i[2] ]=2
a[ i[1]+i[2] ]=3

argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Multiple LHS array words
================================================================================

case $SH in zsh|ash) exit ;; esac

a=(0 1 2)
b=(3 4 5)

#declare -p a b

HOME=/home/spec-test

# empty string, and tilde sub
a[0 + 1]=  b[2 + 0]=~/src

typeset -p a b

echo ---

# In bash, this bad prefix binding prints an error, but nothing fails
a[0 + 1]='foo' argv.py b[2 + 0]='bar'
echo status=$?

typeset -p a b

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: LHS array is protected with shopt -s eval_unsafe_arith, e.g. 'a[$(echo 2)]'
================================================================================

case $SH in zsh|ash) exit ;; esac

a=(0 1 2)
b=(3 4 5)
typeset -p b

expr='a[$(echo 2)]' 

echo 'get' "${b[expr]}"

b[expr]=zzz

echo 'set' "${b[expr]}"
typeset -p b

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: file named a[ is  not executed
================================================================================

case $SH in zsh|ash) exit ;; esac

PATH=".:$PATH"

for name in 'a[' 'a[5'; do
  echo "echo hi from $name: \$# args: \$@" > "$name"
  chmod +x "$name"
done

# this does not executed a[5
a[5 + 1]=
a[5 / 1]=y
echo len=${#a[@]}

# Not detected as assignment because there's a non-arith character
# bash and mksh both give a syntax error
a[5 # 1]=

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: More fragments like a[  a[5  a[5 +  a[5 + 3]
================================================================================


for name in 'a[' 'a[5'; do
  echo "echo hi from $name: \$# args: \$@" > "$name"
  chmod +x "$name"
done

# syntax error in bash
$SH -c 'a['
echo "a[ status=$?"

$SH -c 'a[5'
echo "a[5 status=$?"

# 1 arg +
$SH -c 'a[5 +'
echo "a[5 + status=$?"

# 2 args
$SH -c 'a[5 + 3]'
echo "a[5 + 3] status=$?"

$SH -c 'a[5 + 3]='
echo "a[5 + 3]= status=$?"

$SH -c 'a[5 + 3]+'
echo "a[5 + 3]+ status=$?"

$SH -c 'a[5 + 3]+='
echo "a[5 + 3]+= status=$?"

# mksh doesn't issue extra parse errors
# and it doesn't turn a[5 + 3] and a[5 + 3]+ into commands!

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Are quotes allowed?
================================================================================


# double quotes allowed in bash
a["1"]=2
echo status=$? len=${#a[@]}

a['2']=3
echo status=$? len=${#a[@]}

# allowed in bash
a[2 + "3"]=5
echo status=$? len=${#a[@]}

a[3 + '4']=5
echo status=$? len=${#a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: Tricky parsing - a[ a[0]=1 ]=X  a[ a[0]+=1 ]+=X
================================================================================

case $SH in zsh|mksh|ash) exit ;; esac

# the nested [] means we can't use regular language lookahead?

echo assign=$(( z[0] = 42 ))

a[a[0]=1]=X
declare -p a

a[ a[2]=3 ]=Y
declare -p a

echo ---

a[ a[0]+=1 ]+=X
declare -p a

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: argv.py a[1 + 2]=
================================================================================

case $SH in zsh|ash) exit ;; esac

# This tests that the worse parser doesn't unconditinoally treat a[ as special

a[1 + 2]= argv.py a[1 + 2]=
echo status=$?

a[1 + 2]+= argv.py a[1 + 2]+=
echo status=$?

argv.py a[3 + 4]=

argv.py a[3 + 4]+=

--------------------------------------------------------------------------------

(program)

================================================================================
array-assign.test.sh: declare builtin doesn't allow spaces
================================================================================

case $SH in zsh|mksh|ash) exit ;; esac

# OSH doesn't allow this
declare a[a[0]=1]=X
declare -p a

# neither bash nor OSH allow this
declare a[ a[2]=3 ]=Y
declare -p a

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Literal syntax ([x]=y)
================================================================================

declare -A a
a=([aa]=b [foo]=bar ['a+1']=c)
echo ${a["aa"]}
echo ${a["foo"]}
echo ${a["a+1"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: set associative array to indexed array literal (very surprising bash behavior)
================================================================================

declare -A assoc=([k1]=foo [k2]='spam eggs')
declare -p assoc

# Bash 5.1 assoc=(key value). Bash 5.0 (including the currently tested 4.4)
# does not implement this.

assoc=(foo 'spam eggs')
declare -p assoc

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Can initialize assoc array with the "(key value ...)" sequence
================================================================================

declare -A A=(1 2 3)
echo status=$?
declare -p A

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: create empty assoc array, put, then get
================================================================================

declare -A A  # still undefined
argv.py "${A[@]}"
argv.py "${!A[@]}"
A['foo']=bar
echo ${A['foo']}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Empty value (doesn't use EmptyWord?)
================================================================================

declare -A A=(["k"]= )
argv.py "${A["k"]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: retrieve keys with !
================================================================================

declare -A a
var='x'
a["$var"]=b
a['foo']=bar
a['a+1']=c
for key in "${!a[@]}"; do
  echo $key
done | sort

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: retrieve values with ${A[@]}
================================================================================

declare -A A
var='x'
A["$var"]=b
A['foo']=bar
A['a+1']=c
for val in "${A[@]}"; do
  echo $val
done | sort

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: coerce to string with ${A[*]}, etc.
================================================================================

declare -A A
A['X X']=xx
A['Y Y']=yy
argv.py "${A[*]}"
argv.py "${!A[*]}"

argv.py ${A[@]}
argv.py ${!A[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: ${A[@]/b/B}
================================================================================

# but ${!A[@]/b/B} doesn't work
declare -A A
A['aa']=bbb
A['bb']=ccc
A['cc']=ddd
for val in "${A[@]//b/B}"; do
  echo $val
done | sort

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: ${A[@]#prefix}
================================================================================

declare -A A
A['aa']=one
A['bb']=two
A['cc']=three
for val in "${A[@]#t}"; do
  echo $val
done | sort

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: ${assoc} is like ${assoc[0]}
================================================================================

declare -A a

a=([aa]=b [foo]=bar ['a+1']=c)
echo a="${a}"

a=([0]=zzz)
echo a="${a}"

a=(['0']=yyy)
echo a="${a}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: length ${#a[@]}
================================================================================

declare -A a
a["x"]=1
a["y"]=2
a["z"]=3
echo "${#a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: lookup with ${a[0]} -- "0" is a string
================================================================================

declare -A a
a["0"]=a
a["1"]=b
a["2"]=c
echo 0 "${a[0]}" 1 "${a[1]}" 2 "${a[2]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: lookup with double quoted strings "mykey"
================================================================================

declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a["aa"]}" "${a["foo"]}" "${a["a+1"]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: lookup with single quoted string
================================================================================

declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a['a+1']}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: lookup with unquoted $key and quoted "$i$i"
================================================================================

declare -A A
A["aa"]=b
A["foo"]=bar

key=foo
echo ${A[$key]}
i=a
echo ${A["$i$i"]}   # note: ${A[$i$i]} doesn't work in OSH

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: lookup by unquoted string doesn't work in OSH because it's a variable
================================================================================

declare -A a
a["aa"]=b
a["foo"]=bar
a['a+1']=c
echo "${a[a+1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: bash bug: "i+1" and i+1 are the same key
================================================================================


i=1
array=(5 6 7)
echo array[i]="${array[i]}"
echo array[i+1]="${array[i+1]}"

# arithmetic does NOT work here in bash.  These are unquoted strings!
declare -A assoc
assoc[i]=$i
assoc[i+1]=$i+1

assoc["i"]=string
assoc["i+1"]=string+1

echo assoc[i]="${assoc[i]}" 
echo assoc[i+1]="${assoc[i+1]}"

echo assoc[i]="${assoc["i"]}" 
echo assoc[i+1]="${assoc["i+1"]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Array stored in associative array gets converted to string (without strict_array)
================================================================================


array=('1 2' 3)
declare -A d
d['key']="${array[@]}"
argv.py "${d['key']}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Indexed array as key of associative array coerces to string (without shopt -s strict_array)
================================================================================


declare -a array=(1 2 3)
declare -A assoc
assoc[42]=43
assoc["${array[@]}"]=foo

echo "${assoc["${array[@]}"]}"
for entry in "${!assoc[@]}"; do
  echo $entry
done | sort

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Append to associative array value A['x']+='suffix'
================================================================================

declare -A A
A['x']='foo'
A['x']+='bar'
A['x']+='bar'
argv.py "${A["x"]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Slice of associative array doesn't make sense in bash
================================================================================

declare -A a
a[xx]=1
a[yy]=2
a[zz]=3
a[aa]=4
a[bb]=5
#argv.py ${a["xx"]}
argv.py ${a[@]: 0: 3}
argv.py ${a[@]: 1: 3}
argv.py ${a[@]: 2: 3}
argv.py ${a[@]: 3: 3}
argv.py ${a[@]: 4: 3}
argv.py ${a[@]: 5: 3}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: bash variable can have an associative array part and a string part
================================================================================


# and $assoc is equivalent to ${assoc[0]}, just like regular arrays
declare -A assoc
assoc[1]=1
assoc[2]=2
echo ${assoc[1]} ${assoc[2]} ${assoc}
assoc[0]=zero
echo ${assoc[1]} ${assoc[2]} ${assoc}
assoc=string
echo ${assoc[1]} ${assoc[2]} ${assoc}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Associative array expressions inside (( )) with keys that look like numbers
================================================================================

declare -A assoc
assoc[0]=42
(( var = ${assoc[0]} ))
echo $var
(( var = assoc[0] ))
echo $var

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: (( A[5] += 42 ))
================================================================================

declare -A A
(( A[5] = 10 ))
(( A[5] += 6 ))
echo ${A[5]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: (( A[5] += 42 )) with empty cell
================================================================================

shopt -u strict_arith  # default zero cell
declare -A A
(( A[5] += 6 ))
echo ${A[5]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: setting key to itself (from bash-bug mailing list)
================================================================================

declare -A foo
foo=(["key"]="value1")
echo ${foo["key"]}
foo=(["key"]="${foo["key"]} value2")
echo ${foo["key"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: readonly associative array can't be modified
================================================================================

declare -Ar A
A['x']=1
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: associative array and brace expansion
================================================================================

declare -A A=([k1]=v [k2]=-{a,b}-)
echo ${A["k1"]}
echo ${A["k2"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: declare -A A=() allowed
================================================================================

set -o nounset
shopt -s strict_arith || true

declare -A ASSOC=()
echo len=${#ASSOC[@]}

# Check that it really can be used like an associative array
ASSOC['k']='32'
echo len=${#ASSOC[@]}

# bash allows a variable to be an associative array AND unset, while OSH
# doesn't
set +o nounset
declare -A u
echo unset len=${#u[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: unset -v and assoc array
================================================================================

shopt -s eval_unsafe_arith || true

show-len() {
  echo len=${#assoc[@]}
}

declare -A assoc=(['K']=val)
show-len

unset -v 'assoc["K"]'
show-len

declare -A assoc=(['K']=val)
show-len
key=K
unset -v 'assoc[$key]'
show-len

declare -A assoc=(['K']=val)
show-len
unset -v 'assoc[$(echo K)]'
show-len

# ${prefix} doesn't work here, even though it does in arithmetic
#declare -A assoc=(['K']=val)
#show-len
#prefix=as
#unset -v '${prefix}soc[$key]'
#show-len

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: nameref and assoc array
================================================================================

show-values() {
  echo values: ${A[@]}
}

declare -A A=(['K']=val)
show-values

declare -n ref='A["K"]'
echo before $ref
ref='val2'
echo after $ref
show-values

echo ---

key=K
declare -n ref='A[$key]'
echo before $ref
ref='val3'
echo after $ref
show-values

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: ${!ref} and assoc array
================================================================================


show-values() {
  echo values: ${A[@]}
}

declare -A A=(['K']=val)
show-values

declare ref='A["K"]'
echo ref ${!ref}

key=K
declare ref='A[$key]'
echo ref ${!ref}

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: printf -v and assoc array
================================================================================


show-values() {
  echo values: ${assoc[@]}
}

declare -A assoc=(['K']=val)
show-values

printf -v 'assoc["K"]' '/%s/' val2
show-values

key=K
printf -v 'assoc[$key]' '/%s/' val3
show-values

# Somehow bash doesn't allow this
#prefix=as
#printf -v '${prefix}soc[$key]' '/%s/' val4
#show-values

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: bash bug: (( A["$key"] = 1 )) doesn't work
================================================================================

key='\'
declare -A A
#A["$key"]=1

# Works in both
#A["$key"]=42

# Works in bash only
#(( A[\$key] = 42 ))

(( A["$key"] = 42 ))

argv.py "${!A[@]}"
argv.py "${A[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: Implicit increment of keys
================================================================================

declare -a arr=( [30]=a b [40]=x y)
argv.py "${!arr[@]}"
argv.py "${arr[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: test -v assoc[key]
================================================================================


typeset -A assoc
assoc=([empty]='' [k]=v)

echo 'no quotes'

test -v assoc[empty]
echo empty=$?

test -v assoc[k]
echo k=$?

test -v assoc[nonexistent]
echo nonexistent=$?

echo

# Now with quotes
echo 'quotes'

test -v assoc["empty"]
echo empty=$?

test -v assoc['k']
echo k=$?

test -v assoc['nonexistent'] 
echo nonexistent=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: test -v with dynamic parsing
================================================================================


typeset -A assoc
assoc=([empty]='' [k]=v)

key=empty
test -v 'assoc[$key]'
echo empty=$?

key=k
test -v 'assoc[$key]'
echo k=$?

key=nonexistent
test -v 'assoc[$key]'
echo nonexistent=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: [[ -v assoc[key] ]]
================================================================================


typeset -A assoc
assoc=([empty]='' [k]=v)

echo 'no quotes'

[[ -v assoc[empty] ]]
echo empty=$?

[[ -v assoc[k] ]]
echo k=$?

[[ -v assoc[nonexistent] ]]
echo nonexistent=$?

echo

# Now with quotes
echo 'quotes'

[[ -v assoc["empty"] ]]
echo empty=$?

[[ -v assoc['k'] ]]
echo k=$?

[[ -v assoc['nonexistent'] ]]
echo nonexistent=$?

echo

echo 'vars'

key=empty
[[ -v assoc[$key] ]]
echo empty=$?

key=k
[[ -v assoc[$key] ]]
echo k=$?

key=nonexistent
[[ -v assoc[$key] ]]
echo nonexistent=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: [[ -v assoc[key] ]] syntax errors
================================================================================


typeset -A assoc
assoc=([empty]='' [k]=v)

[[ -v assoc[empty] ]]
echo empty=$?

[[ -v assoc[k] ]]
echo k=$?

[[ -v assoc[k]z ]]
echo typo=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: BashAssoc a+=()
================================================================================


declare -A a=([apple]=red [orange]=orange)
a+=([lemon]=yellow [banana]=yellow)
echo "apple is ${a['apple']}"
echo "orange is ${a['orange']}"
echo "lemon is ${a['lemon']}"
echo "banana is ${a['banana']}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-assoc.test.sh: BashAssoc ${a[@]@Q}
================================================================================


declare -A a=()
a['symbol1']=\'\'
a['symbol2']='"'
a['symbol3']='()<>&|'
a['symbol4']='[]*?'
echo "[${a[@]@Q}]"
echo "[${a[*]@Q}]"

--------------------------------------------------------------------------------

(program)

================================================================================
array-basic.test.sh: "${a[@]}" and "${a[*]}"
================================================================================

a=(1 '2 3')
argv.py "${a[@]}" "${a[*]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-basic.test.sh: ${a[@]} and ${a[*]}
================================================================================

a=(1 '2 3')
argv.py ${a[@]} ${a[*]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-basic.test.sh: 4 ways to interpolate empty array
================================================================================

argv.py 1 "${a[@]}" 2 ${a[@]} 3 "${a[*]}" 4 ${a[*]} 5

--------------------------------------------------------------------------------

(program)

================================================================================
array-basic.test.sh: empty array
================================================================================

empty=()
argv.py "${empty[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-basic.test.sh: Empty array with :-
================================================================================

empty=()
argv.py ${empty[@]:-not one} "${empty[@]:-not one}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: Assignment Causes Array Decay
================================================================================

set -- x y z
argv.py "[$@]"
var="[$@]"
argv.py "$var"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: Array Decay with IFS
================================================================================

IFS=x
set -- x y z
var="[$@]"
argv.py "$var"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: User arrays decay
================================================================================

declare -a a b
a=(x y z)
b="${a[@]}"  # this collapses to a string
c=("${a[@]}")  # this preserves the array
c[1]=YYY  # mutate a copy -- doesn't affect the original
argv.py "${a[@]}"
argv.py "${b}"
argv.py "${c[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: strict_array: $array is not valid in OSH, is ${array[0]} in ksh/bash
================================================================================

shopt -s strict_array

a=(1 '2 3')
echo $a

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: strict_array: ${array} is not valid in OSH, is ${array[0]} in ksh/bash
================================================================================

shopt -s strict_array

a=(1 '2 3')
echo ${a}

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: Assign to array index without initialization
================================================================================

a[5]=5
a[6]=6
echo "${a[@]}" ${#a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: a[40] grows array
================================================================================

a=(1 2 3)
a[1]=5
a[40]=30  # out of order
a[10]=20
echo "${a[@]}" "${#a[@]}"  # length is 1

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: array decays to string when comparing with [[ a = b ]]
================================================================================

a=('1 2' '3 4')
s='1 2 3 4'  # length 2, length 4
echo ${#a[@]} ${#s}
[[ "${a[@]}" = "$s" ]] && echo EQUAL

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: ++ on a whole array increments the first element (disallowed with strict_array)
================================================================================

shopt -s strict_array

a=(1 10)
(( a++ ))  # doesn't make sense
echo "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: Apply vectorized operations on ${a[*]}
================================================================================

a=('-x-' 'y-y' '-z-')

# This does the prefix stripping FIRST, and then it joins.
argv.py "${a[*]#-}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: value.BashArray internal representation - Indexed
================================================================================


case $SH in mksh) exit ;; esac

z=()
declare -a | grep z=

z+=(b c)
declare -a | grep z=

# z[5]= finds the index, or puts it in SORTED order I think
z[5]=d
declare -a | grep z=

z[1]=ZZZ
declare -a | grep z=

# Adds after last index
z+=(f g)
declare -a | grep z=

# This is the equivalent of z[0]+=mystr
z+=-mystr
declare -a | grep z=

z[1]+=-append
declare -a | grep z=

argv.py keys "${!z[@]}"  # 0 1 5 6 7
argv.py values "${z[@]}"

# can't do this conversion
declare -A z
declare -A | grep z=

echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array-compat.test.sh: value.BashArray internal representation - Assoc (ordering is a problem)
================================================================================


case $SH in mksh) exit ;; esac

declare -A A=([k]=v)
declare -A | grep A=

argv.py keys "${!A[@]}"
argv.py values "${A[@]}"

exit

# Huh this actually works, we don't support it
# Hm the order here is all messed up, in bash 5.2
A+=([k2]=v2 [0]=foo [9]=9 [9999]=9999)
declare -A | grep A=

A+=-append
declare -A | grep A=

argv.py keys "${!A[@]}"
argv.py values "${A[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: Tilde expansions in RHS of [k]=v (BashArray)
================================================================================

HOME=/home/user
a=([2]=~ [4]=~:~:~)
echo "${a[2]}"
echo "${a[4]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: Tilde expansions in RHS of [k]=v (BashAssoc)
================================================================================

# Note: bash-5.2 has a bug that the tilde doesn't expand on the right hand side
# of [key]=value.  This problem doesn't happen in bash-3.1..5.1 and bash-5.3.
HOME=/home/user
declare -A a
declare -A a=(['home']=~ ['hello']=~:~:~)
echo "${a['home']}"
echo "${a['hello']}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: index increments without [k]= (BashArray)
================================================================================

a=([100]=1 2 3 4)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([100]=1 2 3 4 [5]=a b c d)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k]=$v and [k]="$@" (BashArray)
================================================================================

i=5
v='1 2 3'
a=($v [i]=$v)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

x=(3 5 7)
a=($v [i]="${x[*]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]="${x[@]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]=${x[*]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=($v [i]=${x[@]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k]=$v and [k]="$@" (BashAssoc)
================================================================================

i=5
v='1 2 3'
declare -A a
a=([i]=$v)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

x=(3 5 7)
a=([i]="${x[*]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]="${x[@]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]=${x[*]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=([i]=${x[@]})
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: append to element (BashArray)
================================================================================

hello=100
a=([hello]=1 [hello]+=2)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a+=([hello]+=:34 [hello]+=:56)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: append to element (BashAssoc)
================================================================================

declare -A a
hello=100
a=([hello]=1 [hello]+=2)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a+=([hello]+=:34 [hello]+=:56)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: non-index forms of element (BashAssoc)
================================================================================

declare -A a
a=([j]=1 2 3 4)
echo "status=$?"
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: Evaluation order (1)
================================================================================

# RHS of [k]=v are expanded when the initializer list is instanciated.  For the
# indexed array, the array indices are evaluated when the array is modified.
i=1
a=([100+i++]=$((i++)) [200+i++]=$((i++)) [300+i++]=$((i++)))
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: Evaluation order (2)
================================================================================

# When evaluating the index, the modification to the array by the previous item
# of the initializer list is visible to the current item.
a=([0]=1+2+3 [a[0]]=10 [a[6]]=hello)
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: Evaluation order (3)
================================================================================

# RHS should be expanded before any modification to the array.
a=(old1 old2 old3)
a=("${a[2]}" "${a[0]}" "${a[1]}" "${a[2]}" "${a[0]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"
a=(old1 old2 old3)
old1=101 old2=102 old3=103
new1=201 new2=202 new3=203
a+=([0]=new1 [1]=new2 [2]=new3 [5]="${a[2]}" [a[0]]="${a[0]}" [a[1]]="${a[1]}")
printf 'keys: '; argv.py "${!a[@]}"
printf 'vals: '; argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k1]=v1 (BashArray)
================================================================================

# Note: This and next tests have originally been in "spec/assign.test.sh" and
# compared the behavior of OSH's BashAssoc and Bash's indexed array.  After
# supporting "arr=([index]=value)" for indexed arrays, the test was adjusted
# and copied here. See also the corresponding tests in "spec/assign.test.sh"
a=([k1]=v1 [k2]=v2)
echo ${a["k1"]}
echo ${a["k2"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k1]=v1 (BashAssoc)
================================================================================

declare -A a
a=([k1]=v1 [k2]=v2)
echo ${a["k1"]}
echo ${a["k2"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k1]=v1 looking like brace expansions (BashAssoc)
================================================================================

declare -A a
a=([k2]=-{a,b}-)
echo ${a["k2"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: [k1]=v1 looking like brace expansions (BashArray)
================================================================================

a=([k2]=-{a,b}-)
echo ${a["k2"]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: BashArray cannot be changed to BashAssoc and vice versa
================================================================================

declare -a a=(1 2 3 4)
eval 'declare -A a=([a]=x [b]=y [c]=z)'
echo status=$?
argv.py "${a[@]}"

declare -A A=([a]=x [b]=y [c]=z)
eval 'declare -a A=(1 2 3 4)'
echo status=$?
argv.py $(printf '%s\n' "${A[@]}" | sort)

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: (strict_array) s+=()
================================================================================

case $SH in bash) ;; *) shopt --set strict_array ;; esac

s1=hello
s2=world

# Overwriting Str with a new BashArray is allowed
eval 's1=(1 2 3 4)'
echo status=$?
declare -p s1
# Promoting Str to a BashArray is disallowed
eval 's2+=(1 2 3 4)'
echo status=$?
declare -p s2

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: (strict_array) declare -A s+=()
================================================================================

case $SH in bash) ;; *) shopt --set strict_array ;; esac

s1=hello
s2=world

# Overwriting Str with a new BashAssoc is allowed
eval 'declare -A s1=([a]=x [b]=y)'
echo status=$?
declare -p s1
# Promoting Str to a BashAssoc is disallowed
eval 'declare -A s2+=([a]=x [b]=y)'
echo status=$?
declare -p s2

--------------------------------------------------------------------------------

(program)

================================================================================
array-literal.test.sh: (strict_array) assoc=(key value ...) is not allowed
================================================================================

case $SH in bash) ;; *) shopt --set strict_array ;; esac

declare -A a=([a]=b)
eval "a=(1 2 3 4)"
declare -p a

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Performance demo
================================================================================


case $SH in bash|mksh) exit ;; esac

shopt -s ysh:upgrade

#pp test_ (a)

sp=( foo {25..27} bar )

sp[10]='sparse'

echo $[type(sp)]

echo len: "${#sp[@]}"

#echo $[len(sp)]

echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"

echo slice: "${sp[@]:2:3}"

sp[0]=set0

echo get0: "${sp[0]}"
echo get1: "${sp[1]}"
echo ---

to_append=(x y)
echo append
sp+=("${to_append[@]}")
echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"
echo ---

echo unset
unset -v 'sp[11]'
echo subst: "${sp[@]}"
echo keys: "${!sp[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: test length
================================================================================

sp=(x y z)

sp[5]=z

echo len=${#sp[@]}

sp[10]=z

echo len=${#sp[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: test "declare -p sp"
================================================================================

a0=()
a1=(1)
a2=(1 2)
a=(x y z w)
a[500]=100
a[1000]=100

case $SH in
bash|mksh)
  typeset -p a0 a1 a2 a
  exit ;;
esac

declare -p a0 a1 a2 a

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: +=
================================================================================

sp1[10]=a
sp1[20]=b
sp1[99]=c
typeset -p sp1 | sed 's/"//g'
sp1+=(1 2 3)
typeset -p sp1 | sed 's/"//g'

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: a[i]=v
================================================================================

sp1[10]=a
sp1[20]=b
sp1[30]=c
typeset -p sp1 | sed 's/"//g'
sp1[10]=X
sp1[25]=Y
sp1[90]=Z
typeset -p sp1 | sed 's/"//g'

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Negative index with a[i]=v
================================================================================

case $SH in mksh) exit ;; esac

sp1[9]=x
typeset -p sp1 | sed 's/"//g'

sp1[-1]=A
sp1[-4]=B
sp1[-8]=C
sp1[-10]=D
typeset -p sp1 | sed 's/"//g'

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: a[i]=v with BigInt
================================================================================

case $SH in mksh) exit ;; esac

sp1[1]=x
sp1[5]=y
sp1[9]=z

echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFF]=a
echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFE]=b
echo "${#sp1[@]}"
sp1[0x7FFFFFFFFFFFFFFD]=c
echo "${#sp1[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Negative out-of-bound index with a[i]=v (1/2)
================================================================================

case $SH in mksh) exit ;; esac

sp1[9]=x
sp1[-11]=E
declare -p sp1

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Negative out-of-bound index with a[i]=v (2/2)
================================================================================

case $SH in mksh) exit ;; esac

sp1[9]=x

sp1[-21]=F
declare -p sp1

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: xtrace a+=()
================================================================================

#case $SH in mksh) exit ;; esac

sp1=(1)
set -x
sp1+=(2)

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: unset -v a[i]
================================================================================

a=(1 2 3 4 5 6 7 8 9)
typeset -p a
unset -v "a[1]"
typeset -p a
unset -v "a[9]"
typeset -p a
unset -v "a[0]"
typeset -p a

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: unset -v a[i] with out-of-bound negative index
================================================================================

case $SH in mksh) exit ;; esac

a=(1)

unset -v "a[-2]"
unset -v "a[-3]"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: unset -v a[i] for max index
================================================================================

case $SH in mksh) exit ;; esac

a=({1..9})
unset -v 'a[-1]'
a[-1]=x
declare -p a
unset -v 'a[-1]'
a[-1]=x
declare -p a

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: [[ -v a[i] ]]
================================================================================

case $SH in mksh) exit ;; esac

sp1=()
[[ -v sp1[0] ]]; echo "$? (expect 1)"
[[ -v sp1[9] ]]; echo "$? (expect 1)"

sp2=({1..9})
[[ -v sp2[0] ]]; echo "$? (expect 0)"
[[ -v sp2[8] ]]; echo "$? (expect 0)"
[[ -v sp2[9] ]]; echo "$? (expect 1)"
[[ -v sp2[-1] ]]; echo "$? (expect 0)"
[[ -v sp2[-2] ]]; echo "$? (expect 0)"
[[ -v sp2[-9] ]]; echo "$? (expect 0)"

sp3=({1..9})
unset -v 'sp3[4]'
[[ -v sp3[3] ]]; echo "$? (expect 0)"
[[ -v sp3[4] ]]; echo "$? (expect 1)"
[[ -v sp3[5] ]]; echo "$? (expect 0)"
[[ -v sp3[-1] ]]; echo "$? (expect 0)"
[[ -v sp3[-4] ]]; echo "$? (expect 0)"
[[ -v sp3[-5] ]]; echo "$? (expect 1)"
[[ -v sp3[-6] ]]; echo "$? (expect 0)"
[[ -v sp3[-9] ]]; echo "$? (expect 0)"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: [[ -v a[i] ]] with invalid negative index
================================================================================

case $SH in mksh) exit ;; esac

sp1=()
([[ -v sp1[-1] ]]; echo "$? (expect 1)")
sp2=({1..9})
([[ -v sp2[-10] ]]; echo "$? (expect 1)")
sp3=({1..9})
unset -v 'sp3[4]'
([[ -v sp3[-10] ]]; echo "$? (expect 1)")

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ((sp[i])) and ((sp[i]++))
================================================================================

a=(1 2 3 4 5 6 7 8 9)
unset -v 'a[2]' 'a[3]' 'a[7]'

echo $((a[0]))
echo $((a[1]))
echo $((a[2]))
echo $((a[3]))
echo $((a[7]))

echo $((a[1]++))
echo $((a[2]++))
echo $((a[3]++))
echo $((a[7]++))

echo $((++a[1]))
echo $((++a[2]))
echo $((++a[3]))
echo $((++a[7]))

echo $((a[1] = 100, a[1]))
echo $((a[2] = 100, a[2]))
echo $((a[3] = 100, a[3]))
echo $((a[7] = 100, a[7]))

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ((sp[i])) and ((sp[i]++)) with invalid negative index
================================================================================

case $SH in mksh) exit ;; esac

a=({1..9})
unset -v 'a[2]' 'a[3]' 'a[7]'

echo $((a[-10]))

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${sp[i]}
================================================================================

case $SH in mksh) exit ;; esac

sp=({1..9})
unset -v 'sp[2]'
unset -v 'sp[3]'
unset -v 'sp[7]'

echo "sp[0]: '${sp[0]}', ${sp[0]:-(empty)}, ${sp[0]+set}."
echo "sp[1]: '${sp[1]}', ${sp[1]:-(empty)}, ${sp[1]+set}."
echo "sp[8]: '${sp[8]}', ${sp[8]:-(empty)}, ${sp[8]+set}."
echo "sp[2]: '${sp[2]}', ${sp[2]:-(empty)}, ${sp[2]+set}."
echo "sp[3]: '${sp[3]}', ${sp[3]:-(empty)}, ${sp[3]+set}."
echo "sp[7]: '${sp[7]}', ${sp[7]:-(empty)}, ${sp[7]+set}."

echo "sp[-1]: '${sp[-1]}'."
echo "sp[-2]: '${sp[-2]}'."
echo "sp[-3]: '${sp[-3]}'."
echo "sp[-4]: '${sp[-4]}'."
echo "sp[-9]: '${sp[-9]}'."

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${sp[i]} with negative invalid index
================================================================================

case $SH in mksh) exit ;; esac

sp=({1..9})
unset -v 'sp[2]'
unset -v 'sp[3]'
unset -v 'sp[7]'

echo "sp[-10]: '${sp[-10]}'."
echo "sp[-11]: '${sp[-11]}'."
echo "sp[-19]: '${sp[-19]}'."

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]:offset:length}
================================================================================

case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

echo '==== ${a[@]:offset} ===='
echo "[${a[@]:0}][${a[*]:0}]"
echo "[${a[@]:2}][${a[*]:2}]"
echo "[${a[@]:3}][${a[*]:3}]"
echo "[${a[@]:5}][${a[*]:5}]"
echo "[${a[@]:9}][${a[*]:9}]"
echo "[${a[@]:10}][${a[*]:10}]"
echo "[${a[@]:11}][${a[*]:11}]"

echo '==== ${a[@]:negative} ===='
echo "[${a[@]: -1}][${a[*]: -1}]"
echo "[${a[@]: -2}][${a[*]: -2}]"
echo "[${a[@]: -5}][${a[*]: -5}]"
echo "[${a[@]: -9}][${a[*]: -9}]"
echo "[${a[@]: -10}][${a[*]: -10}]"
echo "[${a[@]: -11}][${a[*]: -11}]"
echo "[${a[@]: -21}][${a[*]: -21}]"

echo '==== ${a[@]:offset:length} ===='
echo "[${a[@]:0:0}][${a[*]:0:0}]"
echo "[${a[@]:0:1}][${a[*]:0:1}]"
echo "[${a[@]:0:3}][${a[*]:0:3}]"
echo "[${a[@]:2:1}][${a[*]:2:1}]"
echo "[${a[@]:2:4}][${a[*]:2:4}]"
echo "[${a[@]:3:4}][${a[*]:3:4}]"
echo "[${a[@]:5:4}][${a[*]:5:4}]"
echo "[${a[@]:5:0}][${a[*]:5:0}]"
echo "[${a[@]:9:1}][${a[*]:9:1}]"
echo "[${a[@]:9:2}][${a[*]:9:2}]"
echo "[${a[@]:10:1}][${a[*]:10:1}]"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${@:offset:length}
================================================================================

case $SH in mksh) exit ;; esac

set -- v{1..9}

{
  echo '==== ${@:offset:length} ===='
  echo "[${*:0:3}][${*:0:3}]"
  echo "[${*:1:3}][${*:1:3}]"
  echo "[${*:3:3}][${*:3:3}]"
  echo "[${*:5:10}][${*:5:10}]"

  echo '==== ${@:negative} ===='
  echo "[${*: -1}][${*: -1}]"
  echo "[${*: -3}][${*: -3}]"
  echo "[${*: -9}][${*: -9}]"
  echo "[${*: -10}][${*: -10}]"
  echo "[${*: -11}][${*: -11}]"
  echo "[${*: -3:2}][${*: -3:2}]"
  echo "[${*: -9:4}][${*: -9:4}]"
  echo "[${*: -10:4}][${*: -10:4}]"
  echo "[${*: -11:4}][${*: -11:4}]"
} | sed "s:$SH:\$SH:g;s:${SH##*/}:\$SH:g"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]:BigInt}
================================================================================

case $SH in mksh) exit ;; esac

case $SH in
  bash)
    # disabled with soil-ovm-tarball image 2025-04-30b - the CI runs on Debian 12
    # now
    exit

    # Work around bash integer overflow bug that only happens on say Debian 10,
    # but NOT Debian 12.  The bug exists in bash 5.2.  It's unclear why it
    # depends on the OS version.
    v='/etc/debian_version'
    # debian version 10 / debian buster
    if test -f $v && grep -E 'buster/sid|^10' $v >/dev/null; then
      cat << 'EOF'
[x][x]
[y x][y x]
[z y x][z y x]
[z y x][z y x]
EOF
      exit
    fi
    # Actual STDOUT of buggy bash builds:
    # [][]
    # [][]
    # [][]
    # [][]
    ;;
esac

a=(1 2 3)
a[0x7FFFFFFFFFFFFFFF]=x
a[0x7FFFFFFFFFFFFFFE]=y
a[0x7FFFFFFFFFFFFFFD]=z

echo "[${a[@]: -1}][${a[*]: -1}]"
echo "[${a[@]: -2}][${a[*]: -2}]"
echo "[${a[@]: -3}][${a[*]: -3}]"
echo "[${a[@]: -4}][${a[*]: -4}]"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]}
================================================================================

a=(v{0,1,2,3,4,5,6,7,8,9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]}"
argv.py "abc${a[@]}xyz"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]#...}
================================================================================

case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]#v}"
argv.py "abc${a[@]#v}xyz"
argv.py "${a[@]%[0-5]}"
argv.py "abc${a[@]%[0-5]}xyz"
argv.py "${a[@]#v?}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]/pat/rep}
================================================================================


case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]/?}"
argv.py "${a[@]//?}"
argv.py "${a[@]/#?}"
argv.py "${a[@]/%?}"

argv.py "${a[@]/v/x}"
argv.py "${a[@]//v/x}"
argv.py "${a[@]/[0-5]/D}"
argv.py "${a[@]//[!0-5]/_}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]@P}, ${a[@]@Q}, and ${a[@]@a}
================================================================================

case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[2]' 'a[3]' 'a[4]' 'a[7]'

argv.py "${a[@]@P}"
argv.py "${a[*]@P}"
argv.py "${a[@]@Q}"
argv.py "${a[*]@Q}"
argv.py "${a[@]@a}"
argv.py "${a[*]@a}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a[@]-unset}, ${a[@]:-empty}, etc.
================================================================================

a1=()
a2=("")
a3=("" "")

echo "a1 unset: [${a1[@]-unset}]"
echo "a1 empty: [${a1[@]:-empty}]"
echo "a2 unset: [${a2[@]-unset}]"
echo "a2 empty: [${a2[@]:-empty}]"
echo "a3 unset: [${a3[@]-unset}]"
echo "a3 empty: [${a3[@]:-empty}]"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${a-}
================================================================================

a1=()
a2=("" "")
a3=(foo bar)

echo "$a1, ${a1-(unset)}, ${a1:-(empty)};"
echo "$a2, ${a2-(unset)}, ${a2:-(empty)};"
echo "$a3, ${a3-(unset)}, ${a3:-(empty)};"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${!a[0]}
================================================================================

case $SH in mksh) exit ;; esac

v1=hello v2=world
a=(v1 v2)

echo "${!a[0]}, ${!a[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: ${!a[@]}
================================================================================

case $SH in mksh) exit ;; esac

a=(v{0..9})
unset -v 'a[3]' 'a[4]' 'a[7]' 'a[9]'

argv.py "${!a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: "${a[*]}"
================================================================================

a=(v{0,1,2,3,4,5,6,7,8,9})
unset -v 'a[3]' 'a[4]' 'a[7]' 'a[9]'

echo "${a[*]}"
IFS=
echo "${a[*]}"
IFS=/
echo "${a[*]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: compgen -F _set_COMPREPLY
================================================================================

case $SH in mksh) exit ;; esac

_set_COMPREPLY() {
  COMPREPLY=({0..9})
  unset -v 'COMPREPLY[2]' 'COMPREPLY[4]' 'COMPREPLY[6]'
}

compgen -F _set_COMPREPLY

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: compadjust
================================================================================

case $SH in bash|mksh) exit ;; esac

COMP_ARGV=(echo 'Hello,' 'Bash' 'world!')
compadjust cur prev words cword
argv.py "$cur" "$prev" "$cword"
argv.py "${words[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: (YSH) @[sp] and @sp
================================================================================

case $SH in bash|mksh) exit ;; esac

a=({0..5})
unset -v 'a[1]' 'a[2]' 'a[4]'

shopt -s parse_at
argv.py @[a]
argv.py @a

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: (YSH) $[a1 === a2]
================================================================================

case $SH in bash|mksh) exit ;; esac

a1=(1 2 3)
unset -v 'a1[1]'
a2=(1 2 3)
unset -v 'a2[1]'
a3=(1 2 4)
unset -v 'a3[1]'
a4=(1 2 3)

shopt -s ysh:upgrade

echo $[a1 === a1]
echo $[a1 === a2]
echo $[a1 === a3]
echo $[a1 === a4]
echo $[a2 === a1]
echo $[a3 === a1]
echo $[a4 === a1]

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: (YSH) $[bool(a)]
================================================================================

case $SH in bash|mksh) exit ;; esac

a1=()
a2=(0)
a3=(0 1 2)
a4=(0 0)
unset -v 'a4[0]'

shopt -s ysh:upgrade

echo $[bool(a1)]
echo $[bool(a2)]
echo $[bool(a3)]
echo $[bool(a4)]

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Regression: a[-1]=1
================================================================================

case $SH in mksh) exit 99 ;; esac

a[-1]=1

--------------------------------------------------------------------------------

(program)

================================================================================
array-sparse.test.sh: Initializing indexed array with ([index]=value)
================================================================================

case $SH in mksh) exit 99 ;; esac
declare -a a=([xx]=1 [yy]=2 [zz]=3)
echo status=$?
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: nounset / set -u with empty array (bug in bash 4.3, fixed in 4.4)
================================================================================


# http://lists.gnu.org/archive/html/help-bash/2017-09/msg00005.html

set -o nounset
empty=()
argv.py "${empty[@]}"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: local array
================================================================================

# mksh support local variables, but not local arrays, oddly.
f() {
  local a=(1 '2 3')
  argv.py "${a[0]}"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Command with with word splitting in array
================================================================================

array=('1 2' $(echo '3 4'))
argv.py "${array[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: array over multiple lines
================================================================================

a=(
1
'2 3'
)
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: array with empty string
================================================================================

empty=('')
argv.py "${empty[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve index
================================================================================

a=(1 '2 3')
argv.py "${a[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve out of bounds index
================================================================================

a=(1 '2 3')
argv.py "${a[3]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Negative index
================================================================================

a=(1 '2 3')
argv.py "${a[-1]}" "${a[-2]}" "${a[-5]}"  # last one out of bounds

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Negative index and sparse array
================================================================================

a=(0 1 2 3 4)
unset a[1]
unset a[4]
echo "${a[@]}"
echo -1 ${a[-1]}
echo -2 ${a[-2]}
echo -3 ${a[-3]}
echo -4 ${a[-4]}
echo -5 ${a[-5]}

a[-1]+=0  # append 0 on the end
echo ${a[@]}
(( a[-1] += 42 ))
echo ${a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Negative index and sparse array
================================================================================

a=(0 1)
unset 'a[-1]'  # remove last element
a+=(2 3)
echo ${a[0]} $((a[0]))
echo ${a[1]} $((a[1]))
echo ${a[2]} $((a[2]))
echo ${a[3]} $((a[3]))

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Length after unset
================================================================================

a=(0 1 2 3)
unset a[-1]
echo len=${#a[@]}
unset a[-1]
echo len=${#a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve index that is a variable
================================================================================

a=(1 '2 3')
i=1
argv.py "${a[$i]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve index that is a variable without $
================================================================================

a=(1 '2 3')
i=5
argv.py "${a[i-4]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve index that is a command sub
================================================================================

a=(1 '2 3')
argv.py "${a[$(echo 1)]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve array indices with ${!a}
================================================================================

a=(1 '2 3')
argv.py "${!a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Retrieve sparse array indices with ${!a}
================================================================================

a=()
(( a[99]=1 ))
argv.py "${!a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: ${!a[1]} is named ref in bash
================================================================================

# mksh ignores it
foo=bar
a=('1 2' foo '2 3')
argv.py "${!a[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: ${!a} on array
================================================================================


# bash gives empty string because it's like a[0]
# mksh gives the name of the variable with !.  Very weird.

a=(1 '2 3')
argv.py "${!a}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: All elements unquoted
================================================================================

a=(1 '2 3')
argv.py ${a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: All elements quoted
================================================================================

a=(1 '2 3')
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: $*
================================================================================

a=(1 '2 3')
argv.py ${a[*]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: "$*"
================================================================================

a=(1 '2 3')
argv.py "${a[*]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Interpolate array into array
================================================================================

a=(1 '2 3')
a=(0 "${a[@]}" '4 5')
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Exporting array doesn't do anything, not even first element
================================================================================

# bash parses, but doesn't execute.
# mksh gives syntax error -- parses differently with 'export'
# osh no longer parses this statically.

export PYTHONPATH

PYTHONPATH=mystr  # NOTE: in bash, this doesn't work afterward!
printenv.py PYTHONPATH

PYTHONPATH=(myarray)
printenv.py PYTHONPATH

PYTHONPATH=(a b c)
printenv.py PYTHONPATH

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: strict_array prevents exporting array
================================================================================


shopt -s strict_array

export PYTHONPATH
PYTHONPATH=(a b c)
printenv.py PYTHONPATH

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Arrays can't be used as env bindings
================================================================================

# Hm bash it treats it as a string!
A=a B=(b b) printenv.py A B

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Associative arrays can't be used as env bindings either
================================================================================

A=a B=([k]=v) printenv.py A B

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Set element
================================================================================

a=(1 '2 3')
a[0]=9
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Set element with var ref
================================================================================

a=(1 '2 3')
i=0
a[$i]=9
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Set element with array ref
================================================================================

# This makes parsing a little more complex.  Anything can be inside [],
# including other [].
a=(1 '2 3')
i=(0 1)
a[${i[1]}]=9
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Set array item to array
================================================================================

a=(1 2)
a[0]=(3 4)
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Slice of array with [@]
================================================================================

# mksh doesn't support this syntax!  It's a bash extension.
a=(1 2 3)
argv.py "${a[@]:1:2}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Negative slice begin
================================================================================

# mksh doesn't support this syntax!  It's a bash extension.
# NOTE: for some reason -2) has to be in parens?  Ah that's because it
# conflicts with :-!  That's silly.  You can also add a space.
a=(1 2 3 4 5)
argv.py "${a[@]:(-4)}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Negative slice length
================================================================================

a=(1 2 3 4 5)
argv.py "${a[@]: 1: -3}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Slice with arithmetic
================================================================================

a=(1 2 3)
i=5
argv.py "${a[@]:i-4:2}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Number of elements
================================================================================

a=(1 '2 3')
echo "${#a[@]}" ${#a[@]}  # bug fix: also test without quotes

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Length of an element
================================================================================

a=(1 '2 3')
echo "${#a[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Iteration
================================================================================

a=(1 '2 3')
for v in "${a[@]}"; do
  echo $v
done

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: glob within array yields separate elements
================================================================================

touch y.Y yy.Y
a=(*.Y)
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: declare array and then append
================================================================================

declare -a array
array+=(a)
array+=(b c)
argv.py "${array[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Single array with :-
================================================================================


# 2024-06 - bash 5.2 and mksh now match, bash 4.4 differed.
# Could change OSH
# zsh agrees with OSH, but it fails most test cases
# 2025-01 We changed OSH.

single=('')
argv.py ${single[@]:-none} x "${single[@]:-none}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Stripping a whole array unquoted
================================================================================

# Problem: it joins it first.
files=('foo.c' 'sp ace.h' 'bar.c')
argv.py ${files[@]%.c}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Stripping a whole array quoted
================================================================================

files=('foo.c' 'sp ace.h' 'bar.c')
argv.py "${files[@]%.c}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Multiple subscripts not allowed
================================================================================

# NOTE: bash 4.3 had a bug where it ignored the bad subscript, but now it is
# fixed.
a=('123' '456')
argv.py "${a[0]}" "${a[0][0]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Length op, index op, then transform op is not allowed
================================================================================

a=('123' '456')
echo "${#a[0]}" "${#a[0]/1/xxx}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: ${mystr[@]} and ${mystr[*]} are no-ops
================================================================================

s='abc'
echo ${s[@]}
echo ${s[*]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: ${mystr[@]} and ${mystr[*]} disallowed with strict_array
================================================================================


$SH -c 'shopt -s strict_array; s="abc"; echo ${s[@]}'
echo status=$?

$SH -c 'shopt -s strict_array; s="abc"; echo ${s[*]}'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Create a "user" array out of the argv array
================================================================================

set -- 'a b' 'c'
array1=('x y' 'z')
array2=("$@")
argv.py "${array1[@]}" "${array2[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Tilde expansion within array
================================================================================

HOME=/home/bob
a=(~/src ~/git)
echo "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Brace Expansion within Array
================================================================================

a=(-{a,b} {c,d}-)
echo "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: array default
================================================================================

default=('1 2' '3')
argv.py "${undef[@]:-${default[@]}}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Singleton Array Copy and Assign.  OSH can't index strings with ints
================================================================================

a=( '12 3' )
b=( "${a[@]}" )
c="${a[@]}"  # This decays it to a string
d=${a[*]}  # This decays it to a string
echo ${#a[0]} ${#b[0]}
echo ${#a[@]} ${#b[@]}

# osh is intentionally stricter, and these fail.
echo ${#c[0]} ${#d[0]}
echo ${#c[@]} ${#d[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: declare -a / local -a is empty array
================================================================================

declare -a myarray
argv.py "${myarray[@]}"
myarray+=('x')
argv.py "${myarray[@]}"

f() {
  local -a myarray
  argv.py "${myarray[@]}"
  myarray+=('x')
  argv.py "${myarray[@]}"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Create sparse array
================================================================================

a=()
(( a[99]=1 )) # osh doesn't parse index assignment outside arithmetic yet
echo len=${#a[@]}
argv.py "${a[@]}"
echo "unset=${a[33]}"
echo len-of-unset=${#a[33]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Create sparse array implicitly
================================================================================

(( a[99]=1 ))
echo len=${#a[@]}
argv.py "${a[@]}"
echo "unset=${a[33]}"
echo len-of-unset=${#a[33]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Append sparse arrays
================================================================================

a=()
(( a[99]=1 ))
b=()
(( b[33]=2 ))
(( b[66]=3 ))
a+=( "${b[@]}" )
argv.py "${a[@]}"
argv.py "${a[99]}" "${a[100]}" "${a[101]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Slice of sparse array with [@]
================================================================================

# mksh doesn't support this syntax!  It's a bash extension.
(( a[33]=1 ))
(( a[66]=2 ))
(( a[99]=2 ))
argv.py "${a[@]:15:2}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Using an array itself as the index on LHS
================================================================================

shopt -u strict_arith
a[a]=42
a[a]=99
argv.py "${a[@]}" "${a[0]}" "${a[42]}" "${a[99]}"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Using an array itself as the index on RHS
================================================================================

shopt -u strict_arith
a=(1 2 3)
(( x = a[a] ))
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: a[$x$y] on LHS and RHS
================================================================================

x=1
y=2
a[$x$y]=foo

# not allowed by OSH parsing
#echo ${a[$x$y]}

echo ${a[12]}
echo ${#a[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Dynamic parsing of LHS a[$code]=value
================================================================================


declare -a array
array[x=1]='one'

code='y=2'
#code='1+2'  # doesn't work either
array[$code]='two'

argv.py "${array[@]}"
echo x=$x
echo y=$y

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Dynamic parsing of RHS ${a[$code]}
================================================================================

declare -a array
array=(zero one two three)

echo ${array[1+2]}

code='1+2'
echo ${array[$code]}

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Is element set?  test -v a[i]
================================================================================


# note: modern versions of zsh implement this

array=(1 2 3 '')

test -v 'array[1]'
echo set=$?

test -v 'array[3]'
echo empty=$?

test -v 'array[4]'
echo unset=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: [[ -v a[i] ]]
================================================================================


# note: modern versions of zsh implement this

array=(1 2 3)
[[ -v array[1] ]]
echo status=$?

[[ -v array[4] ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: test -v a[i] with arith expressions
================================================================================


array=(1 2 3 '')

test -v 'array[1+1]'
echo status=$?

test -v 'array[4+1]'
echo status=$?

echo
echo dbracket

[[ -v array[1+1] ]]
echo status=$?

[[ -v array[4+1] ]]
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: More arith expressions in [[ -v array[expr]] ]]
================================================================================


typeset -a array
array=('' nonempty)

# This feels inconsistent with the rest of bash?
zero=0

[[ -v array[zero+0] ]]
echo zero=$?

[[ -v array[zero+1] ]]
echo one=$?

[[ -v array[zero+2] ]]
echo two=$?

echo ---

i='0+0'
[[ -v array[i] ]]
echo zero=$?

i='0+1'
[[ -v array[i] ]]
echo one=$?

i='0+2'
[[ -v array[i] ]]
echo two=$?

echo ---

i='0+0'
[[ -v array[$i] ]]
echo zero=$?

i='0+1'
[[ -v array[$i] ]]
echo one=$?

i='0+2'
[[ -v array[$i] ]]
echo two=$?

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: Assigning with out-of-range negative index
================================================================================

a=()
a[-1]=1

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: Negative index in [[ -v a[index] ]]
================================================================================

a[0]=x
a[5]=y
a[10]=z
[[ -v a[-1] ]] && echo 'a has -1'
[[ -v a[-2] ]] && echo 'a has -2'
[[ -v a[-5] ]] && echo 'a has -5'
[[ -v a[-6] ]] && echo 'a has -6'
[[ -v a[-10] ]] && echo 'a has -10'
[[ -v a[-11] ]] && echo 'a has -11'

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: Negative out-of-range index in [[ -v a[index] ]]
================================================================================

e=()
[[ -v e[-1] ]] && echo 'e has -1'

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: a+=() modifies existing instance of BashArray
================================================================================

case $SH in mksh|bash) exit ;; esac

a=(1 2 3)
var b = a
a+=(4 5)
echo "a=(${a[*]})"
echo "b=(${b[*]})"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: unset a[-2]: out-of-bound negative index should cause error
================================================================================

case $SH in mksh) exit ;; esac

a=(1)
unset -v 'a[-2]'

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: Out-of-bound negative offset for ${a[@]:offset}
================================================================================

case $SH in mksh) exit ;; esac

a=(1 2 3 4)
echo "a=(${a[*]})"
echo "begin=-1 -> (${a[*]: -1})"
echo "begin=-2 -> (${a[*]: -2})"
echo "begin=-3 -> (${a[*]: -3})"
echo "begin=-4 -> (${a[*]: -4})"
echo "begin=-5 -> (${a[*]: -5})"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: Array length after unset
================================================================================

case $SH in mksh) exit ;; esac

a=(x)
a[9]=y
echo "len ${#a[@]};"

unset -v 'a[-1]'
echo "len ${#a[@]};"
echo "last ${a[@]: -1};"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: ${a[@]@Q} crash with `a[0]=x a[2]=y`
================================================================================

case $SH in mksh) exit ;; esac

a[0]=x
a[2]=y
echo "quoted = (${a[@]@Q})"

--------------------------------------------------------------------------------

(program)

================================================================================
array.test.sh: Regression: silent out-of-bound negative index in ${a[-2]} and $((a[-2]))
================================================================================

case $SH in mksh) exit ;; esac

a=(x)
echo "[${a[-2]}]"
echo $?
echo "[$((a[-2]))]"
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: typeset a[3]=4
================================================================================

typeset a[3]=4 a[5]=6
echo status=$?
argv.py "${!a[@]}" "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: typeset -a a[1]=a a[3]=c
================================================================================

# declare works the same way in bash, but not mksh.
# spaces are NOT allowed here.
typeset -a a[1*1]=x a[1+2]=z
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: local a[3]=4
================================================================================

f() {
  local a[3]=4 a[5]=6
  echo status=$?
  argv.py "${!a[@]}" "${a[@]}"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: readonly a[7]=8
================================================================================

readonly b[7]=8
echo status=$?
argv.py "${!b[@]}" "${b[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: export a[7]=8
================================================================================

export a[7]=8
echo status=$?
argv.py "${!a[@]}" "${a[@]}"
printenv.py a

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: 'builtin' prefix is allowed on assignments
================================================================================

builtin export e='E'
echo e=$e

--------------------------------------------------------------------------------

(program)

================================================================================
assign-deferred.test.sh: 'command' prefix is allowed on assignments
================================================================================

readonly r1='R1'  # zsh has this
command readonly r2='R2'  # but not this
echo r1=$r1
echo r2=$r2

--------------------------------------------------------------------------------

(program)

================================================================================
assign-dialects.test.sh: K and V are variables in (( array[K] = V ))
================================================================================

K=5
V=42
typeset -a array
(( array[K] = V ))

echo array[5]=${array[5]}
echo keys = ${!array[@]}
echo values = ${array[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
assign-dialects.test.sh: test -v with strings
================================================================================

test -v str
echo str=$?

str=x

test -v str
echo str=$?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-dialects.test.sh: test -v with arrays
================================================================================


typeset -a a

test -v a
echo a=$?
test -v 'a[0]'
echo "a[0]=$?"
echo

a[0]=1

test -v a
echo a=$?
test -v 'a[0]'
echo "a[0]=$?"
echo

test -v 'a[1]'
echo "a[1]=$?"

# stupid rule about undefined 'x'
test -v 'a[x]'
echo "a[x]=$?"
echo

--------------------------------------------------------------------------------

(program)

================================================================================
assign-dialects.test.sh: test -v with assoc arrays
================================================================================


typeset -A A

test -v A
echo A=$?
test -v 'A[0]'
echo "A[0]=$?"
echo

A['0']=x

test -v A
echo A=$?
test -v 'A[0]'
echo "A[0]=$?"
echo

test -v 'A[1]'
echo "A[1]=$?"

# stupid rule about undefined 'x'
test -v 'A[x]'
echo "A[x]=$?"
echo

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: local -a
================================================================================

# nixpkgs setup.sh uses this (issue #26)
f() {
  local -a array=(x y z)
  argv.py "${array[@]}"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -a
================================================================================

# nixpkgs setup.sh uses this (issue #26)
declare -a array=(x y z)
argv.py "${array[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -f exit code indicates function existence
================================================================================

func2=x  # var names are NOT found
declare -f myfunc func2
echo $?

myfunc() { echo myfunc; }
declare -f myfunc func2 > /dev/null
echo $?

func2() { echo func2; }
declare -f myfunc func2 > /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -F prints function names
================================================================================

add () { expr 4 + 4; }
div () { expr 6 / 2; }
ek () { echo hello; }
__ec () { echo hi; }
_ab () { expr 10 % 3; }

declare -F

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -F with shopt -s extdebug prints more info
================================================================================

case $SH in mksh) exit ;; esac

source $REPO_ROOT/spec/testdata/bash-source-2.sh

shopt -s extdebug

add () { expr 4 + 4; }

declare -F 
echo

declare -F add
# in bash-source-2
declare -F g | sed "s;$REPO_ROOT;ROOT;g"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -F with shopt -s extdebug and main file
================================================================================

case $SH in mksh) exit ;; esac

$SH $REPO_ROOT/spec/testdata/extdebug.sh | sed "s;$REPO_ROOT;ROOT;g"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p var (exit status)
================================================================================

var1() { echo func; }  # function names are NOT found.
declare -p var1 var2 >/dev/null
echo $?

var1=x
declare -p var1 var2 >/dev/null
echo $?

var2=y
declare -p var1 var2 >/dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare
================================================================================

test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare
    echo '[readonly]'
    readonly
    echo '[export]'
    export
    echo '[local]'
    local
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p
================================================================================

# BUG: bash doesn't output flags with "local -p", which seems to contradict
#   with manual.
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare -p
    echo '[readonly]'
    readonly -p
    echo '[export]'
    export -p
    echo '[local]'
    local -p
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p doesn't print binary data, but can be loaded into bash
================================================================================


# bash prints binary data!
case $SH in bash*|mksh) exit ;; esac

unquoted='foo'
sq='foo bar'
bash1=$'\x1f'  # ASCII control char
bash2=$'\xfe\xff'  # Invalid UTF-8

s1=$unquoted
s2=$sq
s3=$bash1
s4=$bash2

declare -a a=("$unquoted" "$sq" "$bash1" "$bash2")
declare -A A=(["$unquoted"]="$sq" ["$bash1"]="$bash2")

#echo lengths ${#s1} ${#s2} ${#s3} ${#s4} ${#a[@]} ${#A[@]}

declare -p s1 s2 s3 s4 a A | tee tmp.bash

echo ---

bash -c 'source tmp.bash; echo "$s1 $s2"; echo -n "$s3" "$s4" | od -A n -t x1'
echo bash=$?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p var
================================================================================

# BUG? bash doesn't output anything for 'local/readonly -p var', which seems to
#   contradict with manual.  Besides, 'export -p var' is not described in
#   manual
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare]'
    declare -p test_var{0..5}
    echo '[readonly]'
    readonly -p test_var{0..5}
    echo '[export]'
    export -p test_var{0..5}
    echo '[local]'
    local -p test_var{0..5}
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p arr
================================================================================

test_arr1=()
declare -a test_arr2=()
declare -A test_arr3=()
test_arr4=(1 2 3)
declare -a test_arr5=(1 2 3)
declare -A test_arr6=(['a']=1 ['b']=2 ['c']=3)
test_arr7=()
test_arr7[3]=foo
declare -p test_arr{1..7}

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p foo=bar doesn't make sense
================================================================================

case $SH in mksh) exit 0 ;; esac

declare -p foo=bar
echo status=$?

a=b
declare -p a foo=bar > tmp.txt
echo status=$?
sed 's/"//g' tmp.txt  # don't care about quotes

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -pnrx
================================================================================

test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare -pn]'
    declare -pn
    echo '[declare -pr]'
    declare -pr
    echo '[declare -px]'
    declare -px
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -paA
================================================================================

declare -a test_var6=()
declare -A test_var7=()
f1() {
  {
    echo '[declare -pa]'
    declare -pa
    echo '[declare -pA]'
    declare -pA
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -pnrx var
================================================================================

# Note: Bash ignores other flags (-nrx) when variable names are supplied while
#   OSH uses other flags to select variables.  Bash's behavior is documented.
test_var1=111
readonly test_var2=222
export test_var3=333
declare -n test_var4=test_var1
f1() {
  local test_var5=555
  {
    echo '[declare -pn]'
    declare -pn test_var{0..5}
    echo '[declare -pr]'
    declare -pr test_var{0..5}
    echo '[declare -px]'
    declare -px test_var{0..5}
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -pg
================================================================================

test_var1=global
f1() {
  local test_var1=local
  {
    declare -pg
  } | grep -E '^\[|^\b[^"]*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -pg var
================================================================================

test_var1=global
f1() {
  local test_var1=local
  {
    declare -pg test_var1
  } | grep -E '^\[|^\b.*test_var.\b'
}
f1

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: ble.sh: eval -- "$(declare -p var arr)"
================================================================================

# This illustrates an example usage of "eval & declare" for exporting
# multiple variables from $().
eval -- "$(
  printf '%s\n' a{1..10} | {
    sum=0 i=0 arr=()
    while read line; do
      ((sum+=${#line},i++))
      arr[$((i/3))]=$line
    done
    declare -p sum arr
  })"
echo sum=$sum
for ((i=0;i<${#arr[@]};i++)); do
  echo "arr[$i]=${arr[i]}"
done

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p and value.Undef
================================================================================


# This is a regression for a crash
# But actually there is also an incompatibility -- we don't print anything

declare x
declare -p x

function f { local x; declare -p x; }
x=1
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: eval -- "$(declare -p arr)" (restore arrays w/ unset elements)
================================================================================

arr=(1 2 3)
eval -- "$(arr=(); arr[3]= arr[4]=foo; declare -p arr)"
for i in {0..4}; do
  echo "arr[$i]: ${arr[$i]+set ... [}${arr[$i]-unset}${arr[$i]+]}"
done

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -p UNDEF (and typeset) -- prints something to stderr
================================================================================


x=42
readonly x
export x

declare -p x undef1 undef2 2> de

typeset -p x undef1 undef2 2> ty

# readonly -p and export -p don't accept args!  They only print all
#
# These do not accept args
# readonly -p x undef1 undef2 2> re
# export -p x undef1 undef2 2> ex

f() {
  # it behaves weird with x
  #local -p undef1 undef2 2>lo
  local -p a b b>lo
  #local -p x undef1 undef2 2> lo
}
# local behaves differently in bash 4.4 and bash 5, not specifying now
# f
# files='de ty lo'

files='de ty'

wc -l $files
#cat $files

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset -f
================================================================================

# mksh implement typeset but not declare
typeset  -f myfunc func2
echo $?

myfunc() { echo myfunc; }
# This prints the source code.
typeset  -f myfunc func2 > /dev/null
echo $?

func2() { echo func2; }
typeset  -f myfunc func2 > /dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset -p
================================================================================

var1() { echo func; }  # function names are NOT found.
typeset -p var1 var2 >/dev/null
echo $?

var1=x
typeset -p var1 var2 >/dev/null
echo $?

var2=y
typeset -p var1 var2 >/dev/null
echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset -r makes a string readonly
================================================================================

typeset -r s1='12'
typeset -r s2='34'

s1='c'
echo status=$?
s2='d'
echo status=$?

s1+='e'
echo status=$?
s2+='f'
echo status=$?

unset s1
echo status=$?
unset s2
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset -ar makes it readonly
================================================================================

typeset -a -r array1=(1 2)
typeset -ar array2=(3 4)

array1=('c')
echo status=$?
array2=('d')
echo status=$?

array1+=('e')
echo status=$?
array2+=('f')
echo status=$?

unset array1
echo status=$?
unset array2
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset -x makes it exported
================================================================================

typeset -rx PYTHONPATH=lib/
printenv.py PYTHONPATH

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: Multiple assignments / array assignments on a line
================================================================================

a=1 b[0+0]=2 c=3
echo $a ${b[@]} $c

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: Env bindings shouldn't contain array assignments
================================================================================

a=1 b[0]=2 c=3 printenv.py a b c

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: syntax error in array assignment
================================================================================

a=x b[0+]=y c=z
echo $a $b $c

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: declare -g (bash-specific; bash-completion uses it)
================================================================================

f() {
  declare -g G=42
  declare L=99

  declare -Ag dict
  dict["foo"]=bar

  declare -A localdict
  localdict["spam"]=Eggs

  # For bash-completion
  eval 'declare -Ag ev'
  ev["ev1"]=ev2
}
f
argv.py "$G" "$L"
argv.py "${dict["foo"]}" "${localdict["spam"]}"
argv.py "${ev["ev1"]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: myvar=typeset (another form of dynamic assignment)
================================================================================

myvar=typeset
x='a b'
$myvar x=$x
echo $x

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: dynamic array parsing is not allowed
================================================================================

code='x=(1 2 3)'
typeset -a "$code"  # note: -a flag is required
echo status=$?
argv.py "$x"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: dynamic flag in array in assign builtin
================================================================================

typeset b
b=(unused1 unused2)  # this works in mksh

a=(x 'foo=F' 'bar=B')
typeset -"${a[@]}"
echo foo=$foo
echo bar=$bar
printenv.py foo
printenv.py bar

# syntax error in mksh!  But works in bash and zsh.
#typeset -"${a[@]}" b=(spam eggs)
#echo "length of b = ${#b[@]}"
#echo "b[0]=${b[0]}"
#echo "b[1]=${b[1]}"

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset +x
================================================================================

export e=E
printenv.py e
typeset +x e=E2
printenv.py e  # no longer exported

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: typeset +r removes read-only attribute (TODO: documented in bash to do nothing)
================================================================================

readonly r=r1
echo r=$r

# clear the readonly flag.  Why is this accepted in bash, but doesn't do
# anything?
typeset +r r=r2 
echo r=$r

r=r3
echo r=$r

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: function name with /
================================================================================

ble/foo() { echo hi; }
declare -F ble/foo
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: invalid var name
================================================================================

typeset foo/bar

--------------------------------------------------------------------------------

(program)

================================================================================
assign-extended.test.sh: unset and shell funcs
================================================================================

foo() {
  echo bar
}

foo

declare -F
unset foo
declare -F

foo

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env value doesn't persist
================================================================================

FOO=foo printenv.py FOO
echo -$FOO-

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env value with equals
================================================================================

FOO=foo=foo printenv.py FOO

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env binding can use preceding bindings, but not subsequent ones
================================================================================

# This means that for ASSIGNMENT_WORD, on the RHS you invoke the parser again!
# Could be any kind of quoted string.
FOO="foo" BAR="[$FOO][$BAZ]" BAZ=baz printenv.py FOO BAR BAZ

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env value with two quotes
================================================================================

FOO='foo'"adjacent" printenv.py FOO

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env value with escaped <
================================================================================

FOO=foo\<foo printenv.py FOO

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: FOO=foo echo [foo]
================================================================================

FOO=foo echo "[$foo]"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: FOO=foo fun
================================================================================

fun() {
  echo "[$FOO]"
}
FOO=foo fun

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Multiple temporary envs on the stack
================================================================================

g() {
  echo "$F" "$G1" "$G2"
  echo '--- g() ---'
  P=p printenv.py F G1 G2 A P
}
f() {
  # NOTE: G1 doesn't pick up binding f, but G2 picks up a.
  # I don't quite understand why this is, but bash and OSH agree!
  G1=[$f] G2=[$a] g
  echo '--- f() ---'
  printenv.py F G1 G2 A P
}
a=A
F=f f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Escaped = in command name
================================================================================

# foo=bar is in the 'spec/bin' dir.
foo\=bar

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Trying to run keyword 'for'
================================================================================

FOO=bar for

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Empty env binding
================================================================================

EMPTY= printenv.py EMPTY

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Assignment doesn't do word splitting
================================================================================

words='one two'
a=$words
argv.py "$a"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Assignment doesn't do glob expansion
================================================================================

touch _tmp/z.Z _tmp/zz.Z
a=_tmp/*.Z
argv.py "$a"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Env binding in readonly/declare is NOT exported!  (pitfall)
================================================================================


# All shells agree on this, but it's very confusing behavior.
FOO=foo readonly v=$(printenv.py FOO)
echo "v=$v"

# bash has probems here:
FOO=foo readonly v2=$FOO
echo "v2=$v2"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: assignments / array assignments not interpreted after 'echo'
================================================================================

a=1 echo b[0]=2 c=3

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: dynamic local variables (and splitting)
================================================================================

f() {
  local "$1"  # Only x is assigned here
  echo x=\'$x\'
  echo a=\'$a\'

  local $1  # x and a are assigned here
  echo x=\'$x\'
  echo a=\'$a\'
}
f 'x=y a=b'

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: readonly x= gives empty string (regression)
================================================================================

readonly x=
argv.py "$x"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: 'local x' does not set variable
================================================================================

set -o nounset
f() {
  local x
  echo $x
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: 'local -a x' does not set variable
================================================================================

set -o nounset
f() {
  local -a x
  echo $x
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: 'local x' and then array assignment
================================================================================

f() {
  local x
  x[3]=foo
  echo ${x[3]}
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: 'declare -A' and then dict assignment
================================================================================

declare -A foo
key=bar
foo["$key"]=value
echo ${foo["bar"]}

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: declare in an if statement
================================================================================

# bug caught by my feature detection snippet in bash-completion
if ! foo=bar; then
  echo BAD
fi
echo $foo
if ! eval 'spam=eggs'; then
  echo BAD
fi
echo $spam

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Modify a temporary binding
================================================================================

# (regression for bug found by Michael Greenberg)
f() {
  echo "x before = $x"
  x=$((x+1))
  echo "x after  = $x"
}
x=5 f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Reveal existence of "temp frame" (All shells disagree here!!!)
================================================================================

f() {
  echo "x=$x"

  x=mutated-temp  # mutate temp frame
  echo "x=$x"

  # Declare a new local
  local x='local'
  echo "x=$x"

  # Unset it
  unset x
  echo "x=$x"
}

x=global
x=temp-binding f
echo "x=$x"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Test above without 'local' (which is not POSIX)
================================================================================

f() {
  echo "x=$x"

  x=mutated-temp  # mutate temp frame
  echo "x=$x"

  # Unset it
  unset x
  echo "x=$x"
}

x=global
x=temp-binding f
echo "x=$x"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Using ${x-default} after unsetting local shadowing a global
================================================================================

f() {
  echo "x=$x"
  local x='local'
  echo "x=$x"
  unset x
  echo "- operator = ${x-default}"
  echo ":- operator = ${x:-default}"
}
x=global
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: Using ${x-default} after unsetting a temp binding shadowing a global
================================================================================

f() {
  echo "x=$x"
  local x='local'
  echo "x=$x"
  unset x
  echo "- operator = ${x-default}"
  echo ":- operator = ${x:-default}"
}
x=global
x=temp-binding f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: static assignment doesn't split
================================================================================

words='a b c'
export ex=$words
glo=$words
readonly ro=$words
argv.py "$ex" "$glo" "$ro"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: aliased assignment doesn't split
================================================================================

shopt -s expand_aliases || true
words='a b c'
alias e=export
alias r=readonly
e ex=$words
r ro=$words
argv.py "$ex" "$ro"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: assignment using dynamic keyword (splits in most shells, not in zsh/osh)
================================================================================

words='a b c'
e=export
r=readonly
$e ex=$words
$r ro=$words
argv.py "$ex" "$ro"

# zsh and OSH are smart

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: assignment using dynamic var names doesn't split
================================================================================

words='a b c'
arg_ex=ex=$words
arg_ro=ro=$words

# no quotes, this is split of course
export $arg_ex
readonly $arg_ro

argv.py "$ex" "$ro"

arg_ex2=ex2=$words
arg_ro2=ro2=$words

# quotes, no splitting
export "$arg_ex2"
readonly "$arg_ro2"

argv.py "$ex2" "$ro2"

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: assign and glob
================================================================================

cd $TMP
touch foo=a foo=b
foo=*
argv.py "$foo"
unset foo

export foo=*
argv.py "$foo"
unset foo

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: declare and glob
================================================================================

cd $TMP
touch foo=a foo=b
typeset foo=*
argv.py "$foo"
unset foo

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: readonly $x where x='b c'
================================================================================

one=a
two='b c'
readonly $two $one
a=new
echo status=$?
b=new
echo status=$?
c=new
echo status=$?

# in OSH and zsh, this is an invalid variable name

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: readonly a=(1 2) no_value c=(3 4) makes 'no_value' readonly
================================================================================

readonly a=(1 2) no_value c=(3 4)
no_value=x

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: export a=1 no_value c=2
================================================================================

no_value=foo
export a=1 no_value c=2
printenv.py no_value

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: local a=loc $var c=loc
================================================================================

var='b'
b=global
echo $b
f() {
  local a=loc $var c=loc
  argv.py "$a" "$b" "$c"
}
f

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: redirect after assignment builtin (eval redirects after evaluating arguments)
================================================================================


# See also: spec/redir-order.test.sh (#2307)
# The $(stdout_stderr.py) is evaluated *before* the 2>/dev/null redirection

readonly x=$(stdout_stderr.py) 2>/dev/null
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: redirect after command sub (like case above but without assignment builtin)
================================================================================

echo stdout=$(stdout_stderr.py) 2>/dev/null

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: redirect after bare assignment
================================================================================

x=$(stdout_stderr.py) 2>/dev/null
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: redirect after declare -p
================================================================================

case $SH in *dash) exit 99 ;; esac  # stderr unpredictable

foo=bar
typeset -p foo 1>&2

# zsh and mksh agree on exact output, which we don't really care about

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: declare -a arr does not remove existing arrays (OSH regression)
================================================================================

case $SH in dash) exit 99 ;; esac # dash does not support arrays

declare -a arr
arr=(foo bar baz)
declare -a arr
echo arr:${#arr[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: declare -A dict does not remove existing arrays (OSH regression)
================================================================================

case $SH in dash|mksh) exit 99 ;; esac # dash/mksh does not support associative arrays

declare -A dict
dict['foo']=hello
dict['bar']=oil
dict['baz']=world
declare -A dict
echo dict:${#dict[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: "readonly -a arr" and "readonly -A dict" should not not remove existing arrays
================================================================================

# mksh's readonly does not support the -a option.
# dash/mksh does not support associative arrays.
case $SH in dash|mksh) exit 99 ;; esac

declare -a arr
arr=(foo bar baz)
declare -A dict
dict['foo']=hello
dict['bar']=oil
dict['baz']=world

readonly -a arr
echo arr:${#arr[@]}
readonly -A dict
echo dict:${#dict[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: "declare -a arr" and "readonly -a a" creates an empty array (OSH)
================================================================================

case $SH in dash|mksh) exit 99 ;; esac # dash/mksh does not support associative arrays

declare -a arr1
readonly -a arr2
declare -A dict1
readonly -A dict2

declare -p arr1 arr2 dict1 dict2

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: "var d = {}; declare -p d" does not print anything (OSH)
================================================================================

case $SH in bash-4.4|dash|mksh|zsh) exit 99 ;; esac

# We pretend that the variable does not exist when the variable is not
# representable with the "declare -p" format.

var d = {}
declare -p d

--------------------------------------------------------------------------------

(program)

================================================================================
assign.test.sh: readonly array should not be modified by a+=(1)
================================================================================

case $SH in dash) exit 99 ;; esac # dash/mksh does not support associative arrays

a=(1 2 3)
readonly -a a
eval 'a+=(4)'
argv.py "${a[@]}"
eval 'declare -n r=a; r+=(4)'
argv.py "${a[@]}"

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here string
================================================================================

cat <<< 'hi'

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here string with $
================================================================================

cat <<< $'one\ntwo\n'

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here redirect with explicit descriptor
================================================================================

# A space between 0 and <<EOF causes it to pass '0' as an arg to cat.
cat 0<<EOF
one
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc from another input file descriptor
================================================================================

# NOTE: OSH fails on descriptor 9, but not descriptor 8?  Is this because of
# the Python VM?  How  to inspect state?
read_from_fd.py 8  8<<EOF
here doc on descriptor
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Multiple here docs with different descriptors
================================================================================

read_from_fd.py 0 3 <<EOF 3<<EOF3
fd0
EOF
fd3
EOF3

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with bad var delimiter
================================================================================

# Most shells accept this, but OSH is stricter.
cat <<${a}
here
${a}

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with bad comsub delimiter
================================================================================

# bash is OK with this; dash isn't.  Should be a parse error.
cat <<$(a)
here
$(a)

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc and < redirect -- last one wins
================================================================================


echo hello >$TMP/hello.txt

cat <<EOF <$TMP/hello.txt
here
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: < redirect and here doc -- last one wins
================================================================================


echo hello >$TMP/hello.txt

cat <$TMP/hello.txt <<EOF
here
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with var sub, command sub, arith sub
================================================================================

var=v
cat <<EOF
var: ${var}
command: $(echo hi)
arith: $((1+2))
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc in middle.  And redirects in the middle.
================================================================================

# This isn't specified by the POSIX grammar, but it's accepted by both dash and
# bash!
echo foo > foo.txt
echo bar > bar.txt
cat <<EOF 1>&2 foo.txt - bar.txt
here
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc line continuation
================================================================================

cat <<EOF \
; echo two
one
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with quote expansion in terminator
================================================================================

cat <<'EOF'"2"
one
two
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with multiline double quoted string
================================================================================

cat <<EOF; echo "two
three"
one
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Two here docs -- first is ignored; second ones wins!
================================================================================

<<EOF1 cat <<EOF2
hello
EOF1
there
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with pipe on first line
================================================================================

cat <<EOF | tac
1
2
3
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with pipe continued on last line
================================================================================

cat <<EOF |
1
2
3
EOF
tac

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc with builtin 'read'
================================================================================

# read can't be run in a subshell.
read v1 v2 <<EOF
val1 val2
EOF
echo =$v1= =$v2=

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Compound command here doc
================================================================================

while read line; do
  echo X $line
done <<EOF
1
2
3
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc in while condition and here doc in body
================================================================================

while cat <<E1 && cat <<E2; do cat <<E3; break; done
1
E1
2
E2
3
E3

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc in while condition and here doc in body on multiple lines
================================================================================

while cat <<E1 && cat <<E2
1
E1
2
E2
do
  cat <<E3
3
E3
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc in while loop split up more
================================================================================

while cat <<E1
1
E1

cat <<E2
2
E2

do
  cat <<E3
3
E3
  break
done

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Mixing << and <<-
================================================================================

cat <<-EOF; echo --; cat <<EOF2
	one
EOF
two
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Two compound commands with two here docs
================================================================================

while read line; do echo X $line; done <<EOF; echo ==;  while read line; do echo Y $line; done <<EOF2
1
2
EOF
3
4
EOF2

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Function def and execution with here doc
================================================================================

fun() { cat; } <<EOF; echo before; fun; echo after 
1
2
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc as command prefix
================================================================================

<<EOF tac
1
2
3
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Redirect after here doc
================================================================================

cat <<EOF 1>&2
out
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: here doc stripping tabs
================================================================================

cat <<-EOF
	1
	2
		3  # 2 tabs are both stripped
  4  # spaces are preserved
	EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc within subshell with boolean
================================================================================

[[ $(cat <<EOF
foo
EOF
) == foo ]]; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here Doc in if condition
================================================================================

if cat <<EOF; then
here doc in IF CONDITION
EOF
  echo THEN executed
fi

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Nested here docs which are indented
================================================================================

cat <<- EOF
	outside
	$(cat <<- INSIDE
		inside
INSIDE
)
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Multiple here docs in pipeline
================================================================================

case $SH in *osh) exit ;; esac

# The second instance reads its stdin from the pipe, and fd 5 from a here doc.
read_from_fd.py 3 3<<EOF3 | read_from_fd.py 0 5 5<<EOF5
fd3
EOF3
fd5
EOF5

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Multiple here docs in pipeline on multiple lines
================================================================================

case $SH in *osh) exit ;; esac

# SKIPPED: hangs with osh on Debian
# The second instance reads its stdin from the pipe, and fd 5 from a here doc.
read_from_fd.py 3 3<<EOF3 |
fd3
EOF3
read_from_fd.py 0 5 5<<EOF5
fd5
EOF5

echo ok

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc and backslash double quote
================================================================================

cat <<EOF
a \"quote\"
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
here-doc.test.sh: Here doc escapes
================================================================================

# these are the chars from _DQ_ESCAPED_CHAR
cat <<EOF
\\ \" \$ \`
EOF

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Brace group in pipeline
================================================================================

{ echo one; echo two; } | tac

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: For loop starts pipeline
================================================================================

for w in one two; do
  echo $w
done | tac

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: While Loop ends pipeline
================================================================================

seq 3 | while read i
do
  echo ".$i"
done

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Redirect in Pipeline
================================================================================

echo hi 1>&2 | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Pipeline comments
================================================================================

echo abcd |    # input
               # blank line
tr a-z A-Z     # transform

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Exit code is last status
================================================================================

echo a | egrep '[0-9]+'

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Initial value of PIPESTATUS is empty string
================================================================================

case $SH in dash|zsh) exit ;; esac

echo pipestatus ${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: PIPESTATUS
================================================================================

return3() {
  return 3
}
{ sleep 0.03; exit 1; } | { sleep 0.02; exit 2; } | { sleep 0.01; return3; }
echo ${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: PIPESTATUS is set on simple commands
================================================================================

case $SH in dash|zsh) exit ;; esac

false
echo pipestatus ${PIPESTATUS[@]}

exit 55 | (exit 44)
echo pipestatus ${PIPESTATUS[@]}

true
echo pipestatus ${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: PIPESTATUS with shopt -s lastpipe
================================================================================

shopt -s lastpipe
return3() {
  return 3
}
{ sleep 0.03; exit 1; } | { sleep 0.02; exit 2; } | { sleep 0.01; return3; }
echo ${PIPESTATUS[@]}

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: |&
================================================================================

stdout_stderr.py |& cat

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! turns non-zero into zero
================================================================================

! $SH -c 'exit 42'; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! turns zero into 1
================================================================================

! $SH -c 'exit 0'; echo $?

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! in if
================================================================================

if ! echo hi; then
  echo TRUE
else
  echo FALSE
fi

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! with ||
================================================================================

! echo hi || echo FAILED

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! with { }
================================================================================

! { echo 1; echo 2; } || echo FAILED

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! with ( )
================================================================================

! ( echo 1; echo 2 ) || echo FAILED

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: ! is not a command
================================================================================

v='!'
$v echo hi

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Evaluation of argv[0] in pipeline occurs in child
================================================================================

${cmd=echo} hi | wc -l
echo "cmd=$cmd"

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: bash/dash/mksh run the last command is run in its own process
================================================================================

echo hi | read line
echo "line=$line"

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: shopt -s lastpipe (always on in OSH)
================================================================================

shopt -s lastpipe
echo hi | read line
echo "line=$line"

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: shopt -s lastpipe (always on in OSH)
================================================================================

shopt -s lastpipe
i=0
seq 3 | while read line; do
  (( i++ ))
done
echo i=$i

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: SIGPIPE causes pipeline to die (regression for issue #295)
================================================================================

cat /dev/urandom | sleep 0.1
echo ${PIPESTATUS[@]}

# hm bash gives '1 0' which seems wrong

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Nested pipelines
================================================================================

{ sleep 0.1 | seq 3; } | cat
{ sleep 0.1 | seq 10; } | { cat | cat; } | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: Pipeline in eval
================================================================================

ls /dev/null | eval 'cat | cat' | wc -l

--------------------------------------------------------------------------------

(program)

================================================================================
pipeline.test.sh: shopt -s lastpipe and shopt -s no_last_fork interaction
================================================================================


case $SH in dash) exit ;; esac

$SH -c '
shopt -s lastpipe
set -o errexit
set -o pipefail

ls | false | wc -l'
echo status=$?

# Why does this give status 0?  It should fail

$SH -c '
shopt -s lastpipe
shopt -s no_fork_last  # OSH only
set -o errexit
set -o pipefail

ls | false | wc -l'
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: >$file touches a file
================================================================================

rm -f myfile
test -f myfile
echo status=$?

>myfile
test -f myfile
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: $(< $file) yields the contents of the file
================================================================================


seq 2 3 > myfile
foo=$(< myfile)
argv.py "$foo"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: `< $file` behaves like $(< file)
================================================================================


seq 7 8 > myfile

x=`< myfile`

echo "[$x]"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: $(< file; end) is not a special case
================================================================================


seq 5 6 > myfile

# zsh prints the file each time!
# other shells do nothing?

foo=$(echo begin; < myfile)
echo $foo
echo ---

foo=$(< myfile; echo end)
echo $foo
echo ---

foo=$(< myfile; <myfile)
echo $foo
echo ---

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: < file in pipeline and subshell doesn't work
================================================================================

echo FOO > file2

# This only happens in command subs, which is weird
< file2 | tr A-Z a-z
( < file2 )
echo end

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Leading redirect in a simple command
================================================================================

echo hello >$TMP/hello.txt  # temporary fix
<$TMP/hello.txt cat

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in the middle of a simple command
================================================================================

f=$TMP/out
echo -n 1 2 '3 ' > $f
echo -n 4 5 >> $f '6 '
echo -n 7 >> $f 8 '9 '
echo -n >> $f 1 2 '3 '
echo >> $f -n 4 5 '6'

cat $f
echo

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in command sub
================================================================================

FOO=$(echo foo 1>&2)
echo $FOO

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in the middle of two assignments
================================================================================

FOO=foo >$TMP/out.txt BAR=bar printenv.py FOO BAR
tac $TMP/out.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in assignment
================================================================================

# dash captures stderr to a file here, which seems correct.  Bash doesn't and
# just lets it go to actual stderr.
# For now we agree with dash/mksh, since it involves fewer special cases in the
# code.

FOO=$(echo foo 1>&2) 2>$TMP/no-command.txt
echo FILE=
cat $TMP/no-command.txt
echo "FOO=$FOO"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in function body
================================================================================

fun() { echo hi; } 1>&2
fun

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in function body is evaluated multiple times
================================================================================

i=0
fun() { echo "file $i"; } 1> "$TMP/file$((i++))"
fun
fun
echo i=$i
echo __
cat $TMP/file0
echo __
cat $TMP/file1

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect in function body AND function call
================================================================================

fun() { echo hi; } 1>&2
fun 2>&1

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect bash extensions:   [[  ((  for ((
================================================================================


case $SH in dash|mksh) exit ;; esac

rm -f dbracket dparen for-expr

[[ x = x ]] > dbracket

(( 42 )) > dparen

for ((x = 0; x < 1; ++x)); do
  echo for-expr
done > for-expr

wc -l dbracket dparen for-expr

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect if
================================================================================

if true; then
  echo if-body
fi >out

cat out

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect case
================================================================================

case foo in
  foo)
    echo case-body
    ;;
esac > out

cat out

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect while
================================================================================

while true; do
  echo while-body
  break
done > out

cat out

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect for loop
================================================================================

for i in $(seq 3)
do
  echo $i
done > $TMP/redirect-for-loop.txt
cat $TMP/redirect-for-loop.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: redirect subshell
================================================================================

( echo foo ) 1>&2

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Brace group redirect
================================================================================

# Suffix works, but prefix does NOT work.
# That comes from '| compound_command redirect_list' in the grammar!
{ echo block-redirect; } > $TMP/br.txt
cat $TMP/br.txt | wc -c

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Redirect function stdout
================================================================================

f() { echo one; echo two; }
f > $TMP/redirect-func.txt
cat $TMP/redirect-func.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-command.test.sh: Nested function stdout redirect
================================================================================

# Shows that a stack is necessary.
inner() {
  echo i1
  echo i2
}
outer() {
  echo o1
  inner > $TMP/inner.txt
  echo o2
}
outer > $TMP/outer.txt
cat $TMP/inner.txt
echo --
cat $TMP/outer.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirects with glob args (bash and zsh only)
================================================================================


touch one-bar

echo hi > one-*

cat one-bar

echo escaped > one-\*

cat one-\*

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirect without matching any file
================================================================================


echo hi > zz-*-xx
echo status=$?

echo zz*

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: ysh behavior when glob doesn't match
================================================================================


shopt -s ysh:upgrade

echo hi > qq-*-zz
echo status=$?

echo qq*

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirect without matching any file, with failglob
================================================================================


shopt -s failglob

echo hi > zz-*-xx
echo status=$?

echo zz*
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: Redirect to $empty (in function body)
================================================================================

empty=''
fun() { echo hi; } > $empty
fun
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: Redirect to ''
================================================================================

echo hi > ''
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirect to $var with glob char
================================================================================


touch two-bar

star='*'

# This gets glob-expanded, as it does outside redirects
echo hi > two-$star
echo status=$?

head two-bar two-\*

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirect that globs to more than one file (bash and zsh only)
================================================================================


touch foo-bar
touch foo-spam

echo hi > foo-*
echo status=$?

head foo-bar foo-spam

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirect with extended glob
================================================================================


shopt -s extglob

touch foo-bar

echo hi > @(*-bar|other)
echo status=$?

cat foo-bar

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: Extended glob that doesn't match anything
================================================================================

shopt -s extglob
rm bad_*

# They actually write this literal file!  This is what EvalWordToString() does,
# as opposed to _EvalWordToParts.
echo foo > bad_@(*.cc|*.h)
echo status=$?

echo bad_*

shopt -s failglob

# Note: ysh:ugprade doesn't allow extended globs
# shopt -s ysh:upgrade

echo foo > bad_@(*.cc|*.h)
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: Non-file redirects don't respect glob args (we differe from bash)
================================================================================


touch 10

exec 10>&1  # open stdout as descriptor 10

# Does this go to stdout?  ONLY bash respects it, not zsh
echo should-not-be-on-stdout >& 1*

echo stdout
echo stderr >&2

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: Redirect with brace expansion isn't allowed
================================================================================


echo hi > a-{one,two}
echo status=$?

head a-*
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect-multi.test.sh: File redirects have word splitting too!
================================================================================


file='foo bar'

echo hi > $file
echo status=$?

cat "$file"
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: >& and <& are the same
================================================================================


echo one 1>&2

echo two 1<&2

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: <&
================================================================================

# Is there a simpler test case for this?
echo foo51 > $TMP/lessamp.txt

exec 6< $TMP/lessamp.txt
read line <&6

echo "[$line]"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 2>&1 with no command
================================================================================

( exit 42 )  # status is reset after this
echo status=$?
2>&1
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 2&>1 (is it a redirect or is it like a&>1)
================================================================================

2&>1
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Nonexistent file
================================================================================

cat <$TMP/nonexistent.txt
echo status=$?

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Descriptor redirect with spaces
================================================================================

# Hm this seems like a failure of lookahead!  The second thing should look to a
# file-like thing.
# I think this is a posix issue.
# tag: posix-issue
echo one 1>&2
echo two 1 >&2
echo three 1>& 2

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Filename redirect with spaces
================================================================================

# This time 1 *is* a descriptor, not a word.  If you add a space between 1 and
# >, it doesn't work.
echo two 1> $TMP/file-redir1.txt
cat $TMP/file-redir1.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Quoted filename redirect with spaces
================================================================================

# POSIX makes node of this
echo two \1 > $TMP/file-redir2.txt
cat $TMP/file-redir2.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Descriptor redirect with filename
================================================================================

# bash/mksh treat this like a filename, not a descriptor.
# dash aborts.
echo one 1>&$TMP/nonexistent-filename__
echo "status=$?"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Redirect echo to stderr, and then redirect all of stdout somewhere.
================================================================================

{ echo foo52 1>&2; echo 012345789; } > $TMP/block-stdout.txt
cat $TMP/block-stdout.txt |  wc -c 

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Named file descriptor
================================================================================

exec {myfd}> $TMP/named-fd.txt
echo named-fd-contents >& $myfd
cat $TMP/named-fd.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Double digit fd (20> file)
================================================================================

exec 20> "$TMP/double-digit-fd.txt"
echo hello20 >&20
cat "$TMP/double-digit-fd.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: : 9> fdleak (OSH regression)
================================================================================

true 9> "$TMP/fd.txt"
( echo world >&9 )
cat "$TMP/fd.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: : 3>&3 (OSH regression)
================================================================================


# mksh started being flaky on the continuous build and during release.  We
# don't care!  Related to issue #330.
case $SH in mksh) exit ;; esac

: 3>&3
echo hello

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: : 3>&3-
================================================================================

: 3>&3-
echo hello

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 3>&- << EOF (OSH regression: fail to restore fds)
================================================================================

exec 3> "$TMP/fd.txt"
echo hello 3>&- << EOF
EOF
echo world >&3
exec 3>&-  # close
cat "$TMP/fd.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Open file on descriptor 3 and write to it many times
================================================================================


# different than case below because 3 is the likely first FD of open()

exec 3> "$TMP/fd3.txt"
echo hello >&3
echo world >&3
exec 3>&-  # close
cat "$TMP/fd3.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Open file on descriptor 4 and write to it many times
================================================================================


# different than the case above because because 4 isn't the likely first FD

exec 4> "$TMP/fd4.txt"
echo hello >&4
echo world >&4
exec 4>&-  # close
cat "$TMP/fd4.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Redirect to empty string
================================================================================

f=''
echo s > "$f"
echo "result=$?"
set -o errexit
echo s > "$f"
echo DONE

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Redirect to file descriptor that's not open
================================================================================

# Notes:
# - 7/2021: descriptor 7 seems to work on all CI systems.  The process state
#   isn't clean, but we could probably close it in OSH?
# - dash doesn't allow file descriptors greater than 9.  (This is a good
#   thing, because the bash chapter in AOSA book mentions that juggling user
#   vs.  system file descriptors is a huge pain.)
# - But somehow running in parallel under spec-runner.sh changes whether
#   descriptor 3 is open.  e.g. 'echo hi 1>&3'.  Possibly because of
#   /usr/bin/time.  The _tmp/spec/*.task.txt file gets corrupted!
# - Oh this is because I use time --output-file.  That opens descriptor 3.  And
#   then time forks the shell script.  The file descriptor table is inherited.
#   - You actually have to set the file descriptor to something.  What do
#   configure and debootstrap too?

opened=$(ls /proc/$$/fd)
if echo "$opened" | egrep '^7$'; then
  echo "FD 7 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi

echo hi 1>&7

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Open descriptor with exec
================================================================================

# What is the point of this?  ./configure scripts and debootstrap use it.
exec 3>&1
echo hi 1>&3

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Open multiple descriptors with exec
================================================================================

# What is the point of this?  ./configure scripts and debootstrap use it.
exec 3>&1
exec 4>&1
echo three 1>&3
echo four 1>&4

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: >| to clobber
================================================================================

echo XX >| $TMP/c.txt

set -o noclobber

echo YY >  $TMP/c.txt  # not clobber
echo status=$?

cat $TMP/c.txt
echo ZZ >| $TMP/c.txt

cat $TMP/c.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: &> redirects stdout and stderr
================================================================================

tmp="$(basename $SH)-$$.txt"  # unique name for shell and test case
#echo $tmp

stdout_stderr.py &> $tmp

# order is indeterminate
grep STDOUT $tmp
grep STDERR $tmp

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: >&word redirects stdout and stderr when word is not a number or -
================================================================================


# dash, mksh don't implement this bash behaviour.
case $SH in dash|mksh) exit 1 ;; esac

tmp="$(basename $SH)-$$.txt"  # unique name for shell and test case

stdout_stderr.py >&$tmp

# order is indeterminate
grep STDOUT $tmp
grep STDERR $tmp

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 1>&- to close file descriptor
================================================================================

exec 5> "$TMP/f.txt"
echo hello >&5
exec 5>&-
echo world >&5
cat "$TMP/f.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 1>&2- to move file descriptor
================================================================================

exec 5> "$TMP/f.txt"
echo hello5 >&5
exec 6>&5-
echo world5 >&5
echo world6 >&6
exec 6>&-
cat "$TMP/f.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: 1>&2- (Bash bug: fail to restore closed fd)
================================================================================


# 7/2021: descriptor 8 is open on Github Actions, so use descriptor 6 instead

# Fix for CI systems where process state isn't clean: Close descriptors 6 and 7.
exec 6>&- 7>&-

opened=$(ls /proc/$$/fd)
if echo "$opened" | egrep '^7$'; then
  echo "FD 7 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi
if echo "$opened" | egrep '^6$'; then
  echo "FD 6 shouldn't be open"
  echo "OPENED:"
  echo "$opened"
fi

exec 7> "$TMP/f.txt"
: 6>&7 7>&-
echo hello >&7
: 6>&7-
echo world >&7
exec 7>&-
cat "$TMP/f.txt"

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: <> for read/write
================================================================================

echo first >$TMP/rw.txt
exec 8<>$TMP/rw.txt
read line <&8
echo line=$line
echo second 1>&8
echo CONTENTS
cat $TMP/rw.txt

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: <> for read/write named pipes
================================================================================

rm -f "$TMP/f.pipe"
mkfifo "$TMP/f.pipe"
exec 8<> "$TMP/f.pipe"
echo first >&8
echo second >&8
read line1 <&8
read line2 <&8
exec 8<&-
echo line1=$line1 line2=$line2

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: &>> appends stdout and stderr
================================================================================


# Fix for flaky tests: dash behaves non-deterministically under load!  It
# doesn't implement the behavior anyway so I don't care why.
case $SH in
  *dash)
    exit 1
    ;;
esac

echo "ok" > $TMP/f.txt
stdout_stderr.py &>> $TMP/f.txt
grep ok $TMP/f.txt >/dev/null && echo 'ok'
grep STDOUT $TMP/f.txt >/dev/null && echo 'ok'
grep STDERR $TMP/f.txt >/dev/null && echo 'ok'

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: exec redirect then various builtins
================================================================================

exec 5>$TMP/log.txt
echo hi >&5
set -o >&5
echo done

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: can't mention big file descriptor
================================================================================

echo hi 9>&1
# trivia: 23 is the max descriptor for mksh
#echo hi 24>&1
echo hi 99>&1
echo hi 100>&1

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: : >/dev/null 2> / (OSH regression: fail to pop fd frame)
================================================================================

# oil 0.8.pre4 fails to restore fds after redirection failure. In the
# following case, the fd frame remains after the redirection failure
# "2> /" so that the effect of redirection ">/dev/null" remains after
# the completion of the command.
: >/dev/null 2> /
echo hello

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: echo foo >&100 (OSH regression: does not fail with invalid fd 100)
================================================================================

# oil 0.8.pre4 does not fail with non-existent fd 100.
fd=100
echo foo53 >&$fd

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: echo foo >&N where N is first unused fd
================================================================================

# 1. prepare default fd for internal uses
minfd=10
case ${SH##*/} in
(mksh) minfd=24 ;;
(osh) minfd=100 ;;
esac

# 2. prepare first unused fd
fd=$minfd
is_fd_open() { : >&$1; }
while is_fd_open "$fd"; do
  : $((fd+=1))

  # OLD: prevent infinite loop for broken oils-for-unix
  #if test $fd -gt 1000; then
  #  break
  #fi
done

# 3. test
echo foo54 >&$fd

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: exec {fd}>&- (OSH regression: fails to close fd)
================================================================================

# mksh, dash do not implement {fd} redirections.
case $SH in mksh|dash) exit 1 ;; esac
# oil 0.8.pre4 fails to close fd by {fd}&-.
exec {fd}>file1
echo foo55 >&$fd
exec {fd}>&-
echo bar >&$fd
cat file1

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: noclobber can still write to non-regular files like /dev/null
================================================================================

set -C  # noclobber
set -e  # errexit (raise any redirection errors)

# Each redirect to /dev/null should succeed
echo a  >  /dev/null  # trunc, write stdout
echo a &>  /dev/null  # trunc, write stdout and stderr
echo a  >> /dev/null  # append, write stdout
echo a &>> /dev/null  # append, write stdout and stderr
echo a  >| /dev/null  # ignore noclobber, trunc, write stdout

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Parsing of x=1> and related cases
================================================================================


echo x=1>/dev/stdout
echo x=1 >/dev/stdout
echo x= 1>/dev/stdout

echo +1>/dev/stdout
echo +1 >/dev/stdout
echo + 1>/dev/stdout

echo a1>/dev/stdout

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: Parsing of x={myvar} and related cases
================================================================================

case $SH in dash) exit ;; esac

echo {myvar}>/dev/stdout
# Bash chooses fds starting with 10 here, osh with 100, and there can already
# be some open fds, so compare further fds against this one
starting_fd=$myvar

echo x={myvar}>/dev/stdout
echo $((myvar-starting_fd))
echo x={myvar} >/dev/stdout
echo $((myvar-starting_fd))
echo x= {myvar}>/dev/stdout
echo $((myvar-starting_fd))

echo +{myvar}>/dev/stdout
echo $((myvar-starting_fd))
echo +{myvar} >/dev/stdout
echo $((myvar-starting_fd))
echo + {myvar}>/dev/stdout
echo $((myvar-starting_fd))

--------------------------------------------------------------------------------

(program)

================================================================================
redirect.test.sh: xtrace not affected by redirects
================================================================================

set -x
printf 'aaaa' > /dev/null 2> test_osh
set +x
cat test_osh

--------------------------------------------------------------------------------

(program)
